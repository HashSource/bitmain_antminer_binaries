/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'single_board_test'
*/

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long

struct _eeprom_data_format;
struct bignum_st;
struct _IO_marker;
struct hashtable_bucket;
struct clib_rb_node;
struct te1_settings;
struct sync_serial_settings;
struct fr_proto_pvc_info;
struct fr_proto_pvc;
struct fr_proto;
struct cisco_proto;
struct raw_hdlc_proto;
struct XXH64_state_s;
struct XXH32_state_s;
struct mes_system_configs;
struct mes_system_hw_info;
struct mes_system_pattern;
struct mes_system_asic_reg;
struct mes_system_test_method;
struct mes_system_test_config;
struct mes_system_data;
struct mes_system_test_loop;
struct dtls1_state_st;
struct ssl3_state_st;
struct ssl2_state_st;
struct stack_st_SRTP_PROTECTION_PROFILE;
struct stack_st_X509_NAME;
struct stack_st_SSL_COMP;
struct ssl_ctx_st;
struct lhash_st_SSL_SESSION;
struct x509_store_st;
struct ssl_session_st;
struct ssl_method_st;
struct stack_st_SSL_CIPHER;
struct ssl_cipher_st;
struct ssl_st;
struct stack_st_X509_CRL;
struct stack_st_X509_LOOKUP;
struct stack_st_X509_OBJECT;
struct stack_st_X509;
struct stack_st_X509_REVOKED;
struct stack_st_X509_ALGOR;
struct stack_st_ASN1_OBJECT;
struct stack_st_X509_EXTENSION;
struct stack_st_X509_NAME_ENTRY;
struct stack_st_X509_ATTRIBUTE;
struct dh_st;
struct dsa_st;
struct rsa_st;
struct bio_st;
struct stack_st_void;
struct X509_pubkey_st;
struct X509_name_st;
struct X509_crl_st;
struct X509_algor_st;
struct x509_st;
struct evp_pkey_st;
struct evp_cipher_ctx_st;
struct buf_mem_st;
struct bn_mont_ctx_st;
struct asn1_object_st;
struct asn1_string_st;
struct history_result;
struct LZ4_writeFile_s;
struct LZ4_readFile_s;
union LZ4_streamHC_u;
union LZ4_stream_u;
struct _sweep_ctx;
struct record_pqueue_st;
struct dtls1_bitmap_st;
struct ssl3_buffer_st;
struct ssl3_record_st;
struct ssl_comp_st;
struct srtp_protection_profile_st;
struct X509_val_st;
struct comp_ctx_st;
struct bn_gencb_st;
struct _ptx_err_msg_;
struct hashtable_pair;
union _set_address_t;
union _chain_inactive_t;
union _get_status_t;
union _set_config_t;
union _return_nonce_128bit_t;
union LZ4_streamDecode_u;
struct X509_VERIFY_PARAM_st;
struct x509_cert_aux_st;
struct DSA_SIG_st;
struct asn1_type_st;
struct x509_store_ctx_st;
struct rsa_meth_st;
struct dsa_method;
struct dh_method;
struct env_md_ctx_st;
struct env_md_st;
struct evp_cipher_st;
struct LZ4F_CDict_s;
struct LZ4F_dctx_s;
struct _pattern_work_new;
struct _pattern_work;
struct srp_ctx_st;
struct X509_crl_info_st;
struct x509_cinf_st;
struct bio_method_st;
struct comp_method_st;
struct _pattern_runtime_ctx;
struct mes_system_config_file_info;
struct hmac_ctx_st;
struct LZ4F_cctx_s;
struct _config_ctx;
struct local_config_info;

/* 1 */
struct Elf32_Sym
{
  unsigned __int32 st_name __offset(OFF32,0x2E904);
  unsigned __int32 st_value __off;
  unsigned __int32 st_size;
  unsigned __int8 st_info;
  unsigned __int8 st_other;
  unsigned __int16 st_shndx;
};

/* 2 */
struct Elf32_Rel
{
  unsigned __int32 r_offset;
  unsigned __int32 r_info;
};

/* 3 */
union Elf32_Dyn::$A263394DDF3EC2D4B1B8448EDD30E249
{
  unsigned __int32 d_val;
  unsigned __int32 d_ptr;
};

/* 4 */
struct Elf32_Dyn
{
  __int32 d_tag;
  union Elf32_Dyn::$A263394DDF3EC2D4B1B8448EDD30E249 d_un;
};

/* 5 */
struct Elf32_Verneed
{
  unsigned __int16 vn_version;
  unsigned __int16 vn_cnt;
  unsigned __int32 vn_file __offset(OFF32,0x2E904);
  unsigned __int32 vn_aux;
  unsigned __int32 vn_next;
};

/* 6 */
struct Elf32_Vernaux
{
  unsigned __int32 vna_hash;
  unsigned __int16 vna_flags;
  unsigned __int16 vna_other;
  unsigned __int32 vna_name __offset(OFF32,0x2E904);
  unsigned __int32 vna_next;
};

/* 7 */
typedef void _IO_lock_t;

/* 8 */
struct __va_list
{
  void *__ap;
};

/* 9 */
typedef unsigned int sizetype;

/* 10 */
typedef unsigned int uint32_t;

/* 11 */
typedef unsigned __int64 uint64_t;

/* 257 */
typedef uint32_t LZ4_u32;

/* 103 */
typedef unsigned __int16 uint16_t;

/* 256 */
typedef uint16_t LZ4_u16;

/* 104 */
typedef unsigned __int8 uint8_t;

/* 225 */
typedef uint8_t LZ4_byte;

/* 124 */
typedef char int8_t;

/* 258 */
typedef int8_t LZ4_i8;

/* 12 */
struct LZ4HC_CCtx_internal
{
  LZ4_u32 hashTable[32768];
  LZ4_u16 chainTable[65536];
  const LZ4_byte *end;
  const LZ4_byte *prefixStart;
  const LZ4_byte *dictStart;
  LZ4_u32 dictLimit;
  LZ4_u32 lowLimit;
  LZ4_u32 nextToUpdate;
  __int16 compressionLevel;
  LZ4_i8 favorDecSpeed;
  LZ4_i8 dirty;
  const LZ4HC_CCtx_internal *dictCtx;
};

/* 13 */
struct LZ4_stream_t_internal
{
  LZ4_u32 hashTable[4096];
  const LZ4_byte *dictionary;
  const LZ4_stream_t_internal *dictCtx;
  LZ4_u32 currentOffset;
  LZ4_u32 tableType;
  LZ4_u32 dictSize;
};

/* 62 */
typedef unsigned int size_t;

/* 224 */
typedef void *(*LZ4F_AllocFunction)(void *, size_t);

/* 223 */
typedef void *(*LZ4F_CallocFunction)(void *, size_t);

/* 222 */
typedef void (*LZ4F_FreeFunction)(void *, void *);

/* 14 */
struct LZ4F_CustomMem
{
  LZ4F_AllocFunction customAlloc;
  LZ4F_CallocFunction customCalloc;
  LZ4F_FreeFunction customFree;
  void *opaqueState;
};

/* 15 */
typedef XXH32_state_s XXH32_state_t;

/* 247 */
struct XXH32_state_s
{
  uint32_t total_len_32;
  uint32_t large_len;
  uint32_t v1;
  uint32_t v2;
  uint32_t v3;
  uint32_t v4;
  uint32_t mem32[4];
  uint32_t memsize;
  uint32_t reserved;
};

/* 16 */
typedef uint64_t U64;

/* 17 */
enum dStage_t : __int32
{
  dstage_getFrameHeader = 0x0,
  dstage_storeFrameHeader = 0x1,
  dstage_init = 0x2,
  dstage_getBlockHeader = 0x3,
  dstage_storeBlockHeader = 0x4,
  dstage_copyDirect = 0x5,
  dstage_getBlockChecksum = 0x6,
  dstage_getCBlock = 0x7,
  dstage_storeCBlock = 0x8,
  dstage_flushOut = 0x9,
  dstage_getSuffix = 0xA,
  dstage_storeSuffix = 0xB,
  dstage_getSFrameSize = 0xC,
  dstage_storeSFrameSize = 0xD,
  dstage_skipSkippable = 0xE,
};

/* 18 */
typedef uint32_t U32;

/* 19 */
enum LZ4F_blockCompression_t : __int32
{
  LZ4B_COMPRESSED = 0x0,
  LZ4B_UNCOMPRESSED = 0x1,
};

/* 20 */
typedef uint16_t U16;

/* 21 */
struct LZ4_streamDecode_t_internal
{
  const LZ4_byte *externalDict;
  const LZ4_byte *prefixEnd;
  size_t extDictSize;
  size_t prefixSize;
};

/* 276 */
typedef _eeprom_data_format *edf_ctx_p;

/* 22 */
typedef int (*edf_u8_set)(edf_ctx_p, uint8_t);

/* 23 */
typedef int (*edf_u8_get)(edf_ctx_p);

/* 31 */
typedef int (*edf_i8_array_get)(edf_ctx_p, char *, size_t *);

/* 30 */
typedef int (*edf_i8_array_set)(edf_ctx_p, char *, size_t *);

/* 25 */
typedef int (*edf_u8_array_get)(edf_ctx_p, uint8_t *, size_t *);

/* 24 */
typedef int (*edf_u8_array_set)(edf_ctx_p, uint8_t *, size_t *);

/* 27 */
typedef int (*edf_u16_get)(edf_ctx_p);

/* 26 */
typedef int (*edf_u16_set)(edf_ctx_p, uint16_t);

/* 29 */
typedef int (*edf_i8_get)(edf_ctx_p);

/* 28 */
typedef int (*edf_i8_set)(edf_ctx_p, int8_t);

/* 32 */
struct _eeprom_data_format
{
  int (*load)(edf_ctx_p, uint8_t *, size_t, int);
  uint32_t (*capability)(edf_ctx_p);
  int (*region_all_encode)(edf_ctx_p, char *, size_t *);
  int (*region_1_encode)(edf_ctx_p, char *, size_t *, size_t *);
  int (*region_2_encode)(edf_ctx_p, char *, size_t *, size_t *);
  int (*region_3_encode)(edf_ctx_p, char *, size_t *, size_t *);
  edf_u8_get version_get;
  edf_u8_get enc_algorithm_get;
  edf_u8_set enc_algorithm_set;
  edf_u8_get enc_key_version_get;
  edf_u8_set enc_key_version_set;
  edf_i8_array_get board_sn_get;
  edf_i8_array_set board_sn_set;
  edf_i8_array_get chip_die_get;
  edf_i8_array_set chip_die_set;
  edf_i8_array_get chip_marking_get;
  edf_i8_array_set chip_marking_set;
  edf_i8_array_get ft_version_get;
  edf_i8_array_set ft_version_set;
  edf_i8_array_get chip_tech_get;
  edf_i8_array_set chip_tech_set;
  edf_u8_get chip_bin_get;
  edf_u8_set chip_bin_set;
  edf_u8_get asic_sensor_type_get;
  edf_u8_set asic_sensor_type_set;
  edf_u8_array_get asic_sensor_addr_get;
  edf_u8_array_set asic_sensor_addr_set;
  edf_u8_get pic_sensor_type_get;
  edf_u8_set pic_sensor_type_set;
  edf_u8_get pic_sensor_addr_get;
  edf_u8_set pic_sensor_addr_set;
  edf_i8_array_set sensor_offset_set;
  edf_i8_array_get sensor_offset_get;
  edf_u16_get pcb_version_get;
  edf_u16_set pcb_version_set;
  edf_u16_get bom_version_get;
  edf_u16_set bom_version_set;
  edf_u8_get pt1_result_get;
  edf_u8_set pt1_result_set;
  edf_u8_get pt1_count_get;
  edf_u8_set pt1_count_set;
  edf_u8_get pt2_result_get;
  edf_u8_set pt2_result_set;
  edf_u8_get pt2_count_get;
  edf_u8_set pt2_count_set;
  edf_i8_array_get board_name_get;
  edf_i8_array_set board_name_set;
  edf_i8_array_get factory_job_get;
  edf_i8_array_set factory_job_set;
  edf_u16_get voltage_get;
  edf_u16_set voltage_set;
  edf_u16_get frequency_get;
  edf_u16_set frequency_set;
  edf_u16_get nonce_rate_get;
  edf_u16_set nonce_rate_set;
  edf_i8_get pcb_temp_in_get;
  edf_i8_set pcb_temp_in_set;
  edf_i8_get pcb_temp_out_get;
  edf_i8_set pcb_temp_out_set;
  edf_u8_get test_version_get;
  edf_u8_set test_version_set;
  edf_u8_get test_standard_get;
  edf_u8_set test_standard_set;
  edf_u16_get sweep_hashrate_get;
  edf_u16_set sweep_hashrate_set;
  edf_u16_get sweep_freq_base_get;
  edf_u16_set sweep_freq_base_set;
  edf_u8_get sweep_freq_step_get;
  edf_u8_set sweep_freq_step_set;
  edf_u8_array_get sweep_level_get;
  edf_u8_array_set sweep_level_set;
  edf_u8_get sweep_result_get;
  edf_u8_set sweep_result_set;
  void (*dump_data)(edf_ctx_p);
  void (*destroy)(edf_ctx_p);
  void *priv;
};

/* 33 */
struct _pqueue;

/* 34 */
struct dtls1_timeout_st
{
  unsigned int read_timeouts;
  unsigned int write_timeouts;
  unsigned int num_alerts;
};

/* 412 */
typedef evp_cipher_ctx_st EVP_CIPHER_CTX;

/* 363 */
typedef env_md_ctx_st EVP_MD_CTX;

/* 447 */
typedef comp_ctx_st COMP_CTX;

/* 348 */
typedef ssl_session_st SSL_SESSION;

/* 330 */
struct __attribute__((aligned(4))) dtls1_retransmit_state
{
  EVP_CIPHER_CTX *enc_write_ctx;
  EVP_MD_CTX *write_hash;
  COMP_CTX *compress;
  SSL_SESSION *session;
  unsigned __int16 epoch;
};

/* 35 */
struct hm_header_st
{
  unsigned __int8 type;
  unsigned int msg_len;
  unsigned __int16 seq;
  unsigned int frag_off;
  unsigned int frag_len;
  unsigned int is_ccs;
  dtls1_retransmit_state saved_retransmit_state;
};

/* 410 */
typedef evp_cipher_st EVP_CIPHER;

/* 416 */
typedef void ENGINE;

/* 457 */
struct evp_cipher_ctx_st
{
  const EVP_CIPHER *cipher;
  ENGINE *engine;
  int encrypt;
  int buf_len;
  unsigned __int8 oiv[16];
  unsigned __int8 iv[16];
  unsigned __int8 buf[32];
  int num;
  void *app_data;
  int key_len;
  unsigned int flags;
  void *cipher_data;
  int final_used;
  int block_mask;
  unsigned __int8 final[32];
};

/* 414 */
typedef env_md_st EVP_MD;

/* 413 */
typedef void EVP_PKEY_CTX;

/* 602 */
struct env_md_ctx_st
{
  const EVP_MD *digest;
  ENGINE *engine;
  unsigned int flags;
  void *md_data;
  EVP_PKEY_CTX *pctx;
  int (*update)(EVP_MD_CTX *, const void *, size_t);
};

/* 446 */
typedef comp_method_st COMP_METHOD;

/* 449 */
struct crypto_ex_data_st
{
  stack_st_void *sk;
  int dummy;
};

/* 44 */
typedef crypto_ex_data_st CRYPTO_EX_DATA;

/* 507 */
struct comp_ctx_st
{
  COMP_METHOD *meth;
  unsigned int compress_in;
  unsigned int compress_out;
  unsigned int expand_in;
  unsigned int expand_out;
  CRYPTO_EX_DATA ex_data;
};

/* 354 */
struct sess_cert_st;

/* 422 */
typedef x509_st X509;

/* 358 */
typedef ssl_cipher_st SSL_CIPHER;

/* 353 */
struct ssl_session_st
{
  int ssl_version;
  unsigned int key_arg_length;
  unsigned __int8 key_arg[8];
  int master_key_length;
  unsigned __int8 master_key[48];
  unsigned int session_id_length;
  unsigned __int8 session_id[32];
  unsigned int sid_ctx_length;
  unsigned __int8 sid_ctx[32];
  char *psk_identity_hint;
  char *psk_identity;
  int not_resumable;
  sess_cert_st *sess_cert;
  X509 *peer;
  int verify_result;
  int references;
  int timeout;
  int time;
  unsigned int compress_meth;
  const SSL_CIPHER *cipher;
  unsigned int cipher_id;
  stack_st_SSL_CIPHER *ciphers;
  CRYPTO_EX_DATA ex_data;
  ssl_session_st *prev;
  ssl_session_st *next;
  char *tlsext_hostname;
  size_t tlsext_ecpointformatlist_length;
  unsigned __int8 *tlsext_ecpointformatlist;
  size_t tlsext_ellipticcurvelist_length;
  unsigned __int8 *tlsext_ellipticcurvelist;
  unsigned __int8 *tlsext_tick;
  size_t tlsext_ticklen;
  int tlsext_tick_lifetime_hint;
  char *srp_username;
};

/* 411 */
typedef asn1_type_st ASN1_TYPE;

/* 604 */
struct evp_cipher_st
{
  int nid;
  int block_size;
  int key_len;
  int iv_len;
  unsigned int flags;
  int (*init)(EVP_CIPHER_CTX *, const unsigned __int8 *, const unsigned __int8 *, int);
  int (*do_cipher)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, size_t);
  int (*cleanup)(EVP_CIPHER_CTX *);
  int ctx_size;
  int (*set_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *);
  int (*get_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *);
  int (*ctrl)(EVP_CIPHER_CTX *, int, int, void *);
  void *app_data;
};

/* 603 */
struct env_md_st
{
  int type;
  int pkey_type;
  int md_size;
  unsigned int flags;
  int (*init)(EVP_MD_CTX *);
  int (*update)(EVP_MD_CTX *, const void *, size_t);
  int (*final)(EVP_MD_CTX *, unsigned __int8 *);
  int (*copy)(EVP_MD_CTX *, const EVP_MD_CTX *);
  int (*cleanup)(EVP_MD_CTX *);
  int (*sign)(int, const unsigned __int8 *, unsigned int, unsigned __int8 *, unsigned int *, void *);
  int (*verify)(int, const unsigned __int8 *, unsigned int, const unsigned __int8 *, unsigned int, void *);
  int required_pkey_type[5];
  int block_size;
  int ctx_size;
  int (*md_ctrl)(EVP_MD_CTX *, int, int, void *);
};

/* 616 */
struct comp_method_st
{
  int type;
  const char *name;
  int (*init)(COMP_CTX *);
  void (*finish)(COMP_CTX *);
  int (*compress)(COMP_CTX *, unsigned __int8 *, unsigned int, unsigned __int8 *, unsigned int);
  int (*expand)(COMP_CTX *, unsigned __int8 *, unsigned int, unsigned __int8 *, unsigned int);
  int (*ctrl)(void);
  int (*callback_ctrl)(void);
};

/* 605 */
struct stack_st
{
  int num;
  char **data;
  int sorted;
  int num_alloc;
  int (*comp)(const void *, const void *);
};

/* 352 */
typedef stack_st _STACK;

/* 448 */
struct stack_st_void
{
  _STACK stack;
};

/* 387 */
typedef x509_cinf_st X509_CINF;

/* 403 */
typedef X509_algor_st X509_ALGOR;

/* 435 */
typedef asn1_string_st ASN1_BIT_STRING;

/* 434 */
typedef asn1_string_st ASN1_OCTET_STRING;

/* 386 */
typedef void AUTHORITY_KEYID;

/* 385 */
typedef void X509_POLICY_CACHE;

/* 384 */
struct stack_st_DIST_POINT;

/* 383 */
struct stack_st_GENERAL_NAME;

/* 382 */
typedef void NAME_CONSTRAINTS;

/* 381 */
typedef x509_cert_aux_st X509_CERT_AUX;

/* 454 */
struct x509_st
{
  X509_CINF *cert_info;
  X509_ALGOR *sig_alg;
  ASN1_BIT_STRING *signature;
  int valid;
  int references;
  char *name;
  CRYPTO_EX_DATA ex_data;
  int ex_pathlen;
  int ex_pcpathlen;
  unsigned int ex_flags;
  unsigned int ex_kusage;
  unsigned int ex_xkusage;
  unsigned int ex_nscert;
  ASN1_OCTET_STRING *skid;
  AUTHORITY_KEYID *akid;
  X509_POLICY_CACHE *policy_cache;
  stack_st_DIST_POINT *crldp;
  stack_st_GENERAL_NAME *altname;
  NAME_CONSTRAINTS *nc;
  unsigned __int8 sha1_hash[20];
  X509_CERT_AUX *aux;
};

/* 361 */
struct ssl_cipher_st
{
  int valid;
  const char *name;
  unsigned int id;
  unsigned int algorithm_mkey;
  unsigned int algorithm_auth;
  unsigned int algorithm_enc;
  unsigned int algorithm_mac;
  unsigned int algorithm_ssl;
  unsigned int algo_strength;
  unsigned int algorithm2;
  int strength_bits;
  int alg_bits;
};

/* 360 */
struct stack_st_SSL_CIPHER
{
  _STACK stack;
};

/* 440 */
typedef int ASN1_BOOLEAN;

/* 439 */
typedef asn1_string_st ASN1_STRING;

/* 438 */
typedef asn1_object_st ASN1_OBJECT;

/* 437 */
typedef asn1_string_st ASN1_INTEGER;

/* 436 */
typedef asn1_string_st ASN1_ENUMERATED;

/* 433 */
typedef asn1_string_st ASN1_PRINTABLESTRING;

/* 432 */
typedef asn1_string_st ASN1_T61STRING;

/* 431 */
typedef asn1_string_st ASN1_IA5STRING;

/* 430 */
typedef asn1_string_st ASN1_GENERALSTRING;

/* 429 */
typedef asn1_string_st ASN1_BMPSTRING;

/* 428 */
typedef asn1_string_st ASN1_UNIVERSALSTRING;

/* 427 */
typedef asn1_string_st ASN1_UTCTIME;

/* 426 */
typedef asn1_string_st ASN1_GENERALIZEDTIME;

/* 425 */
typedef asn1_string_st ASN1_VISIBLESTRING;

/* 424 */
typedef asn1_string_st ASN1_UTF8STRING;

/* 423 */
typedef void ASN1_VALUE;

/* 597 */
union asn1_type_st::$2DD2868AF9E8E8462C9810218891F7E4
{
  char *ptr;
  ASN1_BOOLEAN boolean;
  ASN1_STRING *asn1_string;
  ASN1_OBJECT *object;
  ASN1_INTEGER *integer;
  ASN1_ENUMERATED *enumerated;
  ASN1_BIT_STRING *bit_string;
  ASN1_OCTET_STRING *octet_string;
  ASN1_PRINTABLESTRING *printablestring;
  ASN1_T61STRING *t61string;
  ASN1_IA5STRING *ia5string;
  ASN1_GENERALSTRING *generalstring;
  ASN1_BMPSTRING *bmpstring;
  ASN1_UNIVERSALSTRING *universalstring;
  ASN1_UTCTIME *utctime;
  ASN1_GENERALIZEDTIME *generalizedtime;
  ASN1_VISIBLESTRING *visiblestring;
  ASN1_UTF8STRING *utf8string;
  ASN1_STRING *set;
  ASN1_STRING *sequence;
  ASN1_VALUE *asn1_value;
};

/* 596 */
struct asn1_type_st
{
  int type;
  asn1_type_st::$2DD2868AF9E8E8462C9810218891F7E4 value;
};

/* 393 */
typedef X509_name_st X509_NAME;

/* 391 */
typedef X509_val_st X509_VAL;

/* 392 */
typedef X509_pubkey_st X509_PUBKEY;

/* 506 */
struct ASN1_ENCODING_st
{
  unsigned __int8 *enc;
  int len;
  int modified;
};

/* 380 */
typedef ASN1_ENCODING_st ASN1_ENCODING;

/* 614 */
struct x509_cinf_st
{
  ASN1_INTEGER *version;
  ASN1_INTEGER *serialNumber;
  X509_ALGOR *signature;
  X509_NAME *issuer;
  X509_VAL *validity;
  X509_NAME *subject;
  X509_PUBKEY *key;
  ASN1_BIT_STRING *issuerUID;
  ASN1_BIT_STRING *subjectUID;
  stack_st_X509_EXTENSION *extensions;
  ASN1_ENCODING enc;
};

/* 453 */
struct X509_algor_st
{
  ASN1_OBJECT *algorithm;
  ASN1_TYPE *parameter;
};

/* 461 */
struct asn1_string_st
{
  int length;
  int type;
  unsigned __int8 *data;
  int flags;
};

/* 594 */
struct x509_cert_aux_st
{
  stack_st_ASN1_OBJECT *trust;
  stack_st_ASN1_OBJECT *reject;
  ASN1_UTF8STRING *alias;
  ASN1_OCTET_STRING *keyid;
  stack_st_X509_ALGOR *other;
};

/* 460 */
struct asn1_object_st
{
  const char *sn;
  const char *ln;
  int nid;
  int length;
  const unsigned __int8 *data;
  int flags;
};

/* 394 */
typedef buf_mem_st BUF_MEM;

/* 451 */
struct X509_name_st
{
  stack_st_X509_NAME_ENTRY *entries;
  int modified;
  BUF_MEM *bytes;
  unsigned __int8 *canon_enc;
  int canon_enclen;
};

/* 397 */
typedef asn1_string_st ASN1_TIME;

/* 505 */
struct X509_val_st
{
  ASN1_TIME *notBefore;
  ASN1_TIME *notAfter;
};

/* 396 */
typedef evp_pkey_st EVP_PKEY;

/* 450 */
struct X509_pubkey_st
{
  X509_ALGOR *algor;
  ASN1_BIT_STRING *public_key;
  EVP_PKEY *pkey;
};

/* 390 */
struct stack_st_X509_EXTENSION
{
  _STACK stack;
};

/* 389 */
struct stack_st_ASN1_OBJECT
{
  _STACK stack;
};

/* 388 */
struct stack_st_X509_ALGOR
{
  _STACK stack;
};

/* 395 */
struct stack_st_X509_NAME_ENTRY
{
  _STACK stack;
};

/* 458 */
struct buf_mem_st
{
  size_t length;
  char *data;
  size_t max;
};

/* 417 */
typedef void EVP_PKEY_ASN1_METHOD;

/* 418 */
struct ec_key_st;

/* 456 */
union evp_pkey_st::$F5407467FA02B60B7EFCBB61B9739A1C
{
  char *ptr;
  rsa_st *rsa;
  dsa_st *dsa;
  dh_st *dh;
  ec_key_st *ec;
};

/* 455 */
struct evp_pkey_st
{
  int type;
  int save_type;
  int references;
  const EVP_PKEY_ASN1_METHOD *ameth;
  ENGINE *engine;
  evp_pkey_st::$F5407467FA02B60B7EFCBB61B9739A1C pkey;
  int save_parameters;
  stack_st_X509_ATTRIBUTE *attributes;
};

/* 405 */
typedef rsa_meth_st RSA_METHOD;

/* 409 */
typedef bignum_st BIGNUM;

/* 407 */
typedef bn_mont_ctx_st BN_MONT_CTX;

/* 404 */
typedef void BN_BLINDING;

/* 421 */
struct rsa_st
{
  int pad;
  int version;
  const RSA_METHOD *meth;
  ENGINE *engine;
  BIGNUM *n;
  BIGNUM *e;
  BIGNUM *d;
  BIGNUM *p;
  BIGNUM *q;
  BIGNUM *dmp1;
  BIGNUM *dmq1;
  BIGNUM *iqmp;
  CRYPTO_EX_DATA ex_data;
  int references;
  int flags;
  BN_MONT_CTX *_method_mod_n;
  BN_MONT_CTX *_method_mod_p;
  BN_MONT_CTX *_method_mod_q;
  char *bignum_data;
  BN_BLINDING *blinding;
  BN_BLINDING *mt_blinding;
};

/* 398 */
typedef dsa_method DSA_METHOD;

/* 420 */
struct dsa_st
{
  int pad;
  int version;
  int write_params;
  BIGNUM *p;
  BIGNUM *q;
  BIGNUM *g;
  BIGNUM *pub_key;
  BIGNUM *priv_key;
  BIGNUM *kinv;
  BIGNUM *r;
  int flags;
  BN_MONT_CTX *method_mont_p;
  int references;
  CRYPTO_EX_DATA ex_data;
  const DSA_METHOD *meth;
  ENGINE *engine;
};

/* 401 */
typedef dh_method DH_METHOD;

/* 419 */
struct dh_st
{
  int pad;
  int version;
  BIGNUM *p;
  BIGNUM *g;
  int length;
  BIGNUM *pub_key;
  BIGNUM *priv_key;
  int flags;
  BN_MONT_CTX *method_mont_p;
  BIGNUM *q;
  BIGNUM *j;
  unsigned __int8 *seed;
  int seedlen;
  BIGNUM *counter;
  int references;
  CRYPTO_EX_DATA ex_data;
  const DH_METHOD *meth;
  ENGINE *engine;
};

/* 415 */
struct stack_st_X509_ATTRIBUTE
{
  _STACK stack;
};

/* 406 */
typedef rsa_st RSA;

/* 408 */
typedef void BN_CTX;

/* 441 */
typedef bn_gencb_st BN_GENCB;

/* 599 */
struct rsa_meth_st
{
  const char *name;
  int (*rsa_pub_enc)(int, const unsigned __int8 *, unsigned __int8 *, RSA *, int);
  int (*rsa_pub_dec)(int, const unsigned __int8 *, unsigned __int8 *, RSA *, int);
  int (*rsa_priv_enc)(int, const unsigned __int8 *, unsigned __int8 *, RSA *, int);
  int (*rsa_priv_dec)(int, const unsigned __int8 *, unsigned __int8 *, RSA *, int);
  int (*rsa_mod_exp)(BIGNUM *, const BIGNUM *, RSA *, BN_CTX *);
  int (*bn_mod_exp)(BIGNUM *, const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *, BN_MONT_CTX *);
  int (*init)(RSA *);
  int (*finish)(RSA *);
  int flags;
  char *app_data;
  int (*rsa_sign)(int, const unsigned __int8 *, unsigned int, unsigned __int8 *, unsigned int *, const RSA *);
  int (*rsa_verify)(int, const unsigned __int8 *, unsigned int, const unsigned __int8 *, unsigned int, const RSA *);
  int (*rsa_keygen)(RSA *, int, BIGNUM *, BN_GENCB *);
};

/* 47 */
struct bignum_st
{
  unsigned int *d;
  int top;
  int dmax;
  int neg;
  int flags;
};

/* 459 */
struct bn_mont_ctx_st
{
  int ri;
  BIGNUM RR;
  BIGNUM N;
  BIGNUM Ni;
  unsigned int n0[2];
  int flags;
};

/* 400 */
typedef DSA_SIG_st DSA_SIG;

/* 399 */
typedef dsa_st DSA;

/* 600 */
struct dsa_method
{
  const char *name;
  DSA_SIG *(*dsa_do_sign)(const unsigned __int8 *, int, DSA *);
  int (*dsa_sign_setup)(DSA *, BN_CTX *, BIGNUM **, BIGNUM **);
  int (*dsa_do_verify)(const unsigned __int8 *, int, DSA_SIG *, DSA *);
  int (*dsa_mod_exp)(DSA *, BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *, BN_MONT_CTX *);
  int (*bn_mod_exp)(DSA *, BIGNUM *, BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *, BN_MONT_CTX *);
  int (*init)(DSA *);
  int (*finish)(DSA *);
  int flags;
  char *app_data;
  int (*dsa_paramgen)(DSA *, int, const unsigned __int8 *, int, int *, unsigned int *, BN_GENCB *);
  int (*dsa_keygen)(DSA *);
};

/* 402 */
typedef dh_st DH;

/* 601 */
struct dh_method
{
  const char *name;
  int (*generate_key)(DH *);
  int (*compute_key)(unsigned __int8 *, const BIGNUM *, DH *);
  int (*bn_mod_exp)(const DH *, BIGNUM *, const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *, BN_MONT_CTX *);
  int (*init)(DH *);
  int (*finish)(DH *);
  int flags;
  char *app_data;
  int (*generate_params)(DH *, int, int, BN_GENCB *);
};

/* 509 */
union bn_gencb_st::$70E894915DA6DC2BABEF161B69A44B70
{
  void (*cb_1)(int, int, void *);
  int (*cb_2)(int, int, BN_GENCB *);
};

/* 508 */
struct bn_gencb_st
{
  unsigned int ver;
  void *arg;
  bn_gencb_st::$70E894915DA6DC2BABEF161B69A44B70 cb;
};

/* 595 */
struct DSA_SIG_st
{
  BIGNUM *r;
  BIGNUM *s;
};

/* 36 */
typedef record_pqueue_st record_pqueue;

/* 37 */
typedef struct _pqueue *pqueue;

/* 499 */
struct record_pqueue_st
{
  unsigned __int16 epoch;
  pqueue q;
};

/* 38 */
typedef dtls1_bitmap_st DTLS1_BITMAP;

/* 500 */
struct dtls1_bitmap_st
{
  unsigned int map;
  unsigned __int8 max_seq_num[8];
};

/* 39 */
typedef ssl3_record_st SSL3_RECORD;

/* 502 */
struct ssl3_record_st
{
  int type;
  unsigned int length;
  unsigned int off;
  unsigned __int8 *data;
  unsigned __int8 *input;
  unsigned __int8 *comp;
  unsigned int epoch;
  unsigned __int8 seq_num[8];
};

/* 40 */
typedef ssl3_buffer_st SSL3_BUFFER;

/* 501 */
struct ssl3_buffer_st
{
  unsigned __int8 *buf;
  size_t len;
  int offset;
  int left;
};

/* 41 */
struct tls_session_ticket_ext_st
{
  unsigned __int16 length;
  void *data;
};

/* 42 */
typedef srp_ctx_st SRP_CTX;

/* 357 */
typedef ssl_st SSL;

/* 612 */
struct srp_ctx_st
{
  void *SRP_cb_arg;
  int (*TLS_ext_srp_username_callback)(SSL *, int *, void *);
  int (*SRP_verify_param_callback)(SSL *, void *);
  char *(*SRP_give_srp_client_pwd_callback)(SSL *, void *);
  char *login;
  BIGNUM *N;
  BIGNUM *g;
  BIGNUM *s;
  BIGNUM *B;
  BIGNUM *A;
  BIGNUM *a;
  BIGNUM *b;
  BIGNUM *v;
  char *info;
  int strength;
  unsigned int srp_Mask;
};

/* 351 */
typedef ssl_method_st SSL_METHOD;

/* 444 */
typedef bio_st BIO;

/* 368 */
typedef X509_VERIFY_PARAM_st X509_VERIFY_PARAM;

/* 343 */
struct cert_st;

/* 43 */
typedef int (*GEN_SESSION_CB)(const SSL *, unsigned __int8 *, unsigned int *);

/* 367 */
typedef x509_store_ctx_st X509_STORE_CTX;

/* 359 */
typedef ssl_ctx_st SSL_CTX;

/* 336 */
struct stack_st_OCSP_RESPID;

/* 335 */
typedef stack_st_X509_EXTENSION X509_EXTENSIONS;

/* 334 */
typedef tls_session_ticket_ext_st TLS_SESSION_TICKET_EXT;

/* 46 */
typedef int (*tls_session_ticket_ext_cb_fn)(SSL *, const unsigned __int8 *, int, void *);

/* 45 */
typedef int (*tls_session_secret_cb_fn)(SSL *, void *, int *, stack_st_SSL_CIPHER *, SSL_CIPHER **, void *);

/* 333 */
typedef srtp_protection_profile_st SRTP_PROTECTION_PROFILE;

/* 362 */
struct ssl_st
{
  int version;
  int type;
  const SSL_METHOD *method;
  BIO *rbio;
  BIO *wbio;
  BIO *bbio;
  int rwstate;
  int in_handshake;
  int (*handshake_func)(SSL *);
  int server;
  int new_session;
  int quiet_shutdown;
  int shutdown;
  int state;
  int rstate;
  BUF_MEM *init_buf;
  void *init_msg;
  int init_num;
  int init_off;
  unsigned __int8 *packet;
  unsigned int packet_length;
  ssl2_state_st *s2;
  ssl3_state_st *s3;
  dtls1_state_st *d1;
  int read_ahead;
  void (*msg_callback)(int, int, int, const void *, size_t, SSL *, void *);
  void *msg_callback_arg;
  int hit;
  X509_VERIFY_PARAM *param;
  stack_st_SSL_CIPHER *cipher_list;
  stack_st_SSL_CIPHER *cipher_list_by_id;
  int mac_flags;
  EVP_CIPHER_CTX *enc_read_ctx;
  EVP_MD_CTX *read_hash;
  COMP_CTX *expand;
  EVP_CIPHER_CTX *enc_write_ctx;
  EVP_MD_CTX *write_hash;
  COMP_CTX *compress;
  cert_st *cert;
  unsigned int sid_ctx_length;
  unsigned __int8 sid_ctx[32];
  SSL_SESSION *session;
  GEN_SESSION_CB generate_session_id;
  int verify_mode;
  int (*verify_callback)(int, X509_STORE_CTX *);
  void (*info_callback)(const SSL *, int, int);
  int error;
  int error_code;
  unsigned int (*psk_client_callback)(SSL *, const char *, char *, unsigned int, unsigned __int8 *, unsigned int);
  unsigned int (*psk_server_callback)(SSL *, const char *, unsigned __int8 *, unsigned int);
  SSL_CTX *ctx;
  int debug;
  int verify_result;
  CRYPTO_EX_DATA ex_data;
  stack_st_X509_NAME *client_CA;
  int references;
  unsigned int options;
  unsigned int mode;
  int max_cert_list;
  int first_packet;
  int client_version;
  unsigned int max_send_fragment;
  void (*tlsext_debug_cb)(SSL *, int, int, unsigned __int8 *, int, void *);
  void *tlsext_debug_arg;
  char *tlsext_hostname;
  int servername_done;
  int tlsext_status_type;
  int tlsext_status_expected;
  stack_st_OCSP_RESPID *tlsext_ocsp_ids;
  X509_EXTENSIONS *tlsext_ocsp_exts;
  unsigned __int8 *tlsext_ocsp_resp;
  int tlsext_ocsp_resplen;
  int tlsext_ticket_expected;
  size_t tlsext_ecpointformatlist_length;
  unsigned __int8 *tlsext_ecpointformatlist;
  size_t tlsext_ellipticcurvelist_length;
  unsigned __int8 *tlsext_ellipticcurvelist;
  void *tlsext_opaque_prf_input;
  size_t tlsext_opaque_prf_input_len;
  TLS_SESSION_TICKET_EXT *tlsext_session_ticket;
  tls_session_ticket_ext_cb_fn tls_session_ticket_ext_cb;
  void *tls_session_ticket_ext_cb_arg;
  tls_session_secret_cb_fn tls_session_secret_cb;
  void *tls_session_secret_cb_arg;
  SSL_CTX *initial_ctx;
  unsigned __int8 *next_proto_negotiated;
  unsigned __int8 next_proto_negotiated_len;
  stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  SRTP_PROTECTION_PROFILE *srtp_profile;
  unsigned int tlsext_heartbeat;
  unsigned int tlsext_hb_pending;
  unsigned int tlsext_hb_seq;
  int renegotiate;
  SRP_CTX srp_ctx;
  unsigned __int8 *alpn_client_proto_list;
  unsigned int alpn_client_proto_list_len;
};

/* 355 */
struct ssl3_enc_method;

/* 356 */
struct ssl_method_st
{
  int version;
  int (*ssl_new)(SSL *);
  void (*ssl_clear)(SSL *);
  void (*ssl_free)(SSL *);
  int (*ssl_accept)(SSL *);
  int (*ssl_connect)(SSL *);
  int (*ssl_read)(SSL *, void *, int);
  int (*ssl_peek)(SSL *, void *, int);
  int (*ssl_write)(SSL *, const void *, int);
  int (*ssl_shutdown)(SSL *);
  int (*ssl_renegotiate)(SSL *);
  int (*ssl_renegotiate_check)(SSL *);
  int (*ssl_get_message)(SSL *, int, int, int, int, int *);
  int (*ssl_read_bytes)(SSL *, int, unsigned __int8 *, int, int);
  int (*ssl_write_bytes)(SSL *, int, const void *, int);
  int (*ssl_dispatch_alert)(SSL *);
  int (*ssl_ctrl)(SSL *, int, int, void *);
  int (*ssl_ctx_ctrl)(SSL_CTX *, int, int, void *);
  const SSL_CIPHER *(*get_cipher_by_char)(const unsigned __int8 *);
  int (*put_cipher_by_char)(const SSL_CIPHER *, unsigned __int8 *);
  int (*ssl_pending)(const SSL *);
  int (*num_ciphers)(void);
  const SSL_CIPHER *(*get_cipher)(unsigned int);
  const ssl_method_st *(*get_ssl_method)(int);
  int (*get_timeout)(void);
  ssl3_enc_method *ssl3_enc;
  int (*ssl_version)(void);
  int (*ssl_callback_ctrl)(SSL *, int, void (*)(void));
  int (*ssl_ctx_callback_ctrl)(SSL_CTX *, int, void (*)(void));
};

/* 442 */
typedef bio_method_st BIO_METHOD;

/* 445 */
struct bio_st
{
  BIO_METHOD *method;
  int (*callback)(bio_st *, int, const char *, int, int, int);
  char *cb_arg;
  int init;
  int shutdown;
  int flags;
  int retry_reason;
  int num;
  void *ptr;
  bio_st *next_bio;
  bio_st *prev_bio;
  int references;
  unsigned int num_read;
  unsigned int num_write;
  CRYPTO_EX_DATA ex_data;
};

/* 714 */
struct ssl2_state_st::$84C368C7769861FE002B58071E3F7188
{
  unsigned int conn_id_length;
  unsigned int cert_type;
  unsigned int cert_length;
  unsigned int csl;
  unsigned int clear;
  unsigned int enc;
  unsigned __int8 ccl[32];
  unsigned int cipher_spec_length;
  unsigned int session_id_length;
  unsigned int clen;
  unsigned int rlen;
};

/* 339 */
struct ssl2_state_st
{
  int three_byte_header;
  int clear_text;
  int escape;
  int ssl2_rollback;
  unsigned int wnum;
  int wpend_tot;
  const unsigned __int8 *wpend_buf;
  int wpend_off;
  int wpend_len;
  int wpend_ret;
  int rbuf_left;
  int rbuf_offs;
  unsigned __int8 *rbuf;
  unsigned __int8 *wbuf;
  unsigned __int8 *write_ptr;
  unsigned int padding;
  unsigned int rlength;
  int ract_data_length;
  unsigned int wlength;
  int wact_data_length;
  unsigned __int8 *ract_data;
  unsigned __int8 *wact_data;
  unsigned __int8 *mac_data;
  unsigned __int8 *read_key;
  unsigned __int8 *write_key;
  unsigned int challenge_length;
  unsigned __int8 challenge[32];
  unsigned int conn_id_length;
  unsigned __int8 conn_id[16];
  unsigned int key_material_length;
  unsigned __int8 key_material[48];
  unsigned int read_sequence;
  unsigned int write_sequence;
  ssl2_state_st::$84C368C7769861FE002B58071E3F7188 tmp;
};

/* 332 */
typedef ec_key_st EC_KEY;

/* 331 */
typedef ssl_comp_st SSL_COMP;

/* 713 */
struct ssl3_state_st::$4FEB17077B80923927B1BB4D4130D0AA
{
  unsigned __int8 cert_verify_md[128];
  unsigned __int8 finish_md[128];
  int finish_md_len;
  unsigned __int8 peer_finish_md[128];
  int peer_finish_md_len;
  unsigned int message_size;
  int message_type;
  const SSL_CIPHER *new_cipher;
  DH *dh;
  EC_KEY *ecdh;
  int next_state;
  int reuse_message;
  int cert_req;
  int ctype_num;
  char ctype[9];
  stack_st_X509_NAME *ca_names;
  int use_rsa_tmp;
  int key_block_length;
  unsigned __int8 *key_block;
  const EVP_CIPHER *new_sym_enc;
  const EVP_MD *new_hash;
  int new_mac_pkey_type;
  int new_mac_secret_size;
  const SSL_COMP *new_compression;
  int cert_request;
};

/* 338 */
struct ssl3_state_st
{
  int flags;
  int delay_buf_pop_ret;
  unsigned __int8 read_sequence[8];
  int read_mac_secret_size;
  unsigned __int8 read_mac_secret[64];
  unsigned __int8 write_sequence[8];
  int write_mac_secret_size;
  unsigned __int8 write_mac_secret[64];
  unsigned __int8 server_random[32];
  unsigned __int8 client_random[32];
  int need_empty_fragments;
  int empty_fragment_done;
  int init_extra;
  SSL3_BUFFER rbuf;
  SSL3_BUFFER wbuf;
  SSL3_RECORD rrec;
  SSL3_RECORD wrec;
  unsigned __int8 alert_fragment[2];
  unsigned int alert_fragment_len;
  unsigned __int8 handshake_fragment[4];
  unsigned int handshake_fragment_len;
  unsigned int wnum;
  int wpend_tot;
  int wpend_type;
  int wpend_ret;
  const unsigned __int8 *wpend_buf;
  BIO *handshake_buffer;
  EVP_MD_CTX **handshake_dgst;
  int change_cipher_spec;
  int warn_alert;
  int fatal_alert;
  int alert_dispatch;
  unsigned __int8 send_alert[2];
  int renegotiate;
  int total_renegotiations;
  int num_renegotiations;
  int in_read_app_data;
  void *client_opaque_prf_input;
  size_t client_opaque_prf_input_len;
  void *server_opaque_prf_input;
  size_t server_opaque_prf_input_len;
  ssl3_state_st::$4FEB17077B80923927B1BB4D4130D0AA tmp;
  unsigned __int8 previous_client_finished[64];
  unsigned __int8 previous_client_finished_len;
  unsigned __int8 previous_server_finished[64];
  unsigned __int8 previous_server_finished_len;
  int send_connection_binding;
  int next_proto_neg_seen;
  char is_probably_safari;
  unsigned __int8 *alpn_selected;
  unsigned int alpn_selected_len;
};

/* 60 */
typedef int __time_t;

/* 101 */
typedef int __suseconds_t;

/* 100 */
struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};

/* 337 */
struct dtls1_state_st
{
  unsigned int send_cookie;
  unsigned __int8 cookie[256];
  unsigned __int8 rcvd_cookie[256];
  unsigned int cookie_len;
  unsigned __int16 r_epoch;
  unsigned __int16 w_epoch;
  DTLS1_BITMAP bitmap;
  DTLS1_BITMAP next_bitmap;
  unsigned __int16 handshake_write_seq;
  unsigned __int16 next_handshake_write_seq;
  unsigned __int16 handshake_read_seq;
  unsigned __int8 last_write_sequence[8];
  record_pqueue unprocessed_rcds;
  record_pqueue processed_rcds;
  pqueue buffered_messages;
  pqueue sent_messages;
  record_pqueue buffered_app_data;
  unsigned int listen;
  unsigned int link_mtu;
  unsigned int mtu;
  hm_header_st w_msg_hdr;
  hm_header_st r_msg_hdr;
  dtls1_timeout_st timeout;
  timeval next_timeout;
  unsigned __int16 timeout_duration;
  unsigned __int8 alert_fragment[2];
  unsigned int alert_fragment_len;
  unsigned __int8 handshake_fragment[12];
  unsigned int handshake_fragment_len;
  unsigned int retransmitting;
  unsigned int change_cipher_spec_ok;
};

/* 372 */
typedef __time_t time_t;

/* 371 */
typedef void X509_VERIFY_PARAM_ID;

/* 593 */
struct X509_VERIFY_PARAM_st
{
  char *name;
  time_t check_time;
  unsigned int inh_flags;
  unsigned int flags;
  int purpose;
  int trust;
  int depth;
  stack_st_ASN1_OBJECT *policies;
  X509_VERIFY_PARAM_ID *id;
};

/* 365 */
typedef x509_store_st X509_STORE;

/* 374 */
typedef X509_crl_st X509_CRL;

/* 364 */
typedef void X509_POLICY_TREE;

/* 598 */
struct x509_store_ctx_st
{
  X509_STORE *ctx;
  int current_method;
  X509 *cert;
  stack_st_X509 *untrusted;
  stack_st_X509_CRL *crls;
  X509_VERIFY_PARAM *param;
  void *other_ctx;
  int (*verify)(X509_STORE_CTX *);
  int (*verify_cb)(int, X509_STORE_CTX *);
  int (*get_issuer)(X509 **, X509_STORE_CTX *, X509 *);
  int (*check_issued)(X509_STORE_CTX *, X509 *, X509 *);
  int (*check_revocation)(X509_STORE_CTX *);
  int (*get_crl)(X509_STORE_CTX *, X509_CRL **, X509 *);
  int (*check_crl)(X509_STORE_CTX *, X509_CRL *);
  int (*cert_crl)(X509_STORE_CTX *, X509_CRL *, X509 *);
  int (*check_policy)(X509_STORE_CTX *);
  stack_st_X509 *(*lookup_certs)(X509_STORE_CTX *, X509_NAME *);
  stack_st_X509_CRL *(*lookup_crls)(X509_STORE_CTX *, X509_NAME *);
  int (*cleanup)(X509_STORE_CTX *);
  int valid;
  int last_untrusted;
  stack_st_X509 *chain;
  X509_POLICY_TREE *tree;
  int explicit_policy;
  int error_depth;
  int error;
  X509 *current_cert;
  X509 *current_issuer;
  X509_CRL *current_crl;
  int current_crl_score;
  unsigned int current_reasons;
  X509_STORE_CTX *parent;
  CRYPTO_EX_DATA ex_data;
};

/* 617 */
struct ssl_ctx_st::$1FDE854BB3A5E25B344A4239746AC17B
{
  int sess_connect;
  int sess_connect_renegotiate;
  int sess_connect_good;
  int sess_accept;
  int sess_accept_renegotiate;
  int sess_accept_good;
  int sess_miss;
  int sess_timeout;
  int sess_cache_full;
  int sess_hit;
  int sess_cb_hit;
};

/* 346 */
typedef int pem_password_cb(char *, int, int, void *);

/* 342 */
typedef hmac_ctx_st HMAC_CTX;

/* 341 */
struct ssl3_buf_freelist_st;

/* 347 */
struct ssl_ctx_st
{
  const SSL_METHOD *method;
  stack_st_SSL_CIPHER *cipher_list;
  stack_st_SSL_CIPHER *cipher_list_by_id;
  x509_store_st *cert_store;
  lhash_st_SSL_SESSION *sessions;
  unsigned int session_cache_size;
  ssl_session_st *session_cache_head;
  ssl_session_st *session_cache_tail;
  int session_cache_mode;
  int session_timeout;
  int (*new_session_cb)(ssl_st *, SSL_SESSION *);
  void (*remove_session_cb)(ssl_ctx_st *, SSL_SESSION *);
  SSL_SESSION *(*get_session_cb)(ssl_st *, unsigned __int8 *, int, int *);
  ssl_ctx_st::$1FDE854BB3A5E25B344A4239746AC17B stats;
  int references;
  int (*app_verify_callback)(X509_STORE_CTX *, void *);
  void *app_verify_arg;
  pem_password_cb *default_passwd_callback;
  void *default_passwd_callback_userdata;
  int (*client_cert_cb)(SSL *, X509 **, EVP_PKEY **);
  int (*app_gen_cookie_cb)(SSL *, unsigned __int8 *, unsigned int *);
  int (*app_verify_cookie_cb)(SSL *, unsigned __int8 *, unsigned int);
  CRYPTO_EX_DATA ex_data;
  const EVP_MD *rsa_md5;
  const EVP_MD *md5;
  const EVP_MD *sha1;
  stack_st_X509 *extra_certs;
  stack_st_SSL_COMP *comp_methods;
  void (*info_callback)(const SSL *, int, int);
  stack_st_X509_NAME *client_CA;
  unsigned int options;
  unsigned int mode;
  int max_cert_list;
  cert_st *cert;
  int read_ahead;
  void (*msg_callback)(int, int, int, const void *, size_t, SSL *, void *);
  void *msg_callback_arg;
  int verify_mode;
  unsigned int sid_ctx_length;
  unsigned __int8 sid_ctx[32];
  int (*default_verify_callback)(int, X509_STORE_CTX *);
  GEN_SESSION_CB generate_session_id;
  X509_VERIFY_PARAM *param;
  int quiet_shutdown;
  unsigned int max_send_fragment;
  ENGINE *client_cert_engine;
  int (*tlsext_servername_callback)(SSL *, int *, void *);
  void *tlsext_servername_arg;
  unsigned __int8 tlsext_tick_key_name[16];
  unsigned __int8 tlsext_tick_hmac_key[16];
  unsigned __int8 tlsext_tick_aes_key[16];
  int (*tlsext_ticket_key_cb)(SSL *, unsigned __int8 *, unsigned __int8 *, EVP_CIPHER_CTX *, HMAC_CTX *, int);
  int (*tlsext_status_cb)(SSL *, void *);
  void *tlsext_status_arg;
  int (*tlsext_opaque_prf_input_callback)(SSL *, void *, size_t, void *);
  void *tlsext_opaque_prf_input_callback_arg;
  char *psk_identity_hint;
  unsigned int (*psk_client_callback)(SSL *, const char *, char *, unsigned int, unsigned __int8 *, unsigned int);
  unsigned int (*psk_server_callback)(SSL *, const char *, unsigned __int8 *, unsigned int);
  unsigned int freelist_max_len;
  ssl3_buf_freelist_st *wbuf_freelist;
  ssl3_buf_freelist_st *rbuf_freelist;
  SRP_CTX srp_ctx;
  int (*next_protos_advertised_cb)(SSL *, const unsigned __int8 **, unsigned int *, void *);
  void *next_protos_advertised_cb_arg;
  int (*next_proto_select_cb)(SSL *, unsigned __int8 **, unsigned __int8 *, const unsigned __int8 *, unsigned int, void *);
  void *next_proto_select_cb_arg;
  stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  int (*alpn_select_cb)(SSL *, const unsigned __int8 **, unsigned __int8 *, const unsigned __int8 *, unsigned int, void *);
  void *alpn_select_cb_arg;
  unsigned __int8 *alpn_client_proto_list;
  unsigned int alpn_client_proto_list_len;
  size_t tlsext_ecpointformatlist_length;
  unsigned __int8 *tlsext_ecpointformatlist;
  size_t tlsext_ellipticcurvelist_length;
  unsigned __int8 *tlsext_ellipticcurvelist;
};

/* 344 */
struct stack_st_X509_NAME
{
  _STACK stack;
};

/* 340 */
struct stack_st_SRTP_PROTECTION_PROFILE
{
  _STACK stack;
};

/* 504 */
struct srtp_protection_profile_st
{
  const char *name;
  unsigned int id;
};

/* 443 */
typedef void bio_info_cb(bio_st *, int, const char *, int, int, int);

/* 615 */
struct bio_method_st
{
  int type;
  const char *name;
  int (*bwrite)(BIO *, const char *, int);
  int (*bread)(BIO *, char *, int);
  int (*bputs)(BIO *, const char *);
  int (*bgets)(BIO *, char *, int);
  int (*ctrl)(BIO *, int, int, void *);
  int (*create)(BIO *);
  int (*destroy)(BIO *);
  int (*callback_ctrl)(BIO *, int, bio_info_cb *);
};

/* 503 */
struct ssl_comp_st
{
  int id;
  const char *name;
  COMP_METHOD *method;
};

/* 350 */
struct x509_store_st
{
  int cache;
  stack_st_X509_OBJECT *objs;
  stack_st_X509_LOOKUP *get_cert_methods;
  X509_VERIFY_PARAM *param;
  int (*verify)(X509_STORE_CTX *);
  int (*verify_cb)(int, X509_STORE_CTX *);
  int (*get_issuer)(X509 **, X509_STORE_CTX *, X509 *);
  int (*check_issued)(X509_STORE_CTX *, X509 *, X509 *);
  int (*check_revocation)(X509_STORE_CTX *);
  int (*get_crl)(X509_STORE_CTX *, X509_CRL **, X509 *);
  int (*check_crl)(X509_STORE_CTX *, X509_CRL *);
  int (*cert_crl)(X509_STORE_CTX *, X509_CRL *, X509 *);
  stack_st_X509 *(*lookup_certs)(X509_STORE_CTX *, X509_NAME *);
  stack_st_X509_CRL *(*lookup_crls)(X509_STORE_CTX *, X509_NAME *);
  int (*cleanup)(X509_STORE_CTX *);
  CRYPTO_EX_DATA ex_data;
  int references;
};

/* 373 */
struct stack_st_X509
{
  _STACK stack;
};

/* 366 */
struct stack_st_X509_CRL
{
  _STACK stack;
};

/* 378 */
typedef X509_crl_info_st X509_CRL_INFO;

/* 377 */
typedef void ISSUING_DIST_POINT;

/* 376 */
struct stack_st_GENERAL_NAMES;

/* 375 */
typedef void X509_CRL_METHOD;

/* 452 */
struct X509_crl_st
{
  X509_CRL_INFO *crl;
  X509_ALGOR *sig_alg;
  ASN1_BIT_STRING *signature;
  int references;
  int flags;
  AUTHORITY_KEYID *akid;
  ISSUING_DIST_POINT *idp;
  int idp_flags;
  int idp_reasons;
  ASN1_INTEGER *crl_number;
  ASN1_INTEGER *base_crl_number;
  unsigned __int8 sha1_hash[20];
  stack_st_GENERAL_NAMES *issuers;
  const X509_CRL_METHOD *meth;
  void *meth_data;
};

/* 349 */
struct lhash_st_SSL_SESSION
{
  int dummy;
};

/* 345 */
struct stack_st_SSL_COMP
{
  _STACK stack;
};

/* 622 */
struct hmac_ctx_st
{
  const EVP_MD *md;
  EVP_MD_CTX md_ctx;
  EVP_MD_CTX i_ctx;
  EVP_MD_CTX o_ctx;
  unsigned int key_length;
  unsigned __int8 key[128];
};

/* 370 */
struct stack_st_X509_OBJECT
{
  _STACK stack;
};

/* 369 */
struct stack_st_X509_LOOKUP
{
  _STACK stack;
};

/* 613 */
struct X509_crl_info_st
{
  ASN1_INTEGER *version;
  X509_ALGOR *sig_alg;
  X509_NAME *issuer;
  ASN1_TIME *lastUpdate;
  ASN1_TIME *nextUpdate;
  stack_st_X509_REVOKED *revoked;
  stack_st_X509_EXTENSION *extensions;
  ASN1_ENCODING enc;
};

/* 379 */
struct stack_st_X509_REVOKED
{
  _STACK stack;
};

/* 61 */
typedef unsigned __int64 __u_quad_t;

/* 53 */
typedef __u_quad_t __dev_t;

/* 58 */
typedef unsigned int __ino_t;

/* 57 */
typedef unsigned int __mode_t;

/* 56 */
typedef unsigned int __nlink_t;

/* 55 */
typedef unsigned int __uid_t;

/* 54 */
typedef unsigned int __gid_t;

/* 52 */
typedef int __off_t;

/* 51 */
typedef int __blksize_t;

/* 50 */
typedef int __blkcnt_t;

/* 59 */
typedef int __syscall_slong_t;

/* 49 */
struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};

/* 48 */
struct stat
{
  __dev_t st_dev;
  unsigned __int16 __pad1;
  __ino_t st_ino;
  __mode_t st_mode;
  __nlink_t st_nlink;
  __uid_t st_uid;
  __gid_t st_gid;
  __dev_t st_rdev;
  unsigned __int16 __pad2;
  __off_t st_size;
  __blksize_t st_blksize;
  __blkcnt_t st_blocks;
  timespec st_atim;
  timespec st_mtim;
  timespec st_ctim;
  unsigned int __glibc_reserved4;
  unsigned int __glibc_reserved5;
};

/* 63 */
typedef unsigned __int64 UDItype;

/* 64 */
typedef unsigned int USItype;

/* 65 */
typedef double DFtype;

/* 66 */
typedef __va_list __gnuc_va_list;

/* 67 */
enum json_error_code : __int32
{
  json_error_code::json_error_unknown = 0x0,
  json_error_code::json_error_out_of_memory = 0x1,
  json_error_code::json_error_stack_overflow = 0x2,
  json_error_code::json_error_cannot_open_file = 0x3,
  json_error_code::json_error_invalid_argument = 0x4,
  json_error_code::json_error_invalid_utf8 = 0x5,
  json_error_code::json_error_premature_end_of_input = 0x6,
  json_error_code::json_error_end_of_input_expected = 0x7,
  json_error_code::json_error_invalid_syntax = 0x8,
  json_error_code::json_error_invalid_format = 0x9,
  json_error_code::json_error_wrong_type = 0xA,
  json_error_code::json_error_null_character = 0xB,
  json_error_code::json_error_null_value = 0xC,
  json_error_code::json_error_null_byte_in_key = 0xD,
  json_error_code::json_error_duplicate_key = 0xE,
  json_error_code::json_error_numeric_overflow = 0xF,
  json_error_code::json_error_item_not_found = 0x10,
  json_error_code::json_error_index_out_of_range = 0x11,
};

/* 68 */
typedef __gnuc_va_list va_list;

/* 69 */
struct json_error_t
{
  int line;
  int column;
  int position;
  char source[80];
  char text[160];
};

/* 73 */
typedef __int64 __quad_t;

/* 72 */
typedef __quad_t __off64_t;

/* 70 */
struct _IO_FILE
{
  int _flags;
  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;
  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;
  _IO_marker *_markers;
  _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset;
  unsigned __int16 _cur_column;
  char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
  __off64_t _offset;
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;
  int _mode;
  char _unused2[40];
};

/* 71 */
struct _IO_marker
{
  _IO_marker *_next;
  _IO_FILE *_sbuf;
  int _pos;
};

/* 74 */
typedef __int64 json_int_t;

/* 81 */
enum json_type : __int32
{
  JSON_OBJECT = 0x0,
  JSON_ARRAY = 0x1,
  JSON_STRING = 0x2,
  JSON_INTEGER = 0x3,
  JSON_REAL = 0x4,
  JSON_TRUE = 0x5,
  JSON_FALSE = 0x6,
  JSON_NULL = 0x7,
};

/* 84 */
struct json_t
{
  json_type type;
  volatile size_t refcount;
};

/* 75 */
struct json_string_t
{
  json_t json;
  char *value;
  size_t length;
};

/* 83 */
struct hashtable_list
{
  hashtable_list *prev;
  hashtable_list *next;
};

/* 511 */
struct hashtable
{
  size_t size;
  hashtable_bucket *buckets;
  size_t order;
  hashtable_list list;
  hashtable_list ordered_list;
};

/* 80 */
typedef hashtable hashtable_t;

/* 76 */
struct json_object_t
{
  json_t json;
  hashtable_t hashtable;
};

/* 82 */
struct hashtable_bucket
{
  hashtable_list *first;
  hashtable_list *last;
};

/* 77 */
struct json_array_t
{
  json_t json;
  size_t size;
  size_t entries;
  json_t **table;
};

/* 78 */
struct json_real_t
{
  json_t json;
  double value;
};

/* 79 */
struct json_integer_t
{
  json_t json;
  json_int_t value;
};

/* 85 */
typedef int int32_t;

/* 86 */
struct __attribute__((aligned(4))) lconv
{
  char *decimal_point;
  char *thousands_sep;
  char *grouping;
  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;
  char p_cs_precedes;
  char p_sep_by_space;
  char n_cs_precedes;
  char n_sep_by_space;
  char p_sign_posn;
  char n_sign_posn;
  char int_p_cs_precedes;
  char int_p_sep_by_space;
  char int_n_cs_precedes;
  char int_n_sep_by_space;
  char int_p_sign_posn;
  char int_n_sign_posn;
};

/* 87 */
struct strbuffer_t
{
  char *value;
  size_t length;
  size_t size;
};

/* 88 */
typedef void (*json_free_t)(void *);

/* 89 */
typedef void *(*json_malloc_t)(size_t);

/* 90 */
typedef size_t (*json_load_callback_t)(void *, size_t, void *);

/* 91 */
typedef _IO_FILE FILE;

/* 92 */
typedef int (*get_func)(void *);

/* 97 */
struct stream_t
{
  get_func get;
  void *data;
  char buffer[5];
  size_t buffer_pos;
  int state;
  int line;
  int column;
  int last_column;
  size_t position;
};

/* 623 */
struct lex_t::$BD4887B8155239BFEFA5AB9A7B453162::$187604EA7C5609CC783974FAB9764C1D
{
  char *val;
  size_t len;
};

/* 624 */
union lex_t::$BD4887B8155239BFEFA5AB9A7B453162
{
  lex_t::$BD4887B8155239BFEFA5AB9A7B453162::$187604EA7C5609CC783974FAB9764C1D string;
  json_int_t integer;
  double real;
};

/* 93 */
struct lex_t
{
  stream_t stream;
  strbuffer_t saved_text;
  size_t flags;
  size_t depth;
  int token;
  lex_t::$BD4887B8155239BFEFA5AB9A7B453162 value;
};

/* 94 */
struct callback_data_t
{
  char data[1024];
  size_t len;
  size_t pos;
  json_load_callback_t callback;
  void *arg;
};

/* 95 */
struct buffer_data_t
{
  const char *data;
  size_t len;
  size_t pos;
};

/* 96 */
struct string_data_t
{
  const char *data;
  size_t pos;
};

/* 98 */
typedef int __ssize_t;

/* 99 */
struct timezone
{
  int tz_minuteswest;
  int tz_dsttime;
};

/* 102 */
typedef hashtable_pair pair_t;

/* 512 */
struct __attribute__((aligned(4))) hashtable_pair
{
  hashtable_list list;
  hashtable_list ordered_list;
  size_t hash;
  json_t *value;
  char key[1];
};

/* 105 */
typedef hashtable_list list_t;

/* 106 */
typedef hashtable_bucket bucket_t;

/* 107 */
typedef int (*__compar_fn_t)(const void *, const void *);

/* 108 */
typedef int (*json_dump_callback_t)(const char *, size_t, void *);

/* 109 */
struct buffer
{
  const size_t size;
  size_t used;
  char *data;
};

/* 110 */
typedef _chain_inactive_t chain_inactive_t;

/* 516 */
struct _chain_inactive_t::$DF006CCF56AEBE0E5141CAE43FA188A9
{
  unsigned __int8 _CMD : 4;
  unsigned __int8 _ALL : 1;
  unsigned __int8 _TYPE : 3;
  uint8_t _Length;
  uint8_t _RSVD1;
  uint8_t _RSVD2;
  unsigned __int8 _CRC5 : 5;
  unsigned __int8 _RSVD3 : 3;
};

/* 515 */
union _chain_inactive_t
{
  _chain_inactive_t::$DF006CCF56AEBE0E5141CAE43FA188A9 u;
  uint8_t v[5];
};

/* 111 */
typedef _get_status_t get_status_t;

/* 518 */
struct _get_status_t::$5D8EB6D5E061A6FF7E7D1086B04136B9
{
  unsigned __int8 _CMD : 4;
  unsigned __int8 _ALL : 1;
  unsigned __int8 _TYPE : 3;
  uint8_t _Length;
  uint8_t _ADDR;
  uint8_t _REGADDR;
  unsigned __int8 _CRC5 : 5;
  unsigned __int8 _CMD_ID_G : 2;
  unsigned __int8 _RSVD : 1;
};

/* 517 */
union _get_status_t
{
  _get_status_t::$5D8EB6D5E061A6FF7E7D1086B04136B9 u;
  uint8_t v[5];
};

/* 112 */
typedef _set_address_t set_address_t;

/* 514 */
struct _set_address_t::$39C06A240996102D098D1D1C95001593
{
  unsigned __int8 _CMD : 4;
  unsigned __int8 _ALL : 1;
  unsigned __int8 _TYPE : 3;
  uint8_t _Length;
  uint8_t _ADDR;
  uint8_t _RSVD1;
  unsigned __int8 _CRC5 : 5;
  unsigned __int8 _RSVD2 : 3;
};

/* 513 */
union _set_address_t
{
  _set_address_t::$39C06A240996102D098D1D1C95001593 u;
  uint8_t v[5];
};

/* 113 */
typedef _set_config_t set_config_t;

/* 520 */
struct _set_config_t::$03F4A4BD6A877CE7E5FD60953F4D8283
{
  unsigned __int8 _CMD : 4;
  unsigned __int8 _ALL : 1;
  unsigned __int8 _TYPE : 3;
  uint8_t _Length;
  uint8_t _ADDR;
  uint8_t _REGADDR;
  uint8_t _REGDATA[4];
  unsigned __int8 _CRC5 : 5;
  unsigned __int8 _RSVD : 3;
};

/* 519 */
union _set_config_t
{
  _set_config_t::$03F4A4BD6A877CE7E5FD60953F4D8283 u;
  uint8_t v[9];
};

/* 114 */
struct asic_register_value_t
{
  uint32_t register_addr;
  uint32_t register_value;
};

/* 115 */
enum cache_level_e : __int32
{
  hashboard_cache_level = 0x0,
  asic_cache_level = 0x1,
  core_cache_level = 0x2,
};

/* 118 */
struct __pthread_internal_slist
{
  __pthread_internal_slist *__next;
};

/* 117 */
typedef __pthread_internal_slist __pthread_slist_t;

/* 618 */
union __pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95
{
  int __spins;
  __pthread_slist_t __list;
};

/* 116 */
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;
  int __kind;
  unsigned int __nusers;
  union
  {
    int __spins;
    __pthread_slist_t __list;
  };
};

/* 119 */
struct pll_userdivider_t
{
  uint8_t userdivider0;
  uint8_t userdivider1;
  uint8_t userdivider2;
  uint8_t userdivider3;
};

/* 120 */
struct pllparameter_t
{
  uint8_t postdiv1;
  uint8_t postdiv2;
  uint8_t refdiv;
  uint16_t fbdiv;
};

/* 122 */
struct bitmain_tsensor_t
{
  uint8_t slave_addr;
  uint32_t tsensor_fd;
};

/* 121 */
struct bitmain_chain_tsensor
{
  uint8_t num;
  bitmain_tsensor_t bitmain_tsensor[8];
};

/* 569 */
union eeprom_data_t::$0A609ABD55EED6399FF851F6AC5DD11F
{
  unsigned __int8 N[20];
  double V[20];
};

/* 123 */
struct __attribute__((aligned(8))) eeprom_data_t
{
  char sn[18];
  int num;
  union
  {
    unsigned __int8 N[20];
    double V[20];
  };
  double vol[20];
  int32_t c_date;
};

/* 125 */
typedef __ssize_t ssize_t;

/* 126 */
typedef unsigned __int64 __uint64_t;

/* 127 */
struct bitmain_pic_t
{
  uint32_t pic_fd;
  uint32_t chain_has_opened;
};

/* 128 */
enum bitmain_hardware_type_e : __int32
{
  S9_HARDWARE = 0x0,
  T9_PLUS_HARDWARE = 0x1,
  UNKNOWN_HARDWARE_TYPE = 0x2,
};

/* 129 */
struct dhash_job_info_t
{
  uint32_t mid_auto_gen;
  uint32_t mid_state_num;
  uint8_t *coinbase;
  uint32_t coinbase_len;
  uint8_t *merkle_bin;
  uint32_t merkles_num;
  uint32_t ntime;
  uint32_t nbit;
  uint32_t job_id;
  uint32_t bbversion;
  uint32_t version_mask;
  uint8_t *prev_hash;
  uint32_t prev_hash_len;
  uint32_t nonce2_offset;
  uint32_t nonce2_bytes_num;
  uint64_t nonce2_start_value;
  uint32_t send_work_timeout;
  uint32_t new_block;
};

/* 130 */
typedef unsigned int __kernel_ulong_t;

/* 131 */
typedef unsigned int __u32;

/* 132 */
typedef unsigned __int16 __u16;

/* 133 */
typedef int __kernel_long_t;

/* 134 */
struct bitmain_eeprom_t
{
  uint32_t eeprom_fd;
  uint32_t chain_has_opened;
};

/* 135 */
typedef void (*clib_destroy)(void *);

/* 136 */
typedef int (*clib_compare)(void *, void *);

/* 137 */
struct clib_object
{
  void *raw_data;
  size_t size;
};

/* 139 */
struct clib_rb_node
{
  clib_rb_node *left;
  clib_rb_node *right;
  clib_rb_node *parent;
  int color;
  clib_object *key;
  clib_object *value;
};

/* 138 */
struct clib_rb
{
  clib_rb_node *root;
  clib_rb_node sentinel;
  clib_destroy destruct_k_fn;
  clib_destroy destruct_v_fn;
  clib_compare compare_fn;
};

/* 140 */
struct clib_map
{
  clib_rb *root;
};

/* 141 */
struct clib_iterator
{
  clib_object *(*get_next)(clib_iterator *);
  void (*replace_value)(clib_iterator *, void *, size_t);
  void *(*get_value)(void *);
  void *pContainer;
  int pCurrent;
  void *pCurrentElement;
};

/* 144 */
enum bitmain_fan_id_e : __int32
{
  FAN1 = 0x0,
  FAN2 = 0x1,
  FAN3 = 0x2,
  FAN4 = 0x3,
  FAN5 = 0x4,
  FAN6 = 0x5,
  FAN_MAX = 0x6,
};

/* 142 */
struct fan_conf_info
{
  bitmain_fan_id_e fan_id;
  uint32_t fan_name;
  uint32_t max_speed;
};

/* 143 */
struct chain_conf_info
{
  uint32_t chain_id;
  uint32_t uart_index;
  uint32_t plug;
  uint32_t reset;
};

/* 145 */
struct i2c_value_t
{
  uint32_t master;
  uint32_t slave;
};

/* 148 */
enum ui_type_e : __int32
{
  RED_LED = 0x1,
  GREEN_LED = 0x2,
  BEEP_1 = 0x10,
  RESET_KEY = 0x100,
  IP_REPORT_KEY = 0x101,
  PS2PL_RST_KEY = 0x102,
  UI_RESERVED = 0x103,
};

/* 150 */
enum bitmain_key_status_e : __int32
{
  HAL_KEY_PRESSED = 0x0,
  HAL_KEY_UP = 0x1,
};

/* 146 */
typedef void (*bitmain_key_callback)(ui_type_e, bitmain_key_status_e);

/* 147 */
enum ui_status_e : __int32
{
  UI_ON = 0x0,
  UI_OFF = 0x1,
  UI_FLICKER = 0x2,
};

/* 149 */
struct filker_interval_t
{
  uint32_t interval;
  uint32_t timeout;
  uint32_t next_val;
};

/* 151 */
union pthread_attr_t
{
  char __size[36];
  int __align;
};

/* 152 */
union pthread_mutex_t
{
  __pthread_mutex_s __data;
  char __size[24];
  int __align;
};

/* 153 */
enum bitmain_uart_conf_type_t : __int32
{
  BAUD = 0x0,
  UART_VMIN = 0x1,
  RESERVED = 0x2,
};

/* 154 */
struct __attribute__((aligned(4))) pwm_init_param_t
{
  uint32_t freq;
  unsigned __int8 inited;
};

/* 155 */
enum bitmain_pwm_type_e : __int32
{
  PWM_CTRL_FAN = 0x0,
  PWM_CTRL_POWER = 0x1,
  PWM_CTRL_MAX = 0x2,
};

/* 156 */
struct iic_init_param_t
{
  uint32_t chain_id;
  uint16_t master_addr;
  uint8_t slave_high;
  uint8_t slave_low;
};

/* 159 */
typedef void (*bitmain_gpio_callback)(uint32_t, uint8_t);

/* 157 */
struct gpio_callback_t
{
  bitmain_gpio_callback function;
  uint32_t last;
};

/* 158 */
enum bitmain_gpio_direction_e : __int32
{
  DIRECTION_IN = 0x0,
  DIRECTION_OUT = 0x1,
};

/* 160 */
enum bitmain_fpga_e : __int32
{
  HARDWARE_VERSION = 0x0,
  FAN_SPEED = 0x1,
  HASH_ON_PLUG = 0x2,
  WORK_FIFO_STATE = 0x3,
  RETURN_NONCE = 0x4,
  RETURN_NONCE_HI = 0x5,
  NONCE_NUMBER_IN_FIFO = 0x6,
  NONCE_FIFO_INTERRUPT = 0x7,
  TEMPERATURE_0_3 = 0x8,
  TEMPERATURE_4_7 = 0x9,
  TEMPERATURE_8_11 = 0xA,
  TEMPERATURE_12_15 = 0xB,
  IIC_COMMAND = 0xC,
  RESET_HASH_BOARD = 0xD,
  BMC_COUNTER = 0xE,
  FPGA_BT8D = 0xF,
  TW_WRITE_COMMAND = 0x10,
  QN_WRITE_DATA_COMMAND = 0x11,
  RESET_CHAIN = 0x12,
  FAN_CONTROL = 0x13,
  TIME_OUT_CONTROL = 0x14,
  TICKET_MASK_FPGA = 0x15,
  HASH_COUNTING_NUMBER_FPGA = 0x16,
  FAN_CONTROL_1 = 0x17,
  SNO = 0x18,
  SOCKET_ID = 0x19,
  BC_WRITE_COMMAND = 0x1A,
  FRIST_WORD = 0x1B,
  BC_COMMAND_BUFFER = 0x1C,
  BC_COMMAND_BUFFER_1 = 0x1D,
  BC_COMMAND_BUFFER_2 = 0x1E,
  FPGA_CHIP_ID_ADDR = 0x1F,
  FPGA_CHIP_ID_HI = 0x20,
  CRC_ERROR_CNT = 0x21,
  I2C_SW_ID = 0x22,
  DHASH_ACC_CONTROL = 0x23,
  COINBASE_AND_NONCE2_LENGTH = 0x24,
  WORK_NONCE_2 = 0x25,
  WORK_NONCE_2_HI = 0x26,
  NONCE2_AND_JOBID_STORE_ADDRESS = 0x27,
  MERKLE_BIN_NUMBER = 0x28,
  JOB_START_ADDRESS = 0x29,
  JOB_LENGTH = 0x2A,
  JOB_DATA_READY = 0x2B,
  JOB_ID = 0x2C,
  WORK_ENABLE = 0x2D,
  BLOCK_HEADER_VERSION = 0x2E,
  TIME_STAMP = 0x2F,
  TARGET_BITS = 0x30,
  PRE_HEADER_HASH = 0x31,
  PRE_HEADER_HASH1 = 0x32,
  PRE_HEADER_HASH2 = 0x33,
  PRE_HEADER_HASH3 = 0x34,
  PRE_HEADER_HASH4 = 0x35,
  PRE_HEADER_HASH5 = 0x36,
  PRE_HEADER_HASH6 = 0x37,
  PRE_HEADER_HASH7 = 0x38,
  BLOCK_VERSION_0 = 0x39,
  BLOCK_VERSION_1 = 0x3A,
  BLOCK_VERSION_2 = 0x3B,
  BLOCK_VERSION_3 = 0x3C,
  BLOCK_VERSION_4 = 0x3D,
  BLOCK_VERSION_5 = 0x3E,
  BLOCK_VERSION_6 = 0x3F,
  BLOCK_VERSION_7 = 0x40,
  CHAIN0_3_SEND_FIFO_STATUS = 0x41,
  CHAIN4_7_SEND_FIFO_STATUS = 0x42,
  CHAIN8_11_SEND_FIFO_STATUS = 0x43,
  CHAIN12_13_SEND_FIFO_STATUS = 0x44,
  CHAIN0_SEND_READY = 0x45,
  CHAIN0_SEND_BUFFER = 0x46,
  CHAIN1_SEND_READY = 0x47,
  CHAIN1_SEND_BUFFER = 0x48,
  CHAIN2_SEND_READY = 0x49,
  CHAIN2_SEND_BUFFER = 0x4A,
  CHAIN3_SEND_READY = 0x4B,
  CHAIN3_SEND_BUFFER = 0x4C,
  CHAIN4_SEND_READY = 0x4D,
  CHAIN4_SEND_BUFFER = 0x4E,
  CHAIN5_SEND_READY = 0x4F,
  CHAIN5_SEND_BUFFER = 0x50,
  CHAIN6_SEND_READY = 0x51,
  CHAIN6_SEND_BUFFER = 0x52,
  CHAIN7_SEND_READY = 0x53,
  CHAIN7_SEND_BUFFER = 0x54,
  CHAIN8_SEND_READY = 0x55,
  CHAIN8_SEND_BUFFER = 0x56,
  CHAIN9_SEND_READY = 0x57,
  CHAIN9_SEND_BUFFER = 0x58,
  RECEIVE_FIFO_0_1_STATUS = 0x59,
  RECEIVE_FIFO_2_3_STATUS = 0x5A,
  RECEIVE_FIFO_4_5_STATUS = 0x5B,
  RECEIVE_FIFO_6_7_STATUS = 0x5C,
  RECEIVE_FIFO_8_9_STATUS = 0x5D,
  RECEIVE_FIFO_10_11_STATUS = 0x5E,
  RECEIVE_FIFO_12_13_STATUS = 0x5F,
  CHAIN0_READ_ENABLE = 0x60,
  CHAIN0_READ_DATA = 0x61,
  CHAIN1_READ_ENABLE = 0x62,
  CHAIN1_READ_DATA = 0x63,
  CHAIN2_READ_ENABLE = 0x64,
  CHAIN2_READ_DATA = 0x65,
  CHAIN3_READ_ENABLE = 0x66,
  CHAIN3_READ_DATA = 0x67,
  CHAIN4_READ_ENABLE = 0x68,
  CHAIN4_READ_DATA = 0x69,
  CHAIN5_READ_ENABLE = 0x6A,
  CHAIN5_READ_DATA = 0x6B,
  CHAIN6_READ_ENABLE = 0x6C,
  CHAIN6_READ_DATA = 0x6D,
  CHAIN7_READ_ENABLE = 0x6E,
  CHAIN7_READ_DATA = 0x6F,
  CHAIN8_READ_ENABLE = 0x70,
  CHAIN8_READ_DATA = 0x71,
  CHAIN9_READ_ENABLE = 0x72,
  CHAIN9_READ_DATA = 0x73,
  CHAIN10_SEND_READY = 0x74,
  CHAIN10_SEND_BUFFER = 0x75,
  CHAIN11_SEND_READY = 0x76,
  CHAIN11_SEND_BUFFER = 0x77,
  CHAIN12_SEND_READY = 0x78,
  CHAIN12_SEND_BUFFER = 0x79,
  CHAIN13_SEND_READY = 0x7A,
  CHAIN13_SEND_BUFFER = 0x7B,
  CHAIN10_READ_ENABLE = 0x7C,
  CHAIN10_READ_DATA = 0x7D,
  CHAIN11_READ_ENABLE = 0x7E,
  CHAIN11_READ_DATA = 0x7F,
  CHAIN12_READ_ENABLE = 0x80,
  CHAIN12_READ_DATA = 0x81,
  CHAIN13_READ_ENABLE = 0x82,
  CHAIN13_READ_DATA = 0x83,
  SEED_ADDRESS_0 = 0x84,
  SEED_ADDRESS_1 = 0x85,
  SEED_ADDRESS_2 = 0x86,
  SEED_ADDRESS_3 = 0x87,
  SEED_ADDRESS_4 = 0x88,
  SEED_ADDRESS_5 = 0x89,
  SEED_ADDRESS_6 = 0x8A,
  SEED_ADDRESS_7 = 0x8B,
  FULL_NODES_ADDR = 0x8C,
  NUM_MODE_ADDR = 0x8D,
  CACHE_SAVE_ADDR = 0x8E,
  CACHE_START_ADDR = 0x8F,
  DS_START_ADDR = 0x90,
  DS_DONE_ADDR = 0x91,
  DATA_SAVE_ADDR = 0x92,
  UART0_STATUS_ADDR = 0x93,
  UART1_STATUS_ADDR = 0x94,
  UART2_STATUS_ADDR = 0x95,
  UART3_STATUS_ADDR = 0x96,
  UART4_STATUS_ADDR = 0x97,
  UART5_STATUS_ADDR = 0x98,
  UART6_STATUS_ADDR = 0x99,
  UART7_STATUS_ADDR = 0x9A,
  UART8_STATUS_ADDR = 0x9B,
  UART9_STATUS_ADDR = 0x9C,
  UART10_STATUS_ADDR = 0x9D,
  UART11_STATUS_ADDR = 0x9E,
  UART12_STATUS_ADDR = 0x9F,
  UART13_STATUS_ADDR = 0xA0,
  UART14_STATUS_ADDR = 0xA1,
  UART15_STATUS_ADDR = 0xA2,
  UART16_STATUS_ADDR = 0xA3,
  UART17_STATUS_ADDR = 0xA4,
  UART18_STATUS_ADDR = 0xA5,
  UART19_STATUS_ADDR = 0xA6,
  UART20_STATUS_ADDR = 0xA7,
  UART21_STATUS_ADDR = 0xA8,
  UART22_STATUS_ADDR = 0xA9,
  UART23_STATUS_ADDR = 0xAA,
  UART24_STATUS_ADDR = 0xAB,
  UART25_STATUS_ADDR = 0xAC,
  UART26_STATUS_ADDR = 0xAD,
  UART27_STATUS_ADDR = 0xAE,
  UART28_STATUS_ADDR = 0xAF,
  UART29_STATUS_ADDR = 0xB0,
  UART30_STATUS_ADDR = 0xB1,
  UART31_STATUS_ADDR = 0xB2,
  UART_WORK_FLAG_ADDR = 0xB3,
  DATA_SIZE_ADDR = 0xB4,
  DATA_STORE_ADDR = 0xB5,
  UART_CTRL_STATE_ADDR = 0xB6,
  UART_DBG_WR_ADDR = 0xB7,
  UART_DBG_RD_ADDR = 0xB8,
  UART_DBG_STATUS_ADDR = 0xB9,
  BIT_DIV_ADDR = 0xBA,
  MAX_FPGA_INDEX = 0xBB,
};

/* 161 */
enum bitmain_fan_side_e : __int32
{
  FRONT_SIDE = 0x0,
  REAR_SIDE = 0x1,
  BOTH_SIZE = 0x2,
};

/* 162 */
struct bitmain_mac_t
{
  uint8_t mac[6];
};

/* 163 */
struct bitmain_uuid_t
{
  uint8_t uuid[16];
};

/* 166 */
struct bitmain_chain_t
{
  uint32_t chain_id;
};

/* 165 */
struct bitmain_board_t
{
  uint32_t board_id;
  uint32_t chain_num;
  bitmain_chain_t chain[16];
};

/* 164 */
struct bitmain_sys_capability_t
{
  uint32_t board_num;
  bitmain_board_t board[4];
};

/* 572 */
union if_settings::$26F75A7CF7D20622A142A8F9C6BB7EFD
{
  raw_hdlc_proto *raw_hdlc;
  cisco_proto *cisco;
  fr_proto *fr;
  fr_proto_pvc *fr_pvc;
  fr_proto_pvc_info *fr_pvc_info;
  sync_serial_settings *sync;
  te1_settings *te1;
};

/* 167 */
struct if_settings
{
  unsigned int type;
  unsigned int size;
  if_settings::$26F75A7CF7D20622A142A8F9C6BB7EFD ifs_ifsu;
};

/* 176 */
struct raw_hdlc_proto
{
  unsigned __int16 encoding;
  unsigned __int16 parity;
};

/* 175 */
struct cisco_proto
{
  unsigned int interval;
  unsigned int timeout;
};

/* 174 */
struct fr_proto
{
  unsigned int t391;
  unsigned int t392;
  unsigned int n391;
  unsigned int n392;
  unsigned int n393;
  unsigned __int16 lmi;
  unsigned __int16 dce;
};

/* 173 */
struct fr_proto_pvc
{
  unsigned int dlci;
};

/* 172 */
struct fr_proto_pvc_info
{
  unsigned int dlci;
  char master[16];
};

/* 171 */
struct __attribute__((aligned(4))) sync_serial_settings
{
  unsigned int clock_rate;
  unsigned int clock_type;
  unsigned __int16 loopback;
};

/* 170 */
struct te1_settings
{
  unsigned int clock_rate;
  unsigned int clock_type;
  unsigned __int16 loopback;
  unsigned int slot_map;
};

/* 168 */
struct __attribute__((aligned(4))) ifmap
{
  unsigned int mem_start;
  unsigned int mem_end;
  unsigned __int16 base_addr;
  unsigned __int8 irq;
  unsigned __int8 dma;
  unsigned __int8 port;
};

/* 177 */
typedef unsigned __int16 sa_family_t;

/* 169 */
struct sockaddr
{
  sa_family_t sa_family;
  char sa_data[14];
};

/* 178 */
struct sha2_context
{
  uint32_t total[2];
  uint32_t state[8];
  unsigned __int8 buffer[64];
  unsigned __int8 ipad[64];
  unsigned __int8 opad[64];
};

/* 179 */
struct gold_nonce
{
  int times;
  int count;
  int asic;
  uint32_t coreid;
  char midstate[32];
  char data[12];
  uint32_t nonce;
};

/* 180 */
struct work_format
{
  uint8_t work_type;
  uint8_t chain_id;
  uint8_t reserved1[2];
  uint32_t work_count;
  uint8_t data[12];
  uint8_t midstate[16][32];
};

/* 181 */
typedef history_result History_Result;

/* 483 */
struct __attribute__((aligned(8))) history_result
{
  bool asic_ok;
  bool nonce_rate_ok;
  bool eeprom_ok;
  bool pic_sensor_all_OK;
  bool asic_sensor_all_OK;
  bool ctrlboard_sensor_all_OK;
  bool switch_sensor_all_OK;
  bool apw_power_ok;
  bool pic_ok;
  bool sweep_ok;
  int power_version;
  double nonce_rate;
  uint32_t level;
  uint32_t voltage;
  uint32_t pre_open_core_voltage;
  uint32_t frequence;
  uint32_t valid_nonce_num;
  uint32_t repeat_nonce_number;
  uint32_t asic_core_nonce_num[256][1300];
  uint32_t every_asic_got_nonce_num[256];
  uint32_t every_asic_reg_tick_nonce_num[256];
  uint16_t every_asic_reg_ntick_nonce_num[256];
  uint16_t every_asic_reg_nonce_error_num[256];
  uint16_t every_asic_reg_got_nonce_num[256];
  bool ok_asic_list[256];
  bool bad_asic_list[256];
  bool pic_sensor_OK[4];
  bool asic_sensor_OK[4];
  bool ctrlboard_sensor_OK[2];
  bool switch_sensor_OK[12];
  bool switch_OK;
  bool sensor_calibration_OK;
  int8_t sensor_local_temperature_from_asic[4];
  int8_t sensor_remote_temperature_from_asic[4];
  int8_t sensor_local_temperature_from_pic[4];
  int8_t sensor_local_temperature_from_ctrlboard[2];
  int8_t sensor_local_temperature_from_switch[12];
  uint8_t test_standard;
  uint8_t temp_abnormal_count;
};

/* 182 */
typedef local_config_info Local_Config_Info;

/* 574 */
struct pic_sensor
{
  char Pic_Sensor_Model[16];
  uint32_t Pic_Sensor_Addr[4];
};

/* 205 */
typedef pic_sensor Pic_Sensor;

/* 575 */
struct asic_sensor
{
  char Asic_Sensor_Model[16];
  uint32_t Asic_Sensor_Addr[4];
};

/* 204 */
typedef asic_sensor Asic_Sensor;

/* 573 */
struct ctrlboard_sensor
{
  char CtrlBoard_Sensor_Model[16];
  uint32_t CtrlBoard_Sensor_Addr[2];
};

/* 203 */
typedef ctrlboard_sensor CtrlBoard_Sensor;

/* 619 */
struct sensor_info
{
  bool Read_Temperature_From_CtrlBoard;
  bool Read_Temperature_From_Switch;
  bool Read_Temperature_From_Pic;
  bool Read_Temperature_From_Asic;
  Pic_Sensor Pic_Sensor;
  Asic_Sensor Asic_Sensor;
  CtrlBoard_Sensor CtrlBoard_Sensor;
};

/* 202 */
typedef sensor_info Sensor_Info;

/* 628 */
struct hash_board_0
{
  char Miner_Type[16];
  char Board_Name[16];
  char Asic_Type[16];
  uint32_t Asic_Num;
  uint32_t Big_Core_Num;
  uint32_t Small_Core_Num;
  uint32_t Small_Core_Num_In_Big_Core;
  uint32_t Voltage_Domain;
  uint32_t Asic_Num_Per_Voltage_Domain;
  Sensor_Info Sensor_Info;
  uint32_t Power_Version[8];
  bool Has_Pic;
  bool Smooth_Voltage;
  uint32_t Inc_Freq_Delay;
  uint32_t Voltage_Adjust_Step;
  uint32_t Wait_Board_Temp;
};

/* 191 */
typedef hash_board_0 Hash_Board;

/* 482 */
struct __attribute__((aligned(4))) test_method
{
  bool Software_Pattern;
  bool Super_Software_Pattern;
  bool Hardware_Pattern;
  bool Autogen_Pattern;
  uint32_t Midstate_Number;
  bool Capture_Pattern;
};

/* 199 */
typedef test_method Test_Method;

/* 198 */
struct Sweep_Cfg
{
  int Force_Reset_Power_Mode;
  bool Data_Reuse_Mode;
  bool Force_PT2_Before_Sweep;
  int Freq_Float_Percent;
  bool Force_Local_Cfg_Level;
  bool Force_Reset_Freq_Range;
  int Sweep_Min_Freq;
  int Sweep_Max_Freq;
};

/* 481 */
struct test_loop
{
  uint32_t Level;
  uint32_t Pre_Open_Core_Voltage;
  uint32_t Voltage;
  uint32_t Frequence;
};

/* 201 */
typedef test_loop Test_Loop;

/* 606 */
struct test_standard_0
{
  uint32_t Pattern_Number;
  uint32_t Invalid_Core_Number;
  uint32_t Least_Nonce_Per_Core;
  uint32_t Asic_Nonce_Rate;
  uint32_t Nonce_Rate;
  uint32_t leakage_current;
  uint32_t Most_HW_Num;
  Test_Loop Test_Loop[10];
};

/* 197 */
typedef test_standard_0 Test_Standard;

/* 283 */
struct test_speed
{
  uint32_t Baudrate;
  uint32_t Timeout;
};

/* 196 */
typedef test_speed Test_Speed;

/* 480 */
struct asic_register
{
  uint32_t CCdly_Sel;
  uint32_t Pwth_Sel;
  uint32_t Swpf_Mode;
  uint32_t Pulse_Mode;
  uint32_t Clk_Sel;
  uint32_t RO_Relay_En;
  uint32_t CO_Relay_En;
  uint32_t Diode_Vdd_Mux_Sel;
};

/* 195 */
typedef asic_register Asic_Register;

/* 479 */
struct temperature
{
  uint32_t Start_Temp_Gap_Pic;
  uint32_t Max_Wait_Cooling_Down_Time;
  uint32_t Time_For_Cooling_Hashboard;
};

/* 194 */
typedef temperature Temperature;

/* 478 */
struct fan
{
  uint32_t Fan_Speed;
  uint32_t Work_Fan_Speed;
};

/* 193 */
typedef fan Fan;

/* 200 */
struct display
{
  bool Display_result_Voltage_Domain;
  bool Display_result_Every_Core;
};

/* 192 */
typedef display Display;

/* 625 */
struct test_info
{
  bool Factory_Mode;
  bool Bypass_Scan_Code_Gun;
  Test_Method Test_Method;
  Sweep_Cfg Sweep_Cfg;
  Test_Standard Test_Standard;
  Test_Speed Test_Speed;
  Asic_Register Asic_Register;
  Temperature Temperature;
  Fan Fan;
  Display Display;
  char Test_Config_Data_Version[16];
  uint32_t Voltage_Accuracy;
};

/* 190 */
typedef test_info Test_Info;

/* 477 */
struct __attribute__((aligned(4))) repair_mode
{
  uint32_t Close_Power_Delay;
  bool Clear_EEPROM_Data;
  bool Enable_Repair;
};

/* 189 */
typedef repair_mode Repair_Mode;

/* 188 */
struct tpl_t
{
  int row;
  int column;
  int *data;
};

/* 629 */
struct local_config_info
{
  char Test_Process[16];
  Hash_Board Hash_Board;
  Test_Info Test_Info;
  Repair_Mode Repair_Mode;
  tpl_t tpl;
};

/* 183 */
typedef _return_nonce_128bit_t return_nonce_128bit_t;

/* 577 */
struct _return_nonce_128bit_t::$1695F939FDD9828F2683DFD527BF56E2
{
  unsigned __int32 chain_number : 4;
  unsigned __int32 reserved_0 : 1;
  unsigned __int32 err_flag : 1;
  unsigned __int32 nonce_crc_indicator : 1;
  unsigned __int32 nonce_indicator : 1;
  unsigned __int32 nonce_difficulty : 7;
  unsigned __int32 reserved_1 : 1;
  unsigned __int32 work_id : 15;
  unsigned __int32 nonce_or_register_data : 1;
  uint32_t nonce;
  unsigned __int32 reserved_2 : 8;
  unsigned __int32 blk_version : 16;
  unsigned __int32 job_id : 8;
  uint32_t header;
};

/* 578 */
struct _return_nonce_128bit_t::$CF53EC581D4E8D670057591BB1D6B933
{
  unsigned __int32 chain_number : 4;
  unsigned __int32 reserved_0 : 2;
  unsigned __int32 nonce_crc_indicator : 1;
  unsigned __int32 reserved_1 : 1;
  unsigned __int32 register_address : 8;
  unsigned __int32 chip_address : 8;
  unsigned __int32 crc_value : 5;
  unsigned __int32 reg_type : 2;
  unsigned __int32 nonce_or_register_data : 1;
  uint32_t reg_data;
  uint32_t reserved_2[2];
};

/* 576 */
union _return_nonce_128bit_t
{
  _return_nonce_128bit_t::$1695F939FDD9828F2683DFD527BF56E2 nonce;
  _return_nonce_128bit_t::$CF53EC581D4E8D670057591BB1D6B933 reg;
  uint32_t buf[4];
};

/* 186 */
struct test_pattern_new
{
  unsigned __int8 midstate[8];
  uint32_t nonce;
};

/* 184 */
struct work_new
{
  uint16_t id;
  uint16_t is_nonce_return_back;
  test_pattern_new pattern;
};

/* 187 */
struct test_pattern
{
  uint32_t nonce;
  uint8_t data[12];
  uint8_t midstate[32];
};

/* 185 */
struct work
{
  uint16_t id;
  uint16_t is_nonce_return_back;
  test_pattern pattern;
};

/* 208 */
typedef uint32_t in_addr_t;

/* 206 */
struct in_addr
{
  in_addr_t s_addr;
};

/* 207 */
typedef uint16_t in_port_t;

/* 216 */
struct reg_content
{
  uint32_t reg_value;
  uint32_t chip_address;
  uint32_t reg_address;
  uint32_t crc;
  uint32_t chain_number;
};

/* 209 */
struct reg_buf
{
  unsigned int p_wr;
  unsigned int p_rd;
  unsigned int reg_value_num;
  unsigned int loop_back;
  reg_content reg_buffer[511];
};

/* 210 */
struct sweep_bad_asic_info_t
{
  int bad_asic_ids[256];
  int bad_asic_num;
};

/* 211 */
struct pattern_struct_in_file
{
  uint32_t nonce;
  unsigned __int8 data[12];
  unsigned __int8 midstate[32];
};

/* 212 */
struct __attribute__((aligned(2))) pll_conf
{
  pllparameter_t pll_param;
  uint8_t usr_divider;
};

/* 213 */
struct pll_divider_conf_t
{
  uint8_t post_div1;
  uint8_t post_div2;
  uint32_t div_ret;
};

/* 214 */
struct pattern_info_new
{
  work_new *works[256];
};

/* 215 */
struct pattern_info
{
  work *works[256];
};

/* 217 */
struct test_info_t
{
  char file_path[128];
  char test_type[128];
  char sn[128];
  char miner_type[128];
  char fac[128];
  char boardname[128];
};

/* 218 */
struct log_info_t
{
  char path[128];
  char compressed_path[128];
  char encoded_path[128];
  bool compressed;
  bool encode;
  char *data;
  uint32_t origin_size;
  uint32_t filter_size;
};

/* 219 */
struct __attribute__((aligned(2))) dirent
{
  __ino_t d_ino;
  __off_t d_off;
  unsigned __int16 d_reclen;
  unsigned __int8 d_type;
  char d_name[256];
};

/* 220 */
typedef void DIR;

/* 221 */
struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  int tm_gmtoff;
  const char *tm_zone;
};

/* 237 */
enum LZ4F_blockSizeID_t : __int32
{
  LZ4F_default = 0x0,
  LZ4F_max64KB = 0x4,
  LZ4F_max256KB = 0x5,
  LZ4F_max1MB = 0x6,
  LZ4F_max4MB = 0x7,
};

/* 236 */
enum LZ4F_blockMode_t : __int32
{
  LZ4F_blockLinked = 0x0,
  LZ4F_blockIndependent = 0x1,
};

/* 235 */
enum LZ4F_contentChecksum_t : __int32
{
  LZ4F_noContentChecksum = 0x0,
  LZ4F_contentChecksumEnabled = 0x1,
};

/* 234 */
enum LZ4F_frameType_t : __int32
{
  LZ4F_frame = 0x0,
  LZ4F_skippableFrame = 0x1,
};

/* 233 */
enum LZ4F_blockChecksum_t : __int32
{
  LZ4F_noBlockChecksum = 0x0,
  LZ4F_blockChecksumEnabled = 0x1,
};

/* 232 */
struct LZ4F_frameInfo_t
{
  LZ4F_blockSizeID_t blockSizeID;
  LZ4F_blockMode_t blockMode;
  LZ4F_contentChecksum_t contentChecksumFlag;
  LZ4F_frameType_t frameType;
  unsigned __int64 contentSize;
  unsigned int dictID;
  LZ4F_blockChecksum_t blockChecksumFlag;
};

/* 226 */
struct LZ4F_preferences_t
{
  LZ4F_frameInfo_t frameInfo;
  int compressionLevel;
  unsigned int autoFlush;
  unsigned int favorDecSpeed;
  unsigned int reserved[3];
};

/* 227 */
typedef LZ4_writeFile_s LZ4_writeFile_t;

/* 231 */
typedef LZ4F_cctx_s LZ4F_cctx;

/* 229 */
typedef size_t LZ4F_errorCode_t;

/* 484 */
struct LZ4_writeFile_s
{
  LZ4F_cctx *cctxPtr;
  FILE *fp;
  LZ4_byte *dstBuf;
  size_t maxWriteSize;
  size_t dstBufMaxSize;
  LZ4F_errorCode_t errCode;
};

/* 251 */
typedef LZ4F_CDict_s LZ4F_CDict;

/* 244 */
typedef uint8_t BYTE;

/* 626 */
struct __attribute__((aligned(8))) LZ4F_cctx_s
{
  LZ4F_CustomMem cmem;
  LZ4F_preferences_t prefs;
  U32 version;
  U32 cStage;
  const LZ4F_CDict *cdict;
  size_t maxBlockSize;
  size_t maxBufferSize;
  BYTE *tmpBuff;
  BYTE *tmpIn;
  size_t tmpInSize;
  U64 totalInSize;
  XXH32_state_t xxh;
  void *lz4CtxPtr;
  U16 lz4CtxAlloc;
  U16 lz4CtxState;
  LZ4F_blockCompression_t blockCompression;
};

/* 255 */
typedef LZ4_stream_u LZ4_stream_t;

/* 254 */
typedef LZ4_streamHC_u LZ4_streamHC_t;

/* 607 */
struct LZ4F_CDict_s
{
  LZ4F_CustomMem cmem;
  void *dictContent;
  LZ4_stream_t *fastCtx;
  LZ4_streamHC_t *HCCtx;
};

/* 487 */
union LZ4_stream_u
{
  char minStateSize[16416];
  LZ4_stream_t_internal internal_donotuse;
};

/* 486 */
union LZ4_streamHC_u
{
  char minStateSize[262200];
  LZ4HC_CCtx_internal internal_donotuse;
};

/* 228 */
typedef LZ4_readFile_s LZ4_readFile_t;

/* 230 */
typedef LZ4F_dctx_s LZ4F_dctx;

/* 485 */
struct LZ4_readFile_s
{
  LZ4F_dctx *dctxPtr;
  FILE *fp;
  LZ4_byte *srcBuf;
  size_t srcBufNext;
  size_t srcBufSize;
  size_t srcBufMaxSize;
};

/* 608 */
struct __attribute__((aligned(8))) LZ4F_dctx_s
{
  LZ4F_CustomMem cmem;
  LZ4F_frameInfo_t frameInfo;
  U32 version;
  dStage_t dStage;
  U64 frameRemainingSize;
  size_t maxBlockSize;
  size_t maxBufferSize;
  BYTE *tmpIn;
  size_t tmpInSize;
  size_t tmpInTarget;
  BYTE *tmpOutBuffer;
  const BYTE *dict;
  size_t dictSize;
  BYTE *tmpOut;
  size_t tmpOutSize;
  size_t tmpOutStart;
  XXH32_state_t xxh;
  XXH32_state_t blockChecksum;
  int skipChecksum;
  BYTE header[19];
};

/* 238 */
struct XXH64_canonical_t
{
  unsigned __int8 digest[8];
};

/* 239 */
typedef unsigned __int64 XXH64_hash_t;

/* 240 */
enum XXH_alignment : __int32
{
  XXH_aligned = 0x0,
  XXH_unaligned = 0x1,
};

/* 241 */
enum XXH_endianess : __int32
{
  XXH_bigEndian = 0x0,
  XXH_littleEndian = 0x1,
};

/* 242 */
struct XXH32_canonical_t
{
  unsigned __int8 digest[4];
};

/* 243 */
typedef unsigned int XXH32_hash_t;

/* 245 */
typedef XXH64_state_s XXH64_state_t;

/* 246 */
struct __attribute__((aligned(8))) XXH64_state_s
{
  uint64_t total_len;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t mem64[4];
  uint32_t memsize;
  uint32_t reserved[2];
};

/* 248 */
struct LZ4F_decompressOptions_t
{
  unsigned int stableDst;
  unsigned int skipChecksums;
  unsigned int reserved1;
  unsigned int reserved0;
};

/* 249 */
typedef int (*compressFunc_t)(void *, const char *, char *, int, int, int, const LZ4F_CDict *);

/* 250 */
struct LZ4F_compressOptions_t
{
  unsigned int stableSrc;
  unsigned int reserved[3];
};

/* 252 */
typedef LZ4F_cctx_s LZ4F_cctx_t;

/* 253 */
enum LZ4F_errorCodes : __int32
{
  LZ4F_OK_NoError = 0x0,
  LZ4F_ERROR_GENERIC = 0x1,
  LZ4F_ERROR_maxBlockSize_invalid = 0x2,
  LZ4F_ERROR_blockMode_invalid = 0x3,
  LZ4F_ERROR_contentChecksumFlag_invalid = 0x4,
  LZ4F_ERROR_compressionLevel_invalid = 0x5,
  LZ4F_ERROR_headerVersion_wrong = 0x6,
  LZ4F_ERROR_blockChecksum_invalid = 0x7,
  LZ4F_ERROR_reservedFlag_set = 0x8,
  LZ4F_ERROR_allocation_failed = 0x9,
  LZ4F_ERROR_srcSize_tooLarge = 0xA,
  LZ4F_ERROR_dstMaxSize_tooSmall = 0xB,
  LZ4F_ERROR_frameHeader_incomplete = 0xC,
  LZ4F_ERROR_frameType_unknown = 0xD,
  LZ4F_ERROR_frameSize_wrong = 0xE,
  LZ4F_ERROR_srcPtr_wrong = 0xF,
  LZ4F_ERROR_decompressionFailed = 0x10,
  LZ4F_ERROR_headerChecksum_invalid = 0x11,
  LZ4F_ERROR_contentChecksum_invalid = 0x12,
  LZ4F_ERROR_frameDecoding_alreadyStarted = 0x13,
  LZ4F_ERROR_compressionState_uninitialized = 0x14,
  LZ4F_ERROR_parameter_null = 0x15,
  LZ4F_ERROR_maxCode = 0x16,
  _LZ4F_dummy_error_enum_for_c89_never_used = 0x17,
};

/* 259 */
struct LZ4HC_match_t
{
  int off;
  int len;
};

/* 260 */
struct LZ4HC_optimal_t
{
  int price;
  int off;
  int mlen;
  int litlen;
};

/* 261 */
enum limitedOutput_directive : __int32
{
  notLimited = 0x0,
  limitedOutput = 0x1,
  fillOutput = 0x2,
};

/* 262 */
typedef size_t reg_t;

/* 264 */
enum LZ4HC_compress_generic_internal::lz4hc_strat_e : __int32
{
  lz4hc = 0x0,
  lz4opt = 0x1,
};

/* 263 */
struct LZ4HC_compress_generic_internal::cParams_t
{
  LZ4HC_compress_generic_internal::lz4hc_strat_e strat;
  int nbSearches;
  U32 targetLength;
};

/* 265 */
enum HCfavor_e : __int32
{
  favorCompressionRatio = 0x0,
  favorDecompressionSpeed = 0x1,
};

/* 266 */
enum dictCtx_directive : __int32
{
  noDictCtx = 0x0,
  usingDictCtxHc = 0x1,
};

/* 267 */
typedef unsigned int uintptr_t;

/* 268 */
typedef size_t Rvl_t;

/* 269 */
typedef LZ4_streamDecode_u LZ4_streamDecode_t;

/* 582 */
union LZ4_streamDecode_u
{
  char minStateSize[32];
  LZ4_streamDecode_t_internal internal_donotuse;
};

/* 270 */
enum tableType_t : __int32
{
  clearedTable = 0x0,
  byPtr = 0x1,
  byU32 = 0x2,
  byU16 = 0x3,
};

/* 271 */
enum dict_directive : __int32
{
  noDict = 0x0,
  withPrefix64k = 0x1,
  usingExtDict = 0x2,
  usingDictCtx = 0x3,
};

/* 272 */
enum earlyEnd_directive : __int32
{
  decode_full_block = 0x0,
  partial_decode = 0x1,
};

/* 273 */
enum dictIssue_directive : __int32
{
  noDictIssue = 0x0,
  dictSmall = 0x1,
};

/* 274 */
typedef _sweep_ctx sweep_ctx;

/* 488 */
struct _sweep_ctx
{
  uint32_t voltage;
  uint32_t pre_open_core_voltage;
  float range_freq[2];
  float step;
  float bias;
  int eeprom_freq_step;
  int mode;
  int reuse;
  float sweep_online_min;
  float sweep_online_max;
  float sweep_online_avg;
  float sweep_online_var;
  float sweep_online_nonce_rate;
  uint64_t sweep_start_time;
  uint64_t sweep_online_time;
  uint64_t sweep_end_time;
};

/* 275 */
typedef _eeprom_data_format eeprom_data_format_t;

/* 277 */
typedef _config_ctx config_ctx;

/* 492 */
struct _asic_reg_conf
{
  uint32_t ccdly_sel;
  uint32_t pwth_sel;
  uint32_t swpf_mode;
  uint32_t pulse_mode;
  uint32_t clk_sel;
  uint32_t ro_relay_en;
  uint32_t co_relay_en;
  uint32_t diode_vdd_mux_sel;
};

/* 284 */
typedef _asic_reg_conf asic_reg_conf;

/* 491 */
struct _test_speed
{
  uint32_t baudrate;
  uint32_t timeout;
};

/* 583 */
typedef _test_speed test_speed_0;

/* 490 */
struct _sensor_ctx
{
  char senor_name[16];
  uint32_t sensor_addr[4];
  uint32_t sensor_i2c_addr;
  uint32_t sensor_reg_addr;
  int sensor_num;
};

/* 288 */
typedef _sensor_ctx sensor_ctx;

/* 609 */
struct _hash_board
{
  char asic_type[16];
  uint32_t wait_temp;
  sensor_ctx sensor;
};

/* 282 */
typedef _hash_board hash_board;

/* 489 */
struct _temp_ctx
{
  uint32_t temp_gap;
  uint32_t wait_cool_time;
  uint32_t cool_board_time;
};

/* 281 */
typedef _temp_ctx temp_ctx;

/* 287 */
struct _fan_ctx
{
  int fan_speed;
  int work_fan_speed;
};

/* 280 */
typedef _fan_ctx fan_ctx;

/* 285 */
struct _test_standard
{
  int invalid_core_num;
  int least_nonce_per_core;
  int asic_nonce_rate;
  int nonce_rate;
};

/* 279 */
typedef _test_standard test_standard;

/* 286 */
struct _test_ctx
{
  int level;
  int pre_open_core_voltage;
  int voltage;
  int freq;
};

/* 278 */
typedef _test_ctx test_ctx;

/* 627 */
struct _config_ctx
{
  int chain;
  int asics;
  int domains;
  int asics_in_domain;
  int asic_domain_num;
  int big_core;
  int asic_small_cores;
  int samll_core_num_in_big_core;
  int patter_num;
  int abnormal_core;
  int interval;
  bool is_super;
  asic_reg_conf reg;
  test_speed_0 speed;
  hash_board board;
  temp_ctx temp;
  fan_ctx fan;
  test_standard standard;
  test_ctx tests[11];
  int test_levels;
  int sweeped_res_index;
};

/* 289 */
typedef _pattern_runtime_ctx pattern_runtime_ctx;

/* 495 */
struct _pattern_test_stats
{
  uint32_t nonce_stats[256][9];
  uint32_t nonce_num_asic[256];
  uint32_t nonce_num_chain;
  uint32_t nonce_num_domain[64];
  uint32_t nonce_num_domain_big[64];
  uint32_t nonce_num_repeated;
  uint32_t nonce_num_top_check_fail;
  uint32_t nonce_num_crc_err;
  uint32_t nonce_num_invalid;
  uint32_t nonce_num_hw;
  uint32_t nonce_num_extra;
  uint32_t nonce_num_unknown_err;
  uint32_t invalid_chain_num;
  uint32_t invalid_asic_num;
  float nonce_stdev;
};

/* 296 */
typedef _pattern_test_stats pattern_test_stats;

/* 494 */
struct _asic_status
{
  uint8_t asic_core_nonce_num[256][1300];
  uint16_t every_asic_got_nonce_num[256];
  uint16_t every_asic_reg_tick_nonce_num[256];
  uint16_t every_asic_reg_ntick_nonce_num[256];
  uint16_t every_asic_reg_nonce_error_num[256];
  uint16_t every_asic_reg_got_nonce_num[256];
  bool ok_asic_list[256];
  bool bad_asic_list[256];
  uint32_t valid_nonce_num;
  uint16_t domain_nonce_rate[64];
};

/* 295 */
typedef _asic_status asic_status;

/* 292 */
typedef _pattern_work pattern_work;

/* 291 */
typedef _pattern_work_new pattern_work_new;

/* 584 */
struct _pattern_ops_t
{
  const char *type;
  int32_t (*init)(const char *);
  void (*exit)(void);
  void (*clear_stats)(void);
  void (*reset)(void);
  void (*process_nonce)(void *, void *);
  void (*process_reg)(void *, void *);
  int32_t (*send_work)(uint32_t, void *);
  void *(*get_stats)(void);
  int32_t (*is_unbalance_happen)(uint32_t);
  int32_t (*is_recv_nonce_enough)(uint32_t);
};

/* 294 */
typedef _pattern_ops_t pattern_ops_t;

/* 493 */
struct _temp_sensor
{
  float temp;
  uint32_t addr;
};

/* 293 */
typedef _temp_sensor temp_sensor;

/* 620 */
struct __attribute__((aligned(8))) _pattern_runtime_ctx
{
  const char *pattern_file_path;
  void *private_data;
  pattern_test_stats stats;
  asic_status asic_stats;
  uint16_t last_succ_asic_nonce_num[256];
  sweep_ctx sweep;
  pattern_work *works[256];
  pattern_work_new *works_new[256];
  config_ctx *config;
  pattern_ops_t pt_ops;
  uint8_t tempval[4];
  uint32_t chain_status;
  uint8_t is_chain_unbalance;
  uint32_t recv_nonce;
  uint32_t read_temp;
  uint32_t read_asic_temp;
  uint32_t pause_read_asic_temp;
  uint32_t enable_get_register;
  uint32_t pause_recv_nonce;
  float nonce_rate;
  temp_sensor asic_max_temp;
  temp_sensor asic_min_temp;
  float asic_avg_temp;
};

/* 498 */
struct _pattern_bin
{
  uint32_t version;
  uint32_t nonce;
  unsigned __int8 data[12];
  unsigned __int8 midstate[32];
};

/* 290 */
typedef _pattern_bin pattern_bin;

/* 611 */
struct _pattern_work
{
  uint16_t id;
  uint16_t nonce_repeat;
  pattern_bin pattern;
};

/* 497 */
struct _pattern_bin_new
{
  unsigned __int8 midstate[8];
  uint32_t nonce;
};

/* 297 */
typedef _pattern_bin_new pattern_bin_new;

/* 610 */
struct _pattern_work_new
{
  uint16_t id;
  uint16_t nonce_repeat;
  pattern_bin_new pattern;
};

/* 298 */
struct __attribute__((aligned(4))) sweep_result_t
{
  uint16_t hashrate;
  uint16_t freq_base;
  uint8_t freq_step;
  uint32_t freqs[256];
  bool is_pass;
};

/* 299 */
struct __attribute__((aligned(2))) _pll_conf
{
  pllparameter_t pll_param;
  uint8_t usr_divider;
};

/* 300 */
struct edf_v6_priv
{
  uint8_t board_info_version;
  uint8_t algorithm_and_key_version;
  uint8_t board_sn[18];
  uint8_t chip_die[3];
  uint8_t chip_marking[14];
  uint8_t chip_bin;
  uint8_t ft_version[10];
  uint16_t pcb_version;
  uint16_t bom_version;
  uint8_t asic_sensor_type;
  uint8_t sensor_offset[6];
  uint8_t chip_tech[3];
  char board_name[9];
  uint8_t factory_job[24];
  uint8_t pt1_result;
  uint8_t pt1_count;
  uint8_t board_info_crc;
  uint16_t voltage;
  uint16_t frequency;
  uint16_t nonce_rate;
  int8_t pcb_temp_in;
  int8_t pcb_temp_out;
  uint8_t test_version;
  uint8_t test_standard;
  uint8_t pt2_result;
  uint8_t pt2_count;
  char data_padding2[3];
  uint8_t param_info_crc;
  uint16_t sweep_hashrate;
  uint16_t sweep_freq_base;
  uint8_t sweep_freq_step;
  uint8_t sweep_level[128];
  uint8_t sweep_result;
  char data_padding3[1];
  uint8_t sweep_info_crc;
};

/* 301 */
struct edf_v5_priv
{
  uint8_t board_info_version;
  uint8_t algorithm_and_key_version;
  uint8_t board_sn[18];
  uint8_t chip_die[3];
  uint8_t chip_marking[14];
  uint8_t chip_bin;
  uint8_t ft_version[10];
  uint16_t pcb_version;
  uint16_t bom_version;
  uint8_t asic_sensor_type;
  uint8_t asic_sensor_addr[4];
  uint8_t pic_sensor_type;
  uint8_t pic_sensor_addr;
  uint8_t chip_tech[3];
  char board_name[9];
  uint8_t factory_job[24];
  uint8_t pt1_result;
  uint8_t pt1_count;
  uint8_t board_info_crc;
  uint16_t voltage;
  uint16_t frequency;
  uint16_t nonce_rate;
  int8_t pcb_temp_in;
  int8_t pcb_temp_out;
  uint8_t test_version;
  uint8_t test_standard;
  uint8_t pt2_result;
  uint8_t pt2_count;
  char data_padding2[3];
  uint8_t param_info_crc;
  uint16_t sweep_hashrate;
  uint16_t sweep_freq_base;
  uint8_t sweep_freq_step;
  uint8_t sweep_level[128];
  uint8_t sweep_result;
  char data_padding3[1];
  uint8_t sweep_info_crc;
};

/* 302 */
struct edf_v4_priv
{
  uint8_t board_info_version;
  uint8_t algorithm_and_key_version;
  uint8_t board_sn[18];
  uint8_t chip_die[3];
  uint8_t chip_marking[14];
  uint8_t chip_bin;
  uint8_t ft_version[10];
  uint16_t pcb_version;
  uint16_t bom_version;
  uint8_t asic_sensor_type;
  uint8_t asic_sensor_addr[4];
  uint8_t pic_sensor_type;
  uint8_t pic_sensor_addr;
  uint8_t chip_tech[3];
  char board_name[9];
  uint8_t factory_job[24];
  uint8_t pt1_result;
  uint8_t pt1_count;
  uint8_t board_info_crc;
  uint16_t voltage;
  uint16_t frequency;
  uint16_t nonce_rate;
  int8_t pcb_temp_in;
  int8_t pcb_temp_out;
  uint8_t test_version;
  uint8_t test_standard;
  uint8_t pt2_result;
  uint8_t pt2_count;
  char data_padding2[3];
  uint8_t param_info_crc;
  uint16_t sweep_hashrate;
  uint16_t sweep_freq_base;
  uint8_t sweep_freq_step;
  uint8_t sweep_level[128];
  uint8_t sweep_result;
  char data_padding3[1];
  uint8_t sweep_info_crc;
};

/* 303 */
typedef eeprom_data_format_t *(*edf_submodule_init)(void);

/* 304 */
struct hashboard_qr_code
{
  char factory_job[32];
  char chip_die[16];
  char chip_marking[16];
  char chip_bin[16];
  char chip_ftversion[16];
  char temp_sensor_type[16];
  char hashboard_ctrl_code[16];
  char hashboard_index[16];
};

/* 305 */
struct hashboard_sn
{
  char sn_len;
  char board_sn[32];
};

/* 306 */
struct zhiju_information
{
  uint8_t zhiju_information_format_version;
  uint8_t hashboard_sn[17];
  uint8_t chip_die[2];
  uint8_t chip_marking[13];
  uint8_t chip_bin;
  uint8_t chip_ft_program_version[9];
  uint8_t asic_sensor;
  uint8_t asic_sensor_addr[4];
  uint8_t pic_sensor;
  uint8_t pic_sensor_addr;
  uint8_t pcb_version_v1;
  uint8_t pcb_version_v2;
  uint8_t bom_version_v1;
  uint8_t bom_version_v2;
  uint8_t chip_technology[2];
  uint8_t voltage[2];
  uint8_t frequency[2];
  uint8_t nonce_rate[2];
  int8_t pcb_temprature_in;
  int8_t pcb_temprature_out;
  uint8_t test_version;
  uint8_t test_standard;
  uint8_t reserve[2];
  uint8_t zhiju_information_crc5;
};

/* 307 */
typedef mes_system_config_file_info Mes_System_Config_File_Info;

/* 591 */
struct mes_system_result
{
  char version[24];
  char code[24];
  char msg[24];
  mes_system_configs *configs;
};

/* 318 */
typedef mes_system_result Mes_System_Result;

/* 621 */
struct mes_system_config_file_info
{
  char jsonrpc[24];
  uint32_t id;
  Mes_System_Result result;
};

/* 592 */
struct mes_system_rule
{
  mes_system_pattern *pattern;
  mes_system_asic_reg *asic_reg;
  mes_system_test_method *test_method;
  mes_system_test_loop *test_loop;
};

/* 308 */
typedef mes_system_rule Mes_System_Rule;

/* 319 */
struct mes_system_configs
{
  char miner_type[24];
  mes_system_hw_info *hw_info;
  Mes_System_Rule rule;
  mes_system_test_config *test_config;
  mes_system_configs *next;
};

/* 320 */
struct mes_system_hw_info
{
  uint32_t id;
  char board_name[24];
  char asic_type[24];
  uint32_t asic_num;
  uint32_t voltage_domain;
  uint32_t asic_num_per_voltage_domain;
  uint32_t power_version[8];
  mes_system_hw_info *next;
};

/* 321 */
struct mes_system_pattern
{
  uint32_t id;
  uint32_t pattern_number;
  uint32_t invalid_core_num;
  uint32_t most_hw_num;
  uint32_t least_nonce_per_core;
  uint32_t nonce_rate;
  uint32_t midstate_number;
  mes_system_pattern *next;
};

/* 322 */
struct mes_system_asic_reg
{
  uint32_t id;
  uint32_t ccdly_sel;
  uint32_t pwth_sel;
  uint32_t swpf_mode;
  uint32_t pulse_mode;
  uint32_t clk_sel;
  uint32_t ro_relay_en;
  uint32_t co_relay_en;
  uint32_t diode_vdd_mux_sel;
  mes_system_asic_reg *next;
};

/* 323 */
struct mes_system_test_method
{
  uint32_t id;
  char method[24];
  mes_system_test_method *next;
};

/* 326 */
struct mes_system_test_loop
{
  uint32_t id;
  uint32_t frequency;
  uint32_t voltage;
  mes_system_test_loop *next;
};

/* 324 */
struct mes_system_test_config
{
  char hardware_version[24];
  char bom_version[24];
  char chip_technology[24];
  char ft_version[24];
  uint32_t bin;
  uint32_t leakage_current;
  mes_system_data *data;
  mes_system_test_config *next;
};

/* 325 */
struct mes_system_data
{
  char version[24];
  uint32_t pattern_id;
  uint32_t asic_reg_id;
  uint32_t test_method_id;
  uint32_t voltage_accuracy;
  uint32_t fan_speed;
  uint32_t test_loop_id[10];
  uint32_t test_loop_id_number;
  uint32_t pre_open_core_voltage;
  mes_system_data *next;
};

/* 309 */
typedef mes_system_data Mes_System_Data;

/* 310 */
typedef mes_system_test_config Mes_System_Test_Config;

/* 311 */
typedef mes_system_test_loop Mes_System_Test_Loop;

/* 312 */
typedef mes_system_test_method Mes_System_Test_Method;

/* 313 */
typedef mes_system_asic_reg Mes_System_Asic_Reg;

/* 314 */
typedef mes_system_pattern Mes_System_Pattern;

/* 315 */
typedef mes_system_hw_info Mes_System_Hw_Info;

/* 316 */
typedef mes_system_configs Mes_System_Configs;

/* 317 */
struct hostent
{
  char *h_name;
  char **h_aliases;
  int h_addrtype;
  int h_length;
  char **h_addr_list;
};

/* 327 */
typedef char *__caddr_t;

/* 328 */
typedef _ptx_err_msg_ pt_err_msg;

/* 510 */
struct __attribute__((aligned(4))) _ptx_err_msg_
{
  int error_no;
  char error_code[10];
  char error_code_desc[20];
};

/* 465 */
typedef int __fd_mask;

/* 329 */
struct fd_set
{
  __fd_mask __fds_bits[32];
};

/* 464 */
typedef unsigned int __socklen_t;

/* 463 */
typedef __socklen_t socklen_t;

/* 462 */
struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  sockaddr *ai_addr;
  char *ai_canonname;
  addrinfo *ai_next;
};

/* 466 */
struct bitmain_switch_sensor_t
{
  uint32_t sensor_fd;
  uint32_t chain_has_opened;
};

/* 467 */
struct bitmain_switch_t
{
  uint32_t switch_fd;
  uint32_t chain_has_opened;
};

/* 468 */
struct bad_asic_list
{
  uint8_t bad_asic_num;
  uint8_t asic_list[256];
};

/* 469 */
struct __attribute__((aligned(4))) bad_asic_cfg_freq
{
  uint8_t freq_cfg_flag;
  uint8_t bad_asic_num;
  uint32_t freq;
  uint8_t asic_id[5];
};

/* 470 */
struct __sigset_t
{
  unsigned int __val[32];
};

/* 474 */
typedef int __pid_t;

/* 733 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$DDF278A5B88F81FEC3CBEE828E282CB3
{
  __pid_t si_pid;
  __uid_t si_uid;
};

/* 476 */
union sigval
{
  int sival_int;
  void *sival_ptr;
};

/* 475 */
typedef sigval sigval_t;

/* 734 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$F43D85AC31CEBD8CC07B08111ABDF065
{
  int si_tid;
  int si_overrun;
  sigval_t si_sigval;
};

/* 735 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$002955E8B5DE3B92E30DFEF7AB65BFE2
{
  __pid_t si_pid;
  __uid_t si_uid;
  sigval_t si_sigval;
};

/* 473 */
typedef int __clock_t;

/* 736 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$353EAF26536A4016665766004ADC0BD6
{
  __pid_t si_pid;
  __uid_t si_uid;
  int si_status;
  __clock_t si_utime;
  __clock_t si_stime;
};

/* 737 */
struct __attribute__((aligned(4))) siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$E8B6F0BBDFDEB0F2D2A2272DA024FD9B
{
  void *si_addr;
  __int16 si_addr_lsb;
};

/* 738 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$534EC22A0813C1325C3E7D3262B5A8D3
{
  int si_band;
  int si_fd;
};

/* 739 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$4B29161E04CAD4BCDD788B201A5E8E5E
{
  void *_call_addr;
  int _syscall;
  unsigned int _arch;
};

/* 740 */
union siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F
{
  int _pad[29];
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$DDF278A5B88F81FEC3CBEE828E282CB3 _kill;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$F43D85AC31CEBD8CC07B08111ABDF065 _timer;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$002955E8B5DE3B92E30DFEF7AB65BFE2 _rt;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$353EAF26536A4016665766004ADC0BD6 _sigchld;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$E8B6F0BBDFDEB0F2D2A2272DA024FD9B _sigfault;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$534EC22A0813C1325C3E7D3262B5A8D3 _sigpoll;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$4B29161E04CAD4BCDD788B201A5E8E5E _sigsys;
};

/* 471 */
struct siginfo_t
{
  int si_signo;
  int si_errno;
  int si_code;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F _sifields;
};

/* 472 */
typedef void (*__sighandler_t)(int);

/* 496 */
struct _work_cxt
{
  uint8_t work_type;
  uint8_t chain_id;
  uint8_t reserved1[2];
  uint32_t work_count;
  uint8_t data[12];
  uint8_t midstate[16][32];
};

/* 522 */
struct _ocv_pulse_width_t::$93B5D43C9D080135AD7CD2C72C22B99B
{
  unsigned __int16 _PULSE_WIDTH : 8;
  unsigned __int16 _OCV_DOUT : 4;
  unsigned __int16 _RSVD1 : 4;
};

/* 521 */
union _ocv_pulse_width_t
{
  _ocv_pulse_width_t::$93B5D43C9D080135AD7CD2C72C22B99B u;
  uint16_t v;
};

/* 524 */
struct _process_monitor_ctrl_t::$B527025DFEC31D3E4C076D3CFDF0A797
{
  unsigned __int16 _PM_SEL : 2;
  unsigned __int16 _PM_START : 1;
  unsigned __int16 _RSVD : 13;
};

/* 523 */
union _process_monitor_ctrl_t
{
  _process_monitor_ctrl_t::$B527025DFEC31D3E4C076D3CFDF0A797 u;
  uint16_t v;
};

/* 526 */
struct _nonce_bin_overflow_control_t::$BA21811157AC6FD2C001FC6AA9D1E604
{
  unsigned __int16 _NONCE_BIN_OF_ENABLE : 1;
  unsigned __int16 _RSVD1 : 1;
  unsigned __int16 _GOLDEN_TICKET_EN : 1;
  unsigned __int16 _RSVD2 : 1;
  unsigned __int16 _NONCE_OF_STS : 1;
  unsigned __int16 _RSVD3 : 11;
};

/* 525 */
union _nonce_bin_overflow_control_t
{
  _nonce_bin_overflow_control_t::$BA21811157AC6FD2C001FC6AA9D1E604 u;
  uint16_t v;
};

/* 528 */
struct _clock_select_ctrl_t::$00812AFD81DD6EC47DD561900F36A6BB
{
  unsigned __int16 _SWPF_MODE : 1;
  unsigned __int16 _CLK_SEL : 2;
  unsigned __int16 _CLK_SEL_MASK : 1;
  unsigned __int16 _RSVD3 : 12;
};

/* 527 */
union _clock_select_ctrl_t
{
  _clock_select_ctrl_t::$00812AFD81DD6EC47DD561900F36A6BB u;
  uint16_t v;
};

/* 530 */
struct _auto_clk_en_t::$054FC362C05094A409FA46B0A2EC5B35
{
  unsigned __int16 _AUTO_CLK_EN : 1;
  unsigned __int16 _RSVD : 4;
  unsigned __int16 _MODE_MASK : 2;
  unsigned __int16 _RSVD1 : 9;
};

/* 529 */
union _auto_clk_en_t
{
  _auto_clk_en_t::$054FC362C05094A409FA46B0A2EC5B35 u;
  uint16_t v;
};

/* 532 */
struct _nonce_bin_overflow_t::$D4EC59588EDC78D583CAE43EC0CC6290
{
  unsigned __int16 _NONCE_BIN_OF_ENABLE : 1;
  unsigned __int16 _FAKE_NONCE : 1;
  unsigned __int16 _RSVD1 : 2;
  unsigned __int16 _NONCE_BIN_OF : 1;
  unsigned __int16 _RSVD2 : 11;
};

/* 531 */
union _nonce_bin_overflow_t
{
  _nonce_bin_overflow_t::$D4EC59588EDC78D583CAE43EC0CC6290 u;
  uint16_t v;
};

/* 534 */
struct _hash_clock_ctrl_t::$B3876FF50123CD57774DE1BDF87C9675
{
  unsigned __int16 _CLOCK_CTRL : 5;
  unsigned __int16 _RSVD1 : 11;
};

/* 533 */
union _hash_clock_ctrl_t
{
  _hash_clock_ctrl_t::$B3876FF50123CD57774DE1BDF87C9675 u;
  uint16_t v;
};

/* 536 */
struct _core_enable_t::$9EFB38A74C52C61335BCA67486DB7660
{
  uint8_t _CORE_EN_I;
  uint8_t _CORE_EN_N;
};

/* 535 */
union _core_enable_t
{
  _core_enable_t::$9EFB38A74C52C61335BCA67486DB7660 u;
  uint16_t v;
};

/* 538 */
struct _clock_delay_ctrl_t::$D53F5AEF46C1C3DBDD430126E13B2B89
{
  unsigned __int8 _SWPF_MODE : 1;
  unsigned __int8 _HASH_CLKEN : 1;
  unsigned __int8 _PWTH_SEL : 3;
  unsigned __int8 _CCDLY_SEL : 3;
};

/* 537 */
union _clock_delay_ctrl_t
{
  _clock_delay_ctrl_t::$D53F5AEF46C1C3DBDD430126E13B2B89 u;
  uint8_t v;
};

/* 540 */
struct _adc_ctrl1_t::$6612BEB8ADF5C53CD7CD7EC72EFE1F01
{
  unsigned __int32 _PU_TSEN : 1;
  unsigned __int32 _PU_CHOP_TSEN : 1;
  unsigned __int32 _BIT_CURRENT_TSEN : 2;
  unsigned __int32 _CLK_PHASE_TSEN : 1;
  unsigned __int32 _PU_DEM_TSEN : 1;
  unsigned __int32 _BIT_RATIO_TSEN : 2;
  unsigned __int32 _OUT_SEL_TSEN : 2;
  unsigned __int32 _TSEN_RST_CTRL : 1;
  unsigned __int32 _INV_TSEN_VLK : 1;
  unsigned __int32 _RESET_TEMPSEN : 1;
  unsigned __int32 _VIN0_EN : 1;
  unsigned __int32 _VOUT_EN : 1;
  unsigned __int32 _RSVD : 1;
  unsigned __int32 _PU_BG : 1;
  unsigned __int32 _VREF_LDO_OUT : 2;
  unsigned __int32 _VREF_LDO_SET : 3;
  unsigned __int32 _VREF_TI_SEL : 1;
  unsigned __int32 _VREF_BG_SEL : 1;
  unsigned __int32 _CHOP_EN : 1;
  unsigned __int32 _PU_DTC : 1;
  unsigned __int32 _PU_DTF : 1;
  unsigned __int32 _PU_TDI : 1;
  unsigned __int32 _PU_DEM_BG : 1;
  unsigned __int32 _RESETN_BG : 1;
  unsigned __int32 _NOTCH_SEL_BGA : 2;
};

/* 539 */
union _adc_ctrl1_t
{
  _adc_ctrl1_t::$6612BEB8ADF5C53CD7CD7EC72EFE1F01 u;
  uint32_t v;
};

/* 542 */
struct _soft_reset_control_t::$DC44DE6C803C4A241E95AF716A5FB4ED
{
  unsigned __int32 _CORE_SRST : 4;
  unsigned __int32 _CORE_SRST_FAST : 4;
  unsigned __int32 _TVER_RESET : 1;
  unsigned __int32 _TOPCRTL_RESET : 1;
  unsigned __int32 _CHIP_RESET : 1;
  unsigned __int32 _RSVD : 5;
  unsigned __int32 _SRST_TIME : 8;
  unsigned __int32 _RSVD1 : 8;
};

/* 541 */
union _soft_reset_control_t
{
  _soft_reset_control_t::$DC44DE6C803C4A241E95AF716A5FB4ED u;
  uint32_t v;
};

/* 544 */
struct _midstate_cal_register_t::$AA0FEB0BEE114E620DE6EFDCC9CE5947
{
  unsigned __int32 _VER_MASK : 16;
  unsigned __int32 _RSVD1 : 12;
  unsigned __int32 _MIDSX_GEN : 2;
  unsigned __int32 _VER_FIX : 1;
  unsigned __int32 _MID_AUTO_GEN : 1;
};

/* 543 */
union _midstate_cal_register_t
{
  _midstate_cal_register_t::$AA0FEB0BEE114E620DE6EFDCC9CE5947 u;
  uint32_t v;
};

/* 546 */
struct _pad_check::$16525B6ECE528C248B585CB0EAFCCE3A
{
  unsigned __int32 _PLL_VDD_OK : 1;
  unsigned __int32 _CORE_VDD_OK : 1;
  unsigned __int32 _PIN_MODE : 1;
  unsigned __int32 _TEST : 1;
  unsigned __int32 _P_CORE_EN : 1;
  unsigned __int32 _POR_EN : 1;
  unsigned __int32 _INV_CLKO : 1;
  unsigned __int32 _ADDR3 : 1;
  unsigned __int32 _RI_CNT : 4;
  unsigned __int32 _BI_CNT : 4;
  unsigned __int32 _NRSTI_OK : 1;
  unsigned __int32 _NRSTI_PAD_OK : 1;
  unsigned __int32 _ADDR : 2;
  unsigned __int32 _DOMAIN_VDD_OK : 4;
  unsigned __int32 _FREE_POR_GLITCH : 1;
  unsigned __int32 _POR_GLITCH : 1;
  unsigned __int32 _NRSTI_GLITCH : 1;
  unsigned __int32 _RSVD2 : 1;
  unsigned __int32 _CHECK_BEGIN : 4;
};

/* 545 */
union _pad_check
{
  _pad_check::$16525B6ECE528C248B585CB0EAFCCE3A u;
  uint32_t v;
};

/* 548 */
struct _rosc_pad_dis_t::$CB4B4EC29B18329A0472AAC5B123FC72
{
  uint32_t _ROSC_DIS_DATA;
};

/* 547 */
union _rosc_pad_dis_t
{
  _rosc_pad_dis_t::$CB4B4EC29B18329A0472AAC5B123FC72 u;
  uint32_t v;
};

/* 550 */
struct _io_driver_strength_cfg_t::$22ABAECD1EB984C3AFC2D6A07D7323E9
{
  unsigned __int32 _CO_DS : 4;
  unsigned __int32 _BO_DS : 4;
  unsigned __int32 _NRSTO_DS : 4;
  unsigned __int32 _CLKO_DS : 4;
  unsigned __int32 _R0_DS : 4;
  unsigned __int32 _RSVD0 : 4;
  unsigned __int32 _RSVD1 : 4;
  unsigned __int32 _RSVD2 : 4;
};

/* 549 */
union _io_driver_strength_cfg_t
{
  _io_driver_strength_cfg_t::$22ABAECD1EB984C3AFC2D6A07D7323E9 u;
  uint32_t v;
};

/* 552 */
struct _analog_mux_control_t::$C3AC73F14EC83580C3C749CE72866EE5
{
  unsigned __int32 _ANA_MUX_SEL : 4;
  unsigned __int32 _RSVD1 : 28;
};

/* 551 */
union _analog_mux_control_t
{
  _analog_mux_control_t::$C3AC73F14EC83580C3C749CE72866EE5 u;
  uint32_t v;
};

/* 554 */
struct _core_command_t::$3FC10C01ECE15D982DC361CBA51BEA75
{
  unsigned __int32 _REG_WDATA : 8;
  unsigned __int32 _REG_ADDR : 5;
  unsigned __int32 _RSVD1 : 1;
  unsigned __int32 _RW_DONE : 1;
  unsigned __int32 _REG_WRITE : 1;
  unsigned __int32 _CORE_ID : 8;
  unsigned __int32 _NUM : 7;
  unsigned __int32 _ALL : 1;
};

/* 553 */
union _core_command_t
{
  _core_command_t::$3FC10C01ECE15D982DC361CBA51BEA75 u;
  uint8_t v[4];
  uint32_t v_32;
};

/* 556 */
struct _uart_relay_t::$DCDDBA906D4F3204C4D7359C3D71F149
{
  unsigned __int32 _CO_RELAY_EN : 1;
  unsigned __int32 _RO_RELAY_EN : 1;
  unsigned __int32 _NONCE_GAP_EN : 1;
  unsigned __int32 _RSVD1 : 13;
  unsigned __int32 _GAP_CNT : 16;
};

/* 555 */
union _uart_relay_t
{
  _uart_relay_t::$DCDDBA906D4F3204C4D7359C3D71F149 u;
  uint32_t v;
};

/* 558 */
struct _fast_UART_configuration_t::$EBFF4A3E136A7FB3E8D0FCB2A7F2A33C
{
  unsigned __int32 _TOP_DIV : 4;
  unsigned __int32 _RSVD1 : 1;
  unsigned __int32 _TOP_ODDSET : 2;
  unsigned __int32 _TOPCLK_SEL : 1;
  unsigned __int32 _BT8D : 9;
  unsigned __int32 _RSVD2 : 1;
  unsigned __int32 _USRC_ODDSET : 2;
  unsigned __int32 _USRC_DIV : 6;
  unsigned __int32 _BCLK_SEL : 1;
  unsigned __int32 _DSCLK_SEL : 2;
  unsigned __int32 _RSVD3 : 1;
  unsigned __int32 _PDIVCLK_SEL : 1;
  unsigned __int32 _VCO_CLK_EN : 1;
};

/* 557 */
union _fast_UART_configuration_t
{
  _fast_UART_configuration_t::$EBFF4A3E136A7FB3E8D0FCB2A7F2A33C u;
  uint32_t v;
};

/* 560 */
struct _ordered_clock_enable::$A1C6A5A120698085F0BD7C1BEBA0DC9F
{
  unsigned __int32 _CLK_EN : 2;
  unsigned __int32 _RSVD : 29;
  unsigned __int32 _CLK_SEL : 1;
};

/* 559 */
union _ordered_clock_enable
{
  _ordered_clock_enable::$A1C6A5A120698085F0BD7C1BEBA0DC9F u;
  uint32_t v;
};

/* 562 */
struct _misc_control_t::$F1953D4D20D95765F15D8E0D8D7D017C
{
  unsigned __int32 _RSVD1 : 2;
  unsigned __int32 _FSW_CKEN : 1;
  unsigned __int32 _RI_DISA : 1;
  unsigned __int32 _RSVD2 : 2;
  unsigned __int32 _CHIPID_MV : 1;
  unsigned __int32 _RET_WORK_ERR_FLAG : 1;
  unsigned __int32 _PCE_EN : 1;
  unsigned __int32 _FORCE_CORE_EN : 1;
  unsigned __int32 _RSVD3 : 3;
  unsigned __int32 _SOFT_INV_CLKO : 1;
  unsigned __int32 _RNTMO_EN : 1;
  unsigned __int32 _TVER_EN : 1;
  unsigned __int32 _RTST_M_EN : 4;
  unsigned __int32 _RVS_K0 : 1;
  unsigned __int32 _SPAT_NOD : 1;
  unsigned __int32 _VERIFY_FIFO_FULL : 1;
  unsigned __int32 _CORE_SWPS : 1;
  unsigned __int32 _RTST_F_EN : 4;
  unsigned __int32 _RNO_EN : 4;
};

/* 561 */
union _misc_control_t
{
  _misc_control_t::$F1953D4D20D95765F15D8E0D8D7D017C u;
  uint32_t v;
};

/* 564 */
struct _ticket_mask_t::$2670B6AA0243F6DA72D99A2BB1D5C4B1
{
  uint8_t _TM0;
  uint8_t _TM1;
  uint8_t _TM2;
  uint8_t _TM3;
};

/* 563 */
union _ticket_mask_t
{
  _ticket_mask_t::$2670B6AA0243F6DA72D99A2BB1D5C4B1 u;
  uint32_t v;
};

/* 566 */
struct _chip_nonce_offset_t::$0AE3073B893DD576A0F9A3524A723D95
{
  uint16_t _CNO;
  unsigned __int16 _RSVD1 : 15;
  unsigned __int16 _CNOV : 1;
};

/* 565 */
union _chip_nonce_offset_t
{
  _chip_nonce_offset_t::$0AE3073B893DD576A0F9A3524A723D95 u;
  uint32_t v;
};

/* 568 */
struct _pll_parameter_t::$148A86E5292EDB32447E18DFCF0786C7
{
  unsigned __int32 _POSTDIV2 : 3;
  unsigned __int32 _RSVD1 : 1;
  unsigned __int32 _POSTDIV1 : 3;
  unsigned __int32 _RSVD2 : 1;
  unsigned __int32 _REFDIV : 6;
  unsigned __int32 _CALEN : 1;
  unsigned __int32 _FASTCALEN : 1;
  unsigned __int32 _FBDIV : 12;
  unsigned __int32 _VCOSEL : 1;
  unsigned __int32 _BYPASS : 1;
  unsigned __int32 _PLLEN : 1;
  unsigned __int32 _LOCKED : 1;
};

/* 567 */
union _pll_parameter_t
{
  _pll_parameter_t::$148A86E5292EDB32447E18DFCF0786C7 u;
  uint32_t v;
};

/* 571 */
struct _fpga_bt8d_t::$064BE3777DB068CE02E3BEEC5C09C92D
{
  unsigned __int32 bt8d_c0 : 6;
  unsigned __int32 reserved_0 : 2;
  unsigned __int32 bt8d_c1 : 6;
  unsigned __int32 reserved_1 : 2;
  unsigned __int32 bt8d_c2 : 6;
  unsigned __int32 reserved_2 : 2;
  unsigned __int32 bt8d_c3 : 6;
  unsigned __int32 reserved_3 : 2;
};

/* 570 */
union _fpga_bt8d_t
{
  _fpga_bt8d_t::$064BE3777DB068CE02E3BEEC5C09C92D u;
  uint32_t v;
};

/* 580 */
struct _returned_nonce_counter_t::$4B92755CDE5B692329894160767A252E
{
  uint16_t _RETURN_NONCE_CNT;
  uint16_t _RETURN_NONCE_CNT_MATCH;
};

/* 579 */
union _returned_nonce_counter_t
{
  _returned_nonce_counter_t::$4B92755CDE5B692329894160767A252E u;
  uint32_t v;
};

/* 581 */
struct json_t_0
{
  _BYTE gap0[4];
  volatile size_t refcount;
};

/* 586 */
struct _tick_nonce_counter_t::$E411BBEC9451BAA71A7911D02B37276F
{
  uint32_t _tick_nonce_cnt;
};

/* 585 */
union _tick_nonce_counter_t
{
  _tick_nonce_counter_t::$E411BBEC9451BAA71A7911D02B37276F u;
  uint32_t v;
};

/* 588 */
struct _general_i2c_command_t::$46F2FE6AD56A5A19CF83CAD7B0DC115A
{
  unsigned __int32 _DATA : 8;
  unsigned __int32 _REG_ADDR : 8;
  unsigned __int32 _RW_CTRL : 1;
  unsigned __int32 _DEVICE_ADDR : 7;
  unsigned __int32 _REG_ADDR_VAILD : 1;
  unsigned __int32 _AUTO_READ_TEMP : 1;
  unsigned __int32 _AUTO_RET_TEMP : 1;
  unsigned __int32 _RSVD1 : 3;
  unsigned __int32 _RW_FAIL : 1;
  unsigned __int32 _BUSY : 1;
};

/* 587 */
union _general_i2c_command_t
{
  _general_i2c_command_t::$46F2FE6AD56A5A19CF83CAD7B0DC115A u;
  uint32_t v;
};

/* 590 */
struct _frequency_sweep_control_t::$CB775C3371B5AB98A2F218254CEFB524
{
  unsigned __int32 _SWP_EN : 1;
  unsigned __int32 _SWP_TRIG : 1;
  unsigned __int32 _SWP_ONGOING : 1;
  unsigned __int32 _SWP_DONE_ALL : 1;
  unsigned __int32 _SWP_PAT_ADDR : 3;
  unsigned __int32 _SWP_ONE_PAT_DONE : 1;
  unsigned __int32 _CURR_PAT_ADDR : 3;
  unsigned __int32 _SWEEP_RESET : 1;
  unsigned __int32 _SWEEP_FAIL_LOCK_EN : 1;
  unsigned __int32 _ALL_CORE_CLK_SEL_CHANGE_ST : 1;
  unsigned __int32 _RSVD1 : 2;
  unsigned __int32 _SWEEP_ST_ADDR : 8;
  unsigned __int32 _SWEEP_STATE : 3;
  unsigned __int32 _INC_DISABLE : 1;
  unsigned __int32 _EN_OR_MATCH_NONCES : 1;
  unsigned __int32 _CORE_CLK_CFG_DIS : 1;
  unsigned __int32 _OVERLAP_LOCK_EN : 1;
  unsigned __int32 _RSVD2 : 1;
};

/* 589 */
union _frequency_sweep_control_t
{
  _frequency_sweep_control_t::$CB775C3371B5AB98A2F218254CEFB524 u;
  uint32_t v;
};

/* 630 */
struct complex_double
{
  double real;
  double imag;
};

/* 631 */
struct complex_float
{
  float real;
  float imag;
};

/* 632 */
typedef __int64 DItype;

/* 633 */
typedef _IO_marker _IO_marker_0;

/* 635 */
struct nonce_format_t::$F4175EC6656FD4F18765A5BC5960D424
{
  unsigned __int32 _DATA : 17;
  unsigned __int32 _CHIP_ADDR : 8;
  unsigned __int32 _CORE_ID : 7;
};

/* 636 */
struct nonce_format_t::$DE677E723494A2B4F9BAA0655AD0031A
{
  unsigned __int32 _DATA : 9;
  unsigned __int32 _CHIP_NONCE_OFFSET : 16;
  unsigned __int32 _CORE_ID : 7;
};

/* 634 */
union nonce_format_t
{
  nonce_format_t::$F4175EC6656FD4F18765A5BC5960D424 u;
  nonce_format_t::$DE677E723494A2B4F9BAA0655AD0031A u2;
  uint32_t v;
};

/* 637 */
typedef _ocv_pulse_width_t ocv_pulse_width_t;

/* 638 */
typedef _process_monitor_ctrl_t process_monitor_ctrl_t;

/* 639 */
typedef _nonce_bin_overflow_control_t nonce_bin_overflow_control_t;

/* 640 */
typedef _clock_select_ctrl_t clock_select_ctrl_t;

/* 641 */
typedef _auto_clk_en_t auto_clk_en_t;

/* 642 */
typedef _nonce_bin_overflow_t nonce_bin_overflow_t;

/* 643 */
typedef _hash_clock_ctrl_t hash_clock_ctrl_t;

/* 644 */
typedef _core_enable_t core_enable_t;

/* 645 */
typedef _clock_delay_ctrl_t clock_delay_ctrl_t;

/* 646 */
typedef _adc_ctrl1_t adc_ctrl1_t;

/* 647 */
typedef _soft_reset_control_t soft_reset_control_t;

/* 648 */
typedef _midstate_cal_register_t midstate_cal_register_t;

/* 649 */
typedef _pad_check pad_check_t;

/* 650 */
typedef _rosc_pad_dis_t rosc_pad_dis_t;

/* 651 */
typedef _io_driver_strength_cfg_t io_driver_strength_cfg_t;

/* 652 */
typedef _analog_mux_control_t analog_mux_control_t;

/* 653 */
typedef _core_command_t core_command_t;

/* 654 */
typedef _uart_relay_t uart_relay_t;

/* 655 */
typedef _fast_UART_configuration_t fast_UART_configuration_t;

/* 656 */
typedef _ordered_clock_enable ordered_clock_enable;

/* 657 */
typedef _misc_control_t misc_control_t;

/* 658 */
typedef _ticket_mask_t ticket_mask_t;

/* 659 */
typedef _chip_nonce_offset_t chip_nonce_offset_t;

/* 660 */
typedef _pll_parameter_t pll_parameter_t;

/* 661 */
enum bitmain_tsensor_error_code : __int32
{
  bitmain_tsensor_error_code::TSENSOR_NO_ERROR = 0x0,
  bitmain_tsensor_error_code::TSENSOR_ERROR_COMMON = 0x80000600,
  bitmain_tsensor_error_code::TSENSOR_BAD_PARAM = 0x80000601,
};

/* 662 */
struct bitmain_power_t
{
  uint32_t power_fd;
  uint32_t power_open;
  uint32_t power_version;
  bool power_Calibrated;
  eeprom_data_t eeprom;
};

/* 663 */
enum bitmain_power_error_code : __int32
{
  bitmain_power_error_code::POWER_NO_ERROR = 0x0,
  bitmain_power_error_code::POWER_ERROR_COMMON = 0x80000300,
  bitmain_power_error_code::POWER_BAD_PARAM = 0x80000301,
  bitmain_power_error_code::POWER_NOT_SUPPORT = 0x80000302,
};

/* 664 */
typedef __int64 int64_t;

/* 665 */
typedef __int16 int16_t;

/* 666 */
enum bitmain_pic_error_code : __int32
{
  bitmain_pic_error_code::PIC_NO_ERROR = 0x0,
  bitmain_pic_error_code::PIC_ERROR_COMMON = 0x80000200,
  bitmain_pic_error_code::PIC_BAD_PARAM = 0x80000201,
  bitmain_pic_error_code::PIC_NOT_SUPPORT = 0x80000202,
};

/* 667 */
typedef _fpga_bt8d_t fpga_bt8d_t;

/* 668 */
struct sysinfo
{
  __kernel_long_t uptime;
  __kernel_ulong_t loads[3];
  __kernel_ulong_t totalram;
  __kernel_ulong_t freeram;
  __kernel_ulong_t sharedram;
  __kernel_ulong_t bufferram;
  __kernel_ulong_t totalswap;
  __kernel_ulong_t freeswap;
  __u16 procs;
  __u16 pad;
  __kernel_ulong_t totalhigh;
  __kernel_ulong_t freehigh;
  __u32 mem_unit;
  char _f[8];
};

/* 669 */
enum bitmain_eeprom_error_code : __int32
{
  bitmain_eeprom_error_code::EEPROM_NO_ERROR = 0x0,
  bitmain_eeprom_error_code::EEPROM_ERROR_COMMON = 0x80000100,
  bitmain_eeprom_error_code::EEPROM_BAD_PARAM = 0x80000101,
};

/* 670 */
struct clib_deque
{
  clib_object **pElements;
  int no_max_elements;
  int head;
  int tail;
  int no_of_elements;
  clib_compare compare_fn;
  clib_destroy destruct_fn;
};

/* 671 */
typedef int clib_error;

/* 672 */
typedef int clib_bool;

/* 673 */
typedef unsigned int pthread_t;

/* 674 */
struct gpio_map_t
{
  pthread_mutex_t ctrl_mutex;
  clib_map *gpio_callback_map;
};

/* 676 */
union ifreq::$4AF2B49FDDB54BAFABDFAE063E6E4A98
{
  char ifrn_name[16];
};

/* 677 */
union ifreq::$08A4139B8351F6B925C0D8B85C61C082
{
  sockaddr ifru_addr;
  sockaddr ifru_dstaddr;
  sockaddr ifru_broadaddr;
  sockaddr ifru_netmask;
  sockaddr ifru_hwaddr;
  __int16 ifru_flags;
  int ifru_ivalue;
  int ifru_mtu;
  ifmap ifru_map;
  char ifru_slave[16];
  char ifru_newname[16];
  void *ifru_data;
  if_settings ifru_settings;
};

/* 675 */
struct ifreq
{
  ifreq::$4AF2B49FDDB54BAFABDFAE063E6E4A98 ifr_ifrn;
  ifreq::$08A4139B8351F6B925C0D8B85C61C082 ifr_ifru;
};

/* 678 */
enum __socket_type : __int32
{
  __socket_type::SOCK_STREAM = 0x1,
  __socket_type::SOCK_DGRAM = 0x2,
  __socket_type::SOCK_RAW = 0x3,
  __socket_type::SOCK_RDM = 0x4,
  __socket_type::SOCK_SEQPACKET = 0x5,
  __socket_type::SOCK_DCCP = 0x6,
  __socket_type::SOCK_PACKET = 0xA,
  __socket_type::SOCK_CLOEXEC = 0x80000,
  __socket_type::SOCK_NONBLOCK = 0x800,
};

/* 679 */
struct sockaddr_in
{
  sa_family_t sin_family;
  in_port_t sin_port;
  in_addr sin_addr;
  unsigned __int8 sin_zero[8];
};

/* 680 */
struct parse_bin_file_16midstate_super::pattern_struct_in_file
{
  uint32_t nonce;
  unsigned __int8 data[12];
  unsigned __int8 midstate[32];
};

/* 681 */
struct parse_bin_file_16midstate_sf::pattern_struct_in_file
{
  unsigned __int8 midstate[8];
  uint32_t nonce;
};

/* 682 */
struct parse_bin_file_8midstate::pattern_struct_in_file
{
  uint32_t nonce;
  unsigned __int8 data[12];
  unsigned __int8 midstate[32];
};

/* 683 */
enum SWEEP_MODE : __int32
{
  SWEEP_MODE::HW_MODE = 0x0,
  SWEEP_MODE::SW_MODE = 0x1,
  SWEEP_MODE::PM_MODE = 0x2,
};

/* 684 */
struct mid_auto_gen_work_format
{
  uint8_t work_type;
  uint8_t chain_id;
  uint8_t reserved1[2];
  uint32_t work_count;
  uint8_t data[12];
  uint8_t chunk[64];
};

/* 685 */
enum WATER_SWEEP_ERROR_CODE : __int32
{
  WATER_SWEEP_ERROR_CODE::SWEEP_NORMAL = 0x0,
  WATER_SWEEP_ERROR_CODE::ENV_TEMP_TOO_HIGH = 0x1,
  WATER_SWEEP_ERROR_CODE::ENV_TEMP_TOO_LOW = 0x2,
  WATER_SWEEP_ERROR_CODE::ASIC_TEMP_TOO_HIGH = 0x3,
  WATER_SWEEP_ERROR_CODE::ASIC_TEMP_TOO_LOW = 0x4,
  WATER_SWEEP_ERROR_CODE::ASIC_TEMP_DIFF = 0x5,
  WATER_SWEEP_ERROR_CODE::WATER_REVERSE = 0x6,
  WATER_SWEEP_ERROR_CODE::FIND_ASIC_ERROR = 0x7,
};

/* 686 */
typedef _returned_nonce_counter_t returned_nonce_counter_t;

/* 687 */
struct __dirstream;

/* 689 */
struct __attribute__((aligned(8))) pthread_cond_t::$37B88C9EDD6CA635C8B2267C69E10A67
{
  int __lock;
  unsigned int __futex;
  unsigned __int64 __total_seq;
  unsigned __int64 __wakeup_seq;
  unsigned __int64 __woken_seq;
  void *__mutex;
  unsigned int __nwaiters;
  unsigned int __broadcast_seq;
};

/* 688 */
union pthread_cond_t
{
  pthread_cond_t::$37B88C9EDD6CA635C8B2267C69E10A67 __data;
  char __size[48];
  __int64 __align;
};

/* 690 */
typedef __mode_t mode_t;

/* 691 */
union unalign64
{
  U32 u32;
  U64 u64;
};

/* 692 */
union unalign
{
  U32 u32;
};

/* 693 */
enum XXH_errorcode : __int32
{
  XXH_OK = 0x0,
  XXH_ERROR = 0x1,
};

/* 694 */
enum LZ4F_lastBlockStatus : __int32
{
  notDone = 0x0,
  fromTmpBuffer = 0x1,
  fromSrcBuffer = 0x2,
};

/* 695 */
typedef int ptrdiff_t;

/* 696 */
enum repeat_state_e : __int32
{
  rep_untested = 0x0,
  rep_not = 0x1,
  rep_confirmed = 0x2,
};

/* 697 */
union LZ4_unalign
{
  U16 u16;
  U32 u32;
  reg_t uArch;
};

/* 698 */
typedef uintptr_t uptrval;

/* 699 */
struct op_sweep
{
  int (*warmup)(const char *, int, int, int);
  int (*init)(void *, void *);
  int (*sweep)(float **, uint8_t **);
  int (*stop)(...);
  int (*flush)(float **);
  int (*check_status)(...);
};

/* 700 */
enum SWEEP_ERROR_CODE : __int32
{
  SWEEP_ERROR_CODE::SWEEP_PT2_FAIL = 0x1,
  SWEEP_ERROR_CODE::SWEEP_READ_EEPROM_FAIL = 0x2,
  SWEEP_ERROR_CODE::SWEEP_MAX_CHAIN = 0x3,
  SWEEP_ERROR_CODE::SWEEP_NOT_SUPPORT = 0x4,
  SWEEP_ERROR_CODE::SWEEP_HAL_INIT_FAIL = 0x5,
  SWEEP_ERROR_CODE::SWEEP_FAN_INIT_FAIL = 0x6,
  SWEEP_ERROR_CODE::SWEEP_OPEN_PATTERN_FILE_FAIL = 0x7,
  SWEEP_ERROR_CODE::SWEEP_MEMORY_FULL = 0x8,
  SWEEP_ERROR_CODE::SWEEP_PATTERN_WORK_NOT_ENOUGH = 0x9,
  SWEEP_ERROR_CODE::SWEEP_LOW_NONCE_RATE = 0xA,
  SWEEP_ERROR_CODE::SWEEP_BASE_FREQ_ERR = 0xB,
};

/* 701 */
struct parse_8midstate_file_sf::pattern_struct_in_file
{
  unsigned __int8 midstate[8];
  uint32_t nonce;
};

/* 702 */
struct parse_8midstate_file::pattern_struct_in_file
{
  uint32_t nonce;
  unsigned __int8 data[12];
  unsigned __int8 midstate[32];
};

/* 703 */
typedef _work_cxt work_cxt;

/* 704 */
struct pt1_ctx
{
  char factory_job[32];
  char chip_die[16];
  char chip_marking[16];
  char chip_ftversion[16];
  char temp_sensor_type[16];
  char hashboard_ctrl_code[16];
  char hashboard_index[16];
  char chip_tech[3];
  char board_name[9];
  char board_sn[32];
  int chip_bin;
};

/* 705 */
typedef _tick_nonce_counter_t tick_nonce_counter_t;

/* 706 */
typedef _general_i2c_command_t general_i2c_command_t;

/* 707 */
typedef _frequency_sweep_control_t frequency_sweep_control_t;

/* 708 */
struct tm_0
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  int __tm_gmtoff;
  const char *__tm_zone;
};

/* 709 */
struct zhiju_eeprom_data_map
{
  uint8_t algorithm_and_key_version;
  uint8_t zhiju_information_length;
  zhiju_information zhiju_information;
};

/* 711 */
union ifreq_0::$4AF2B49FDDB54BAFABDFAE063E6E4A98
{
  char ifrn_name[16];
};

/* 712 */
union ifreq_0::$17ED3CA7772E9BBD734F9855D60E4536
{
  sockaddr ifru_addr;
  sockaddr ifru_dstaddr;
  sockaddr ifru_broadaddr;
  sockaddr ifru_netmask;
  sockaddr ifru_hwaddr;
  __int16 ifru_flags;
  int ifru_ivalue;
  int ifru_mtu;
  ifmap ifru_map;
  char ifru_slave[16];
  char ifru_newname[16];
  __caddr_t ifru_data;
};

/* 710 */
struct ifreq_0
{
  ifreq_0::$4AF2B49FDDB54BAFABDFAE063E6E4A98 ifr_ifrn;
  ifreq_0::$17ED3CA7772E9BBD734F9855D60E4536 ifr_ifru;
};

/* 715 */
struct X509_VERIFY_PARAM_ID_st;

/* 716 */
struct ASN1_VALUE_st;

/* 717 */
struct NAME_CONSTRAINTS_st;

/* 718 */
struct ISSUING_DIST_POINT_st;

/* 719 */
struct AUTHORITY_KEYID_st;

/* 720 */
struct X509_POLICY_CACHE_st;

/* 721 */
struct X509_POLICY_TREE_st;

/* 722 */
struct engine_st;

/* 723 */
struct x509_crl_method_st;

/* 724 */
struct evp_pkey_ctx_st;

/* 725 */
struct evp_pkey_asn1_method_st;

/* 726 */
struct bn_blinding_st;

/* 727 */
struct bignum_ctx;

/* 728 */
enum __ns_sect : __int32
{
  __ns_sect::ns_s_qd = 0x0,
  __ns_sect::ns_s_zn = 0x0,
  __ns_sect::ns_s_an = 0x1,
  __ns_sect::ns_s_pr = 0x1,
  __ns_sect::ns_s_ns = 0x2,
  __ns_sect::ns_s_ud = 0x2,
  __ns_sect::ns_s_ar = 0x3,
  __ns_sect::ns_s_max = 0x4,
};

/* 729 */
struct ADC_Data_Out
{
  uint32_t counter[256];
  uint32_t Data_out[256][10];
};

/* 730 */
struct temp_struct
{
  float temp;
  uint32_t addr;
};

/* 732 */
union sigaction::$A0D7C018272EA30F374433AF4EA79BEE
{
  __sighandler_t sa_handler;
  void (*sa_sigaction)(int, siginfo_t *, void *);
};

/* 731 */
struct sigaction
{
  sigaction::$A0D7C018272EA30F374433AF4EA79BEE __sigaction_handler;
  __sigset_t sa_mask;
  int sa_flags;
  void (*sa_restorer)(void);
};

/* 741 */
const union $636B5B6A2AF01AF0A17EDFBBF647AFA3
{
  U32 u;
  BYTE c[4];
};

/* 742 */
struct pollfd
{
  int fd;
  __int16 events;
  __int16 revents;
};

/* 743 */
typedef unsigned int __useconds_t;

/* 744 */
union __attribute__((aligned(8))) __n64
{
  unsigned __int64 n64_u64[1];
  unsigned __int32 n64_u32[2];
  unsigned __int16 n64_u16[4];
  unsigned __int8 n64_u8[8];
  __int64 n64_i64[1];
  __int32 n64_i32[2];
  __int16 n64_i16[4];
  __int8 n64_i8[8];
  float n64_f32[2];
  double n64_f64[1];
};

/* 745 */
union __attribute__((aligned(8))) __n128
{
  unsigned __int64 n128_u64[2];
  unsigned __int32 n128_u32[4];
  unsigned __int16 n128_u16[8];
  unsigned __int8 n128_u8[16];
  __int64 n128_i64[2];
  __int32 n128_i32[4];
  __int16 n128_i16[8];
  __int8 n128_i8[16];
  float n128_f32[4];
  double n128_f64[2];
};

/* 746 */
typedef __n64 int8x8_t;

/* 747 */
typedef __n64 uint8x8_t;

/* 748 */
typedef __n64 int16x4_t;

/* 749 */
typedef __n64 int32x2_t;

/* 750 */
typedef __n64 uint16x4_t;

/* 751 */
typedef __n64 uint32x2_t;

/* 752 */
typedef __n128 int8x16_t;

/* 753 */
typedef __n128 int16x8_t;

/* 754 */
typedef __n128 int32x4_t;

/* 755 */
typedef __n128 int64x2_t;

/* 756 */
typedef __n128 uint8x16_t;

/* 757 */
typedef __n128 uint16x8_t;

/* 758 */
typedef __n128 uint32x4_t;

/* 759 */
typedef __n128 uint64x2_t;

/* 760 */
typedef __n64 poly8x8_t;

/* 761 */
typedef __n64 poly16x4_t;

/* 762 */
typedef __n128 poly16x8_t;

/* 763 */
typedef __n128 poly8x16_t;

/* 764 */
typedef __n64 float16x4_t;

/* 765 */
typedef __n64 float32x2_t;

/* 766 */
typedef __n128 float16x8_t;

/* 767 */
typedef __n128 float32x4_t;

/* 768 */
typedef __n128 float64x2_t;

/* 769 */
typedef __n128 poly128_t;

/* 770 */
typedef int16x4_t int16x2_t;

/* 771 */
typedef uint16x4_t uint16x2_t;

/* 772 */
typedef float16x4_t float16x2_t;


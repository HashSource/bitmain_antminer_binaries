/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'cgminer'
*/

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long

struct thr_info;
struct cgpu_info;
struct hashtable_bucket;
struct hashtable_list;
struct json_t;
struct _IO_marker;
struct pool;
struct thread_q;
struct device_drv;
struct api_data;
struct UT_hash_table;
struct UT_hash_bucket;
struct io_data;
struct k_item;
struct sockaddr;
struct target_temp_args;
struct fan_speed_temp_args;
struct _freq_tuning_info;
struct hashtable_pair;
struct hashtable;
struct k_list;
union _core_command_t;
struct _reg_status_t;
union _clock_delay_ctrl_t;
union _get_status_t;
union _set_config_t;

/* 1 */
struct Elf32_Sym
{
  unsigned __int32 st_name __offset(OFF32,0x11188);
  unsigned __int32 st_value __off;
  unsigned __int32 st_size;
  unsigned __int8 st_info;
  unsigned __int8 st_other;
  unsigned __int16 st_shndx;
};

/* 2 */
struct Elf32_Rel
{
  unsigned __int32 r_offset;
  unsigned __int32 r_info;
};

/* 3 */
union Elf32_Dyn::$A263394DDF3EC2D4B1B8448EDD30E249
{
  unsigned __int32 d_val;
  unsigned __int32 d_ptr;
};

/* 4 */
struct Elf32_Dyn
{
  __int32 d_tag;
  union Elf32_Dyn::$A263394DDF3EC2D4B1B8448EDD30E249 d_un;
};

/* 5 */
struct Elf32_Verneed
{
  unsigned __int16 vn_version;
  unsigned __int16 vn_cnt;
  unsigned __int32 vn_file __offset(OFF32,0x11188);
  unsigned __int32 vn_aux;
  unsigned __int32 vn_next;
};

/* 6 */
struct Elf32_Vernaux
{
  unsigned __int32 vna_hash;
  unsigned __int16 vna_flags;
  unsigned __int16 vna_other;
  unsigned __int32 vna_name __offset(OFF32,0x11188);
  unsigned __int32 vna_next;
};

/* 7 */
typedef void _IO_lock_t;

/* 8 */
struct __va_list
{
  void *__ap;
};

/* 9 */
struct stratum_work
{
  char *job_id;
  unsigned __int8 **merkle_bin;
  bool clean;
  double diff;
};

/* 10 */
enum pool_enable : __int32
{
  pool_enable::POOL_DISABLED = 0x0,
  pool_enable::POOL_ENABLED = 0x1,
  pool_enable::POOL_REJECTING = 0x2,
};

/* 101 */
typedef unsigned __int64 __uint64_t;

/* 75 */
typedef __uint64_t uint64_t;

/* 36 */
typedef unsigned int __uint32_t;

/* 21 */
typedef __uint32_t uint32_t;

/* 100 */
typedef int __time_t;

/* 99 */
typedef int __suseconds_t;

/* 71 */
struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};

/* 22 */
typedef unsigned int size_t;

/* 89 */
struct UT_hash_handle
{
  UT_hash_table *tbl;
  void *prev;
  void *next;
  UT_hash_handle *hh_prev;
  UT_hash_handle *hh_next;
  void *key;
  unsigned int keylen;
  unsigned int hashv;
};

/* 11 */
struct work
{
  unsigned __int8 data[128];
  unsigned __int8 midstate[32];
  unsigned __int8 target[32];
  unsigned __int8 hash[32];
  double device_diff;
  uint64_t share_diff;
  int rolls;
  int drv_rolllimit;
  uint32_t nonce;
  thr_info *thr;
  int thr_id;
  pool *pool;
  timeval tv_staged;
  bool mined;
  bool clone;
  bool cloned;
  int rolltime;
  bool longpoll;
  bool stale;
  bool mandatory;
  bool block;
  bool stratum;
  char *job_id;
  uint64_t nonce2;
  size_t nonce2_len;
  char *ntime;
  double sdiff;
  char *nonce1;
  bool gbt;
  char *coinbase;
  int gbt_txns;
  unsigned int work_block;
  uint32_t id;
  UT_hash_handle hh;
  double work_difficulty;
  int subid;
  bool devflag;
  timeval tv_stamp;
  timeval tv_getwork;
  timeval tv_getwork_reply;
  timeval tv_cloned;
  timeval tv_work_start;
  timeval tv_work_found;
  char getwork_mode;
  int version;
};

/* 74 */
typedef unsigned int pthread_t;

/* 208 */
union sem_t
{
  char __size[16];
  int __align;
};

/* 84 */
typedef sem_t cgsem_t;

/* 12 */
struct thr_info
{
  int id;
  int device_thread;
  bool primary_thread;
  pthread_t pth;
  cgsem_t sem;
  thread_q *q;
  cgpu_info *cgpu;
  void *cgpu_data;
  timeval last;
  timeval sick;
  bool pause;
  bool getwork;
  bool work_restart;
  bool work_update;
};

/* 102 */
typedef __int64 __int64_t;

/* 81 */
typedef __int64_t int64_t;

/* 80 */
typedef int proxytypes_t;

/* 97 */
struct __pthread_internal_slist
{
  __pthread_internal_slist *__next;
};

/* 96 */
typedef __pthread_internal_slist __pthread_slist_t;

/* 299 */
union __pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95
{
  int __spins;
  __pthread_slist_t __list;
};

/* 95 */
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;
  int __kind;
  unsigned int __nusers;
  union
  {
    int __spins;
    __pthread_slist_t __list;
  };
};

/* 73 */
union pthread_mutex_t
{
  __pthread_mutex_s __data;
  char __size[24];
  int __align;
};

/* 93 */
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;
  unsigned __int8 __flags;
  unsigned __int8 __shared;
  unsigned __int8 __pad1;
  unsigned __int8 __pad2;
  int __cur_writer;
};

/* 86 */
union pthread_rwlock_t
{
  __pthread_rwlock_arch_t __data;
  char __size[32];
  int __align;
};

/* 304 */
struct cglock
{
  pthread_mutex_t mutex;
  pthread_rwlock_t rwlock;
};

/* 72 */
typedef cglock cglock_t;

/* 214 */
struct __pthread_cond_s::$1948864A517A55083A59240547837AC2::$620CBDB56FB461BCCDEBCCDB2BD438DA
{
  unsigned int __low;
  unsigned int __high;
};

/* 215 */
union __pthread_cond_s::$1948864A517A55083A59240547837AC2
{
  unsigned __int64 __wseq;
  __pthread_cond_s::$1948864A517A55083A59240547837AC2::$620CBDB56FB461BCCDEBCCDB2BD438DA __wseq32;
};

/* 216 */
struct __pthread_cond_s::$6F5B582BCFE66EA44995FCD80445B231::$620CBDB56FB461BCCDEBCCDB2BD438DA
{
  unsigned int __low;
  unsigned int __high;
};

/* 217 */
union __pthread_cond_s::$6F5B582BCFE66EA44995FCD80445B231
{
  unsigned __int64 __g1_start;
  __pthread_cond_s::$6F5B582BCFE66EA44995FCD80445B231::$620CBDB56FB461BCCDEBCCDB2BD438DA __g1_start32;
};

/* 94 */
struct __pthread_cond_s
{
  union
  {
    unsigned __int64 __wseq;
    __pthread_cond_s::$1948864A517A55083A59240547837AC2::$620CBDB56FB461BCCDEBCCDB2BD438DA __wseq32;
  };
  union
  {
    unsigned __int64 __g1_start;
    __pthread_cond_s::$6F5B582BCFE66EA44995FCD80445B231::$620CBDB56FB461BCCDEBCCDB2BD438DA __g1_start32;
  };
  unsigned int __g_refs[2];
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

/* 79 */
union pthread_cond_t
{
  __pthread_cond_s __data;
  char __size[48];
  __int64 __align;
};

/* 78 */
struct list_head
{
  list_head *next;
  list_head *prev;
};

/* 77 */
typedef __time_t time_t;

/* 14 */
struct cgminer_stats
{
  uint32_t getwork_calls;
  timeval getwork_wait;
  timeval getwork_wait_max;
  timeval getwork_wait_min;
};

/* 76 */
struct cgminer_pool_stats
{
  uint32_t getwork_calls;
  uint32_t getwork_attempts;
  timeval getwork_wait;
  timeval getwork_wait_max;
  timeval getwork_wait_min;
  double getwork_wait_rolling;
  bool hadrolltime;
  bool canroll;
  bool hadexpire;
  uint32_t rolltime;
  double min_diff;
  double max_diff;
  double last_diff;
  uint32_t min_diff_count;
  uint32_t max_diff_count;
  uint64_t times_sent;
  uint64_t bytes_sent;
  uint64_t net_bytes_sent;
  uint64_t times_received;
  uint64_t bytes_received;
  uint64_t net_bytes_received;
};

/* 43 */
typedef int __int32_t;

/* 42 */
typedef __int32_t int32_t;

/* 68 */
typedef char CURL;

/* 70 */
struct __attribute__((aligned(8))) pool
{
  int pool_no;
  int prio;
  int64_t accepted;
  int64_t rejected;
  int seq_rejects;
  int seq_getfails;
  int solved;
  int64_t diff1;
  char diff[8];
  int quota;
  int quota_gcd;
  int quota_used;
  int works;
  double diff_accepted;
  double diff_rejected;
  double diff_stale;
  bool submit_fail;
  bool idle;
  bool lagging;
  bool probed;
  pool_enable enabled;
  bool submit_old;
  bool removed;
  bool lp_started;
  bool blocking;
  char *hdr_path;
  char *lp_url;
  unsigned int getwork_requested;
  unsigned int stale_shares;
  unsigned int discarded_work;
  unsigned int getfail_occasions;
  unsigned int remotefail_occasions;
  timeval tv_idle;
  double utility;
  int last_shares;
  int shares;
  char *rpc_req;
  char *rpc_url;
  char *rpc_userpass;
  char *rpc_user;
  char *rpc_pass;
  proxytypes_t rpc_proxytype;
  char *rpc_proxy;
  pthread_mutex_t pool_lock;
  cglock_t data_lock;
  thread_q *submit_q;
  thread_q *getwork_q;
  pthread_t longpoll_thread;
  pthread_t test_thread;
  bool testing;
  int curls;
  pthread_cond_t cr_cond;
  list_head curlring;
  time_t last_share_time;
  double last_share_diff;
  uint64_t best_diff;
  uint64_t bad_work;
  cgminer_stats cgminer_stats;
  cgminer_pool_stats cgminer_pool_stats;
  char prev_block[32];
  char *stratum_url;
  bool extranonce_subscribe;
  char *stratum_port;
  int sock;
  char *sockbuf;
  size_t sockbuf_size;
  char *sockaddr_url;
  char *sockaddr_proxy_url;
  char *sockaddr_proxy_port;
  char *nonce1;
  unsigned __int8 *nonce1bin;
  uint64_t nonce2;
  unsigned int n2size;
  char *sessionid;
  bool has_stratum;
  bool stratum_active;
  bool stratum_init;
  bool stratum_notify;
  bool support_ab;
  int version_num;
  int32_t ab_mask;
  int version[4];
  stratum_work swork;
  pthread_t stratum_sthread;
  pthread_t stratum_rthread;
  pthread_mutex_t stratum_lock;
  thread_q *stratum_q;
  int sshares;
  bool has_gbt;
  cglock_t gbt_lock;
  unsigned __int8 previousblockhash[32];
  unsigned __int8 gbt_target[32];
  char *coinbasetxn;
  char *longpollid;
  char *gbt_workid;
  int gbt_expires;
  uint32_t gbt_version;
  uint32_t curtime;
  uint32_t gbt_bits;
  unsigned __int8 *txn_hashes;
  int gbt_txns;
  int height;
  bool gbt_solo;
  unsigned __int8 merklebin[512];
  int transactions;
  char *txn_data;
  unsigned __int8 scriptsig_base[100];
  unsigned __int8 script_pubkey[28];
  int nValue;
  CURL *gbt_curl;
  bool gbt_curl_inuse;
  size_t n1_len;
  unsigned __int8 *coinbase;
  unsigned int coinbase_len;
  int nonce2_offset;
  unsigned __int8 header_bin[128];
  int merkles;
  char prev_hash[68];
  char bbversion[12];
  char nbit[12];
  char ntime[12];
  double next_diff;
  double sdiff;
  uint32_t current_height;
  timeval tv_lastwork;
};

/* 91 */
typedef int ptrdiff_t;

/* 90 */
struct UT_hash_table
{
  UT_hash_bucket *buckets;
  unsigned int num_buckets;
  unsigned int log2_num_buckets;
  unsigned int num_items;
  UT_hash_handle *tail;
  ptrdiff_t hho;
  unsigned int ideal_chain_maxlen;
  unsigned int nonideal_items;
  unsigned int ineff_expands;
  unsigned int noexpand;
  uint32_t signature;
};

/* 82 */
struct thread_q
{
  list_head q;
  bool frozen;
  pthread_mutex_t mutex;
  pthread_cond_t cond;
};

/* 16 */
enum dev_enable : __int32
{
  dev_enable::DEV_ENABLED = 0x0,
  dev_enable::DEV_DISABLED = 0x1,
  dev_enable::DEV_RECOVER = 0x2,
};

/* 87 */
enum alive : __int32
{
  alive::LIFE_WELL = 0x0,
  alive::LIFE_SICK = 0x1,
  alive::LIFE_DEAD = 0x2,
  alive::LIFE_NOSTART = 0x3,
  alive::LIFE_INIT = 0x4,
};

/* 15 */
enum dev_reason : __int32
{
  dev_reason::REASON_THREAD_FAIL_INIT = 0x0,
  dev_reason::REASON_THREAD_ZERO_HASH = 0x1,
  dev_reason::REASON_THREAD_FAIL_QUEUE = 0x2,
  dev_reason::REASON_DEV_SICK_IDLE_60 = 0x3,
  dev_reason::REASON_DEV_DEAD_IDLE_600 = 0x4,
  dev_reason::REASON_DEV_NOSTART = 0x5,
  dev_reason::REASON_DEV_OVER_HEAT = 0x6,
  dev_reason::REASON_DEV_THERMAL_CUTOFF = 0x7,
  dev_reason::REASON_DEV_COMMS_ERROR = 0x8,
  dev_reason::REASON_DEV_THROTTLE = 0x9,
};

/* 17 */
struct __attribute__((aligned(8))) cgpu_info
{
  int cgminer_id;
  device_drv *drv;
  int device_id;
  char *name;
  char *device_path;
  void *device_data;
  void *dup_data;
  char *unique_id;
  dev_enable deven;
  int accepted;
  int rejected;
  int hw_errors;
  double rolling;
  double rolling1;
  double rolling5;
  double rolling15;
  double total_mhashes;
  double utility;
  alive status;
  char init[40];
  timeval last_message_tv;
  int threads;
  thr_info **thr;
  int64_t max_hashes;
  const char *kname;
  bool new_work;
  double temp;
  int cutofftemp;
  int64_t diff1;
  double diff_accepted;
  double diff_rejected;
  int last_share_pool;
  time_t last_share_pool_time;
  double last_share_diff;
  time_t last_device_valid_work;
  uint32_t last_nonce;
  time_t device_last_well;
  time_t device_last_not_well;
  dev_reason device_not_well_reason;
  int thread_fail_init_count;
  int thread_zero_hash_count;
  int thread_fail_queue_count;
  int dev_sick_idle_60_count;
  int dev_dead_idle_600_count;
  int dev_nostart_count;
  int dev_over_heat_count;
  int dev_thermal_cutoff_count;
  int dev_comms_error_count;
  int dev_throttle_count;
  cgminer_stats cgminer_stats;
  pthread_rwlock_t qlock;
  work *queued_work;
  work *unqueued_work;
  unsigned int queued_count;
  bool shutdown;
  timeval dev_start_tv;
  int hidiff;
  int lodiff;
  int direction;
};

/* 92 */
struct UT_hash_bucket
{
  UT_hash_handle *hh_head;
  unsigned int count;
  unsigned int expand_mult;
};

/* 88 */
enum drv_driver : __int32
{
  drv_driver::DRIVER_bitforce = 0x0,
  drv_driver::DRIVER_modminer = 0x1,
  drv_driver::DRIVER_bitmain = 0x2,
  drv_driver::DRIVER_bitmain_soc = 0x3,
  drv_driver::DRIVER_MAX = 0x4,
};

/* 83 */
struct device_drv
{
  drv_driver drv_id;
  char *dname;
  char *name;
  void (*drv_detect)(bool);
  void (*reinit_device)(cgpu_info *);
  void (*get_statline_before)(char *, size_t, cgpu_info *);
  void (*get_statline)(char *, size_t, cgpu_info *);
  api_data *(*get_api_stats)(cgpu_info *);
  bool (*get_stats)(cgpu_info *);
  void (*identify_device)(cgpu_info *);
  char *(*set_device)(cgpu_info *, char *, char *, char *);
  bool (*thread_prepare)(thr_info *);
  uint32_t (*can_limit_work)(thr_info *);
  bool (*thread_init)(thr_info *);
  bool (*prepare_work)(thr_info *, work *);
  void (*hash_work)(thr_info *);
  int64_t (*scanhash)(thr_info *, work *, int64_t);
  int64_t (*scanwork)(thr_info *);
  bool (*queue_full)(cgpu_info *);
  void (*flush_work)(cgpu_info *);
  void (*update_work)(cgpu_info *);
  void (*hw_error)(thr_info *);
  void (*thread_shutdown)(thr_info *);
  void (*thread_enable)(thr_info *);
  void (*zero_stats)(cgpu_info *);
  bool copy;
  double max_diff;
  double min_diff;
};

/* 13 */
enum api_data_type : __int32
{
  api_data_type::API_ESCAPE = 0x0,
  api_data_type::API_STRING = 0x1,
  api_data_type::API_CONST = 0x2,
  api_data_type::API_UINT8 = 0x3,
  api_data_type::API_INT16 = 0x4,
  api_data_type::API_UINT16 = 0x5,
  api_data_type::API_INT = 0x6,
  api_data_type::API_UINT = 0x7,
  api_data_type::API_UINT32 = 0x8,
  api_data_type::API_HEX32 = 0x9,
  api_data_type::API_UINT64 = 0xA,
  api_data_type::API_INT64 = 0xB,
  api_data_type::API_DOUBLE = 0xC,
  api_data_type::API_ELAPSED = 0xD,
  api_data_type::API_BOOL = 0xE,
  api_data_type::API_TIMEVAL = 0xF,
  api_data_type::API_TIME = 0x10,
  api_data_type::API_MHS = 0x11,
  api_data_type::API_MHTOTAL = 0x12,
  api_data_type::API_TEMP = 0x13,
  api_data_type::API_UTILITY = 0x14,
  api_data_type::API_FREQ = 0x15,
  api_data_type::API_VOLTS = 0x16,
  api_data_type::API_HS = 0x17,
  api_data_type::API_DIFF = 0x18,
  api_data_type::API_PERCENT = 0x19,
  api_data_type::API_AVG = 0x1A,
};

/* 85 */
struct api_data
{
  api_data_type type;
  char *name;
  void *data;
  bool data_was_malloc;
  api_data *prev;
  api_data *next;
};

/* 40 */
typedef unsigned __int8 __uint8_t;

/* 39 */
typedef __uint8_t uint8_t;

/* 38 */
typedef unsigned __int16 __uint16_t;

/* 37 */
typedef __uint16_t uint16_t;

/* 219 */
union in6_addr::$B80A5568EDCB3DEA112C17957211D170
{
  uint8_t __u6_addr8[16];
  uint16_t __u6_addr16[8];
  uint32_t __u6_addr32[4];
};

/* 18 */
struct in6_addr
{
  in6_addr::$B80A5568EDCB3DEA112C17957211D170 __in6_u;
};

/* 19 */
typedef uint16_t in_port_t;

/* 118 */
typedef uint32_t in_addr_t;

/* 20 */
struct in_addr
{
  in_addr_t s_addr;
};

/* 23 */
typedef unsigned int rpl_memchr::longword;

/* 24 */
typedef hashtable_bucket bucket_t;

/* 28 */
struct hashtable_bucket
{
  hashtable_list *first;
  hashtable_list *last;
};

/* 29 */
struct hashtable_list
{
  hashtable_list *prev;
  hashtable_list *next;
};

/* 25 */
typedef hashtable_list list_t;

/* 26 */
typedef hashtable hashtable_t;

/* 212 */
struct hashtable
{
  size_t size;
  hashtable_bucket *buckets;
  size_t order;
  hashtable_list list;
  hashtable_list ordered_list;
};

/* 27 */
typedef hashtable_pair pair_t;

/* 211 */
struct __attribute__((aligned(4))) hashtable_pair
{
  hashtable_list list;
  hashtable_list ordered_list;
  size_t hash;
  json_t *value;
  char key[1];
};

/* 31 */
enum json_type : __int32
{
  JSON_OBJECT = 0x0,
  JSON_ARRAY = 0x1,
  JSON_STRING = 0x2,
  JSON_INTEGER = 0x3,
  JSON_REAL = 0x4,
  JSON_TRUE = 0x5,
  JSON_FALSE = 0x6,
  JSON_NULL = 0x7,
};

/* 30 */
struct json_t
{
  json_type type;
  size_t refcount;
};

/* 35 */
typedef int __off_t;

/* 41 */
typedef __int64 __quad_t;

/* 34 */
typedef __quad_t __off64_t;

/* 32 */
struct _IO_FILE
{
  int _flags;
  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;
  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;
  _IO_marker *_markers;
  _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset;
  unsigned __int16 _cur_column;
  char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
  __off64_t _offset;
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;
  int _mode;
  char _unused2[40];
};

/* 33 */
struct _IO_marker
{
  _IO_marker *_next;
  _IO_FILE *_sbuf;
  int _pos;
};

/* 44 */
typedef void (*json_free_t)(void *);

/* 45 */
typedef void *(*json_malloc_t)(size_t);

/* 46 */
typedef int (*json_dump_callback_t)(const char *, size_t, void *);

/* 47 */
struct json_object_t
{
  json_t json;
  hashtable_t hashtable;
  int visited;
};

/* 48 */
struct json_array_t
{
  json_t json;
  size_t size;
  size_t entries;
  json_t **table;
  int visited;
};

/* 49 */
typedef _IO_FILE FILE;

/* 50 */
typedef int (*get_func)(void *);

/* 51 */
struct stream_t
{
  get_func get;
  void *data;
  char buffer[5];
  size_t buffer_pos;
  int state;
  int line;
  int column;
  int last_column;
  size_t position;
};

/* 58 */
struct strbuffer_t
{
  char *value;
  size_t length;
  size_t size;
};

/* 302 */
struct lex_t::$BD4887B8155239BFEFA5AB9A7B453162::$187604EA7C5609CC783974FAB9764C1D
{
  char *val;
  size_t len;
};

/* 59 */
typedef __int64 json_int_t;

/* 303 */
union lex_t::$BD4887B8155239BFEFA5AB9A7B453162
{
  lex_t::$BD4887B8155239BFEFA5AB9A7B453162::$187604EA7C5609CC783974FAB9764C1D string;
  json_int_t integer;
  double real;
};

/* 52 */
struct lex_t
{
  stream_t stream;
  strbuffer_t saved_text;
  size_t flags;
  size_t depth;
  int token;
  lex_t::$BD4887B8155239BFEFA5AB9A7B453162 value;
};

/* 53 */
struct string_data_t
{
  const char *data;
  int pos;
};

/* 54 */
struct buffer_data_t
{
  const char *data;
  size_t len;
  size_t pos;
};

/* 57 */
typedef size_t (*json_load_callback_t)(void *, size_t, void *);

/* 55 */
struct callback_data_t
{
  char data[1024];
  size_t len;
  size_t pos;
  json_load_callback_t callback;
  void *arg;
};

/* 56 */
struct json_error_t
{
  int line;
  int column;
  int position;
  char source[80];
  char text[160];
};

/* 60 */
typedef __va_list __gnuc_va_list;

/* 61 */
struct json_string_t
{
  json_t json;
  char *value;
  size_t length;
};

/* 62 */
struct json_integer_t
{
  json_t json;
  json_int_t value;
};

/* 63 */
struct json_real_t
{
  json_t json;
  double value;
};

/* 64 */
typedef __gnuc_va_list va_list;

/* 66 */
enum __bitmask opt_type : __int32
{
  opt_type::OPT_NOARG = 0x1,
  opt_type::OPT_HASARG = 0x2,
  opt_type::OPT_PROCESSARG = 0x4,
  opt_type::OPT_SUBTABLE = 0x8,
  opt_type::OPT_END = 0x10,
};

/* 213 */
union opt_table::$E59A6B864CBE004D1CCF35FB265C4519
{
  const void *carg;
  void *arg;
  size_t tlen;
};

/* 65 */
struct opt_table
{
  const char *names;
  opt_type type;
  char *(*cb)(void *);
  char *(*cb_arg)(const char *, void *);
  void (*show)(char *, const void *);
  opt_table::$E59A6B864CBE004D1CCF35FB265C4519 u;
  const char *desc;
};

/* 67 */
struct sha2_context
{
  uint32_t total[2];
  uint32_t state[8];
  unsigned __int8 buffer[64];
  unsigned __int8 ipad[64];
  unsigned __int8 opad[64];
};

/* 69 */
struct strategies
{
  const char *s;
};

/* 98 */
struct timezone
{
  int tz_minuteswest;
  int tz_dsttime;
};

/* 103 */
typedef k_item K_ITEM;

/* 115 */
struct k_item
{
  const char *name;
  k_item *prev;
  k_item *next;
  void *data;
};

/* 135 */
typedef int __fd_mask;

/* 104 */
struct fd_set
{
  __fd_mask fds_bits[32];
};

/* 126 */
typedef unsigned __int16 sa_family_t;

/* 105 */
struct sockaddr_storage
{
  sa_family_t ss_family;
  char __ss_padding[122];
  unsigned int __ss_align;
};

/* 106 */
struct __attribute__((aligned(4))) CMDS
{
  char *name;
  void (*func)(io_data *, int, char *, bool, char);
  bool iswritemode;
  bool joinable;
};

/* 109 */
struct __attribute__((aligned(4))) io_data
{
  size_t siz;
  char *ptr;
  char *cur;
  bool sock;
  bool close;
};

/* 107 */
typedef k_list K_LIST;

/* 218 */
struct k_list
{
  const char *name;
  bool is_store;
  cglock_t *lock;
  k_item *head;
  k_item *tail;
  size_t siz;
  int total;
  int count;
  int count_up;
  int allocate;
  int limit;
  bool do_tail;
  int item_mem_count;
  void **item_memory;
  int data_mem_count;
  void **data_memory;
};

/* 108 */
struct io_list
{
  io_data *io_data;
  io_list *prev;
  io_list *next;
};

/* 110 */
struct __attribute__((aligned(4))) IPACCESS
{
  in6_addr ip;
  in6_addr mask;
  char group;
};

/* 111 */
struct APIGROUPS
{
  char *commands;
};

/* 114 */
enum code_severity : __int32
{
  code_severity::SEVERITY_ERR = 0x0,
  code_severity::SEVERITY_WARN = 0x1,
  code_severity::SEVERITY_INFO = 0x2,
  code_severity::SEVERITY_SUCC = 0x3,
  code_severity::SEVERITY_FAIL = 0x4,
};

/* 113 */
enum code_parameters : __int32
{
  code_parameters::PARAM_PGA = 0x0,
  code_parameters::PARAM_ASC = 0x1,
  code_parameters::PARAM_PID = 0x2,
  code_parameters::PARAM_PGAMAX = 0x3,
  code_parameters::PARAM_ASCMAX = 0x4,
  code_parameters::PARAM_PMAX = 0x5,
  code_parameters::PARAM_POOLMAX = 0x6,
  code_parameters::PARAM_DMAX = 0x7,
  code_parameters::PARAM_CMD = 0x8,
  code_parameters::PARAM_POOL = 0x9,
  code_parameters::PARAM_STR = 0xA,
  code_parameters::PARAM_BOTH = 0xB,
  code_parameters::PARAM_BOOL = 0xC,
  code_parameters::PARAM_SET = 0xD,
  code_parameters::PARAM_INT = 0xE,
  code_parameters::PARAM_NONE = 0xF,
};

/* 112 */
struct CODES
{
  const code_severity severity;
  const int code;
  const code_parameters params;
  const char *description;
};

/* 134 */
typedef unsigned int __socklen_t;

/* 117 */
typedef __socklen_t socklen_t;

/* 116 */
struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  sockaddr *ai_addr;
  char *ai_canonname;
  addrinfo *ai_next;
};

/* 132 */
struct sockaddr
{
  sa_family_t sa_family;
  char sa_data[14];
};

/* 119 */
struct sockaddr_x25;

/* 120 */
struct sockaddr_un;

/* 121 */
struct sockaddr_ns;

/* 122 */
struct sockaddr_iso;

/* 123 */
struct sockaddr_ipx;

/* 124 */
struct sockaddr_inarp;

/* 125 */
struct sockaddr_in6
{
  sa_family_t sin6_family;
  in_port_t sin6_port;
  uint32_t sin6_flowinfo;
  in6_addr sin6_addr;
  uint32_t sin6_scope_id;
};

/* 127 */
struct sockaddr_in
{
  sa_family_t sin_family;
  in_port_t sin_port;
  in_addr sin_addr;
  unsigned __int8 sin_zero[8];
};

/* 128 */
struct sockaddr_eon;

/* 129 */
struct sockaddr_dl;

/* 130 */
struct sockaddr_ax25;

/* 131 */
struct sockaddr_at;

/* 133 */
typedef int __jmp_buf[64];

/* 136 */
typedef __int16 __int16_t;

/* 137 */
typedef int __ssize_t;

/* 140 */
typedef __int16_t int16_t;

/* 142 */
typedef char __int8_t;

/* 139 */
typedef __int8_t int8_t;

/* 138 */
struct __attribute__((aligned(4))) all_parameters
{
  unsigned int *current_job_start_address;
  unsigned int pwm_value;
  unsigned int chain_exist[16];
  unsigned int timeout;
  unsigned int fan_exist_map;
  unsigned int temp_sensor_map;
  unsigned int nonce_error;
  unsigned int chain_asic_exist[16][8];
  unsigned int chain_asic_status[16][8];
  char chain_asic_temp_num[16];
  unsigned __int8 TempChipType[16][8];
  unsigned __int8 TempChipAddr[16][8];
  int16_t chain_asic_temp[16][8][4];
  unsigned __int8 chain_asic_temp_status[16][8];
  int16_t chain_asic_maxtemp[16][4];
  int16_t chain_asic_mintemp[16][4];
  int8_t chain_asic_iic[48];
  uint32_t chain_hw[16];
  uint64_t chain_asic_nonce[16][128];
  char chain_asic_status_string[16][136];
  unsigned __int64 total_nonce_num;
  unsigned __int8 fan_exist[8];
  unsigned int fan_speed_value[8];
  int temp[16];
  uint8_t chain_asic_num[16];
  unsigned __int8 pwm_percent;
  unsigned __int8 chain_num;
  unsigned __int8 fan_num;
  unsigned __int8 temp_num;
  unsigned int fan_speed_top1;
  unsigned int fan_speed_low1;
  int temp_top1[4];
  int temp_low1[4];
  int temp_air_out_avg;
  int temp_air_out_sum;
  int temp_bad_count;
  int temp_air_out_good_count;
  int temp_air_in_bad_count;
  int temp_top1_last;
  unsigned int baud;
  unsigned int corenum;
  unsigned __int8 addrInterval;
  unsigned __int8 max_asic_num_in_one_chain;
  unsigned __int8 diff;
  uint8_t fan_eft;
  uint8_t fan_pwm;
  __attribute__((packed)) __attribute__((aligned(1))) unsigned __int16 frequency;
  char frequency_t[10];
  __attribute__((packed)) __attribute__((aligned(1))) unsigned __int16 freq[16];
  __attribute__((packed)) __attribute__((aligned(1))) pthread_t heart_beat_id[16];
};

/* 141 */
union pthread_attr_t
{
  char __size[36];
  int __align;
};

/* 143 */
struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  int tm_gmtoff;
  const char *tm_zone;
};

/* 144 */
struct __attribute__((aligned(2))) core_cmd
{
  unsigned __int8 chain;
  unsigned __int8 chip_addr;
  unsigned __int8 mode;
  unsigned __int8 core_mode;
  unsigned int core_id;
  unsigned __int8 cmd_type;
  unsigned __int8 rw_falg;
  unsigned __int8 reserved;
  __attribute__((packed)) __attribute__((aligned(1))) unsigned int reg_data;
};

/* 145 */
struct sha256_ctx
{
  unsigned int tot_len;
  unsigned int len;
  unsigned __int8 block[128];
  uint32_t h[8];
};

/* 147 */
struct __attribute__((packed)) __attribute__((aligned(2))) eeprom_tuning_result_t
{
  uint8_t freq[48];
  uint16_t voltage;
  uint32_t hash_rate;
};

/* 146 */
struct eeprom_layout_t
{
  uint16_t fixture_header;
  uint16_t fixture_version;
  uint8_t hash_board_sn[20];
  uint16_t pcb_version;
  uint16_t bom_version;
  uint8_t temp_sensor_type;
  uint8_t product_id;
  uint16_t crc_fixture;
  uint8_t reserved_0[8];
  uint16_t cgminer_header;
  eeprom_tuning_result_t tuning_ret[3];
  uint16_t crc_cgminer;
  uint8_t reserved_1[50];
};

/* 148 */
struct _log_ctx
{
  int need_clear;
  char *src_dir;
  char *tgt_dir;
  char last_path[30];
  char path[30];
  char ts[20];
  char *prefix;
};

/* 149 */
typedef _get_status_t get_status_t;

/* 298 */
struct _get_status_t::$B606635B7BDB8F969EFD5A2D3B4F3FFC
{
  __int8 _CMD : 4;
  __int8 _ALL : 1;
  __int8 _TYPE : 3;
  uint8_t _Length;
  uint8_t _ADDR;
  uint8_t _REGADDR;
  __int8 _CRC5 : 5;
  __int8 _RSVD : 3;
};

/* 297 */
union _get_status_t
{
  _get_status_t::$B606635B7BDB8F969EFD5A2D3B4F3FFC u;
  uint8_t v[5];
};

/* 150 */
typedef _core_command_t core_command_t;

/* 231 */
struct _core_command_t::$12624B0E56C6BDE80BD8DB4EF1E18607
{
  __int32 _REG_WDATA : 8;
  __int32 _REG_ADDR : 4;
  __int32 _RSVD0 : 2;
  __int32 _RD_DONE : 1;
  __int32 _REG_WRITE : 1;
  __int32 _CORE_ID : 9;
  __int32 _RSVD1 : 6;
  __int32 _ALL : 1;
};

/* 230 */
union _core_command_t
{
  _core_command_t::$12624B0E56C6BDE80BD8DB4EF1E18607 u;
  uint8_t v[4];
  uint32_t v_32;
};

/* 151 */
typedef _set_config_t set_config_t;

/* 301 */
struct _set_config_t::$2DA941D08B7DE9862C20EB71370A5B45
{
  __int8 _CMD : 4;
  __int8 _ALL : 1;
  __int8 _TYPE : 3;
  uint8_t _Length;
  uint8_t _ADDR;
  uint8_t _REGADDR;
  uint8_t _REGDATA[4];
  __int8 _CRC5 : 5;
  __int8 _RSVD : 3;
};

/* 300 */
union _set_config_t
{
  _set_config_t::$2DA941D08B7DE9862C20EB71370A5B45 u;
  uint8_t v[9];
};

/* 152 */
typedef _reg_status_t reg_status_t;

/* 232 */
struct __attribute__((aligned(4))) _reg_status_t
{
  uint32_t reg_response;
  uint8_t found;
};

/* 153 */
struct reg_content
{
  unsigned int reg_value;
  unsigned __int8 crc;
  unsigned __int8 chip_address;
  unsigned __int8 reg_address;
  unsigned __int8 chain_number;
};

/* 154 */
struct reg_buf
{
  unsigned int p_wr;
  unsigned int p_rd;
  unsigned int reg_value_num;
  reg_content reg_buffer[511];
};

/* 155 */
enum pool_strategy : __int32
{
  pool_strategy::POOL_FAILOVER = 0x0,
  pool_strategy::POOL_ROUNDROBIN = 0x1,
  pool_strategy::POOL_ROTATE = 0x2,
  pool_strategy::POOL_LOADBALANCE = 0x3,
  pool_strategy::POOL_BALANCE = 0x4,
};

/* 156 */
struct schedtime
{
  bool enable;
  tm tm;
};

/* 157 */
struct curl_ent
{
  CURL *curl;
  list_head node;
  timeval tv;
};

/* 158 */
struct _cgpu_devid_counter
{
  char name[4];
  int lastid;
  UT_hash_handle hh;
};

/* 159 */
struct JE
{
  char *buf;
  JE *next;
};

/* 160 */
struct stratum_share
{
  UT_hash_handle hh;
  bool block;
  work *work;
  int id;
  time_t sshare_time;
  time_t sshare_sent;
};

/* 161 */
struct block
{
  char hash[68];
  UT_hash_handle hh;
  int block_no;
};

/* 162 */
struct benchfile_layout
{
  int length;
  char *name;
};

/* 163 */
typedef unsigned int __kernel_ulong_t;

/* 164 */
typedef unsigned int __u32;

/* 165 */
typedef unsigned __int16 __u16;

/* 166 */
typedef int __kernel_long_t;

/* 167 */
struct __sigset_t
{
  unsigned int __val[32];
};

/* 172 */
typedef int __pid_t;

/* 171 */
typedef unsigned int __uid_t;

/* 362 */
struct siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$DDF278A5B88F81FEC3CBEE828E282CB3
{
  __pid_t si_pid;
  __uid_t si_uid;
};

/* 174 */
union sigval
{
  int sival_int;
  void *sival_ptr;
};

/* 173 */
typedef sigval sigval_t;

/* 363 */
struct siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$F43D85AC31CEBD8CC07B08111ABDF065
{
  int si_tid;
  int si_overrun;
  sigval_t si_sigval;
};

/* 364 */
struct siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$002955E8B5DE3B92E30DFEF7AB65BFE2
{
  __pid_t si_pid;
  __uid_t si_uid;
  sigval_t si_sigval;
};

/* 170 */
typedef int __clock_t;

/* 365 */
struct siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$353EAF26536A4016665766004ADC0BD6
{
  __pid_t si_pid;
  __uid_t si_uid;
  int si_status;
  __clock_t si_utime;
  __clock_t si_stime;
};

/* 366 */
struct siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$265B18A126C812B550AFBF1D29E5326D::$1ABA0B5CD3F99EF9F5BDED5620AD4FC1::$662BF2F748E3912036E0D25CDC9D9EE4
{
  void *_lower;
  void *_upper;
};

/* 367 */
union siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$265B18A126C812B550AFBF1D29E5326D::$1ABA0B5CD3F99EF9F5BDED5620AD4FC1
{
  siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$265B18A126C812B550AFBF1D29E5326D::$1ABA0B5CD3F99EF9F5BDED5620AD4FC1::$662BF2F748E3912036E0D25CDC9D9EE4 _addr_bnd;
  __uint32_t _pkey;
};

/* 368 */
struct siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$265B18A126C812B550AFBF1D29E5326D
{
  void *si_addr;
  __int16 si_addr_lsb;
  siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$265B18A126C812B550AFBF1D29E5326D::$1ABA0B5CD3F99EF9F5BDED5620AD4FC1 _bounds;
};

/* 369 */
struct siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$534EC22A0813C1325C3E7D3262B5A8D3
{
  int si_band;
  int si_fd;
};

/* 370 */
struct siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$4B29161E04CAD4BCDD788B201A5E8E5E
{
  void *_call_addr;
  int _syscall;
  unsigned int _arch;
};

/* 371 */
union siginfo_t::$B03DB822B349322EA93D3BE0E5948B41
{
  int _pad[29];
  siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$DDF278A5B88F81FEC3CBEE828E282CB3 _kill;
  siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$F43D85AC31CEBD8CC07B08111ABDF065 _timer;
  siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$002955E8B5DE3B92E30DFEF7AB65BFE2 _rt;
  siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$353EAF26536A4016665766004ADC0BD6 _sigchld;
  siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$265B18A126C812B550AFBF1D29E5326D _sigfault;
  siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$534EC22A0813C1325C3E7D3262B5A8D3 _sigpoll;
  siginfo_t::$B03DB822B349322EA93D3BE0E5948B41::$4B29161E04CAD4BCDD788B201A5E8E5E _sigsys;
};

/* 168 */
struct siginfo_t
{
  int si_signo;
  int si_errno;
  int si_code;
  siginfo_t::$B03DB822B349322EA93D3BE0E5948B41 _sifields;
};

/* 169 */
typedef void (*__sighandler_t)(int);

/* 175 */
typedef int __syscall_slong_t;

/* 176 */
struct tq_ent
{
  void *data;
  list_head q_node;
};

/* 177 */
struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};

/* 178 */
typedef timespec cgtimer_t;

/* 179 */
typedef __ssize_t ssize_t;

/* 180 */
struct cg_completion
{
  cgsem_t cgsem;
  void (*fn)(void *);
  void *fnarg;
};

/* 181 */
struct __attribute__((aligned(8))) power_info_t
{
  bool is_voltage_stable;
  double current_voltage;
  double highest_voltage;
  double working_voltage;
  double higher_voltage;
  uint8_t current_iic_data;
};

/* 182 */
enum FREQ_SCAN_ERRNO : __int32
{
  ASIC_NUM_ERR = 0x0,
  HASH_RATE_ERR = 0x1,
  EEPROM_SET_ERR = 0x2,
  FAN_NUM_ERR = 0x3,
  INBALANCE_NUM_ERR = 0x4,
};

/* 183 */
struct SCAN_FREQ_RESULT
{
  unsigned __int8 magic1;
  unsigned __int8 magic2;
  unsigned __int8 start_freq_high;
  unsigned __int8 start_freq_low;
  unsigned __int8 freq_step;
  unsigned __int8 freq_decrease;
  unsigned __int8 column_freq_level[4];
  unsigned __int8 crc16_high;
  unsigned __int8 crc16_low;
  uint32_t freq_eeprom[108];
};

/* 256 */
struct nonce_format_t::$9B741C527EBF5F8211572955528A4715
{
  unsigned __int32 data : 14;
  unsigned __int32 chip_address : 8;
  unsigned __int32 big_core_id : 9;
  unsigned __int32 internal_core_id : 1;
};

/* 184 */
union nonce_format_t
{
  nonce_format_t::$9B741C527EBF5F8211572955528A4715 u;
  uint32_t v;
};

/* 185 */
struct reinit_info_t
{
  uint8_t chain;
  uint8_t volt;
  float freq;
};

/* 186 */
struct init_config
{
  uint8_t token_type;
  uint8_t version;
  uint16_t length;
  __int8 reset : 1;
  __int8 fan_eft : 1;
  __int8 timeout_eft : 1;
  __int8 frequency_eft : 1;
  __int8 voltage_eft : 1;
  __int8 chain_check_time_eft : 1;
  __int8 chip_config_eft : 1;
  __int8 hw_error_eft : 1;
  __int8 beeper_ctrl : 1;
  __int8 temp_ctrl : 1;
  __int8 chain_freq_eft : 1;
  __int8 reserved1 : 5;
  uint8_t reserved2[2];
  uint8_t chain_num;
  uint8_t asic_num;
  uint8_t fan_pwm_percent;
  uint8_t temperature;
  uint16_t frequency;
  uint16_t voltage;
  uint8_t chain_check_time_integer;
  uint8_t chain_check_time_fractions;
  uint8_t timeout_data_integer;
  uint8_t timeout_data_fractions;
  uint32_t reg_data;
  uint8_t chip_address;
  uint8_t reg_address;
  uint16_t chain_min_freq;
  uint16_t chain_max_freq;
  uint16_t crc;
};

/* 187 */
struct part_of_job
{
  uint8_t token_type;
  uint8_t version;
  uint16_t reserved;
  uint32_t length;
  uint8_t pool_nu;
  __int8 new_block : 1;
  __int8 asic_diff_valid : 1;
  __int8 reserved1 : 6;
  uint8_t asic_diff;
  uint8_t reserved2[1];
  uint32_t job_id;
  uint32_t bbversion;
  uint8_t prev_hash[32];
  uint32_t ntime;
  uint32_t nbit;
  uint16_t coinbase_len;
  uint16_t nonce2_offset;
  uint16_t nonce2_bytes_num;
  uint16_t merkles_num;
  uint64_t nonce2_start_value;
  bool support_ab;
  int version_num;
};

/* 188 */
struct __attribute__((aligned(4))) bitmain_soc_info
{
  cglock_t update_lock;
  uint8_t data_type;
  uint8_t version;
  uint16_t length;
  __int8 chip_value_eft : 1;
  __int8 reserved1 : 7;
  uint8_t chain_num;
  uint16_t reserved2;
  uint8_t fan_num;
  uint8_t temp_num;
  uint8_t reserved3[2];
  uint32_t fan_exist;
  uint32_t temp_exist;
  uint16_t diff;
  uint16_t reserved4;
  uint32_t reg_value;
  uint32_t chain_asic_exist[16][4];
  uint32_t chain_asic_status[16][4];
  uint8_t chain_asic_num[16];
  uint8_t temp[16];
  uint8_t fan_speed_value[8];
  uint16_t freq[16];
  thr_info *thr;
  pthread_t read_nonce_thr;
  pthread_mutex_t lock;
  init_config soc_config;
  int pool_no;
  pool pool0;
  pool pool1;
  pool pool2;
  uint32_t pool0_given_id;
  uint32_t pool1_given_id;
  uint32_t pool2_given_id;
  uint16_t crc;
};

/* 189 */
struct LOG_FILE_BACKUP
{
  bool use_syslog;
  bool logfile_enable;
  char logfile_path[256];
  char logfile_openflag[32];
};

/* 190 */
struct low_temp_process_parms_t
{
  int low_temp;
  int middle_temp;
  int high_temp;
  float delta_vol;
};

/* 191 */
struct high_pll_out
{
  uint32_t freq;
  uint8_t divider;
  uint32_t pll_out;
};

/* 192 */
struct freq_pll
{
  int freq;
  unsigned int fildiv1;
  unsigned int fildiv2;
  unsigned int vilpll;
};

/* 193 */
struct SCAN_FREQ_WORK
{
  int id;
  uint32_t nonce;
  unsigned __int8 data[12];
  unsigned __int8 midstate[32];
  unsigned int is_nonce_return_back[16];
};

/* 194 */
typedef _clock_delay_ctrl_t clock_delay_ctrl_t;

/* 253 */
struct _clock_delay_ctrl_t::$BEBC5E3EFF6E7ED47925F28BF716C4D3
{
  __int8 _SWPF_MODE : 1;
  __int8 _RSVD : 1;
  __int8 _MMEN : 1;
  __int8 _HASH_CLKEN : 1;
  __int8 _PWTH_SEL : 2;
  __int8 _CCDLY_SEL : 2;
};

/* 252 */
union _clock_delay_ctrl_t
{
  _clock_delay_ctrl_t::$BEBC5E3EFF6E7ED47925F28BF716C4D3 u;
  uint8_t v;
};

/* 195 */
struct __attribute__((packed)) __attribute__((aligned(4))) nonce_content
{
  uint32_t job_id;
  uint32_t work_id;
  uint32_t header_version;
  uint64_t nonce2;
  uint32_t nonce3;
  uint32_t chain_num;
  uint8_t midstate[32];
};

/* 196 */
struct nonce_buf
{
  unsigned int p_wr;
  unsigned int p_rd;
  unsigned int nonce_num;
  nonce_content nonce_buffer[511];
};

/* 203 */
enum TEMP_SENSOR_TYPE : __int32
{
  TMP451 = 0x1,
  TMP461 = 0x2,
  TMP421 = 0x3,
  TMP431 = 0x4,
  ECT218 = 0x5,
  TMP441B = 0x6,
  TMP411C = 0x7,
};

/* 197 */
struct temp_info_t
{
  TEMP_SENSOR_TYPE type;
  uint32_t num;
  char pos[8];
  char offset[8];
};

/* 198 */
enum STATUS_CODE : __int32
{
  STATUS_INIT = 0x0,
  STATUS_OK = 0x1,
  ERROR_NETCONN_LOST = 0x2,
  ERROR_OVER_MAXTEMP = 0x3,
  ERROR_FAN_LOST = 0x4,
  ERROR_UNKOWN_STATUS = 0x5,
};

/* 199 */
typedef target_temp_args target_temp_args_t;

/* 200 */
struct target_temp_args
{
  int target_airin_pcb_temp;
  int target_airout_pcb_temp;
};

/* 201 */
typedef fan_speed_temp_args fan_speed_temp_args_t;

/* 202 */
struct fan_speed_temp_args
{
  int temp;
  int fan_speed;
};

/* 204 */
struct send_work_parameter
{
  int chain;
  int done;
};

/* 205 */
typedef _freq_tuning_info freq_tuning_info;

/* 210 */
struct __attribute__((aligned(4))) _freq_tuning_info
{
  int asic_num_per_chain;
  int asic_num_per_vol_domain;
  int freq_table[16][128];
  int chip_rate_table[16][8][128];
  int vol_value_table[16];
  int scan_freq[16];
  int scan_level_table[8];
  int asic_quality_per_vol_domain[16][128];
  bool test_done[16];
  bool fake_done[16];
  int ideal_hash_rate[16];
  bool is_pass;
  bool is_unbalance_happened;
};

/* 206 */
struct freq_tuning_project_conf
{
  int proj_type;
  int proj_sub_type;
  int asic_num;
  int base_voltage;
  int base_freq;
  int freq_step;
  int max_voltage;
  int target_hash_rate;
  int max_hash_rate;
  int fan_pwm;
  int serial_level_count;
};

/* 207 */
struct freq_tuning_work
{
  int id;
  uint32_t nonce;
  unsigned __int8 data[12];
  unsigned __int8 midstate[32];
};

/* 209 */
struct sbitem
{
  char *buf;
  size_t siz;
  size_t tot;
};

/* 221 */
struct _analog_mux_control_t::$FE7205A26BC8406C3E93AF7F14EC1871
{
  __int32 _DIODE_VDD_MUX_SEL : 3;
  __int32 _RSVD1 : 29;
};

/* 220 */
union _analog_mux_control_t
{
  _analog_mux_control_t::$FE7205A26BC8406C3E93AF7F14EC1871 u;
  uint32_t v;
};

/* 223 */
struct _UART_relay_t::$1289DD682C038CFB242F491748D07A73
{
  __int32 _CO_RELAY_EN : 1;
  __int32 _RO_RELAY_EN : 1;
  __int32 _Reserved : 14;
  __int32 _GAP_CNT : 16;
};

/* 222 */
union _UART_relay_t
{
  _UART_relay_t::$1289DD682C038CFB242F491748D07A73 u;
  uint32_t v;
};

/* 225 */
struct _fast_UART_configuration_t::$4E236626D64A25021C3BBACC037A42C5
{
  __int32 _CLKO_DIV : 8;
  __int32 _Reserved_0 : 4;
  __int32 _CLKO_ODDSET : 2;
  __int32 _CLKO_SEL : 1;
  __int32 _ForceCoreEn : 1;
  __int32 _USRC_DIV : 6;
  __int32 _USRC_ODDSET : 2;
  __int32 _PLL3_DIV4 : 4;
  __int32 _Reserved_1 : 2;
  __int32 _DIV4_ODDSET : 2;
};

/* 224 */
union _fast_UART_configuration_t
{
  _fast_UART_configuration_t::$4E236626D64A25021C3BBACC037A42C5 u;
  uint32_t v;
};

/* 227 */
struct _general_i2c_command_t::$BC0836598D03B679E119B877264D3096
{
  __int32 _DATA : 8;
  __int32 _RegAddr : 8;
  __int32 _RW_Ctrl : 1;
  __int32 _DeviceAddr : 7;
  __int32 _RegAddrValid : 1;
  __int32 _AutoReadTemp : 1;
  __int32 _AutoRetTemp : 1;
  __int32 _Reserved : 3;
  __int32 _RW_Fail : 1;
  __int32 _Busy : 1;
};

/* 226 */
union _general_i2c_command_t
{
  _general_i2c_command_t::$BC0836598D03B679E119B877264D3096 u;
  uint32_t v;
};

/* 229 */
struct _pll_parameter_t::$C62A7412FED9A443AA2608AEFC10504A
{
  __int32 _POSTDIV2 : 3;
  __int32 _RSVD1 : 1;
  __int32 _POSTDIV1 : 3;
  __int32 _RSVD2 : 1;
  __int32 _REFDIV : 6;
  __int32 _RSVD3 : 2;
  __int32 _FBDIV : 12;
  __int32 _RSVD4 : 2;
  __int32 _PLLEN : 1;
  __int32 _LOCKED : 1;
};

/* 228 */
union _pll_parameter_t
{
  _pll_parameter_t::$C62A7412FED9A443AA2608AEFC10504A u;
  uint32_t v;
};

/* 234 */
struct _frequency_sweep_control_t::$53C77B236ACB94107D486BB9EF0005E6
{
  __int32 _SWP_EN : 1;
  __int32 _SWP_TRIG : 1;
  __int32 _SWP_ONGOING : 1;
  __int32 _SWP_DONE_ALL : 1;
  __int32 _SWP_PAD_ADDR : 3;
  __int32 _SWP_ONE_PAT_DONE : 1;
  __int32 _CURR_PAT_ADDR : 3;
  __int32 _SWEEP_RESET : 1;
  __int32 _SWEEP_FAIL_LOCK_EN : 1;
  __int32 _ALL_CORE_CLK_SEL_CHANGE_ST : 1;
  __int32 _RSVD1 : 2;
  __int32 _SWEEP_ST_ADDR : 5;
  __int32 _RSVD2 : 3;
  __int32 _SWEEP_STATE : 3;
  __int32 _RSVD3 : 5;
};

/* 233 */
union _frequency_sweep_control_t
{
  _frequency_sweep_control_t::$53C77B236ACB94107D486BB9EF0005E6 u;
  uint32_t v;
};

/* 236 */
struct _clock_order_control1_t::$87EB1CBC29E28D35E1CB08768837EC30
{
  __int32 _CLK8_SEL : 4;
  __int32 _CLK9_SEL : 4;
  __int32 _CLK10_SEL : 4;
  __int32 _CLK11_SEL : 4;
  __int32 _CLK12_SEL : 4;
  __int32 _CLK13_SEL : 4;
  __int32 _CLK14_SEL : 4;
  __int32 _CLK15_SEL : 4;
};

/* 235 */
union _clock_order_control1_t
{
  _clock_order_control1_t::$87EB1CBC29E28D35E1CB08768837EC30 u;
  uint32_t v;
};

/* 238 */
struct _clock_order_control0_t::$95BA672906FB3039E330724C27D54C8D
{
  __int32 _CLK0_SEL : 4;
  __int32 _CLK1_SEL : 4;
  __int32 _CLK2_SEL : 4;
  __int32 _CLK3_SEL : 4;
  __int32 _CLK4_SEL : 4;
  __int32 _CLK5_SEL : 4;
  __int32 _CLK6_SEL : 4;
  __int32 _CLK7_SEL : 4;
};

/* 237 */
union _clock_order_control0_t
{
  _clock_order_control0_t::$95BA672906FB3039E330724C27D54C8D u;
  uint32_t v;
};

/* 240 */
struct _pll_divider_t::$ECC0ACD607993E3B5E39A73C6886E864
{
  __int32 _PLL_DIV0 : 4;
  __int32 _RSVD1 : 4;
  __int32 _PLL_DIV1 : 4;
  __int32 _RSVD2 : 4;
  __int32 _PLL_DIV2 : 4;
  __int32 _RSVD3 : 4;
  __int32 _PLL_DIV3 : 4;
  __int32 _RSVD4 : 4;
};

/* 239 */
union _pll_divider_t
{
  _pll_divider_t::$ECC0ACD607993E3B5E39A73C6886E864 u;
  uint32_t v;
};

/* 242 */
struct _io_driver_strength_cfg_t::$54B9F47612C968BE6993853EB4BB8816
{
  __int32 _CO_DS : 4;
  __int32 _BO_DS : 4;
  __int32 _NRSTO_DS : 4;
  __int32 _CLKO_DS : 4;
  __int32 _R0_DS : 4;
  __int32 _D0RS_EN : 1;
  __int32 _D1RS_DISA : 1;
  __int32 _D2RS_DISA : 1;
  __int32 _D3RS_DISA : 1;
  __int32 _RF_DS : 4;
  __int32 _RSVD1 : 4;
};

/* 241 */
union _io_driver_strength_cfg_t
{
  _io_driver_strength_cfg_t::$54B9F47612C968BE6993853EB4BB8816 u;
  uint32_t v;
};

/* 244 */
struct _misc_control_t::$7ECDB15BAF8B953726522553CB051C24
{
  __int32 _HASHRATE_TWS : 2;
  __int32 _RSVD1 : 2;
  __int32 _TFS : 3;
  __int32 _RET_WORK_ERR_FLAG : 1;
  __int32 _BT8D : 5;
  __int32 _INV_CLKO : 1;
  __int32 _RFS : 1;
  __int32 _RET_ERR_NONCE : 1;
  __int32 _RSVD2 : 2;
  __int32 _DSCLK_SEL : 2;
  __int32 _RVS_K0 : 1;
  __int32 _SPAT_NOD : 1;
  __int32 _CORE_SRST : 1;
  __int32 _RSVD3 : 9;
};

/* 243 */
union _misc_control_t
{
  _misc_control_t::$7ECDB15BAF8B953726522553CB051C24 u;
  uint32_t v;
};

/* 246 */
struct _hashrate_t::$B847315B2A15FF737E69BA2608518E6A
{
  __int32 _HASHRATE : 31;
  __int32 _LONG : 1;
};

/* 245 */
union _hashrate_t
{
  _hashrate_t::$B847315B2A15FF737E69BA2608518E6A u;
  uint32_t v;
};

/* 248 */
struct _core_error_t::$71373D528D1F372647A91BC9F69932DF
{
  __int8 _CMD_ERR_CNT : 4;
  __int8 _INI_NONCE_ERR : 1;
  __int8 _RSVD : 3;
};

/* 247 */
union _core_error_t
{
  _core_error_t::$71373D528D1F372647A91BC9F69932DF u;
  uint8_t v;
};

/* 249 */
union _process_monitor_data_t
{
  uint16_t _FREQ_CNT;
};

/* 251 */
struct _process_monitor_ctrl_t::$70974B93ABDF13C9A4FD639641805FC2
{
  __int8 _PM_SEL : 2;
  __int8 _PM_START : 1;
  __int8 _RSVD : 5;
};

/* 250 */
union _process_monitor_ctrl_t
{
  _process_monitor_ctrl_t::$70974B93ABDF13C9A4FD639641805FC2 u;
  uint8_t v;
};

/* 255 */
struct _core_response_t::$DBF5E38D9E993EE995FC285CB3283DBF
{
  __int32 core_register_data : 16;
  __int32 core_id : 16;
};

/* 254 */
union _core_response_t
{
  _core_response_t::$DBF5E38D9E993EE995FC285CB3283DBF u;
  uint32_t v;
};

/* 258 */
struct _returned_single_pattern_status_t::$8E754177B90B3D8906A712534CF9C9A4
{
  uint32_t _RSTS;
};

/* 257 */
union _returned_single_pattern_status_t
{
  _returned_single_pattern_status_t::$8E754177B90B3D8906A712534CF9C9A4 u;
  uint32_t v;
};

/* 260 */
struct _nonce_returned_timeout_t::$F268A6F77F24329B3DAAE5C192F08A7B
{
  uint16_t _SWEEP_TIMEOUT;
  uint16_t _RSVD1;
};

/* 259 */
union _nonce_returned_timeout_t
{
  _nonce_returned_timeout_t::$F268A6F77F24329B3DAAE5C192F08A7B u;
  uint32_t v;
};

/* 262 */
struct _returned_group_pattern_status_t::$8E754177B90B3D8906A712534CF9C9A4
{
  uint32_t _RSTS;
};

/* 261 */
union _returned_group_pattern_status_t
{
  _returned_group_pattern_status_t::$8E754177B90B3D8906A712534CF9C9A4 u;
  uint32_t v;
};

/* 264 */
struct _golden_nonce_for_sweep_return_t::$3F2A43195829ECD6D30F9201083F25E4
{
  uint32_t _GNOSWR;
};

/* 263 */
union _golden_nonce_for_sweep_return_t
{
  _golden_nonce_for_sweep_return_t::$3F2A43195829ECD6D30F9201083F25E4 u;
  uint32_t v;
};

/* 266 */
struct _ordered_clock_monitor_t::$B9617D56952E365FF6BF894919F456E4
{
  uint16_t _CLK_COUNT;
  __int16 _RSVD1 : 8;
  __int16 _CLK_SEL : 4;
  __int16 _RSVD2 : 3;
  __int16 _START : 1;
};

/* 265 */
union _ordered_clock_monitor_t
{
  _ordered_clock_monitor_t::$B9617D56952E365FF6BF894919F456E4 u;
  uint32_t v;
};

/* 268 */
struct _time_out_t::$1B184345F56409ACBF0149587C96A28B
{
  uint16_t _TMOUT;
  uint16_t _RSVD1;
};

/* 267 */
union _time_out_t
{
  _time_out_t::$1B184345F56409ACBF0149587C96A28B u;
  uint32_t v;
};

/* 270 */
struct _nonce_overflow_counter_t::$0700D3514053C1C8BE00BF616C838EEF
{
  uint32_t _OVF_CNT;
};

/* 269 */
union _nonce_overflow_counter_t
{
  _nonce_overflow_counter_t::$0700D3514053C1C8BE00BF616C838EEF u;
  uint32_t v;
};

/* 272 */
struct _nonce_error_counter_t::$4D4BE8D3FE3737AA05434FE3C2958321
{
  uint32_t _ERR_CNT;
};

/* 271 */
union _nonce_error_counter_t
{
  _nonce_error_counter_t::$4D4BE8D3FE3737AA05434FE3C2958321 u;
  uint32_t v;
};

/* 274 */
struct _error_flag_t::$25349377D3DE550B4DF5A74CF3ACBA06
{
  uint8_t _CMD_ERR_CNT;
  uint8_t _WORK_ERR_CNT;
  uint8_t _RSVD1;
  uint8_t _CORE_RESP_ERR;
};

/* 273 */
union _error_flag_t
{
  _error_flag_t::$25349377D3DE550B4DF5A74CF3ACBA06 u;
  uint32_t v;
};

/* 276 */
struct _external_temperature_sensor_read_t::$CAC779C4A305C8ED58071D4E541E3A44
{
  uint8_t _EXTERNAL_TEMP_DATA;
  uint8_t _EXTERNAL_TEMP_ADDR;
  uint8_t _LOCAL_TEMP_DATA;
  uint8_t _LOCAL_TEMP_ADDR;
};

/* 275 */
union _external_temperature_sensor_read_t
{
  _external_temperature_sensor_read_t::$CAC779C4A305C8ED58071D4E541E3A44 u;
  uint32_t v;
};

/* 278 */
struct _ticket_mask2_t::$AC556C1FF82DCB351E4A94E315DD0547
{
  uint32_t _TM;
};

/* 277 */
union _ticket_mask2_t
{
  _ticket_mask2_t::$AC556C1FF82DCB351E4A94E315DD0547 u;
  uint32_t v;
};

/* 280 */
struct _ordered_clock_enable_t::$3D453E70EABCED9F81187C0BF91FE6BE
{
  uint16_t _CLKEN;
  uint16_t _RSVD1;
};

/* 279 */
union _ordered_clock_enable_t
{
  _ordered_clock_enable_t::$3D453E70EABCED9F81187C0BF91FE6BE u;
  uint32_t v;
};

/* 282 */
struct _ticket_mask_t::$2670B6AA0243F6DA72D99A2BB1D5C4B1
{
  uint8_t _TM0;
  uint8_t _TM1;
  uint8_t _TM2;
  uint8_t _TM3;
};

/* 281 */
union _ticket_mask_t
{
  _ticket_mask_t::$2670B6AA0243F6DA72D99A2BB1D5C4B1 u;
  uint32_t v;
};

/* 284 */
struct _hash_counting_nubmer_t::$ACE29B9BAE85E6096B1EC680D0412215
{
  uint32_t _HCN;
};

/* 283 */
union _hash_counting_nubmer_t
{
  _hash_counting_nubmer_t::$ACE29B9BAE85E6096B1EC680D0412215 u;
  uint32_t v;
};

/* 286 */
struct _chip_nonce_offset_t::$E1A7D4B4009AE0EE97993BAF96FEB0DC
{
  uint16_t _CNO;
  __int16 _RSVD1 : 15;
  __int16 _CNOV : 1;
};

/* 285 */
union _chip_nonce_offset_t
{
  _chip_nonce_offset_t::$E1A7D4B4009AE0EE97993BAF96FEB0DC u;
  uint32_t v;
};

/* 288 */
struct _chip_address_t::$B77DEA6A737D486D92E188ED91020878
{
  uint8_t _ADDR;
  uint8_t _CORE_NUM;
  uint16_t _CHIP_ID;
};

/* 287 */
union _chip_address_t
{
  _chip_address_t::$B77DEA6A737D486D92E188ED91020878 u;
  uint32_t v;
};

/* 290 */
struct _sweep_freq_ctrl_t::$B288B8B4E574D764C3E3079BBB0F5226
{
  __int8 _CLK_SEL : 4;
  __int8 _RSVD0 : 3;
  __int8 _SWPF_MODE : 1;
  uint8_t _RSVD1;
};

/* 289 */
union _sweep_freq_ctrl_t
{
  _sweep_freq_ctrl_t::$B288B8B4E574D764C3E3079BBB0F5226 u;
  uint16_t v;
};

/* 292 */
struct _hash_clock_counter_t::$666A9BC7D1AE3D9B226AC6E647CBC76F
{
  uint8_t _CLOCK_CNT;
};

/* 291 */
union _hash_clock_counter_t
{
  _hash_clock_counter_t::$666A9BC7D1AE3D9B226AC6E647CBC76F u;
  uint8_t v;
};

/* 294 */
struct _hash_clock_ctrl_t::$C926B35480FEF84D45A568B6901F6A51
{
  uint8_t _CLOCK_CTRL;
};

/* 293 */
union _hash_clock_ctrl_t
{
  _hash_clock_ctrl_t::$C926B35480FEF84D45A568B6901F6A51 u;
  uint8_t v;
};

/* 296 */
struct _core_enable_t::$27ADC7C198E55E8D3A9FB66D6BF40A6F
{
  uint8_t _CORE_EN_I;
};

/* 295 */
union _core_enable_t
{
  _core_enable_t::$27ADC7C198E55E8D3A9FB66D6BF40A6F u;
  uint8_t v;
};

/* 305 */
struct _IO_FILE_plus;

/* 306 */
struct _IO_marker_0
{
  _IO_marker *_next;
  _IO_FILE *_sbuf;
  int _pos;
};

/* 307 */
enum _LIB_VERSION_TYPE : __int32
{
  _IEEE_ = 0xFFFFFFFF,
  _SVID_ = 0x0,
  _XOPEN_ = 0x1,
  _POSIX_ = 0x2,
  _ISOC_ = 0x3,
};

/* 308 */
struct UT_hash_table_0
{
  UT_hash_bucket *buckets;
  unsigned int num_buckets;
  unsigned int log2_num_buckets;
  unsigned int num_items;
  UT_hash_handle *tail;
  ptrdiff_t hho;
  unsigned int ideal_chain_maxlen;
  unsigned int nonideal_items;
  unsigned int ineff_expands;
  unsigned int noexpand;
  uint32_t signature;
};

/* 309 */
typedef sbitem SBITEM;

/* 310 */
struct ipv6_mreq
{
  in6_addr ipv6mr_multiaddr;
  unsigned int ipv6mr_interface;
};

/* 311 */
struct ip_mreq
{
  in_addr imr_multiaddr;
  in_addr imr_interface;
};

/* 312 */
enum __socket_type : __int32
{
  __socket_type::SOCK_STREAM = 0x1,
  __socket_type::SOCK_DGRAM = 0x2,
  __socket_type::SOCK_RAW = 0x3,
  __socket_type::SOCK_RDM = 0x4,
  __socket_type::SOCK_SEQPACKET = 0x5,
  __socket_type::SOCK_DCCP = 0x6,
  __socket_type::SOCK_PACKET = 0xA,
  __socket_type::SOCK_CLOEXEC = 0x80000,
  __socket_type::SOCK_NONBLOCK = 0x800,
};

/* 314 */
struct __attribute__((aligned(8))) __pthread_unwind_buf_t::$C277420EBC3478189FF06E3E7E99E2B1
{
  __jmp_buf __cancel_jmp_buf;
  int __mask_was_saved;
};

/* 313 */
struct __pthread_unwind_buf_t
{
  __pthread_unwind_buf_t::$C277420EBC3478189FF06E3E7E99E2B1 __cancel_jmp_buf[1];
  void *__pad[4];
};

/* 315 */
typedef _analog_mux_control_t analog_mux_control_t;

/* 316 */
typedef _UART_relay_t UART_relay_t;

/* 317 */
typedef _fast_UART_configuration_t fast_UART_configuration_t;

/* 318 */
typedef _general_i2c_command_t general_i2c_command_t;

/* 319 */
typedef _pll_parameter_t pll_parameter_t;

/* 321 */
struct fpga_bt8d_t::$B280B9F5BE741ED2DFF88F9FC557BEA4
{
  __int32 reserved_0 : 16;
  __int32 bt8d : 6;
  __int32 reserved_1 : 10;
};

/* 320 */
union fpga_bt8d_t
{
  fpga_bt8d_t::$B280B9F5BE741ED2DFF88F9FC557BEA4 u;
  uint32_t v;
};

/* 323 */
struct order_clock_enable_t::$B8AA433223362DDB644247646A45B7FA
{
  uint16_t CLKEN;
  uint16_t Reserved;
};

/* 322 */
union order_clock_enable_t
{
  order_clock_enable_t::$B8AA433223362DDB644247646A45B7FA u;
  uint32_t v;
};

/* 325 */
struct misc_ctrl_t::$307AA0B7C6A22F5D72F400F8649E1B51
{
  __int32 hash_rate_tws : 2;
  __int32 reserved_0 : 2;
  __int32 tfs : 3;
  __int32 ret_work_err_flag : 1;
  __int32 bt8d_4_0 : 5;
  __int32 inv_clko : 1;
  __int32 rfs : 1;
  __int32 ret_err_nonce : 1;
  __int32 bclk_sel : 1;
  __int32 topclk_sel : 1;
  __int32 dsclk_sel : 2;
  __int32 rvs_k0 : 1;
  __int32 spat_nod : 1;
  __int32 core_srst : 1;
  __int32 reserved_1 : 1;
  __int32 bt8d_8_5 : 4;
  __int32 reserved_2 : 4;
};

/* 324 */
union misc_ctrl_t
{
  misc_ctrl_t::$307AA0B7C6A22F5D72F400F8649E1B51 u;
  uint32_t v;
};

/* 326 */
typedef _returned_single_pattern_status_t returned_single_pattern_status_t;

/* 327 */
typedef _nonce_returned_timeout_t nonce_returned_timeout_t;

/* 328 */
typedef _returned_group_pattern_status_t returned_group_pattern_status_t;

/* 329 */
typedef _golden_nonce_for_sweep_return_t golden_nonce_for_sweep_return_t;

/* 330 */
typedef _frequency_sweep_control_t frequency_sweep_control_t;

/* 331 */
typedef _clock_order_control1_t clock_order_control1_t;

/* 332 */
typedef _clock_order_control0_t clock_order_control0_t;

/* 333 */
typedef _pll_divider_t pll_divider_t;

/* 334 */
typedef _ordered_clock_monitor_t ordered_clock_monitor_t;

/* 335 */
typedef _time_out_t time_out_t;

/* 336 */
typedef _io_driver_strength_cfg_t io_driver_strength_cfg_t;

/* 337 */
typedef _nonce_overflow_counter_t nonce_overflow_counter_t;

/* 338 */
typedef _nonce_error_counter_t nonce_error_counter_t;

/* 339 */
typedef _error_flag_t error_flag_t;

/* 340 */
typedef _external_temperature_sensor_read_t external_temperature_sensor_read_t;

/* 341 */
typedef _ticket_mask2_t ticket_mask2_t;

/* 342 */
typedef _ordered_clock_enable_t ordered_clock_enable_t;

/* 343 */
typedef _misc_control_t misc_control_t;

/* 344 */
typedef _ticket_mask_t ticket_mask_t;

/* 345 */
typedef _hash_counting_nubmer_t hash_counting_nubmer_t;

/* 346 */
typedef _chip_nonce_offset_t chip_nonce_offset_t;

/* 347 */
typedef _hashrate_t hashrate_t;

/* 348 */
typedef _chip_address_t chip_address_t;

/* 349 */
typedef _sweep_freq_ctrl_t sweep_freq_ctrl_t;

/* 350 */
typedef _hash_clock_counter_t hash_clock_counter_t;

/* 351 */
typedef _hash_clock_ctrl_t hash_clock_ctrl_t;

/* 352 */
typedef _core_enable_t core_enable_t;

/* 353 */
typedef _core_error_t core_error_t;

/* 354 */
typedef _process_monitor_data_t process_monitor_data_t;

/* 355 */
typedef _process_monitor_ctrl_t process_monitor_ctrl_t;

/* 356 */
typedef _core_response_t core_response_t;

/* 357 */
enum benchwork : __int32
{
  benchwork::BENCHWORK_VERSION = 0x0,
  benchwork::BENCHWORK_MERKLEROOT = 0x1,
  benchwork::BENCHWORK_PREVHASH = 0x2,
  benchwork::BENCHWORK_DIFFBITS = 0x3,
  benchwork::BENCHWORK_NONCETIME = 0x4,
  benchwork::BENCHWORK_COUNT = 0x5,
};

/* 358 */
struct sysinfo
{
  __kernel_long_t uptime;
  __kernel_ulong_t loads[3];
  __kernel_ulong_t totalram;
  __kernel_ulong_t freeram;
  __kernel_ulong_t sharedram;
  __kernel_ulong_t bufferram;
  __kernel_ulong_t totalswap;
  __kernel_ulong_t freeswap;
  __u16 procs;
  __u16 pad;
  __kernel_ulong_t totalhigh;
  __kernel_ulong_t freehigh;
  __u32 mem_unit;
  char _f[8];
};

/* 360 */
union sigaction::$A0D7C018272EA30F374433AF4EA79BEE
{
  __sighandler_t sa_handler;
  void (*sa_sigaction)(int, siginfo_t *, void *);
};

/* 359 */
struct sigaction
{
  sigaction::$A0D7C018272EA30F374433AF4EA79BEE __sigaction_handler;
  __sigset_t sa_mask;
  int sa_flags;
  void (*sa_restorer)(void);
};

/* 361 */
typedef __sighandler_t sighandler_t;

/* 372 */
enum send_ret : __int32
{
  send_ret::SEND_OK = 0x0,
  send_ret::SEND_SELECTFAIL = 0x1,
  send_ret::SEND_SENDFAIL = 0x2,
  send_ret::SEND_INACTIVE = 0x3,
};

/* 373 */
struct lldiv_t
{
  __int64 quot;
  __int64 rem;
};

/* 374 */
struct pattern_info
{
  char file_path[50];
  uint8_t scan_pic_voltage[16];
  int AsicNum;
  int CoreNum;
  int AsicWorkCount;
  int RequiredChainNonce;
  int RequiredAsicNonce;
  int send_work_num[16];
  int ret_nonce_num[16];
  int repeated_nonce_num[16];
  int other_nonce_num[16];
  int HW_nonce_num[16];
  int valid_nonce_num[16];
  int asic_nonce_num[16][128];
  int asic_core_nonce_num[16][128][1024];
  int asic_core_enabled_flag[16][128][1024];
  int scan_record_count[16];
  float PassNonceRate;
  float freq_init;
  float freq_min;
  float freq_step;
  float freq_max;
  float cur_freq[16];
  float next_freq[16];
  float pass_noncerate[16];
  float scan_noncerate_record[16][128];
  bool decline_once[16];
  bool chain_need_reinit[16];
  bool scan_finished[16];
  bool current_is_pass[16];
  bool scan_success[16];
  bool stop_heart_beat[16];
  bool all_chain_scan_success;
  SCAN_FREQ_WORK send_work[128];
  SCAN_FREQ_WORK *works[48];
  pthread_t heart_beat_id[16];
};

/* 375 */
struct SCAN_FREQ_INFO;

/* 376 */
struct vil_work_1387
{
  uint8_t work_type;
  uint8_t chain_id;
  uint8_t reserved1[2];
  uint32_t work_count;
  uint8_t data[12];
  uint8_t midstate[32];
};

/* 377 */
struct CALC_NONCE_INFO
{
  int chain_nonce_number[16];
  int chain_asic_nonce_num[16][48];
  int chain_asic_core_nonce_num[16][48][672];
  int reserve;
};

/* 378 */
struct work_0
{
  unsigned __int8 data[128];
  unsigned __int8 midstate[32];
  unsigned __int8 target[32];
  unsigned __int8 hash[32];
  double device_diff;
  uint64_t share_diff;
  int rolls;
  int drv_rolllimit;
  uint32_t nonce;
  thr_info *thr;
  int thr_id;
  pool *pool;
  timeval tv_staged;
  bool mined;
  bool clone;
  bool cloned;
  int rolltime;
  bool longpoll;
  bool stale;
  bool mandatory;
  bool block;
  bool stratum;
  char *job_id;
  uint64_t nonce2;
  size_t nonce2_len;
  char *ntime;
  double sdiff;
  char *nonce1;
  bool gbt;
  char *coinbase;
  int gbt_txns;
  unsigned int work_block;
  uint32_t id;
  UT_hash_handle hh;
  double work_difficulty;
  int subid;
  bool devflag;
  timeval tv_stamp;
  timeval tv_getwork;
  timeval tv_getwork_reply;
  timeval tv_cloned;
  timeval tv_work_start;
  timeval tv_work_found;
  char getwork_mode;
  int version;
};

/* 379 */
struct freq_tuning_project
{
  int proj_type;
  int sub_proj_count;
  freq_tuning_project_conf *conf_list;
  const char *test_pattern;
};

/* 381 */
struct freq_tuning_return_nonce::$F45E4B70E168E3D315A85266B20194D3::$5788C3B2C133C5E6FC73A6F075E756D4
{
  unsigned __int32 chain_number : 4;
  unsigned __int32 rsvd0 : 1;
  unsigned __int32 err_flag : 1;
  unsigned __int32 nonce_crc_indicator : 1;
  unsigned __int32 nonce_indicator : 1;
  unsigned __int32 nonce_difficulty : 7;
  unsigned __int32 rsvd1 : 1;
  unsigned __int32 work_id : 15;
  unsigned __int32 nonce_or_register_data : 1;
};

/* 382 */
union freq_tuning_return_nonce::$F45E4B70E168E3D315A85266B20194D3
{
  freq_tuning_return_nonce::$F45E4B70E168E3D315A85266B20194D3::$5788C3B2C133C5E6FC73A6F075E756D4 u;
  uint32_t v;
};

/* 380 */
struct freq_tuning_return_nonce
{
  freq_tuning_return_nonce::$F45E4B70E168E3D315A85266B20194D3 buf0;
  uint32_t nonce;
};

/* 383 */
union $C3A5E62BD3479D440C63A6482DBEA85A
{
  const void *ptr;
  size_t i;
};

/* 384 */
struct $8BF8CEFDD07FC02C86A88CD42330C887
{
  const char *name;
  proxytypes_t proxytype;
};

/* 385 */
union __attribute__((aligned(8))) __n64
{
  unsigned __int64 n64_u64[1];
  unsigned __int32 n64_u32[2];
  unsigned __int16 n64_u16[4];
  unsigned __int8 n64_u8[8];
  __int64 n64_i64[1];
  __int32 n64_i32[2];
  __int16 n64_i16[4];
  __int8 n64_i8[8];
  float n64_f32[2];
  double n64_f64[1];
};

/* 386 */
union __attribute__((aligned(8))) __n128
{
  unsigned __int64 n128_u64[2];
  unsigned __int32 n128_u32[4];
  unsigned __int16 n128_u16[8];
  unsigned __int8 n128_u8[16];
  __int64 n128_i64[2];
  __int32 n128_i32[4];
  __int16 n128_i16[8];
  __int8 n128_i8[16];
  float n128_f32[4];
  double n128_f64[2];
};

/* 387 */
typedef __n64 int8x8_t;

/* 388 */
typedef __n64 uint8x8_t;

/* 389 */
typedef __n64 int16x4_t;

/* 390 */
typedef __n64 int32x2_t;

/* 391 */
typedef __n64 uint16x4_t;

/* 392 */
typedef __n64 uint32x2_t;

/* 393 */
typedef __n128 int8x16_t;

/* 394 */
typedef __n128 int16x8_t;

/* 395 */
typedef __n128 int32x4_t;

/* 396 */
typedef __n128 int64x2_t;

/* 397 */
typedef __n128 uint8x16_t;

/* 398 */
typedef __n128 uint16x8_t;

/* 399 */
typedef __n128 uint32x4_t;

/* 400 */
typedef __n128 uint64x2_t;

/* 401 */
typedef __n64 poly8x8_t;

/* 402 */
typedef __n64 poly16x4_t;

/* 403 */
typedef __n128 poly16x8_t;

/* 404 */
typedef __n128 poly8x16_t;

/* 405 */
typedef __n64 float16x4_t;

/* 406 */
typedef __n64 float32x2_t;

/* 407 */
typedef __n128 float16x8_t;

/* 408 */
typedef __n128 float32x4_t;

/* 409 */
typedef __n128 float64x2_t;

/* 410 */
typedef __n128 poly128_t;

/* 411 */
typedef int16x4_t int16x2_t;

/* 412 */
typedef uint16x4_t uint16x2_t;

/* 413 */
typedef float16x4_t float16x2_t;


/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'single_board_test'
*/

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long

struct _eeprom_data_format;
struct _IO_marker;
struct hashtable_bucket;
struct clib_rb;
struct clib_rb_node;
struct clib_object;
struct te1_settings;
struct sync_serial_settings;
struct fr_proto_pvc_info;
struct fr_proto_pvc;
struct fr_proto;
struct cisco_proto;
struct raw_hdlc_proto;
struct XXH64_state_s;
struct XXH32_state_s;
struct mes_system_configs;
struct mes_system_hw_info;
struct mes_system_pattern;
struct mes_system_asic_reg;
struct mes_system_test_method;
struct mes_system_test_config;
struct mes_system_data;
struct mes_system_test_loop;
struct history_result;
struct LZ4_writeFile_s;
struct LZ4_readFile_s;
union LZ4_streamHC_u;
union LZ4_stream_u;
struct _sweep_ctx;
struct _ptx_err_msg_;
struct hashtable_pair;
union _set_address_t;
union _chain_inactive_t;
union _get_status_t;
union _set_config_t;
union _return_nonce_128bit_t;
union LZ4_streamDecode_u;
struct LZ4F_CDict_s;
struct LZ4F_dctx_s;
struct _pattern_work;
struct _pattern_runtime_ctx;
struct mes_system_config_file_info;
struct LZ4F_cctx_s;
struct _config_ctx;
struct local_config_info;

/* 1 */
struct Elf32_Sym
{
  unsigned __int32 st_name __offset(OFF32,0x13490);
  unsigned __int32 st_value __off;
  unsigned __int32 st_size;
  unsigned __int8 st_info;
  unsigned __int8 st_other;
  unsigned __int16 st_shndx;
};

/* 2 */
struct Elf32_Rel
{
  unsigned __int32 r_offset;
  unsigned __int32 r_info;
};

/* 3 */
union Elf32_Dyn::$A263394DDF3EC2D4B1B8448EDD30E249
{
  unsigned __int32 d_val;
  unsigned __int32 d_ptr;
};

/* 4 */
struct Elf32_Dyn
{
  __int32 d_tag;
  union Elf32_Dyn::$A263394DDF3EC2D4B1B8448EDD30E249 d_un;
};

/* 5 */
struct Elf32_Verneed
{
  unsigned __int16 vn_version;
  unsigned __int16 vn_cnt;
  unsigned __int32 vn_file __offset(OFF32,0x13490);
  unsigned __int32 vn_aux;
  unsigned __int32 vn_next;
};

/* 6 */
struct Elf32_Vernaux
{
  unsigned __int32 vna_hash;
  unsigned __int16 vna_flags;
  unsigned __int16 vna_other;
  unsigned __int32 vna_name __offset(OFF32,0x13490);
  unsigned __int32 vna_next;
};

/* 52 */
typedef unsigned __int8 uint8_t;

/* 51 */
typedef unsigned __int16 uint16_t;

/* 13 */
typedef unsigned int uint32_t;

/* 336 */
union in6_addr::$B80A5568EDCB3DEA112C17957211D170
{
  uint8_t __u6_addr8[16];
  uint16_t __u6_addr16[8];
  uint32_t __u6_addr32[4];
};

/* 7 */
struct in6_addr
{
  in6_addr::$B80A5568EDCB3DEA112C17957211D170 __in6_u;
};

/* 8 */
typedef uint16_t in_port_t;

/* 53 */
typedef uint32_t in_addr_t;

/* 9 */
struct in_addr
{
  in_addr_t s_addr;
};

/* 10 */
typedef void _IO_lock_t;

/* 11 */
struct __va_list
{
  void *__ap;
};

/* 12 */
typedef unsigned int sizetype;

/* 14 */
typedef unsigned __int64 uint64_t;

/* 245 */
typedef uint32_t LZ4_u32;

/* 244 */
typedef uint16_t LZ4_u16;

/* 210 */
typedef uint8_t LZ4_byte;

/* 126 */
typedef char int8_t;

/* 246 */
typedef int8_t LZ4_i8;

/* 15 */
struct LZ4HC_CCtx_internal
{
  LZ4_u32 hashTable[32768];
  LZ4_u16 chainTable[65536];
  const LZ4_byte *end;
  const LZ4_byte *prefixStart;
  const LZ4_byte *dictStart;
  LZ4_u32 dictLimit;
  LZ4_u32 lowLimit;
  LZ4_u32 nextToUpdate;
  __int16 compressionLevel;
  LZ4_i8 favorDecSpeed;
  LZ4_i8 dirty;
  const LZ4HC_CCtx_internal *dictCtx;
};

/* 16 */
struct LZ4_stream_t_internal
{
  LZ4_u32 hashTable[4096];
  const LZ4_byte *dictionary;
  const LZ4_stream_t_internal *dictCtx;
  LZ4_u32 currentOffset;
  LZ4_u32 tableType;
  LZ4_u32 dictSize;
};

/* 50 */
typedef unsigned int size_t;

/* 217 */
typedef void *(*LZ4F_AllocFunction)(void *, size_t);

/* 216 */
typedef void *(*LZ4F_CallocFunction)(void *, size_t);

/* 215 */
typedef void (*LZ4F_FreeFunction)(void *, void *);

/* 17 */
struct LZ4F_CustomMem
{
  LZ4F_AllocFunction customAlloc;
  LZ4F_CallocFunction customCalloc;
  LZ4F_FreeFunction customFree;
  void *opaqueState;
};

/* 18 */
typedef XXH32_state_s XXH32_state_t;

/* 235 */
struct XXH32_state_s
{
  uint32_t total_len_32;
  uint32_t large_len;
  uint32_t v1;
  uint32_t v2;
  uint32_t v3;
  uint32_t v4;
  uint32_t mem32[4];
  uint32_t memsize;
  uint32_t reserved;
};

/* 19 */
typedef uint64_t U64;

/* 20 */
enum dStage_t : __int32
{
  dstage_getFrameHeader = 0x0,
  dstage_storeFrameHeader = 0x1,
  dstage_init = 0x2,
  dstage_getBlockHeader = 0x3,
  dstage_storeBlockHeader = 0x4,
  dstage_copyDirect = 0x5,
  dstage_getBlockChecksum = 0x6,
  dstage_getCBlock = 0x7,
  dstage_storeCBlock = 0x8,
  dstage_flushOut = 0x9,
  dstage_getSuffix = 0xA,
  dstage_storeSuffix = 0xB,
  dstage_getSFrameSize = 0xC,
  dstage_storeSFrameSize = 0xD,
  dstage_skipSkippable = 0xE,
};

/* 21 */
typedef uint32_t U32;

/* 22 */
enum LZ4F_blockCompression_t : __int32
{
  LZ4B_COMPRESSED = 0x0,
  LZ4B_UNCOMPRESSED = 0x1,
};

/* 23 */
typedef uint16_t U16;

/* 24 */
struct LZ4_streamDecode_t_internal
{
  const LZ4_byte *externalDict;
  const LZ4_byte *prefixEnd;
  size_t extDictSize;
  size_t prefixSize;
};

/* 279 */
typedef _eeprom_data_format *edf_ctx_p;

/* 25 */
typedef int (*edf_u8_set)(edf_ctx_p, uint8_t);

/* 26 */
typedef int (*edf_u8_get)(edf_ctx_p);

/* 34 */
typedef int (*edf_i8_array_get)(edf_ctx_p, char *, size_t *);

/* 33 */
typedef int (*edf_i8_array_set)(edf_ctx_p, char *, size_t *);

/* 28 */
typedef int (*edf_u8_array_get)(edf_ctx_p, uint8_t *, size_t *);

/* 27 */
typedef int (*edf_u8_array_set)(edf_ctx_p, uint8_t *, size_t *);

/* 30 */
typedef int (*edf_u16_get)(edf_ctx_p);

/* 29 */
typedef int (*edf_u16_set)(edf_ctx_p, uint16_t);

/* 32 */
typedef int (*edf_i8_get)(edf_ctx_p);

/* 31 */
typedef int (*edf_i8_set)(edf_ctx_p, int8_t);

/* 35 */
struct _eeprom_data_format
{
  int (*load)(edf_ctx_p, uint8_t *, size_t, int);
  uint32_t (*capability)(edf_ctx_p);
  int (*region_all_encode)(edf_ctx_p, char *, size_t *);
  int (*region_1_encode)(edf_ctx_p, char *, size_t *, size_t *);
  int (*region_2_encode)(edf_ctx_p, char *, size_t *, size_t *);
  int (*region_3_encode)(edf_ctx_p, char *, size_t *, size_t *);
  edf_u8_get version_get;
  edf_u8_get enc_algorithm_get;
  edf_u8_set enc_algorithm_set;
  edf_u8_get enc_key_version_get;
  edf_u8_set enc_key_version_set;
  edf_i8_array_get board_sn_get;
  edf_i8_array_set board_sn_set;
  edf_i8_array_get chip_die_get;
  edf_i8_array_set chip_die_set;
  edf_i8_array_get chip_marking_get;
  edf_i8_array_set chip_marking_set;
  edf_i8_array_get ft_version_get;
  edf_i8_array_set ft_version_set;
  edf_i8_array_get chip_tech_get;
  edf_i8_array_set chip_tech_set;
  edf_u8_get chip_bin_get;
  edf_u8_set chip_bin_set;
  edf_u8_get asic_sensor_type_get;
  edf_u8_set asic_sensor_type_set;
  edf_u8_array_get asic_sensor_addr_get;
  edf_u8_array_set asic_sensor_addr_set;
  edf_u8_get pic_sensor_type_get;
  edf_u8_set pic_sensor_type_set;
  edf_u8_get pic_sensor_addr_get;
  edf_u8_set pic_sensor_addr_set;
  edf_u16_get pcb_version_get;
  edf_u16_set pcb_version_set;
  edf_u16_get bom_version_get;
  edf_u16_set bom_version_set;
  edf_u8_get pt1_result_get;
  edf_u8_set pt1_result_set;
  edf_u8_get pt1_count_get;
  edf_u8_set pt1_count_set;
  edf_u8_get pt2_result_get;
  edf_u8_set pt2_result_set;
  edf_u8_get pt2_count_get;
  edf_u8_set pt2_count_set;
  edf_i8_array_get board_name_get;
  edf_i8_array_set board_name_set;
  edf_i8_array_get factory_job_get;
  edf_i8_array_set factory_job_set;
  edf_u16_get voltage_get;
  edf_u16_set voltage_set;
  edf_u16_get frequency_get;
  edf_u16_set frequency_set;
  edf_u16_get nonce_rate_get;
  edf_u16_set nonce_rate_set;
  edf_i8_get pcb_temp_in_get;
  edf_i8_set pcb_temp_in_set;
  edf_i8_get pcb_temp_out_get;
  edf_i8_set pcb_temp_out_set;
  edf_u8_get test_version_get;
  edf_u8_set test_version_set;
  edf_u8_get test_standard_get;
  edf_u8_set test_standard_set;
  edf_u16_get sweep_hashrate_get;
  edf_u16_set sweep_hashrate_set;
  edf_u16_get sweep_freq_base_get;
  edf_u16_set sweep_freq_base_set;
  edf_u8_get sweep_freq_step_get;
  edf_u8_set sweep_freq_step_set;
  edf_u8_array_get sweep_level_get;
  edf_u8_array_set sweep_level_set;
  edf_u8_get sweep_result_get;
  edf_u8_set sweep_result_set;
  void (*dump_data)(edf_ctx_p);
  void (*destroy)(edf_ctx_p);
  void *priv;
};

/* 49 */
typedef unsigned __int64 __u_quad_t;

/* 41 */
typedef __u_quad_t __dev_t;

/* 46 */
typedef unsigned int __ino_t;

/* 45 */
typedef unsigned int __mode_t;

/* 44 */
typedef unsigned int __nlink_t;

/* 43 */
typedef unsigned int __uid_t;

/* 42 */
typedef unsigned int __gid_t;

/* 40 */
typedef int __off_t;

/* 39 */
typedef int __blksize_t;

/* 38 */
typedef int __blkcnt_t;

/* 48 */
typedef int __time_t;

/* 47 */
typedef int __syscall_slong_t;

/* 37 */
struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};

/* 36 */
struct stat
{
  __dev_t st_dev;
  unsigned __int16 __pad1;
  __ino_t st_ino;
  __mode_t st_mode;
  __nlink_t st_nlink;
  __uid_t st_uid;
  __gid_t st_gid;
  __dev_t st_rdev;
  unsigned __int16 __pad2;
  __off_t st_size;
  __blksize_t st_blksize;
  __blkcnt_t st_blocks;
  timespec st_atim;
  timespec st_mtim;
  timespec st_ctim;
  unsigned int __glibc_reserved4;
  unsigned int __glibc_reserved5;
};

/* 54 */
struct sockaddr_x25;

/* 55 */
struct sockaddr_un;

/* 56 */
struct sockaddr_ns;

/* 57 */
struct sockaddr_iso;

/* 58 */
struct sockaddr_ipx;

/* 59 */
struct sockaddr_inarp;

/* 67 */
typedef unsigned __int16 sa_family_t;

/* 60 */
struct sockaddr_in6
{
  sa_family_t sin6_family;
  in_port_t sin6_port;
  uint32_t sin6_flowinfo;
  in6_addr sin6_addr;
  uint32_t sin6_scope_id;
};

/* 61 */
struct sockaddr_in
{
  sa_family_t sin_family;
  in_port_t sin_port;
  in_addr sin_addr;
  unsigned __int8 sin_zero[8];
};

/* 62 */
struct sockaddr_eon;

/* 63 */
struct sockaddr_dl;

/* 64 */
struct sockaddr_ax25;

/* 65 */
struct sockaddr_at;

/* 66 */
struct sockaddr
{
  sa_family_t sa_family;
  char sa_data[14];
};

/* 68 */
struct timezone
{
  int tz_minuteswest;
  int tz_dsttime;
};

/* 69 */
typedef unsigned __int64 UDItype;

/* 70 */
typedef unsigned int USItype;

/* 71 */
typedef double DFtype;

/* 72 */
typedef __va_list __gnuc_va_list;

/* 73 */
enum json_error_code : __int32
{
  json_error_code::json_error_unknown = 0x0,
  json_error_code::json_error_out_of_memory = 0x1,
  json_error_code::json_error_stack_overflow = 0x2,
  json_error_code::json_error_cannot_open_file = 0x3,
  json_error_code::json_error_invalid_argument = 0x4,
  json_error_code::json_error_invalid_utf8 = 0x5,
  json_error_code::json_error_premature_end_of_input = 0x6,
  json_error_code::json_error_end_of_input_expected = 0x7,
  json_error_code::json_error_invalid_syntax = 0x8,
  json_error_code::json_error_invalid_format = 0x9,
  json_error_code::json_error_wrong_type = 0xA,
  json_error_code::json_error_null_character = 0xB,
  json_error_code::json_error_null_value = 0xC,
  json_error_code::json_error_null_byte_in_key = 0xD,
  json_error_code::json_error_duplicate_key = 0xE,
  json_error_code::json_error_numeric_overflow = 0xF,
  json_error_code::json_error_item_not_found = 0x10,
  json_error_code::json_error_index_out_of_range = 0x11,
};

/* 74 */
typedef __gnuc_va_list va_list;

/* 75 */
struct json_error_t
{
  int line;
  int column;
  int position;
  char source[80];
  char text[160];
};

/* 79 */
typedef __int64 __quad_t;

/* 78 */
typedef __quad_t __off64_t;

/* 76 */
struct _IO_FILE
{
  int _flags;
  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;
  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;
  _IO_marker *_markers;
  _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset;
  unsigned __int16 _cur_column;
  char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
  __off64_t _offset;
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;
  int _mode;
  char _unused2[40];
};

/* 77 */
struct _IO_marker
{
  _IO_marker *_next;
  _IO_FILE *_sbuf;
  int _pos;
};

/* 80 */
typedef __int64 json_int_t;

/* 87 */
enum json_type : __int32
{
  JSON_OBJECT = 0x0,
  JSON_ARRAY = 0x1,
  JSON_STRING = 0x2,
  JSON_INTEGER = 0x3,
  JSON_REAL = 0x4,
  JSON_TRUE = 0x5,
  JSON_FALSE = 0x6,
  JSON_NULL = 0x7,
};

/* 90 */
struct json_t
{
  json_type type;
  volatile size_t refcount;
};

/* 81 */
struct json_string_t
{
  json_t json;
  char *value;
  size_t length;
};

/* 89 */
struct hashtable_list
{
  hashtable_list *prev;
  hashtable_list *next;
};

/* 355 */
struct hashtable
{
  size_t size;
  hashtable_bucket *buckets;
  size_t order;
  hashtable_list list;
  hashtable_list ordered_list;
};

/* 86 */
typedef hashtable hashtable_t;

/* 82 */
struct json_object_t
{
  json_t json;
  hashtable_t hashtable;
};

/* 88 */
struct hashtable_bucket
{
  hashtable_list *first;
  hashtable_list *last;
};

/* 83 */
struct json_array_t
{
  json_t json;
  size_t size;
  size_t entries;
  json_t **table;
};

/* 84 */
struct json_real_t
{
  json_t json;
  double value;
};

/* 85 */
struct json_integer_t
{
  json_t json;
  json_int_t value;
};

/* 91 */
typedef int int32_t;

/* 92 */
struct __attribute__((aligned(4))) lconv
{
  char *decimal_point;
  char *thousands_sep;
  char *grouping;
  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;
  char p_cs_precedes;
  char p_sep_by_space;
  char n_cs_precedes;
  char n_sep_by_space;
  char p_sign_posn;
  char n_sign_posn;
  char int_p_cs_precedes;
  char int_p_sep_by_space;
  char int_n_cs_precedes;
  char int_n_sep_by_space;
  char int_p_sign_posn;
  char int_n_sign_posn;
};

/* 93 */
struct strbuffer_t
{
  char *value;
  size_t length;
  size_t size;
};

/* 94 */
typedef void (*json_free_t)(void *);

/* 95 */
typedef void *(*json_malloc_t)(size_t);

/* 96 */
typedef size_t (*json_load_callback_t)(void *, size_t, void *);

/* 97 */
typedef _IO_FILE FILE;

/* 98 */
typedef int (*get_func)(void *);

/* 103 */
struct stream_t
{
  get_func get;
  void *data;
  char buffer[5];
  size_t buffer_pos;
  int state;
  int line;
  int column;
  int last_column;
  size_t position;
};

/* 450 */
struct lex_t::$BD4887B8155239BFEFA5AB9A7B453162::$187604EA7C5609CC783974FAB9764C1D
{
  char *val;
  size_t len;
};

/* 451 */
union lex_t::$BD4887B8155239BFEFA5AB9A7B453162
{
  lex_t::$BD4887B8155239BFEFA5AB9A7B453162::$187604EA7C5609CC783974FAB9764C1D string;
  json_int_t integer;
  double real;
};

/* 99 */
struct lex_t
{
  stream_t stream;
  strbuffer_t saved_text;
  size_t flags;
  size_t depth;
  int token;
  lex_t::$BD4887B8155239BFEFA5AB9A7B453162 value;
};

/* 100 */
struct callback_data_t
{
  char data[1024];
  size_t len;
  size_t pos;
  json_load_callback_t callback;
  void *arg;
};

/* 101 */
struct buffer_data_t
{
  const char *data;
  size_t len;
  size_t pos;
};

/* 102 */
struct string_data_t
{
  const char *data;
  size_t pos;
};

/* 104 */
typedef int __ssize_t;

/* 106 */
typedef int __suseconds_t;

/* 105 */
struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};

/* 107 */
typedef hashtable_pair pair_t;

/* 356 */
struct __attribute__((aligned(4))) hashtable_pair
{
  hashtable_list list;
  hashtable_list ordered_list;
  size_t hash;
  json_t *value;
  char key[1];
};

/* 108 */
typedef hashtable_list list_t;

/* 109 */
typedef hashtable_bucket bucket_t;

/* 110 */
typedef int (*__compar_fn_t)(const void *, const void *);

/* 111 */
typedef int (*json_dump_callback_t)(const char *, size_t, void *);

/* 112 */
struct buffer
{
  const size_t size;
  size_t used;
  char *data;
};

/* 113 */
typedef _chain_inactive_t chain_inactive_t;

/* 360 */
struct _chain_inactive_t::$DF006CCF56AEBE0E5141CAE43FA188A9
{
  unsigned __int8 _CMD : 4;
  unsigned __int8 _ALL : 1;
  unsigned __int8 _TYPE : 3;
  uint8_t _Length;
  uint8_t _RSVD1;
  uint8_t _RSVD2;
  unsigned __int8 _CRC5 : 5;
  unsigned __int8 _RSVD3 : 3;
};

/* 359 */
union _chain_inactive_t
{
  _chain_inactive_t::$DF006CCF56AEBE0E5141CAE43FA188A9 u;
  uint8_t v[5];
};

/* 114 */
typedef _get_status_t get_status_t;

/* 362 */
struct _get_status_t::$5D8EB6D5E061A6FF7E7D1086B04136B9
{
  unsigned __int8 _CMD : 4;
  unsigned __int8 _ALL : 1;
  unsigned __int8 _TYPE : 3;
  uint8_t _Length;
  uint8_t _ADDR;
  uint8_t _REGADDR;
  unsigned __int8 _CRC5 : 5;
  unsigned __int8 _CMD_ID_G : 2;
  unsigned __int8 _RSVD : 1;
};

/* 361 */
union _get_status_t
{
  _get_status_t::$5D8EB6D5E061A6FF7E7D1086B04136B9 u;
  uint8_t v[5];
};

/* 115 */
typedef _set_address_t set_address_t;

/* 358 */
struct _set_address_t::$39C06A240996102D098D1D1C95001593
{
  unsigned __int8 _CMD : 4;
  unsigned __int8 _ALL : 1;
  unsigned __int8 _TYPE : 3;
  uint8_t _Length;
  uint8_t _ADDR;
  uint8_t _RSVD1;
  unsigned __int8 _CRC5 : 5;
  unsigned __int8 _RSVD2 : 3;
};

/* 357 */
union _set_address_t
{
  _set_address_t::$39C06A240996102D098D1D1C95001593 u;
  uint8_t v[5];
};

/* 116 */
typedef _set_config_t set_config_t;

/* 364 */
struct _set_config_t::$03F4A4BD6A877CE7E5FD60953F4D8283
{
  unsigned __int8 _CMD : 4;
  unsigned __int8 _ALL : 1;
  unsigned __int8 _TYPE : 3;
  uint8_t _Length;
  uint8_t _ADDR;
  uint8_t _REGADDR;
  uint8_t _REGDATA[4];
  unsigned __int8 _CRC5 : 5;
  unsigned __int8 _RSVD : 3;
};

/* 363 */
union _set_config_t
{
  _set_config_t::$03F4A4BD6A877CE7E5FD60953F4D8283 u;
  uint8_t v[9];
};

/* 117 */
struct asic_register_value_t
{
  uint32_t register_addr;
  uint32_t register_value;
};

/* 118 */
enum cache_level_e : __int32
{
  hashboard_cache_level = 0x0,
  asic_cache_level = 0x1,
  core_cache_level = 0x2,
};

/* 121 */
struct __pthread_internal_slist
{
  __pthread_internal_slist *__next;
};

/* 120 */
typedef __pthread_internal_slist __pthread_slist_t;

/* 445 */
union __pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95
{
  int __spins;
  __pthread_slist_t __list;
};

/* 119 */
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;
  int __kind;
  unsigned int __nusers;
  union
  {
    int __spins;
    __pthread_slist_t __list;
  };
};

/* 122 */
struct pll_userdivider_t
{
  uint8_t userdivider0;
  uint8_t userdivider1;
  uint8_t userdivider2;
  uint8_t userdivider3;
};

/* 123 */
struct pllparameter_t
{
  uint8_t postdiv1;
  uint8_t postdiv2;
  uint8_t refdiv;
  uint16_t fbdiv;
};

/* 124 */
struct clib_map
{
  clib_rb *root;
};

/* 130 */
struct clib_rb_node
{
  clib_rb_node *left;
  clib_rb_node *right;
  clib_rb_node *parent;
  int color;
  clib_object *key;
  clib_object *value;
};

/* 129 */
typedef void (*clib_destroy)(void *);

/* 128 */
typedef int (*clib_compare)(void *, void *);

/* 127 */
struct clib_rb
{
  clib_rb_node *root;
  clib_rb_node sentinel;
  clib_destroy destruct_k_fn;
  clib_destroy destruct_v_fn;
  clib_compare compare_fn;
};

/* 132 */
struct clib_object
{
  void *raw_data;
  size_t size;
};

/* 125 */
struct i2c_value_t
{
  uint32_t master;
  uint32_t slave;
};

/* 131 */
struct clib_iterator
{
  clib_object *(*get_next)(clib_iterator *);
  void (*replace_value)(clib_iterator *, void *, size_t);
  void *(*get_value)(void *);
  void *pContainer;
  int pCurrent;
  void *pCurrentElement;
};

/* 133 */
struct iic_init_param_t
{
  uint32_t chain_id;
  uint16_t master_addr;
  uint8_t slave_high;
  uint8_t slave_low;
};

/* 135 */
struct bitmain_tsensor_t
{
  uint8_t slave_addr;
  uint32_t tsensor_fd;
};

/* 134 */
struct bitmain_chain_tsensor
{
  uint8_t num;
  bitmain_tsensor_t bitmain_tsensor[8];
};

/* 136 */
typedef __int16 int16_t;

/* 137 */
struct power_temp_t
{
  int32_t temp_pfc;
  int32_t temp_llc1;
  int32_t temp_llc2;
};

/* 417 */
union eeprom_data_t::$0A609ABD55EED6399FF851F6AC5DD11F
{
  unsigned __int8 N[20];
  double V[20];
};

/* 138 */
struct __attribute__((aligned(8))) eeprom_data_t
{
  char sn[18];
  int num;
  union
  {
    unsigned __int8 N[20];
    double V[20];
  };
  double vol[20];
  int32_t c_date;
};

/* 139 */
typedef __ssize_t ssize_t;

/* 140 */
typedef unsigned __int64 __uint64_t;

/* 141 */
struct bitmain_pic_t
{
  uint32_t pic_fd;
  uint32_t chain_has_opened;
};

/* 142 */
enum bitmain_hardware_type_e : __int32
{
  S9_HARDWARE = 0x0,
  T9_PLUS_HARDWARE = 0x1,
  UNKNOWN_HARDWARE_TYPE = 0x2,
};

/* 143 */
struct dhash_job_info_t
{
  uint32_t mid_auto_gen;
  uint32_t mid_state_num;
  uint8_t *coinbase;
  uint32_t coinbase_len;
  uint8_t *merkle_bin;
  uint32_t merkles_num;
  uint32_t ntime;
  uint32_t nbit;
  uint32_t job_id;
  uint32_t bbversion;
  uint32_t version_mask;
  uint8_t *prev_hash;
  uint32_t prev_hash_len;
  uint32_t nonce2_offset;
  uint32_t nonce2_bytes_num;
  uint64_t nonce2_start_value;
  uint32_t send_work_timeout;
  uint32_t new_block;
};

/* 144 */
typedef unsigned int __kernel_ulong_t;

/* 145 */
typedef unsigned int __u32;

/* 146 */
typedef unsigned __int16 __u16;

/* 147 */
typedef int __kernel_long_t;

/* 148 */
struct bitmain_eeprom_t
{
  uint32_t eeprom_fd;
  uint32_t chain_has_opened;
};

/* 151 */
enum bitmain_fan_id_e : __int32
{
  FAN1 = 0x0,
  FAN2 = 0x1,
  FAN3 = 0x2,
  FAN4 = 0x3,
  FAN5 = 0x4,
  FAN6 = 0x5,
  FAN_MAX = 0x6,
};

/* 149 */
struct fan_conf_info
{
  bitmain_fan_id_e fan_id;
  uint32_t fan_name;
  uint32_t max_speed;
};

/* 150 */
struct chain_conf_info
{
  uint32_t chain_id;
  uint32_t uart_index;
  uint32_t plug;
  uint32_t reset;
};

/* 154 */
enum ui_type_e : __int32
{
  RED_LED = 0x1,
  GREEN_LED = 0x2,
  BEEP_1 = 0x10,
  RESET_KEY = 0x100,
  IP_REPORT_KEY = 0x101,
  PS2PL_RST_KEY = 0x102,
  UI_RESERVED = 0x103,
};

/* 156 */
enum bitmain_key_status_e : __int32
{
  HAL_KEY_PRESSED = 0x0,
  HAL_KEY_UP = 0x1,
};

/* 152 */
typedef void (*bitmain_key_callback)(ui_type_e, bitmain_key_status_e);

/* 153 */
enum ui_status_e : __int32
{
  UI_ON = 0x0,
  UI_OFF = 0x1,
  UI_FLICKER = 0x2,
};

/* 155 */
struct filker_interval_t
{
  uint32_t interval;
  uint32_t timeout;
  uint32_t next_val;
};

/* 157 */
union pthread_attr_t
{
  char __size[36];
  int __align;
};

/* 158 */
union pthread_mutex_t
{
  __pthread_mutex_s __data;
  char __size[24];
  int __align;
};

/* 159 */
enum bitmain_uart_conf_type_t : __int32
{
  BAUD = 0x0,
  UART_VMIN = 0x1,
  RESERVED = 0x2,
};

/* 160 */
struct __attribute__((aligned(4))) pwm_init_param_t
{
  uint32_t freq;
  unsigned __int8 inited;
};

/* 161 */
enum bitmain_pwm_type_e : __int32
{
  PWM_CTRL_FAN = 0x0,
  PWM_CTRL_POWER = 0x1,
  PWM_CTRL_MAX = 0x2,
};

/* 164 */
typedef void (*bitmain_gpio_callback)(uint32_t, uint8_t);

/* 162 */
struct gpio_callback_t
{
  bitmain_gpio_callback function;
  uint32_t last;
};

/* 163 */
enum bitmain_gpio_direction_e : __int32
{
  DIRECTION_IN = 0x0,
  DIRECTION_OUT = 0x1,
};

/* 165 */
enum bitmain_fpga_e : __int32
{
  HARDWARE_VERSION = 0x0,
  FAN_SPEED = 0x1,
  HASH_ON_PLUG = 0x2,
  WORK_FIFO_STATE = 0x3,
  RETURN_NONCE = 0x4,
  RETURN_NONCE_HI = 0x5,
  NONCE_NUMBER_IN_FIFO = 0x6,
  NONCE_FIFO_INTERRUPT = 0x7,
  TEMPERATURE_0_3 = 0x8,
  TEMPERATURE_4_7 = 0x9,
  TEMPERATURE_8_11 = 0xA,
  TEMPERATURE_12_15 = 0xB,
  IIC_COMMAND = 0xC,
  RESET_HASH_BOARD = 0xD,
  BMC_COUNTER = 0xE,
  FPGA_BT8D = 0xF,
  TW_WRITE_COMMAND = 0x10,
  QN_WRITE_DATA_COMMAND = 0x11,
  RESET_CHAIN = 0x12,
  FAN_CONTROL = 0x13,
  TIME_OUT_CONTROL = 0x14,
  TICKET_MASK_FPGA = 0x15,
  HASH_COUNTING_NUMBER_FPGA = 0x16,
  FAN_CONTROL_1 = 0x17,
  SNO = 0x18,
  SOCKET_ID = 0x19,
  BC_WRITE_COMMAND = 0x1A,
  FRIST_WORD = 0x1B,
  BC_COMMAND_BUFFER = 0x1C,
  BC_COMMAND_BUFFER_1 = 0x1D,
  BC_COMMAND_BUFFER_2 = 0x1E,
  FPGA_CHIP_ID_ADDR = 0x1F,
  FPGA_CHIP_ID_HI = 0x20,
  CRC_ERROR_CNT = 0x21,
  I2C_SW_ID = 0x22,
  DHASH_ACC_CONTROL = 0x23,
  COINBASE_AND_NONCE2_LENGTH = 0x24,
  WORK_NONCE_2 = 0x25,
  WORK_NONCE_2_HI = 0x26,
  NONCE2_AND_JOBID_STORE_ADDRESS = 0x27,
  MERKLE_BIN_NUMBER = 0x28,
  JOB_START_ADDRESS = 0x29,
  JOB_LENGTH = 0x2A,
  JOB_DATA_READY = 0x2B,
  JOB_ID = 0x2C,
  WORK_ENABLE = 0x2D,
  BLOCK_HEADER_VERSION = 0x2E,
  TIME_STAMP = 0x2F,
  TARGET_BITS = 0x30,
  PRE_HEADER_HASH = 0x31,
  PRE_HEADER_HASH1 = 0x32,
  PRE_HEADER_HASH2 = 0x33,
  PRE_HEADER_HASH3 = 0x34,
  PRE_HEADER_HASH4 = 0x35,
  PRE_HEADER_HASH5 = 0x36,
  PRE_HEADER_HASH6 = 0x37,
  PRE_HEADER_HASH7 = 0x38,
  BLOCK_VERSION_0 = 0x39,
  BLOCK_VERSION_1 = 0x3A,
  BLOCK_VERSION_2 = 0x3B,
  BLOCK_VERSION_3 = 0x3C,
  BLOCK_VERSION_4 = 0x3D,
  BLOCK_VERSION_5 = 0x3E,
  BLOCK_VERSION_6 = 0x3F,
  BLOCK_VERSION_7 = 0x40,
  CHAIN0_3_SEND_FIFO_STATUS = 0x41,
  CHAIN4_7_SEND_FIFO_STATUS = 0x42,
  CHAIN8_11_SEND_FIFO_STATUS = 0x43,
  CHAIN12_13_SEND_FIFO_STATUS = 0x44,
  CHAIN0_SEND_READY = 0x45,
  CHAIN0_SEND_BUFFER = 0x46,
  CHAIN1_SEND_READY = 0x47,
  CHAIN1_SEND_BUFFER = 0x48,
  CHAIN2_SEND_READY = 0x49,
  CHAIN2_SEND_BUFFER = 0x4A,
  CHAIN3_SEND_READY = 0x4B,
  CHAIN3_SEND_BUFFER = 0x4C,
  CHAIN4_SEND_READY = 0x4D,
  CHAIN4_SEND_BUFFER = 0x4E,
  CHAIN5_SEND_READY = 0x4F,
  CHAIN5_SEND_BUFFER = 0x50,
  CHAIN6_SEND_READY = 0x51,
  CHAIN6_SEND_BUFFER = 0x52,
  CHAIN7_SEND_READY = 0x53,
  CHAIN7_SEND_BUFFER = 0x54,
  CHAIN8_SEND_READY = 0x55,
  CHAIN8_SEND_BUFFER = 0x56,
  CHAIN9_SEND_READY = 0x57,
  CHAIN9_SEND_BUFFER = 0x58,
  RECEIVE_FIFO_0_1_STATUS = 0x59,
  RECEIVE_FIFO_2_3_STATUS = 0x5A,
  RECEIVE_FIFO_4_5_STATUS = 0x5B,
  RECEIVE_FIFO_6_7_STATUS = 0x5C,
  RECEIVE_FIFO_8_9_STATUS = 0x5D,
  RECEIVE_FIFO_10_11_STATUS = 0x5E,
  RECEIVE_FIFO_12_13_STATUS = 0x5F,
  CHAIN0_READ_ENABLE = 0x60,
  CHAIN0_READ_DATA = 0x61,
  CHAIN1_READ_ENABLE = 0x62,
  CHAIN1_READ_DATA = 0x63,
  CHAIN2_READ_ENABLE = 0x64,
  CHAIN2_READ_DATA = 0x65,
  CHAIN3_READ_ENABLE = 0x66,
  CHAIN3_READ_DATA = 0x67,
  CHAIN4_READ_ENABLE = 0x68,
  CHAIN4_READ_DATA = 0x69,
  CHAIN5_READ_ENABLE = 0x6A,
  CHAIN5_READ_DATA = 0x6B,
  CHAIN6_READ_ENABLE = 0x6C,
  CHAIN6_READ_DATA = 0x6D,
  CHAIN7_READ_ENABLE = 0x6E,
  CHAIN7_READ_DATA = 0x6F,
  CHAIN8_READ_ENABLE = 0x70,
  CHAIN8_READ_DATA = 0x71,
  CHAIN9_READ_ENABLE = 0x72,
  CHAIN9_READ_DATA = 0x73,
  CHAIN10_SEND_READY = 0x74,
  CHAIN10_SEND_BUFFER = 0x75,
  CHAIN11_SEND_READY = 0x76,
  CHAIN11_SEND_BUFFER = 0x77,
  CHAIN12_SEND_READY = 0x78,
  CHAIN12_SEND_BUFFER = 0x79,
  CHAIN13_SEND_READY = 0x7A,
  CHAIN13_SEND_BUFFER = 0x7B,
  CHAIN10_READ_ENABLE = 0x7C,
  CHAIN10_READ_DATA = 0x7D,
  CHAIN11_READ_ENABLE = 0x7E,
  CHAIN11_READ_DATA = 0x7F,
  CHAIN12_READ_ENABLE = 0x80,
  CHAIN12_READ_DATA = 0x81,
  CHAIN13_READ_ENABLE = 0x82,
  CHAIN13_READ_DATA = 0x83,
  SEED_ADDRESS_0 = 0x84,
  SEED_ADDRESS_1 = 0x85,
  SEED_ADDRESS_2 = 0x86,
  SEED_ADDRESS_3 = 0x87,
  SEED_ADDRESS_4 = 0x88,
  SEED_ADDRESS_5 = 0x89,
  SEED_ADDRESS_6 = 0x8A,
  SEED_ADDRESS_7 = 0x8B,
  FULL_NODES_ADDR = 0x8C,
  NUM_MODE_ADDR = 0x8D,
  CACHE_SAVE_ADDR = 0x8E,
  CACHE_START_ADDR = 0x8F,
  DS_START_ADDR = 0x90,
  DS_DONE_ADDR = 0x91,
  DATA_SAVE_ADDR = 0x92,
  UART0_STATUS_ADDR = 0x93,
  UART1_STATUS_ADDR = 0x94,
  UART2_STATUS_ADDR = 0x95,
  UART3_STATUS_ADDR = 0x96,
  UART4_STATUS_ADDR = 0x97,
  UART5_STATUS_ADDR = 0x98,
  UART6_STATUS_ADDR = 0x99,
  UART7_STATUS_ADDR = 0x9A,
  UART8_STATUS_ADDR = 0x9B,
  UART9_STATUS_ADDR = 0x9C,
  UART10_STATUS_ADDR = 0x9D,
  UART11_STATUS_ADDR = 0x9E,
  UART12_STATUS_ADDR = 0x9F,
  UART13_STATUS_ADDR = 0xA0,
  UART14_STATUS_ADDR = 0xA1,
  UART15_STATUS_ADDR = 0xA2,
  UART16_STATUS_ADDR = 0xA3,
  UART17_STATUS_ADDR = 0xA4,
  UART18_STATUS_ADDR = 0xA5,
  UART19_STATUS_ADDR = 0xA6,
  UART20_STATUS_ADDR = 0xA7,
  UART21_STATUS_ADDR = 0xA8,
  UART22_STATUS_ADDR = 0xA9,
  UART23_STATUS_ADDR = 0xAA,
  UART24_STATUS_ADDR = 0xAB,
  UART25_STATUS_ADDR = 0xAC,
  UART26_STATUS_ADDR = 0xAD,
  UART27_STATUS_ADDR = 0xAE,
  UART28_STATUS_ADDR = 0xAF,
  UART29_STATUS_ADDR = 0xB0,
  UART30_STATUS_ADDR = 0xB1,
  UART31_STATUS_ADDR = 0xB2,
  UART_WORK_FLAG_ADDR = 0xB3,
  DATA_SIZE_ADDR = 0xB4,
  DATA_STORE_ADDR = 0xB5,
  UART_CTRL_STATE_ADDR = 0xB6,
  UART_DBG_WR_ADDR = 0xB7,
  UART_DBG_RD_ADDR = 0xB8,
  UART_DBG_STATUS_ADDR = 0xB9,
  BIT_DIV_ADDR = 0xBA,
  MAX_FPGA_INDEX = 0xBB,
};

/* 166 */
enum bitmain_fan_side_e : __int32
{
  FRONT_SIDE = 0x0,
  REAR_SIDE = 0x1,
  BOTH_SIZE = 0x2,
};

/* 167 */
struct bitmain_mac_t
{
  uint8_t mac[6];
};

/* 168 */
struct bitmain_uuid_t
{
  uint8_t uuid[16];
};

/* 171 */
struct bitmain_chain_t
{
  uint32_t chain_id;
};

/* 170 */
struct bitmain_board_t
{
  uint32_t board_id;
  uint32_t chain_num;
  bitmain_chain_t chain[16];
};

/* 169 */
struct bitmain_sys_capability_t
{
  uint32_t board_num;
  bitmain_board_t board[4];
};

/* 420 */
union if_settings::$26F75A7CF7D20622A142A8F9C6BB7EFD
{
  raw_hdlc_proto *raw_hdlc;
  cisco_proto *cisco;
  fr_proto *fr;
  fr_proto_pvc *fr_pvc;
  fr_proto_pvc_info *fr_pvc_info;
  sync_serial_settings *sync;
  te1_settings *te1;
};

/* 172 */
struct if_settings
{
  unsigned int type;
  unsigned int size;
  if_settings::$26F75A7CF7D20622A142A8F9C6BB7EFD ifs_ifsu;
};

/* 180 */
struct raw_hdlc_proto
{
  unsigned __int16 encoding;
  unsigned __int16 parity;
};

/* 179 */
struct cisco_proto
{
  unsigned int interval;
  unsigned int timeout;
};

/* 178 */
struct fr_proto
{
  unsigned int t391;
  unsigned int t392;
  unsigned int n391;
  unsigned int n392;
  unsigned int n393;
  unsigned __int16 lmi;
  unsigned __int16 dce;
};

/* 177 */
struct fr_proto_pvc
{
  unsigned int dlci;
};

/* 176 */
struct fr_proto_pvc_info
{
  unsigned int dlci;
  char master[16];
};

/* 175 */
struct __attribute__((aligned(4))) sync_serial_settings
{
  unsigned int clock_rate;
  unsigned int clock_type;
  unsigned __int16 loopback;
};

/* 174 */
struct te1_settings
{
  unsigned int clock_rate;
  unsigned int clock_type;
  unsigned __int16 loopback;
  unsigned int slot_map;
};

/* 173 */
struct __attribute__((aligned(4))) ifmap
{
  unsigned int mem_start;
  unsigned int mem_end;
  unsigned __int16 base_addr;
  unsigned __int8 irq;
  unsigned __int8 dma;
  unsigned __int8 port;
};

/* 181 */
struct sha2_context
{
  uint32_t total[2];
  uint32_t state[8];
  unsigned __int8 buffer[64];
  unsigned __int8 ipad[64];
  unsigned __int8 opad[64];
};

/* 182 */
typedef history_result History_Result;

/* 343 */
struct __attribute__((aligned(8))) history_result
{
  bool asic_ok;
  bool nonce_rate_ok;
  bool eeprom_ok;
  bool pic_sensor_all_OK;
  bool asic_sensor_all_OK;
  bool ctrlboard_sensor_all_OK;
  bool apw_power_ok;
  bool pic_ok;
  bool seep_ok;
  double nonce_rate;
  uint32_t level;
  uint32_t voltage;
  uint32_t pre_open_core_voltage;
  uint32_t frequence;
  uint32_t valid_nonce_num;
  uint32_t repeat_nonce_number;
  uint8_t asic_core_nonce_num[108][1280];
  uint16_t every_asic_got_nonce_num[108];
  uint16_t every_asic_reg_ntick_nonce_num[108];
  uint16_t every_asic_reg_nonce_error_num[108];
  uint16_t every_asic_reg_got_nonce_num[108];
  bool ok_asic_list[108];
  bool bad_asic_list[108];
  bool pic_sensor_OK[4];
  bool asic_sensor_OK[108];
  bool ctrlboard_sensor_OK[2];
  int8_t sensor_local_temperature_from_pic[4];
  int8_t sensor_local_temperature_from_ctrlboard[2];
  uint8_t test_standard;
};

/* 183 */
typedef local_config_info Local_Config_Info;

/* 422 */
struct pic_sensor
{
  char Pic_Sensor_Model[16];
  uint32_t Pic_Sensor_Addr[4];
};

/* 203 */
typedef pic_sensor Pic_Sensor;

/* 421 */
struct ctrlboard_sensor
{
  char CtrlBoard_Sensor_Model[16];
  uint32_t trlBoard_Sensor_Addr[2];
};

/* 202 */
typedef ctrlboard_sensor CtrlBoard_Sensor;

/* 446 */
struct sensor_info
{
  bool Read_Temperature_From_CtrlBoard;
  bool Read_Temperature_From_Pic;
  bool Read_Temperature_From_Asic;
  Pic_Sensor Pic_Sensor;
  CtrlBoard_Sensor CtrlBoard_Sensor;
};

/* 201 */
typedef sensor_info Sensor_Info;

/* 454 */
struct hash_board_0
{
  char Miner_Type[16];
  char Board_Name[16];
  char Asic_Type[16];
  uint32_t Asic_Num;
  uint32_t Big_Core_Num;
  uint32_t Small_Core_Num;
  uint32_t Small_Core_Num_In_Big_Core;
  uint32_t Voltage_Domain;
  uint32_t Asic_Num_Per_Voltage_Domain;
  Sensor_Info Sensor_Info;
  uint32_t Power_Version[16];
  bool Has_Pic;
  bool Smooth_Voltage;
  uint32_t Inc_Freq_Delay;
  uint32_t Voltage_Adjust_Step;
  uint32_t Wait_Board_Temp;
};

/* 190 */
typedef hash_board_0 Hash_Board;

/* 342 */
struct __attribute__((aligned(4))) test_method
{
  bool Software_Pattern;
  bool Super_Software_Pattern;
  bool Hardware_Pattern;
  bool Autogen_Pattern;
  uint32_t Midstate_Number;
  bool Capture_Pattern;
};

/* 198 */
typedef test_method Test_Method;

/* 197 */
struct Sweep_Cfg
{
  int Force_Reset_Power_Mode;
  bool Data_Reuse_Mode;
  bool Force_PT2_Before_Sweep;
  int Freq_Float_Percent;
  bool Force_Local_Cfg_Level;
  bool Force_Reset_Freq_Range;
  int Sweep_Min_Freq;
  int Sweep_Max_Freq;
};

/* 341 */
struct test_loop
{
  uint32_t Level;
  uint32_t Pre_Open_Core_Voltage;
  uint32_t Voltage;
  uint32_t Frequence;
};

/* 200 */
typedef test_loop Test_Loop;

/* 441 */
struct test_standard_0
{
  uint32_t Pattern_Number;
  uint32_t Invalid_Core_Number;
  uint32_t Least_Nonce_Per_Core;
  uint32_t Nonce_Rate;
  uint32_t Most_HW_Num;
  uint32_t Asic_Nonce_Rate;
  Test_Loop Test_Loop[50];
};

/* 196 */
typedef test_standard_0 Test_Standard;

/* 271 */
struct test_speed
{
  uint32_t Baudrate;
  uint32_t Timeout;
};

/* 195 */
typedef test_speed Test_Speed;

/* 340 */
struct asic_register
{
  uint32_t CCdly_Sel;
  uint32_t Pwth_Sel;
  uint32_t Swpf_Mode;
  uint32_t Pulse_Mode;
  uint32_t Clk_Sel;
  uint32_t RO_Relay_En;
  uint32_t CO_Relay_En;
  uint32_t Diode_Vdd_Mux_Sel;
};

/* 194 */
typedef asic_register Asic_Register;

/* 339 */
struct temperature
{
  int32_t Start_Temp_Gap_Pic;
  uint32_t Max_Wait_Cooling_Down_Time;
  uint32_t Time_For_Cooling_Hashboard;
  int32_t Max_Board_Temp;
};

/* 193 */
typedef temperature Temperature;

/* 338 */
struct fan
{
  uint32_t Fan_Speed;
  uint32_t Work_Fan_Speed;
  uint32_t Fan_Limit;
};

/* 192 */
typedef fan Fan;

/* 199 */
struct display
{
  bool Display_result_Voltage_Domain;
  bool Display_result_Every_Core;
};

/* 191 */
typedef display Display;

/* 452 */
struct test_info
{
  bool Factory_Mode;
  bool Bypass_Scan_Code_Gun;
  int Max_PT1_Board_Poweron_Time;
  Test_Method Test_Method;
  Sweep_Cfg Sweep_Cfg;
  Test_Standard Test_Standard;
  Test_Speed Test_Speed;
  Asic_Register Asic_Register;
  Temperature Temperature;
  Fan Fan;
  Display Display;
  bool Find_Stupid_Asic;
  int Freq_Flex;
  char Test_Config_Data_Version[16];
  uint32_t Voltage_Accuracy;
};

/* 189 */
typedef test_info Test_Info;

/* 337 */
struct __attribute__((aligned(4))) repair_mode
{
  uint32_t Close_Power_Delay;
  bool Clear_EEPROM_Data;
  bool Enable_Repair;
};

/* 188 */
typedef repair_mode Repair_Mode;

/* 456 */
struct local_config_info
{
  char Test_Process[16];
  Hash_Board Hash_Board;
  Test_Info Test_Info;
  Repair_Mode Repair_Mode;
};

/* 184 */
struct work_format
{
  uint8_t work_type;
  uint8_t chain_id;
  uint8_t reserved1[2];
  uint32_t work_count;
  uint8_t data[12];
  uint8_t midstate[16][32];
};

/* 185 */
typedef _return_nonce_128bit_t return_nonce_128bit_t;

/* 424 */
struct _return_nonce_128bit_t::$1695F939FDD9828F2683DFD527BF56E2
{
  unsigned __int32 chain_number : 4;
  unsigned __int32 reserved_0 : 1;
  unsigned __int32 err_flag : 1;
  unsigned __int32 nonce_crc_indicator : 1;
  unsigned __int32 nonce_indicator : 1;
  unsigned __int32 nonce_difficulty : 7;
  unsigned __int32 reserved_1 : 1;
  unsigned __int32 work_id : 15;
  unsigned __int32 nonce_or_register_data : 1;
  uint32_t nonce;
  unsigned __int32 reserved_2 : 8;
  unsigned __int32 blk_version : 16;
  unsigned __int32 job_id : 8;
  uint32_t header;
};

/* 425 */
struct _return_nonce_128bit_t::$CF53EC581D4E8D670057591BB1D6B933
{
  unsigned __int32 chain_number : 4;
  unsigned __int32 reserved_0 : 2;
  unsigned __int32 nonce_crc_indicator : 1;
  unsigned __int32 reserved_1 : 1;
  unsigned __int32 register_address : 8;
  unsigned __int32 chip_address : 8;
  unsigned __int32 crc_value : 5;
  unsigned __int32 reg_type : 2;
  unsigned __int32 nonce_or_register_data : 1;
  uint32_t reg_data;
  uint32_t reserved_2[2];
};

/* 423 */
union _return_nonce_128bit_t
{
  _return_nonce_128bit_t::$1695F939FDD9828F2683DFD527BF56E2 nonce;
  _return_nonce_128bit_t::$CF53EC581D4E8D670057591BB1D6B933 reg;
  uint32_t buf[4];
};

/* 187 */
struct test_pattern_new
{
  unsigned __int8 midstate[8];
  uint32_t nonce;
};

/* 186 */
struct work_new
{
  uint32_t is_nonce_return_back;
  test_pattern_new pattern;
};

/* 209 */
struct reg_content
{
  uint32_t reg_value;
  uint32_t chip_address;
  uint32_t reg_address;
  uint32_t crc;
  uint32_t chain_number;
};

/* 204 */
struct reg_buf
{
  unsigned int p_wr;
  unsigned int p_rd;
  unsigned int reg_value_num;
  unsigned int loop_back;
  reg_content reg_buffer[4095];
};

/* 205 */
struct pattern_struct_in_file
{
  unsigned __int8 midstate[8];
  uint32_t nonce;
};

/* 206 */
struct __attribute__((aligned(2))) pll_conf
{
  pllparameter_t pll_param;
  uint8_t usr_divider;
};

/* 207 */
struct pll_divider_conf_t
{
  uint8_t post_div1;
  uint8_t post_div2;
  uint32_t div_ret;
};

/* 208 */
struct pattern_info_new
{
  work_new *works[108];
};

/* 225 */
enum LZ4F_blockSizeID_t : __int32
{
  LZ4F_default = 0x0,
  LZ4F_max64KB = 0x4,
  LZ4F_max256KB = 0x5,
  LZ4F_max1MB = 0x6,
  LZ4F_max4MB = 0x7,
};

/* 224 */
enum LZ4F_blockMode_t : __int32
{
  LZ4F_blockLinked = 0x0,
  LZ4F_blockIndependent = 0x1,
};

/* 223 */
enum LZ4F_contentChecksum_t : __int32
{
  LZ4F_noContentChecksum = 0x0,
  LZ4F_contentChecksumEnabled = 0x1,
};

/* 222 */
enum LZ4F_frameType_t : __int32
{
  LZ4F_frame = 0x0,
  LZ4F_skippableFrame = 0x1,
};

/* 221 */
enum LZ4F_blockChecksum_t : __int32
{
  LZ4F_noBlockChecksum = 0x0,
  LZ4F_blockChecksumEnabled = 0x1,
};

/* 220 */
struct LZ4F_frameInfo_t
{
  LZ4F_blockSizeID_t blockSizeID;
  LZ4F_blockMode_t blockMode;
  LZ4F_contentChecksum_t contentChecksumFlag;
  LZ4F_frameType_t frameType;
  unsigned __int64 contentSize;
  unsigned int dictID;
  LZ4F_blockChecksum_t blockChecksumFlag;
};

/* 211 */
struct LZ4F_preferences_t
{
  LZ4F_frameInfo_t frameInfo;
  int compressionLevel;
  unsigned int autoFlush;
  unsigned int favorDecSpeed;
  unsigned int reserved[3];
};

/* 212 */
typedef LZ4_writeFile_s LZ4_writeFile_t;

/* 219 */
typedef LZ4F_cctx_s LZ4F_cctx;

/* 214 */
typedef size_t LZ4F_errorCode_t;

/* 344 */
struct LZ4_writeFile_s
{
  LZ4F_cctx *cctxPtr;
  FILE *fp;
  LZ4_byte *dstBuf;
  size_t maxWriteSize;
  size_t dstBufMaxSize;
  LZ4F_errorCode_t errCode;
};

/* 239 */
typedef LZ4F_CDict_s LZ4F_CDict;

/* 232 */
typedef uint8_t BYTE;

/* 453 */
struct __attribute__((aligned(8))) LZ4F_cctx_s
{
  LZ4F_CustomMem cmem;
  LZ4F_preferences_t prefs;
  U32 version;
  U32 cStage;
  const LZ4F_CDict *cdict;
  size_t maxBlockSize;
  size_t maxBufferSize;
  BYTE *tmpBuff;
  BYTE *tmpIn;
  size_t tmpInSize;
  U64 totalInSize;
  XXH32_state_t xxh;
  void *lz4CtxPtr;
  U16 lz4CtxAlloc;
  U16 lz4CtxState;
  LZ4F_blockCompression_t blockCompression;
};

/* 243 */
typedef LZ4_stream_u LZ4_stream_t;

/* 242 */
typedef LZ4_streamHC_u LZ4_streamHC_t;

/* 442 */
struct LZ4F_CDict_s
{
  LZ4F_CustomMem cmem;
  void *dictContent;
  LZ4_stream_t *fastCtx;
  LZ4_streamHC_t *HCCtx;
};

/* 347 */
union LZ4_stream_u
{
  char minStateSize[16416];
  LZ4_stream_t_internal internal_donotuse;
};

/* 346 */
union LZ4_streamHC_u
{
  char minStateSize[262200];
  LZ4HC_CCtx_internal internal_donotuse;
};

/* 213 */
typedef LZ4_readFile_s LZ4_readFile_t;

/* 218 */
typedef LZ4F_dctx_s LZ4F_dctx;

/* 345 */
struct LZ4_readFile_s
{
  LZ4F_dctx *dctxPtr;
  FILE *fp;
  LZ4_byte *srcBuf;
  size_t srcBufNext;
  size_t srcBufSize;
  size_t srcBufMaxSize;
};

/* 443 */
struct __attribute__((aligned(8))) LZ4F_dctx_s
{
  LZ4F_CustomMem cmem;
  LZ4F_frameInfo_t frameInfo;
  U32 version;
  dStage_t dStage;
  U64 frameRemainingSize;
  size_t maxBlockSize;
  size_t maxBufferSize;
  BYTE *tmpIn;
  size_t tmpInSize;
  size_t tmpInTarget;
  BYTE *tmpOutBuffer;
  const BYTE *dict;
  size_t dictSize;
  BYTE *tmpOut;
  size_t tmpOutSize;
  size_t tmpOutStart;
  XXH32_state_t xxh;
  XXH32_state_t blockChecksum;
  int skipChecksum;
  BYTE header[19];
};

/* 226 */
struct XXH64_canonical_t
{
  unsigned __int8 digest[8];
};

/* 227 */
typedef unsigned __int64 XXH64_hash_t;

/* 228 */
enum XXH_alignment : __int32
{
  XXH_aligned = 0x0,
  XXH_unaligned = 0x1,
};

/* 229 */
enum XXH_endianess : __int32
{
  XXH_bigEndian = 0x0,
  XXH_littleEndian = 0x1,
};

/* 230 */
struct XXH32_canonical_t
{
  unsigned __int8 digest[4];
};

/* 231 */
typedef unsigned int XXH32_hash_t;

/* 233 */
typedef XXH64_state_s XXH64_state_t;

/* 234 */
struct __attribute__((aligned(8))) XXH64_state_s
{
  uint64_t total_len;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t mem64[4];
  uint32_t memsize;
  uint32_t reserved[2];
};

/* 236 */
struct LZ4F_decompressOptions_t
{
  unsigned int stableDst;
  unsigned int skipChecksums;
  unsigned int reserved1;
  unsigned int reserved0;
};

/* 237 */
typedef int (*compressFunc_t)(void *, const char *, char *, int, int, int, const LZ4F_CDict *);

/* 238 */
struct LZ4F_compressOptions_t
{
  unsigned int stableSrc;
  unsigned int reserved[3];
};

/* 240 */
typedef LZ4F_cctx_s LZ4F_cctx_t;

/* 241 */
enum LZ4F_errorCodes : __int32
{
  LZ4F_OK_NoError = 0x0,
  LZ4F_ERROR_GENERIC = 0x1,
  LZ4F_ERROR_maxBlockSize_invalid = 0x2,
  LZ4F_ERROR_blockMode_invalid = 0x3,
  LZ4F_ERROR_contentChecksumFlag_invalid = 0x4,
  LZ4F_ERROR_compressionLevel_invalid = 0x5,
  LZ4F_ERROR_headerVersion_wrong = 0x6,
  LZ4F_ERROR_blockChecksum_invalid = 0x7,
  LZ4F_ERROR_reservedFlag_set = 0x8,
  LZ4F_ERROR_allocation_failed = 0x9,
  LZ4F_ERROR_srcSize_tooLarge = 0xA,
  LZ4F_ERROR_dstMaxSize_tooSmall = 0xB,
  LZ4F_ERROR_frameHeader_incomplete = 0xC,
  LZ4F_ERROR_frameType_unknown = 0xD,
  LZ4F_ERROR_frameSize_wrong = 0xE,
  LZ4F_ERROR_srcPtr_wrong = 0xF,
  LZ4F_ERROR_decompressionFailed = 0x10,
  LZ4F_ERROR_headerChecksum_invalid = 0x11,
  LZ4F_ERROR_contentChecksum_invalid = 0x12,
  LZ4F_ERROR_frameDecoding_alreadyStarted = 0x13,
  LZ4F_ERROR_compressionState_uninitialized = 0x14,
  LZ4F_ERROR_parameter_null = 0x15,
  LZ4F_ERROR_maxCode = 0x16,
  _LZ4F_dummy_error_enum_for_c89_never_used = 0x17,
};

/* 247 */
struct LZ4HC_match_t
{
  int off;
  int len;
};

/* 248 */
struct LZ4HC_optimal_t
{
  int price;
  int off;
  int mlen;
  int litlen;
};

/* 249 */
enum limitedOutput_directive : __int32
{
  notLimited = 0x0,
  limitedOutput = 0x1,
  fillOutput = 0x2,
};

/* 250 */
typedef size_t reg_t;

/* 252 */
enum LZ4HC_compress_generic_internal::lz4hc_strat_e : __int32
{
  lz4hc = 0x0,
  lz4opt = 0x1,
};

/* 251 */
struct LZ4HC_compress_generic_internal::cParams_t
{
  LZ4HC_compress_generic_internal::lz4hc_strat_e strat;
  int nbSearches;
  U32 targetLength;
};

/* 253 */
enum HCfavor_e : __int32
{
  favorCompressionRatio = 0x0,
  favorDecompressionSpeed = 0x1,
};

/* 254 */
enum dictCtx_directive : __int32
{
  noDictCtx = 0x0,
  usingDictCtxHc = 0x1,
};

/* 255 */
typedef unsigned int uintptr_t;

/* 256 */
typedef size_t Rvl_t;

/* 257 */
typedef LZ4_streamDecode_u LZ4_streamDecode_t;

/* 426 */
union LZ4_streamDecode_u
{
  char minStateSize[32];
  LZ4_streamDecode_t_internal internal_donotuse;
};

/* 258 */
enum tableType_t : __int32
{
  clearedTable = 0x0,
  byPtr = 0x1,
  byU32 = 0x2,
  byU16 = 0x3,
};

/* 259 */
enum dict_directive : __int32
{
  noDict = 0x0,
  withPrefix64k = 0x1,
  usingExtDict = 0x2,
  usingDictCtx = 0x3,
};

/* 260 */
enum earlyEnd_directive : __int32
{
  decode_full_block = 0x0,
  partial_decode = 0x1,
};

/* 261 */
enum dictIssue_directive : __int32
{
  noDictIssue = 0x0,
  dictSmall = 0x1,
};

/* 262 */
typedef _sweep_ctx sweep_ctx;

/* 348 */
struct _sweep_ctx
{
  uint32_t voltage;
  uint32_t pre_open_core_voltage;
  float range_freq[2];
  float step;
  float bias;
  int eeprom_freq_step;
  int mode;
  int reuse;
  float sweep_online_min;
  float sweep_online_max;
  float sweep_online_avg;
  float sweep_online_var;
  float sweep_online_nonce_rate;
  uint64_t sweep_start_time;
  uint64_t sweep_online_time;
  uint64_t sweep_end_time;
};

/* 263 */
struct __attribute__((aligned(4))) sweep_err_state
{
  int err_val;
  bool consumed;
};

/* 264 */
typedef _config_ctx config_ctx;

/* 351 */
struct _asic_reg_conf
{
  uint32_t ccdly_sel;
  uint32_t pwth_sel;
  uint32_t swpf_mode;
  uint32_t pulse_mode;
  uint32_t clk_sel;
  uint32_t ro_relay_en;
  uint32_t co_relay_en;
  uint32_t diode_vdd_mux_sel;
};

/* 272 */
typedef _asic_reg_conf asic_reg_conf;

/* 350 */
struct _test_speed
{
  uint32_t baudrate;
  uint32_t timeout;
};

/* 427 */
typedef _test_speed test_speed_0;

/* 428 */
struct _sensor_ctx
{
  char senor_name[16];
  uint32_t sensor_addr[4];
  uint32_t sensor_i2c_addr;
  uint32_t sensor_reg_addr;
  int sensor_num;
};

/* 276 */
typedef _sensor_ctx sensor_ctx;

/* 447 */
struct _hash_board
{
  char asic_type[16];
  uint32_t wait_temp;
  sensor_ctx sensor;
};

/* 270 */
typedef _hash_board hash_board;

/* 349 */
struct _temp_ctx
{
  uint32_t temp_gap;
  uint32_t wait_cool_time;
  uint32_t cool_board_time;
};

/* 269 */
typedef _temp_ctx temp_ctx;

/* 275 */
struct _fan_ctx
{
  int fan_speed;
  int work_fan_speed;
};

/* 268 */
typedef _fan_ctx fan_ctx;

/* 273 */
struct _test_standard
{
  int invalid_core_num;
  int least_nonce_per_core;
  int asic_nonce_rate;
  int nonce_rate;
};

/* 267 */
typedef _test_standard test_standard;

/* 274 */
struct _test_ctx
{
  int level;
  int pre_open_core_voltage;
  int voltage;
  int freq;
};

/* 266 */
typedef _test_ctx test_ctx;

/* 455 */
struct _config_ctx
{
  int chain;
  int asics;
  int domains;
  int asics_in_domain;
  int asic_domain_num;
  int big_core;
  int asic_small_cores;
  int samll_core_num_in_big_core;
  int patter_num;
  int abnormal_core;
  int interval;
  int freq_flex;
  asic_reg_conf reg;
  test_speed_0 speed;
  hash_board board;
  temp_ctx temp;
  fan_ctx fan;
  test_standard standard;
  test_ctx tests[11];
  int test_levels;
  int sweeped_res_index;
};

/* 265 */
typedef _pattern_work pattern_work;

/* 352 */
struct _pattern_bin
{
  unsigned __int8 midstate[8];
  uint32_t nonce;
};

/* 277 */
typedef _pattern_bin pattern_bin;

/* 444 */
struct _pattern_work
{
  uint32_t nonce_repeat;
  pattern_bin pattern;
};

/* 278 */
typedef _eeprom_data_format eeprom_data_format_t;

/* 280 */
typedef _pattern_runtime_ctx pattern_runtime_ctx;

/* 353 */
struct _pattern_test_stats
{
  uint32_t nonce_stats[108][9];
  uint32_t nonce_num_asic[108];
  uint32_t nonce_num_chain;
  uint32_t nonce_num_domain[64];
  uint32_t nonce_num_domain_big[64];
  uint32_t nonce_num_repeated;
  uint32_t nonce_num_top_check_fail;
  uint32_t nonce_num_crc_err;
  uint32_t nonce_num_invalid;
  uint32_t nonce_num_hw;
  uint32_t nonce_num_extra;
  uint32_t nonce_num_unknown_err;
  uint32_t invalid_chain_num;
  uint32_t invalid_asic_num;
  float nonce_stdev;
};

/* 283 */
typedef _pattern_test_stats pattern_test_stats;

/* 429 */
struct _asic_status
{
  uint8_t asic_core_nonce_num[108][1280];
  uint16_t every_asic_got_nonce_num[108];
  uint16_t every_asic_reg_ntick_nonce_num[108];
  uint16_t every_asic_reg_nonce_error_num[108];
  uint16_t every_asic_reg_got_nonce_num[108];
  bool ok_asic_list[108];
  bool bad_asic_list[108];
  uint32_t valid_nonce_num;
};

/* 282 */
typedef _asic_status asic_status;

/* 430 */
struct _pattern_ops_t
{
  const char *type;
  int32_t (*init)(const char *);
  void (*exit)(void);
  void (*clear_stats)(void);
  void (*reset)(void);
  void (*process_nonce)(void *, void *);
  void (*process_reg)(void *, void *);
  int32_t (*send_work)(uint32_t, void *);
  void *(*get_stats)(void);
  int32_t (*is_unbalance_happen)(uint32_t);
  int32_t (*is_recv_nonce_enough)(uint32_t);
};

/* 281 */
typedef _pattern_ops_t pattern_ops_t;

/* 448 */
struct _pattern_runtime_ctx
{
  const char *pattern_file_path;
  void *private_data;
  pattern_test_stats stats;
  asic_status asic_stats;
  uint16_t last_succ_asic_nonce_num[108];
  sweep_ctx sweep;
  pattern_work *works[108];
  config_ctx *config;
  pattern_ops_t pt_ops;
  int8_t tempval[4];
  uint32_t send_nonce_num;
  uint32_t chain_status;
  uint8_t is_chain_unbalance;
  uint32_t recv_nonce;
  uint32_t read_temp;
  uint32_t pause_recv_nonce;
  float nonce_rate;
};

/* 284 */
struct __attribute__((aligned(2))) _pll_conf
{
  pllparameter_t pll_param;
  uint8_t usr_divider;
};

/* 285 */
struct sweep_bad_asic_info_t
{
  int bad_asic_num;
  int bad_asic_ids[12];
};

/* 286 */
struct __attribute__((aligned(4))) sweep_result_t
{
  uint16_t hashrate;
  uint16_t freq_base;
  uint8_t freq_step;
  uint32_t freqs[256];
  bool is_pass;
};

/* 287 */
struct test_info_t
{
  char file_path[128];
  char test_type[128];
  char sn[128];
  char miner_type[128];
  char fac[128];
  char boardname[128];
};

/* 288 */
struct log_info_t
{
  char path[128];
  char compressed_path[128];
  char encoded_path[128];
  bool compressed;
  bool encode;
  char *data;
  uint32_t origin_size;
  uint32_t filter_size;
};

/* 289 */
struct __attribute__((aligned(2))) dirent
{
  __ino_t d_ino;
  __off_t d_off;
  unsigned __int16 d_reclen;
  unsigned __int8 d_type;
  char d_name[256];
};

/* 290 */
typedef void DIR;

/* 291 */
struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  int tm_gmtoff;
  const char *tm_zone;
};

/* 292 */
struct edf_v5_priv
{
  uint8_t board_info_version;
  uint8_t algorithm_and_key_version;
  uint8_t board_sn[18];
  uint8_t chip_die[3];
  uint8_t chip_marking[14];
  uint8_t chip_bin;
  uint8_t ft_version[10];
  uint16_t pcb_version;
  uint16_t bom_version;
  uint8_t asic_sensor_type;
  uint8_t asic_sensor_addr[4];
  uint8_t pic_sensor_type;
  uint8_t pic_sensor_addr;
  uint8_t chip_tech[3];
  char board_name[9];
  uint8_t factory_job[24];
  uint8_t pt1_result;
  uint8_t pt1_count;
  uint8_t board_info_crc;
  uint16_t voltage;
  uint16_t frequency;
  uint16_t nonce_rate;
  int8_t pcb_temp_in;
  int8_t pcb_temp_out;
  uint8_t test_version;
  uint8_t test_standard;
  uint8_t pt2_result;
  uint8_t pt2_count;
  char data_padding2[3];
  uint8_t param_info_crc;
  uint16_t sweep_hashrate;
  uint16_t sweep_freq_base;
  uint8_t sweep_freq_step;
  uint8_t sweep_level[128];
  uint8_t sweep_result;
  char data_padding3[1];
  uint8_t sweep_info_crc;
};

/* 293 */
struct edf_v4_priv
{
  uint8_t board_info_version;
  uint8_t algorithm_and_key_version;
  uint8_t board_sn[18];
  uint8_t chip_die[3];
  uint8_t chip_marking[14];
  uint8_t chip_bin;
  uint8_t ft_version[10];
  uint16_t pcb_version;
  uint16_t bom_version;
  uint8_t asic_sensor_type;
  uint8_t asic_sensor_addr[4];
  uint8_t pic_sensor_type;
  uint8_t pic_sensor_addr;
  uint8_t chip_tech[3];
  char board_name[9];
  uint8_t factory_job[24];
  uint8_t pt1_result;
  uint8_t pt1_count;
  uint8_t board_info_crc;
  uint16_t voltage;
  uint16_t frequency;
  uint16_t nonce_rate;
  int8_t pcb_temp_in;
  int8_t pcb_temp_out;
  uint8_t test_version;
  uint8_t test_standard;
  uint8_t pt2_result;
  uint8_t pt2_count;
  char data_padding2[3];
  uint8_t param_info_crc;
};

/* 294 */
typedef eeprom_data_format_t *(*edf_submodule_init)(void);

/* 295 */
struct hashboard_qr_code
{
  char factory_job[32];
  char chip_die[16];
  char chip_marking[16];
  char chip_bin[16];
  char chip_ftversion[16];
  char temp_sensor_type[16];
  char hashboard_ctrl_code[16];
  char hashboard_index[16];
};

/* 296 */
struct hashboard_sn
{
  char sn_len;
  char board_sn[32];
};

/* 297 */
struct zhiju_information
{
  uint8_t zhiju_information_format_version;
  uint8_t hashboard_sn[17];
  uint8_t chip_die[2];
  uint8_t chip_marking[13];
  uint8_t chip_bin;
  uint8_t chip_ft_program_version[9];
  uint8_t asic_sensor;
  uint8_t asic_sensor_addr[4];
  uint8_t pic_sensor;
  uint8_t pic_sensor_addr;
  uint8_t pcb_version_v1;
  uint8_t pcb_version_v2;
  uint8_t bom_version_v1;
  uint8_t bom_version_v2;
  uint8_t chip_technology[2];
  uint8_t voltage[2];
  uint8_t frequency[2];
  uint8_t nonce_rate[2];
  int8_t pcb_temprature_in;
  int8_t pcb_temprature_out;
  uint8_t test_version;
  uint8_t test_standard;
  uint8_t reserve[2];
  uint8_t zhiju_information_crc5;
};

/* 298 */
typedef mes_system_config_file_info Mes_System_Config_File_Info;

/* 439 */
struct mes_system_result
{
  char version[24];
  char code[24];
  char msg[24];
  mes_system_configs *configs;
};

/* 309 */
typedef mes_system_result Mes_System_Result;

/* 449 */
struct mes_system_config_file_info
{
  char jsonrpc[24];
  uint32_t id;
  Mes_System_Result result;
};

/* 440 */
struct mes_system_rule
{
  mes_system_pattern *pattern;
  mes_system_asic_reg *asic_reg;
  mes_system_test_method *test_method;
  mes_system_test_loop *test_loop;
};

/* 299 */
typedef mes_system_rule Mes_System_Rule;

/* 310 */
struct mes_system_configs
{
  char miner_type[24];
  mes_system_hw_info *hw_info;
  Mes_System_Rule rule;
  mes_system_test_config *test_config;
  mes_system_configs *next;
};

/* 311 */
struct mes_system_hw_info
{
  uint32_t id;
  char board_name[24];
  char asic_type[24];
  uint32_t asic_num;
  uint32_t voltage_domain;
  uint32_t asic_num_per_voltage_domain;
  uint32_t power_version[16];
  mes_system_hw_info *next;
};

/* 312 */
struct mes_system_pattern
{
  uint32_t id;
  uint32_t pattern_number;
  uint32_t invalid_core_num;
  uint32_t most_hw_num;
  uint32_t least_nonce_per_core;
  uint32_t nonce_rate;
  uint32_t midstate_number;
  mes_system_pattern *next;
};

/* 313 */
struct mes_system_asic_reg
{
  uint32_t id;
  uint32_t ccdly_sel;
  uint32_t pwth_sel;
  uint32_t swpf_mode;
  uint32_t pulse_mode;
  uint32_t clk_sel;
  uint32_t ro_relay_en;
  uint32_t co_relay_en;
  uint32_t diode_vdd_mux_sel;
  mes_system_asic_reg *next;
};

/* 314 */
struct mes_system_test_method
{
  uint32_t id;
  char method[24];
  mes_system_test_method *next;
};

/* 317 */
struct mes_system_test_loop
{
  uint32_t id;
  uint32_t frequency;
  uint32_t voltage;
  mes_system_test_loop *next;
};

/* 315 */
struct mes_system_test_config
{
  char hardware_version[24];
  char bom_version[24];
  char chip_technology[24];
  char ft_version[24];
  uint32_t bin;
  mes_system_data *data;
  mes_system_test_config *next;
};

/* 316 */
struct mes_system_data
{
  char version[24];
  uint32_t pattern_id;
  uint32_t asic_reg_id;
  uint32_t test_method_id;
  uint32_t voltage_accuracy;
  uint32_t fan_speed;
  uint32_t test_loop_id[50];
  uint32_t test_loop_id_number;
  uint32_t pre_open_core_voltage;
  mes_system_data *next;
};

/* 300 */
typedef mes_system_data Mes_System_Data;

/* 301 */
typedef mes_system_test_config Mes_System_Test_Config;

/* 302 */
typedef mes_system_test_loop Mes_System_Test_Loop;

/* 303 */
typedef mes_system_test_method Mes_System_Test_Method;

/* 304 */
typedef mes_system_asic_reg Mes_System_Asic_Reg;

/* 305 */
typedef mes_system_pattern Mes_System_Pattern;

/* 306 */
typedef mes_system_hw_info Mes_System_Hw_Info;

/* 307 */
typedef mes_system_configs Mes_System_Configs;

/* 308 */
struct hostent
{
  char *h_name;
  char **h_aliases;
  int h_addrtype;
  int h_length;
  char **h_addr_list;
};

/* 318 */
typedef char *__caddr_t;

/* 319 */
struct PID
{
  float max_limit;
  float min_limit;
  float target;
  float feedback;
  float startup_Kp;
  float Kp;
  float Ki;
  float Kd;
  float e_0;
  float e_1;
  float e_2;
};

/* 320 */
typedef _ptx_err_msg_ pt_err_msg;

/* 354 */
struct __attribute__((aligned(4))) _ptx_err_msg_
{
  int error_no;
  char error_code[10];
  char error_code_desc[20];
};

/* 321 */
typedef void SSL_CTX;

/* 327 */
typedef int __fd_mask;

/* 322 */
struct fd_set
{
  __fd_mask __fds_bits[32];
};

/* 323 */
typedef void SSL;

/* 326 */
typedef unsigned int __socklen_t;

/* 325 */
typedef __socklen_t socklen_t;

/* 324 */
struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  sockaddr *ai_addr;
  char *ai_canonname;
  addrinfo *ai_next;
};

/* 328 */
struct __attribute__((aligned(8))) asic_val_t
{
  double max_asic_val;
  double min_asic_val;
  double avg_asic_val;
  double asic_val[108];
  int read_succ_size;
  uint8_t asic_val_readover[108];
  int idx;
};

/* 329 */
struct __sigset_t
{
  unsigned int __val[32];
};

/* 333 */
typedef int __pid_t;

/* 540 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$DDF278A5B88F81FEC3CBEE828E282CB3
{
  __pid_t si_pid;
  __uid_t si_uid;
};

/* 335 */
union sigval
{
  int sival_int;
  void *sival_ptr;
};

/* 334 */
typedef sigval sigval_t;

/* 541 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$F43D85AC31CEBD8CC07B08111ABDF065
{
  int si_tid;
  int si_overrun;
  sigval_t si_sigval;
};

/* 542 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$002955E8B5DE3B92E30DFEF7AB65BFE2
{
  __pid_t si_pid;
  __uid_t si_uid;
  sigval_t si_sigval;
};

/* 332 */
typedef int __clock_t;

/* 543 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$353EAF26536A4016665766004ADC0BD6
{
  __pid_t si_pid;
  __uid_t si_uid;
  int si_status;
  __clock_t si_utime;
  __clock_t si_stime;
};

/* 544 */
struct __attribute__((aligned(4))) siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$E8B6F0BBDFDEB0F2D2A2272DA024FD9B
{
  void *si_addr;
  __int16 si_addr_lsb;
};

/* 545 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$534EC22A0813C1325C3E7D3262B5A8D3
{
  int si_band;
  int si_fd;
};

/* 546 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$4B29161E04CAD4BCDD788B201A5E8E5E
{
  void *_call_addr;
  int _syscall;
  unsigned int _arch;
};

/* 547 */
union siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F
{
  int _pad[29];
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$DDF278A5B88F81FEC3CBEE828E282CB3 _kill;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$F43D85AC31CEBD8CC07B08111ABDF065 _timer;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$002955E8B5DE3B92E30DFEF7AB65BFE2 _rt;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$353EAF26536A4016665766004ADC0BD6 _sigchld;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$E8B6F0BBDFDEB0F2D2A2272DA024FD9B _sigfault;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$534EC22A0813C1325C3E7D3262B5A8D3 _sigpoll;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$4B29161E04CAD4BCDD788B201A5E8E5E _sigsys;
};

/* 330 */
struct siginfo_t
{
  int si_signo;
  int si_errno;
  int si_code;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F _sifields;
};

/* 331 */
typedef void (*__sighandler_t)(int);

/* 366 */
struct _ocv_pulse_width_t::$93B5D43C9D080135AD7CD2C72C22B99B
{
  unsigned __int16 _PULSE_WIDTH : 8;
  unsigned __int16 _OCV_DOUT : 4;
  unsigned __int16 _RSVD1 : 4;
};

/* 365 */
union _ocv_pulse_width_t
{
  _ocv_pulse_width_t::$93B5D43C9D080135AD7CD2C72C22B99B u;
  uint16_t v;
};

/* 368 */
struct _process_monitor_ctrl_t::$B527025DFEC31D3E4C076D3CFDF0A797
{
  unsigned __int16 _PM_SEL : 2;
  unsigned __int16 _PM_START : 1;
  unsigned __int16 _RSVD : 13;
};

/* 367 */
union _process_monitor_ctrl_t
{
  _process_monitor_ctrl_t::$B527025DFEC31D3E4C076D3CFDF0A797 u;
  uint16_t v;
};

/* 370 */
struct _nonce_bin_overflow_control_t::$BA21811157AC6FD2C001FC6AA9D1E604
{
  unsigned __int16 _NONCE_BIN_OF_ENABLE : 1;
  unsigned __int16 _RSVD1 : 1;
  unsigned __int16 _GOLDEN_TICKET_EN : 1;
  unsigned __int16 _RSVD2 : 1;
  unsigned __int16 _NONCE_OF_STS : 1;
  unsigned __int16 _RSVD3 : 11;
};

/* 369 */
union _nonce_bin_overflow_control_t
{
  _nonce_bin_overflow_control_t::$BA21811157AC6FD2C001FC6AA9D1E604 u;
  uint16_t v;
};

/* 372 */
struct _auto_clk_en_t::$054FC362C05094A409FA46B0A2EC5B35
{
  unsigned __int16 _AUTO_CLK_EN : 1;
  unsigned __int16 _RSVD : 4;
  unsigned __int16 _MODE_MASK : 2;
  unsigned __int16 _RSVD1 : 9;
};

/* 371 */
union _auto_clk_en_t
{
  _auto_clk_en_t::$054FC362C05094A409FA46B0A2EC5B35 u;
  uint16_t v;
};

/* 374 */
struct _nonce_bin_overflow_t::$D4EC59588EDC78D583CAE43EC0CC6290
{
  unsigned __int16 _NONCE_BIN_OF_ENABLE : 1;
  unsigned __int16 _FAKE_NONCE : 1;
  unsigned __int16 _RSVD1 : 2;
  unsigned __int16 _NONCE_BIN_OF : 1;
  unsigned __int16 _RSVD2 : 11;
};

/* 373 */
union _nonce_bin_overflow_t
{
  _nonce_bin_overflow_t::$D4EC59588EDC78D583CAE43EC0CC6290 u;
  uint16_t v;
};

/* 376 */
struct _clock_select_ctrl_t::$00812AFD81DD6EC47DD561900F36A6BB
{
  unsigned __int16 _SWPF_MODE : 1;
  unsigned __int16 _CLK_SEL : 2;
  unsigned __int16 _CLK_SEL_MASK : 1;
  unsigned __int16 _RSVD3 : 12;
};

/* 375 */
union _clock_select_ctrl_t
{
  _clock_select_ctrl_t::$00812AFD81DD6EC47DD561900F36A6BB u;
  uint16_t v;
};

/* 378 */
struct _hash_clock_ctrl_t::$B3876FF50123CD57774DE1BDF87C9675
{
  unsigned __int16 _CLOCK_CTRL : 5;
  unsigned __int16 _RSVD1 : 11;
};

/* 377 */
union _hash_clock_ctrl_t
{
  _hash_clock_ctrl_t::$B3876FF50123CD57774DE1BDF87C9675 u;
  uint16_t v;
};

/* 380 */
struct _core_enable_t::$9EFB38A74C52C61335BCA67486DB7660
{
  uint8_t _CORE_EN_I;
  uint8_t _CORE_EN_N;
};

/* 379 */
union _core_enable_t
{
  _core_enable_t::$9EFB38A74C52C61335BCA67486DB7660 u;
  uint16_t v;
};

/* 382 */
struct _clock_delay_ctrl_t::$7A4DEA714C77553AE3268A9440D03508
{
  unsigned __int8 _SWPF_MODE : 1;
  unsigned __int8 _RSVD1 : 1;
  unsigned __int8 _RSVD2 : 1;
  unsigned __int8 _PWTH_SEL : 3;
  unsigned __int8 _CCDLY_SEL : 2;
};

/* 381 */
union _clock_delay_ctrl_t
{
  _clock_delay_ctrl_t::$7A4DEA714C77553AE3268A9440D03508 u;
  uint8_t v;
};

/* 384 */
struct _sweep_clk_mode_ctrl_t::$0735B93FDEA9BF439A597EE28571B7EB
{
  unsigned __int32 _CORE_CLK_MODE_SEL : 2;
  unsigned __int32 _CLK_MODE_MARGIN : 1;
  unsigned __int32 _CORE_NUM_DEC_LOCK_EN : 1;
  unsigned __int32 _RSVD : 28;
};

/* 383 */
union _sweep_clk_mode_ctrl_t
{
  _sweep_clk_mode_ctrl_t::$0735B93FDEA9BF439A597EE28571B7EB u;
  uint32_t v;
};

/* 386 */
struct _frequency_sweep_control_t::$CB775C3371B5AB98A2F218254CEFB524
{
  unsigned __int32 _SWP_EN : 1;
  unsigned __int32 _SWP_TRIG : 1;
  unsigned __int32 _SWP_ONGOING : 1;
  unsigned __int32 _SWP_DONE_ALL : 1;
  unsigned __int32 _SWP_PAT_ADDR : 3;
  unsigned __int32 _SWP_ONE_PAT_DONE : 1;
  unsigned __int32 _CURR_PAT_ADDR : 3;
  unsigned __int32 _SWEEP_RESET : 1;
  unsigned __int32 _SWEEP_FAIL_LOCK_EN : 1;
  unsigned __int32 _ALL_CORE_CLK_SEL_CHANGE_ST : 1;
  unsigned __int32 _RSVD1 : 2;
  unsigned __int32 _SWEEP_ST_ADDR : 8;
  unsigned __int32 _SWEEP_STATE : 3;
  unsigned __int32 _INC_DISABLE : 1;
  unsigned __int32 _EN_OR_MATCH_NONCES : 1;
  unsigned __int32 _CORE_CLK_CFG_DIS : 1;
  unsigned __int32 _OVERLAP_LOCK_EN : 1;
  unsigned __int32 _RSVD2 : 1;
};

/* 385 */
union _frequency_sweep_control_t
{
  _frequency_sweep_control_t::$CB775C3371B5AB98A2F218254CEFB524 u;
  uint32_t v;
};

/* 388 */
struct _temp_ctrl_t_::$2682C6D097AA622077DD9A936FAE1ADB
{
  unsigned __int32 _CFG0 : 8;
  unsigned __int32 _CFGA : 8;
  unsigned __int32 _TS_CLK_SEL : 1;
  unsigned __int32 _TS_SOFT_RSTN : 1;
  unsigned __int32 _RSVD_1 : 6;
  unsigned __int32 _TS_CLOAD : 1;
  unsigned __int32 _RSVD_2 : 3;
  unsigned __int32 _RUN_EN : 1;
  unsigned __int32 _RUN_CTRL : 1;
  unsigned __int32 _RSVD_3 : 1;
  unsigned __int32 _TS_PD : 1;
};

/* 387 */
union _temp_ctrl_t_
{
  _temp_ctrl_t_::$2682C6D097AA622077DD9A936FAE1ADB u;
  uint32_t v;
};

/* 390 */
struct _soft_reset_control_t::$DC44DE6C803C4A241E95AF716A5FB4ED
{
  unsigned __int32 _CORE_SRST : 4;
  unsigned __int32 _CORE_SRST_FAST : 4;
  unsigned __int32 _TVER_RESET : 1;
  unsigned __int32 _TOPCRTL_RESET : 1;
  unsigned __int32 _CHIP_RESET : 1;
  unsigned __int32 _RSVD : 5;
  unsigned __int32 _SRST_TIME : 8;
  unsigned __int32 _RSVD1 : 8;
};

/* 389 */
union _soft_reset_control_t
{
  _soft_reset_control_t::$DC44DE6C803C4A241E95AF716A5FB4ED u;
  uint32_t v;
};

/* 392 */
struct _midstate_cal_register_t::$AA0FEB0BEE114E620DE6EFDCC9CE5947
{
  unsigned __int32 _VER_MASK : 16;
  unsigned __int32 _RSVD1 : 12;
  unsigned __int32 _MIDSX_GEN : 2;
  unsigned __int32 _VER_FIX : 1;
  unsigned __int32 _MID_AUTO_GEN : 1;
};

/* 391 */
union _midstate_cal_register_t
{
  _midstate_cal_register_t::$AA0FEB0BEE114E620DE6EFDCC9CE5947 u;
  uint32_t v;
};

/* 394 */
struct _pad_check::$16525B6ECE528C248B585CB0EAFCCE3A
{
  unsigned __int32 _PLL_VDD_OK : 1;
  unsigned __int32 _CORE_VDD_OK : 1;
  unsigned __int32 _PIN_MODE : 1;
  unsigned __int32 _TEST : 1;
  unsigned __int32 _P_CORE_EN : 1;
  unsigned __int32 _POR_EN : 1;
  unsigned __int32 _INV_CLKO : 1;
  unsigned __int32 _ADDR3 : 1;
  unsigned __int32 _RI_CNT : 4;
  unsigned __int32 _BI_CNT : 4;
  unsigned __int32 _NRSTI_OK : 1;
  unsigned __int32 _NRSTI_PAD_OK : 1;
  unsigned __int32 _ADDR : 2;
  unsigned __int32 _DOMAIN_VDD_OK : 4;
  unsigned __int32 _FREE_POR_GLITCH : 1;
  unsigned __int32 _POR_GLITCH : 1;
  unsigned __int32 _NRSTI_GLITCH : 1;
  unsigned __int32 _RSVD2 : 1;
  unsigned __int32 _CHECK_BEGIN : 4;
};

/* 393 */
union _pad_check
{
  _pad_check::$16525B6ECE528C248B585CB0EAFCCE3A u;
  uint32_t v;
};

/* 396 */
struct _rosc_pad_dis_t::$CB4B4EC29B18329A0472AAC5B123FC72
{
  uint32_t _ROSC_DIS_DATA;
};

/* 395 */
union _rosc_pad_dis_t
{
  _rosc_pad_dis_t::$CB4B4EC29B18329A0472AAC5B123FC72 u;
  uint32_t v;
};

/* 398 */
struct _io_driver_strength_cfg_t::$22ABAECD1EB984C3AFC2D6A07D7323E9
{
  unsigned __int32 _CO_DS : 4;
  unsigned __int32 _BO_DS : 4;
  unsigned __int32 _NRSTO_DS : 4;
  unsigned __int32 _CLKO_DS : 4;
  unsigned __int32 _R0_DS : 4;
  unsigned __int32 _RSVD0 : 4;
  unsigned __int32 _RSVD1 : 4;
  unsigned __int32 _RSVD2 : 4;
};

/* 397 */
union _io_driver_strength_cfg_t
{
  _io_driver_strength_cfg_t::$22ABAECD1EB984C3AFC2D6A07D7323E9 u;
  uint32_t v;
};

/* 400 */
struct _analog_mux_control_t::$C3AC73F14EC83580C3C749CE72866EE5
{
  unsigned __int32 _ANA_MUX_SEL : 4;
  unsigned __int32 _RSVD1 : 28;
};

/* 399 */
union _analog_mux_control_t
{
  _analog_mux_control_t::$C3AC73F14EC83580C3C749CE72866EE5 u;
  uint32_t v;
};

/* 402 */
struct _core_command_t::$3FC10C01ECE15D982DC361CBA51BEA75
{
  unsigned __int32 _REG_WDATA : 8;
  unsigned __int32 _REG_ADDR : 5;
  unsigned __int32 _RSVD1 : 1;
  unsigned __int32 _RW_DONE : 1;
  unsigned __int32 _REG_WRITE : 1;
  unsigned __int32 _CORE_ID : 8;
  unsigned __int32 _NUM : 7;
  unsigned __int32 _ALL : 1;
};

/* 401 */
union _core_command_t
{
  _core_command_t::$3FC10C01ECE15D982DC361CBA51BEA75 u;
  uint8_t v[4];
  uint32_t v_32;
};

/* 404 */
struct _uart_relay_t::$DCDDBA906D4F3204C4D7359C3D71F149
{
  unsigned __int32 _CO_RELAY_EN : 1;
  unsigned __int32 _RO_RELAY_EN : 1;
  unsigned __int32 _NONCE_GAP_EN : 1;
  unsigned __int32 _RSVD1 : 13;
  unsigned __int32 _GAP_CNT : 16;
};

/* 403 */
union _uart_relay_t
{
  _uart_relay_t::$DCDDBA906D4F3204C4D7359C3D71F149 u;
  uint32_t v;
};

/* 406 */
struct _fast_UART_configuration_t::$EBFF4A3E136A7FB3E8D0FCB2A7F2A33C
{
  unsigned __int32 _TOP_DIV : 4;
  unsigned __int32 _RSVD1 : 1;
  unsigned __int32 _TOP_ODDSET : 2;
  unsigned __int32 _TOPCLK_SEL : 1;
  unsigned __int32 _BT8D : 9;
  unsigned __int32 _RSVD2 : 1;
  unsigned __int32 _USRC_ODDSET : 2;
  unsigned __int32 _USRC_DIV : 6;
  unsigned __int32 _BCLK_SEL : 1;
  unsigned __int32 _DSCLK_SEL : 2;
  unsigned __int32 _RSVD3 : 1;
  unsigned __int32 _PDIVCLK_SEL : 1;
  unsigned __int32 _VCO_CLK_EN : 1;
};

/* 405 */
union _fast_UART_configuration_t
{
  _fast_UART_configuration_t::$EBFF4A3E136A7FB3E8D0FCB2A7F2A33C u;
  uint32_t v;
};

/* 408 */
struct _ordered_clock_enable::$A1C6A5A120698085F0BD7C1BEBA0DC9F
{
  unsigned __int32 _CLK_EN : 2;
  unsigned __int32 _RSVD : 29;
  unsigned __int32 _CLK_SEL : 1;
};

/* 407 */
union _ordered_clock_enable
{
  _ordered_clock_enable::$A1C6A5A120698085F0BD7C1BEBA0DC9F u;
  uint32_t v;
};

/* 410 */
struct _misc_control_t::$77DE47BA02AAC8748DE731800B9F4535
{
  unsigned __int32 _RSVD1 : 2;
  unsigned __int32 _FSW_CKEN : 1;
  unsigned __int32 _RI_DISA : 1;
  unsigned __int32 _RSVD2 : 3;
  unsigned __int32 _RET_WORK_ERR_FLAG : 1;
  unsigned __int32 _PCE_EN : 1;
  unsigned __int32 _FORCE_CORE_EN : 1;
  unsigned __int32 _RSVD3 : 3;
  unsigned __int32 _SOFT_INV_CLKO : 1;
  unsigned __int32 _RNTMO_EN : 1;
  unsigned __int32 _TVER_EN : 1;
  unsigned __int32 _RTST_M_EN : 4;
  unsigned __int32 _RVS_K0 : 1;
  unsigned __int32 _SPAT_NOD : 1;
  unsigned __int32 _VERIFY_FIFO_FULL : 1;
  unsigned __int32 _CORE_SWPS : 1;
  unsigned __int32 _RTST_F_EN : 4;
  unsigned __int32 _RNO_EN : 4;
};

/* 409 */
union _misc_control_t
{
  _misc_control_t::$77DE47BA02AAC8748DE731800B9F4535 u;
  uint32_t v;
};

/* 412 */
struct _ticket_mask_t::$2670B6AA0243F6DA72D99A2BB1D5C4B1
{
  uint8_t _TM0;
  uint8_t _TM1;
  uint8_t _TM2;
  uint8_t _TM3;
};

/* 411 */
union _ticket_mask_t
{
  _ticket_mask_t::$2670B6AA0243F6DA72D99A2BB1D5C4B1 u;
  uint32_t v;
};

/* 414 */
struct _chip_nonce_offset_t::$0AE3073B893DD576A0F9A3524A723D95
{
  uint16_t _CNO;
  unsigned __int16 _RSVD1 : 15;
  unsigned __int16 _CNOV : 1;
};

/* 413 */
union _chip_nonce_offset_t
{
  _chip_nonce_offset_t::$0AE3073B893DD576A0F9A3524A723D95 u;
  uint32_t v;
};

/* 416 */
struct _pll_parameter_t::$148A86E5292EDB32447E18DFCF0786C7
{
  unsigned __int32 _POSTDIV2 : 3;
  unsigned __int32 _RSVD1 : 1;
  unsigned __int32 _POSTDIV1 : 3;
  unsigned __int32 _RSVD2 : 1;
  unsigned __int32 _REFDIV : 6;
  unsigned __int32 _CALEN : 1;
  unsigned __int32 _FASTCALEN : 1;
  unsigned __int32 _FBDIV : 12;
  unsigned __int32 _VCOSEL : 1;
  unsigned __int32 _BYPASS : 1;
  unsigned __int32 _PLLEN : 1;
  unsigned __int32 _LOCKED : 1;
};

/* 415 */
union _pll_parameter_t
{
  _pll_parameter_t::$148A86E5292EDB32447E18DFCF0786C7 u;
  uint32_t v;
};

/* 419 */
struct _fpga_bt8d_t::$064BE3777DB068CE02E3BEEC5C09C92D
{
  unsigned __int32 bt8d_c0 : 6;
  unsigned __int32 reserved_0 : 2;
  unsigned __int32 bt8d_c1 : 6;
  unsigned __int32 reserved_1 : 2;
  unsigned __int32 bt8d_c2 : 6;
  unsigned __int32 reserved_2 : 2;
  unsigned __int32 bt8d_c3 : 6;
  unsigned __int32 reserved_3 : 2;
};

/* 418 */
union _fpga_bt8d_t
{
  _fpga_bt8d_t::$064BE3777DB068CE02E3BEEC5C09C92D u;
  uint32_t v;
};

/* 431 */
struct _work_cxt
{
  uint8_t work_type;
  uint8_t chain_id;
  uint8_t reserved1[2];
  uint32_t work_count;
  uint8_t data[12];
  uint8_t midstate[16][32];
};

/* 433 */
struct _returned_nonce_counter_t::$4B92755CDE5B692329894160767A252E
{
  uint16_t _RETURN_NONCE_CNT;
  uint16_t _RETURN_NONCE_CNT_MATCH;
};

/* 432 */
union _returned_nonce_counter_t
{
  _returned_nonce_counter_t::$4B92755CDE5B692329894160767A252E u;
  uint32_t v;
};

/* 435 */
struct _tick_nonce_counter_t::$E411BBEC9451BAA71A7911D02B37276F
{
  uint32_t _tick_nonce_cnt;
};

/* 434 */
union _tick_nonce_counter_t
{
  _tick_nonce_counter_t::$E411BBEC9451BAA71A7911D02B37276F u;
  uint32_t v;
};

/* 437 */
struct _general_i2c_command_t::$46F2FE6AD56A5A19CF83CAD7B0DC115A
{
  unsigned __int32 _DATA : 8;
  unsigned __int32 _REG_ADDR : 8;
  unsigned __int32 _RW_CTRL : 1;
  unsigned __int32 _DEVICE_ADDR : 7;
  unsigned __int32 _REG_ADDR_VAILD : 1;
  unsigned __int32 _AUTO_READ_TEMP : 1;
  unsigned __int32 _AUTO_RET_TEMP : 1;
  unsigned __int32 _RSVD1 : 3;
  unsigned __int32 _RW_FAIL : 1;
  unsigned __int32 _BUSY : 1;
};

/* 436 */
union _general_i2c_command_t
{
  _general_i2c_command_t::$46F2FE6AD56A5A19CF83CAD7B0DC115A u;
  uint32_t v;
};

/* 438 */
struct json_t_0
{
  _BYTE gap0[4];
  volatile size_t refcount;
};

/* 457 */
struct complex_double
{
  double real;
  double imag;
};

/* 458 */
struct complex_float
{
  float real;
  float imag;
};

/* 459 */
typedef __int64 DItype;

/* 460 */
typedef _IO_marker _IO_marker_0;

/* 462 */
struct nonce_format_t::$F4175EC6656FD4F18765A5BC5960D424
{
  unsigned __int32 _DATA : 17;
  unsigned __int32 _CHIP_ADDR : 8;
  unsigned __int32 _CORE_ID : 7;
};

/* 463 */
struct nonce_format_t::$DE677E723494A2B4F9BAA0655AD0031A
{
  unsigned __int32 _DATA : 9;
  unsigned __int32 _CHIP_NONCE_OFFSET : 16;
  unsigned __int32 _CORE_ID : 7;
};

/* 461 */
union nonce_format_t
{
  nonce_format_t::$F4175EC6656FD4F18765A5BC5960D424 u;
  nonce_format_t::$DE677E723494A2B4F9BAA0655AD0031A u2;
  uint32_t v;
};

/* 464 */
typedef _ocv_pulse_width_t ocv_pulse_width_t;

/* 465 */
typedef _process_monitor_ctrl_t process_monitor_ctrl_t;

/* 466 */
typedef _nonce_bin_overflow_control_t nonce_bin_overflow_control_t;

/* 467 */
typedef _auto_clk_en_t auto_clk_en_t;

/* 468 */
typedef _nonce_bin_overflow_t nonce_bin_overflow_t;

/* 469 */
typedef _clock_select_ctrl_t clock_select_ctrl_t;

/* 470 */
typedef _hash_clock_ctrl_t hash_clock_ctrl_t;

/* 471 */
typedef _core_enable_t core_enable_t;

/* 472 */
typedef _clock_delay_ctrl_t clock_delay_ctrl_t;

/* 473 */
typedef _sweep_clk_mode_ctrl_t sweep_clk_mode_ctrl_t;

/* 474 */
typedef _frequency_sweep_control_t frequency_sweep_control_t;

/* 475 */
typedef _temp_ctrl_t_ temp_ctrl_t;

/* 476 */
typedef _soft_reset_control_t soft_reset_control_t;

/* 477 */
typedef _midstate_cal_register_t midstate_cal_register_t;

/* 478 */
typedef _pad_check pad_check_t;

/* 479 */
typedef _rosc_pad_dis_t rosc_pad_dis_t;

/* 480 */
typedef _io_driver_strength_cfg_t io_driver_strength_cfg_t;

/* 481 */
typedef _analog_mux_control_t analog_mux_control_t;

/* 482 */
typedef _core_command_t core_command_t;

/* 483 */
typedef _uart_relay_t uart_relay_t;

/* 484 */
typedef _fast_UART_configuration_t fast_UART_configuration_t;

/* 485 */
typedef _ordered_clock_enable ordered_clock_enable;

/* 486 */
typedef _misc_control_t misc_control_t;

/* 487 */
typedef _ticket_mask_t ticket_mask_t;

/* 488 */
typedef _chip_nonce_offset_t chip_nonce_offset_t;

/* 489 */
typedef _pll_parameter_t pll_parameter_t;

/* 490 */
struct clib_deque
{
  clib_object **pElements;
  int no_max_elements;
  int head;
  int tail;
  int no_of_elements;
  clib_compare compare_fn;
  clib_destroy destruct_fn;
};

/* 491 */
enum bitmain_tsensor_error_code : __int32
{
  bitmain_tsensor_error_code::TSENSOR_NO_ERROR = 0x0,
  bitmain_tsensor_error_code::TSENSOR_ERROR_COMMON = 0x80000600,
  bitmain_tsensor_error_code::TSENSOR_BAD_PARAM = 0x80000601,
};

/* 492 */
struct bitmain_power_t
{
  uint32_t power_fd;
  uint32_t power_open;
  uint32_t power_version;
  uint32_t power_fw_version;
  bool power_Calibrated;
  eeprom_data_t eeprom;
};

/* 493 */
enum bitmain_power_error_code : __int32
{
  bitmain_power_error_code::POWER_NO_ERROR = 0x0,
  bitmain_power_error_code::POWER_ERROR_COMMON = 0x80000300,
  bitmain_power_error_code::POWER_BAD_PARAM = 0x80000301,
  bitmain_power_error_code::POWER_NOT_SUPPORT = 0x80000302,
};

/* 494 */
typedef __int64 int64_t;

/* 495 */
enum bitmain_pic_error_code : __int32
{
  bitmain_pic_error_code::PIC_NO_ERROR = 0x0,
  bitmain_pic_error_code::PIC_ERROR_COMMON = 0x80000200,
  bitmain_pic_error_code::PIC_BAD_PARAM = 0x80000201,
  bitmain_pic_error_code::PIC_NOT_SUPPORT = 0x80000202,
};

/* 496 */
typedef _fpga_bt8d_t fpga_bt8d_t;

/* 497 */
struct sysinfo
{
  __kernel_long_t uptime;
  __kernel_ulong_t loads[3];
  __kernel_ulong_t totalram;
  __kernel_ulong_t freeram;
  __kernel_ulong_t sharedram;
  __kernel_ulong_t bufferram;
  __kernel_ulong_t totalswap;
  __kernel_ulong_t freeswap;
  __u16 procs;
  __u16 pad;
  __kernel_ulong_t totalhigh;
  __kernel_ulong_t freehigh;
  __u32 mem_unit;
  char _f[8];
};

/* 498 */
enum bitmain_eeprom_error_code : __int32
{
  bitmain_eeprom_error_code::EEPROM_NO_ERROR = 0x0,
  bitmain_eeprom_error_code::EEPROM_ERROR_COMMON = 0x80000100,
  bitmain_eeprom_error_code::EEPROM_BAD_PARAM = 0x80000101,
};

/* 499 */
typedef int clib_error;

/* 500 */
typedef int clib_bool;

/* 501 */
typedef unsigned int pthread_t;

/* 502 */
struct gpio_map_t
{
  pthread_mutex_t ctrl_mutex;
  clib_map *gpio_callback_map;
};

/* 504 */
union ifreq::$4AF2B49FDDB54BAFABDFAE063E6E4A98
{
  char ifrn_name[16];
};

/* 505 */
union ifreq::$08A4139B8351F6B925C0D8B85C61C082
{
  sockaddr ifru_addr;
  sockaddr ifru_dstaddr;
  sockaddr ifru_broadaddr;
  sockaddr ifru_netmask;
  sockaddr ifru_hwaddr;
  __int16 ifru_flags;
  int ifru_ivalue;
  int ifru_mtu;
  ifmap ifru_map;
  char ifru_slave[16];
  char ifru_newname[16];
  void *ifru_data;
  if_settings ifru_settings;
};

/* 503 */
struct ifreq
{
  ifreq::$4AF2B49FDDB54BAFABDFAE063E6E4A98 ifr_ifrn;
  ifreq::$08A4139B8351F6B925C0D8B85C61C082 ifr_ifru;
};

/* 506 */
enum __socket_type : __int32
{
  __socket_type::SOCK_STREAM = 0x1,
  __socket_type::SOCK_DGRAM = 0x2,
  __socket_type::SOCK_RAW = 0x3,
  __socket_type::SOCK_RDM = 0x4,
  __socket_type::SOCK_SEQPACKET = 0x5,
  __socket_type::SOCK_DCCP = 0x6,
  __socket_type::SOCK_PACKET = 0xA,
  __socket_type::SOCK_CLOEXEC = 0x80000,
  __socket_type::SOCK_NONBLOCK = 0x800,
};

/* 507 */
struct fix_pattern_file::pattern_struct_in_file
{
  unsigned __int8 midstate[8];
  uint32_t nonce;
};

/* 508 */
struct parse_bin_file_16midstate_sf::pattern_struct_in_file
{
  unsigned __int8 midstate[8];
  uint32_t nonce;
};

/* 509 */
enum SWEEP_ERROR_CODE : __int32
{
  SWEEP_ERROR_CODE::SWEEP_NO_ERR = 0x0,
  SWEEP_ERROR_CODE::SWEEP_PT2_FAIL = 0x1,
  SWEEP_ERROR_CODE::SWEEP_READ_EEPROM_FAIL = 0x2,
  SWEEP_ERROR_CODE::SWEEP_MAX_CHAIN = 0x3,
  SWEEP_ERROR_CODE::SWEEP_HAL_INIT_FAIL = 0x4,
  SWEEP_ERROR_CODE::SWEEP_FAN_INIT_FAIL = 0x5,
  SWEEP_ERROR_CODE::SWEEP_SENSOR_READ_FAIL = 0x6,
  SWEEP_ERROR_CODE::SWEEP_OPEN_PATTERN_FILE_FAIL = 0x7,
  SWEEP_ERROR_CODE::SWEEP_MEMORY_FULL = 0x8,
  SWEEP_ERROR_CODE::SWEEP_PATTERN_WORK_NOT_ENOUGH = 0x9,
  SWEEP_ERROR_CODE::SWEEP_ERR_POWER_NOT_CALIBRATE = 0xA,
  SWEEP_ERROR_CODE::SWEEP_ERR_POWER_ON_ERR = 0xB,
  SWEEP_ERROR_CODE::SWEEP_ERR_FIRST_FIND_ASIC = 0xC,
  SWEEP_ERROR_CODE::SWEEP_ERR_SECOND_FIND_ASIC = 0xD,
  SWEEP_ERROR_CODE::SWEEP_ERR_LEVEL_MATCH = 0xE,
  SWEEP_ERROR_CODE::SWEEP_ERR_HEATING = 0xF,
  SWEEP_ERROR_CODE::SWEEP_BASE_FREQ_ERR = 0x10,
  SWEEP_ERROR_CODE::SWEEP_CAN_NOT_DROP = 0x11,
};

/* 510 */
union unalign64
{
  U32 u32;
  U64 u64;
};

/* 511 */
union unalign
{
  U32 u32;
};

/* 512 */
enum XXH_errorcode : __int32
{
  XXH_OK = 0x0,
  XXH_ERROR = 0x1,
};

/* 513 */
enum LZ4F_lastBlockStatus : __int32
{
  notDone = 0x0,
  fromTmpBuffer = 0x1,
  fromSrcBuffer = 0x2,
};

/* 514 */
typedef int ptrdiff_t;

/* 515 */
enum repeat_state_e : __int32
{
  rep_untested = 0x0,
  rep_not = 0x1,
  rep_confirmed = 0x2,
};

/* 516 */
union LZ4_unalign
{
  U16 u16;
  U32 u32;
  reg_t uArch;
};

/* 517 */
typedef uintptr_t uptrval;

/* 518 */
struct op_sweep
{
  int (*init)(void *, void *);
  int (*sweep)(float **, uint8_t **);
  int (*drop)(float **, uint8_t **);
  int (*stop)(...);
  int (*flush)(float **);
  int (*check_status)(...);
};

/* 519 */
enum SWEEP_MODE : __int32
{
  SWEEP_MODE::HW_MODE = 0x0,
  SWEEP_MODE::SW_MODE = 0x1,
  SWEEP_MODE::PM_MODE = 0x2,
};

/* 520 */
typedef _work_cxt work_cxt;

/* 521 */
typedef _returned_nonce_counter_t returned_nonce_counter_t;

/* 522 */
typedef _tick_nonce_counter_t tick_nonce_counter_t;

/* 523 */
typedef _general_i2c_command_t general_i2c_command_t;

/* 524 */
struct pt1_ctx
{
  char factory_job[32];
  char chip_die[16];
  char chip_marking[16];
  char chip_ftversion[16];
  char temp_sensor_type[16];
  char hashboard_ctrl_code[16];
  char hashboard_index[16];
  char chip_tech[3];
  char board_name[9];
  char board_sn[32];
  int chip_bin;
};

/* 525 */
struct __dirstream;

/* 527 */
struct __attribute__((aligned(8))) pthread_cond_t::$37B88C9EDD6CA635C8B2267C69E10A67
{
  int __lock;
  unsigned int __futex;
  unsigned __int64 __total_seq;
  unsigned __int64 __wakeup_seq;
  unsigned __int64 __woken_seq;
  void *__mutex;
  unsigned int __nwaiters;
  unsigned int __broadcast_seq;
};

/* 526 */
union pthread_cond_t
{
  pthread_cond_t::$37B88C9EDD6CA635C8B2267C69E10A67 __data;
  char __size[48];
  __int64 __align;
};

/* 528 */
typedef __mode_t mode_t;

/* 529 */
typedef __time_t time_t;

/* 530 */
struct tm_0
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  int __tm_gmtoff;
  const char *__tm_zone;
};

/* 531 */
struct zhiju_eeprom_data_map
{
  uint8_t algorithm_and_key_version;
  uint8_t zhiju_information_length;
  zhiju_information zhiju_information;
};

/* 533 */
union ifreq_0::$4AF2B49FDDB54BAFABDFAE063E6E4A98
{
  char ifrn_name[16];
};

/* 534 */
union ifreq_0::$17ED3CA7772E9BBD734F9855D60E4536
{
  sockaddr ifru_addr;
  sockaddr ifru_dstaddr;
  sockaddr ifru_broadaddr;
  sockaddr ifru_netmask;
  sockaddr ifru_hwaddr;
  __int16 ifru_flags;
  int ifru_ivalue;
  int ifru_mtu;
  ifmap ifru_map;
  char ifru_slave[16];
  char ifru_newname[16];
  __caddr_t ifru_data;
};

/* 532 */
struct ifreq_0
{
  ifreq_0::$4AF2B49FDDB54BAFABDFAE063E6E4A98 ifr_ifrn;
  ifreq_0::$17ED3CA7772E9BBD734F9855D60E4536 ifr_ifru;
};

/* 535 */
struct ssl_ctx_st;

/* 536 */
struct ssl_st;

/* 537 */
enum __ns_sect : __int32
{
  __ns_sect::ns_s_qd = 0x0,
  __ns_sect::ns_s_zn = 0x0,
  __ns_sect::ns_s_an = 0x1,
  __ns_sect::ns_s_pr = 0x1,
  __ns_sect::ns_s_ns = 0x2,
  __ns_sect::ns_s_ud = 0x2,
  __ns_sect::ns_s_ar = 0x3,
  __ns_sect::ns_s_max = 0x4,
};

/* 539 */
union sigaction::$A0D7C018272EA30F374433AF4EA79BEE
{
  __sighandler_t sa_handler;
  void (*sa_sigaction)(int, siginfo_t *, void *);
};

/* 538 */
struct sigaction
{
  sigaction::$A0D7C018272EA30F374433AF4EA79BEE __sigaction_handler;
  __sigset_t sa_mask;
  int sa_flags;
  void (*sa_restorer)(void);
};

/* 548 */
const union $636B5B6A2AF01AF0A17EDFBBF647AFA3
{
  U32 u;
  BYTE c[4];
};

/* 549 */
typedef unsigned int __useconds_t;

/* 550 */
struct utsname
{
  char sysname[65];
  char nodename[65];
  char release[65];
  char version[65];
  char machine[65];
  char __domainname[65];
};

/* 551 */
union __attribute__((aligned(8))) __n64
{
  unsigned __int64 n64_u64[1];
  unsigned __int32 n64_u32[2];
  unsigned __int16 n64_u16[4];
  unsigned __int8 n64_u8[8];
  __int64 n64_i64[1];
  __int32 n64_i32[2];
  __int16 n64_i16[4];
  __int8 n64_i8[8];
  float n64_f32[2];
  double n64_f64[1];
};

/* 552 */
union __attribute__((aligned(8))) __n128
{
  unsigned __int64 n128_u64[2];
  unsigned __int32 n128_u32[4];
  unsigned __int16 n128_u16[8];
  unsigned __int8 n128_u8[16];
  __int64 n128_i64[2];
  __int32 n128_i32[4];
  __int16 n128_i16[8];
  __int8 n128_i8[16];
  float n128_f32[4];
  double n128_f64[2];
};

/* 553 */
typedef __n64 int8x8_t;

/* 554 */
typedef __n64 uint8x8_t;

/* 555 */
typedef __n64 int16x4_t;

/* 556 */
typedef __n64 int32x2_t;

/* 557 */
typedef __n64 uint16x4_t;

/* 558 */
typedef __n64 uint32x2_t;

/* 559 */
typedef __n128 int8x16_t;

/* 560 */
typedef __n128 int16x8_t;

/* 561 */
typedef __n128 int32x4_t;

/* 562 */
typedef __n128 int64x2_t;

/* 563 */
typedef __n128 uint8x16_t;

/* 564 */
typedef __n128 uint16x8_t;

/* 565 */
typedef __n128 uint32x4_t;

/* 566 */
typedef __n128 uint64x2_t;

/* 567 */
typedef __n64 poly8x8_t;

/* 568 */
typedef __n64 poly16x4_t;

/* 569 */
typedef __n128 poly16x8_t;

/* 570 */
typedef __n128 poly8x16_t;

/* 571 */
typedef __n64 float16x4_t;

/* 572 */
typedef __n64 float32x2_t;

/* 573 */
typedef __n128 float16x8_t;

/* 574 */
typedef __n128 float32x4_t;

/* 575 */
typedef __n128 float64x2_t;

/* 576 */
typedef __n128 poly128_t;

/* 577 */
typedef int16x4_t int16x2_t;

/* 578 */
typedef uint16x4_t uint16x2_t;

/* 579 */
typedef float16x4_t float16x2_t;


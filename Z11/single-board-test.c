/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_10DEC();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// void *calloc(size_t nmemb, size_t size);
// char *strstr(const char *haystack, const char *needle);
// int raise(int sig);
// void setbuf(FILE *stream, char *buf);
// int strcmp(const char *s1, const char *s2);
// int printf(const char *format, ...);
// int _isoc99_fscanf(_DWORD, const char *, ...); weak
// FILE *fopen(const char *filename, const char *modes);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int fflush(FILE *stream);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_detach(pthread_t th);
// pthread_t pthread_self(void);
// void *memcpy(void *dest, const void *src, size_t n);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// time_t time(time_t *timer);
// __off_t lseek(int fd, __off_t offset, int whence);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
// int memcmp(const void *s1, const void *s2, size_t n);
// unsigned int sleep(unsigned int seconds);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int pthread_cond_destroy(pthread_cond_t *cond);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strcat(char *dest, const char *src);
// int usleep(__useconds_t useconds);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int puts(const char *s);
// void *malloc(size_t size);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// struct tm *localtime(const time_t *timer);
// int _gmon_start__(void); weak
// int open(const char *file, int oflag, ...);
// void exit(int status);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// size_t strlen(const char *s);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// int fprintf(FILE *stream, const char *format, ...);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// void *memset(void *s, int c, size_t n);
// int putchar(int c);
// int pthread_cancel(pthread_t th);
// ssize_t write(int fd, const void *buf, size_t n);
// int fileno(FILE *stream);
// int fclose(FILE *stream);
// int munmap(void *addr, size_t len);
// int pthread_join(pthread_t th, void **thread_return);
// int sprintf(char *s, const char *format, ...);
// int _isoc99_scanf(const char *, ...); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int fseek(FILE *stream, int off, int whence);
// int isatty(int fd);
// int pthread_cond_signal(pthread_cond_t *cond);
// void abort(void);
// int close(int fd);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...);
int call_weak_fn();
int *deregister_tm_clones();
__int64 register_tm_clones();
int *_do_global_dtors_aux();
__int64 frame_dummy();
__int64 __fastcall load64(unsigned __int8 *a1);
_DWORD *__fastcall store32(_DWORD *result, int a2);
_DWORD *__fastcall store64(_DWORD *result, int a2, int a3, int a4);
unsigned __int64 __fastcall rotr64(unsigned __int64 a1, char a2);
void *__fastcall secure_zero_memory(void *a1, size_t a2);
int __fastcall blake2b_set_lastnode(int a1);
bool __fastcall blake2b_is_lastblock(int a1);
int __fastcall blake2b_set_lastblock(int a1);
int __fastcall blake2b_increment_counter(int a1, unsigned __int64 a2);
int __fastcall blake2b_init0(void *a1);
int __fastcall blake2b_init_param(void *a1, int a2);
int __fastcall blake2b_init(void *a1, unsigned __int8 a2);
int __fastcall blake2b_init_key(void *a1, unsigned __int8 a2, const void *a3, unsigned __int8 a4);
int __fastcall blake2b_compress(_QWORD *a1, int a2);
int __fastcall blake2b_update(int a1, char *a2, unsigned __int64 a3);
int __fastcall blake2b_final(int a1, void *a2, unsigned __int8 a3);
int __fastcall blake2b(void *a1, char *a2, const void *a3, unsigned __int8 a4, unsigned __int64 a5, unsigned __int8 a6);
__int64 now();
size_t __fastcall midd_ioctl(unsigned __int8 a1, int a2, int a3);
int __fastcall target_zero_cal(int a1);
int __fastcall targetValidator(const void *a1, const void *a2);
size_t __fastcall read_register(int a1, char a2, char a3, char a4);
size_t __fastcall write_register_2(int a1, char a2, char a3, char a4, int a5);
size_t __fastcall write_register(char a1, int a2);
int set_i2c_enable();
int __fastcall i2c_status(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall i2c_recv(unsigned __int8 a1, unsigned __int8 a2, char a3, char a4, _DWORD *a5);
size_t __fastcall i2c_send(unsigned __int8 a1, char a2, char a3, char a4, char a5);
void asic_num_calculate();
int __fastcall calculate_asic_number(unsigned int a1);
int asic_addr_interval();
size_t __fastcall set_frequency(int a1);
int __fastcall set_frequency_scanfreq(int result);
int __fastcall set_ticket_mask(int result);
size_t set_io_drive_strength();
size_t __fastcall set_baud_chain(size_t result);
int set_address();
size_t __fastcall set_core_timeout(size_t result);
size_t __fastcall set_txn_data(size_t result);
size_t __fastcall set_nonce_shift(char a1);
size_t __fastcall set_pt_ctrl(size_t result, char a2);
size_t __fastcall set_pt_result(size_t result, char a2);
int __fastcall x86_tty_open(int a1, int a2);
int x86_tty_close();
int __fastcall x86_tty_init(int a1, int a2);
int nonce_scanhash(); // weak
void __noreturn nonce_scanhash_loop();
int __fastcall nonce_integrality(unsigned __int8 a1, unsigned __int8 a2, int a3, int a4);
int clear_nonce_fifo();
int __fastcall pm_handle(int a1, int a2, unsigned __int8 a3);
FILE *__fastcall pt_handle(int a1, int a2, unsigned __int8 a3);
int __fastcall reg_handle(int a1, char a2, char a3);
int __fastcall nonce_handle(int a1, int a2, _BYTE *a3, int a4, char a5);
_DWORD *__fastcall add_point(_DWORD *result, int a2);
void __noreturn handle_asic_response();
int bm1744_app_init();
int bm1744_app_exit();
int __fastcall work_list_insert(char a1, const void *a2);
int __fastcall work_list_find(char a1, void *a2);
size_t __fastcall send_work(unsigned __int8 *a1, char a2, char a3);
int __fastcall read_sensor(unsigned __int8 a1, int a2, char a3, unsigned __int8 a4, _BYTE *a5);
void app_config_init_registers();
void __noreturn rw_register_loop();
int __fastcall get_bt8d_from_baud(int a1);
int __fastcall get_index_by_freq(int a1);
int __fastcall get_freq_by_index(int a1);
int __fastcall get_plldata(int result, _DWORD *a2);
int __fastcall makeup_work_pkg(void *a1, _BYTE *a2);
int __fastcall makeup_set_address_cmd(int a1, unsigned int a2, char a3);
int __fastcall makeup_set_config_cmd(int a1, unsigned int a2, char a3, char a4, char a5, unsigned int a6);
int __fastcall makeup_get_status_cmd(int a1, unsigned int a2, char a3, char a4, char a5);
int __fastcall makeup_chain_inactive_cmd(int a1, unsigned int a2);
int __fastcall pack_ioctl_pkg(void *a1, unsigned int a2, int a3, int a4);
int __fastcall add_reg_item(int a1, int a2, int a3);
int __fastcall read_reg_item(unsigned __int8 *a1, int a2);
int reg_scan_aging();
int reg_scan_init();
int reg_scan_exit();
unsigned int __fastcall _bswap_32(unsigned int a1);
unsigned int __fastcall compressArray(int a1, int a2, int a3, unsigned int a4, unsigned int a5, unsigned int a6);
unsigned int __fastcall expandArray(int a1, unsigned int a2, int a3, int a4, unsigned int a5, unsigned int a6);
unsigned int __fastcall getIndices(int a1, int a2, int a3, int a4, int a5, unsigned int a6);
int __fastcall isZero(int a1, unsigned int a2);
int __fastcall generateHash(const void *a1, int a2, void *a3, unsigned __int8 a4);
int __fastcall compareSR(const void *a1, const void *a2);
int __fastcall sort_pair(int result, unsigned int a2);
int __fastcall sortValidator(_DWORD *a1, int a2);
void *__fastcall zcashPerson(_DWORD *a1, int a2, int a3);
int __fastcall digestInit(void *a1, int a2, int a3);
int __fastcall CRC5(_BYTE *a1, unsigned __int8 a2);
int __fastcall CRC16(_BYTE *a1, __int16 a2);
int bitmain_axi_init();
int bitmain_axi_close();
int __fastcall read_axi_fpga(int a1);
int __fastcall write_axi_fpga(int result, int a2);
int init_fpga();
int __fastcall get_return_nonce(int *a1);
int __fastcall set_BC_command_buffer(int *a1);
int get_BC_write_command();
int __fastcall set_BC_write_command(int a1);
int __fastcall asic_baud_to_fpga_baud(unsigned __int8 a1);
int __fastcall set_fpga_baud(unsigned __int8 a1);
int __fastcall i2c_write(int a1);
int __fastcall i2c_read(int a1);
int __fastcall ISL_page_enable(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
int __fastcall ISL_on(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall ISL_off(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall ISL_set_on_off_config(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
int __fastcall ISL_set_clear_faults(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall ISL_set_write_protect(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
int __fastcall ISL_set_vout_command(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int16 a4);
int __fastcall ISL_set_apply_settings(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall ISL_get_voltage(unsigned __int8 a1, unsigned __int8 a2, char a3, _WORD *a4);
int __fastcall ISL_read_reg_default(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __fastcall ISL_set_voltage(unsigned __int8 a1, unsigned __int8 a2, char a3, unsigned __int16 a4);
int open_key();
int close_key();
int __fastcall read_key(char a1);
int open_lcd();
int close_lcd();
unsigned int __fastcall write_lcd(unsigned int result, int a2, unsigned int a3);
unsigned int __fastcall write_lcd_no_memset(unsigned int result, int a2, unsigned int a3);
int open_red_led();
int close_red_led();
ssize_t red_led_on();
ssize_t red_led_off();
int open_green_led();
int close_green_led();
ssize_t green_led_on();
ssize_t green_led_off();
int __fastcall main(int argc, const char **argv, const char **envp);
void miner_start();
void miner_join();
int __fastcall print_solver_line(int a1, int a2, int a3, int a4);
int __fastcall set_baud(size_t a1);
int bm1744_hashboard_init();
void *show_nonce_detail();
void __noreturn singleboard_sensor_test(); // weak
int singleboard_set_address_test();
size_t __fastcall singleboard_step_increase_frequency(int a1, int a2);
size_t singleboard_nonce_test();
unsigned int singleboard_patten_test();
int pcba_test();
int __fastcall vol_init(unsigned __int16 a1);
int __fastcall isl_communication_check(unsigned __int16 a1);
int start_single_board_test();
int hw_test_customized();
int pcba_app_manual_test();
int start_pcba_test();
int __fastcall write_pic(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall read_pic(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall write_dc_dc(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4, int a5, int a6);
int __fastcall read_dc_dc(unsigned __int8 a1, unsigned __int8 a2, char a3, char a4, int a5, int a6);
int __fastcall set_PIC16F1704_flash_pointer(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall send_data_to_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3);
int __fastcall read_PIC16F1704_flash_pointer(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 *a3, unsigned __int8 *a4);
int __fastcall read_PIC16F1704_flash_data(unsigned __int8 a1, unsigned __int8 a2, int a3);
int __fastcall erase_PIC16F1704_flash(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall write_data_into_PIC16F1704_flash(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall jump_from_loader_to_app_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall reset_PIC16F1704_pic(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall set_PIC16F1704_voltage(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall write_hash_ID_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3);
int __fastcall read_hash_id_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3);
int __fastcall enable_PIC16F1704_dc_dc(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall heart_beat_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2);
void __fastcall __noreturn pic_heart_beat_func(unsigned __int8 *a1);
int __fastcall get_PIC16F1704_software_version(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 *a3);
int __fastcall PIC16F1704_i2c_forward_send(unsigned __int8 a1, unsigned __int8 a2, char a3, int a4, char a5, size_t n, unsigned __int8 *src);
int __fastcall set_PIC16F1704_voltage_z9(int result, unsigned __int8 a2, __int16 a3);
int __fastcall get_PIC16F1704_voltage_z9(int result, unsigned __int8 a2);
int __fastcall get_PIC16F1704_voltage(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 *a3);
int __fastcall write_temperature_offset_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3);
int __fastcall read_temperature_offset_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3);
int __fastcall erase_PIC16F1704_app_flash(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall PIC1704_update_pic_app_program(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall save_freq_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, unsigned __int16 a3);
int __fastcall get_PIC16F1704_freq(unsigned __int8 a1, unsigned __int8 a2, unsigned __int16 *a3);
int __fastcall set_temperature_offset_value(unsigned __int8 a1, unsigned __int8 a2, int a3);
int __fastcall write_PIC16F1705_iic_slave(unsigned __int8 a1, unsigned __int8 a2, int a3, unsigned __int8 a4);
int __fastcall read_PIC16F1705_iic_slave(unsigned __int8 a1, unsigned __int8 a2, int a3, unsigned __int8 a4);
int __fastcall write_data_to_PIC16F1704_flash(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 *a3, signed int a4);
int __fastcall read_data_from_PIC16F1704_flash(unsigned __int8 a1, unsigned __int8 a2, void *a3, unsigned __int8 a4);
int get_fan_speed();
int __fastcall set_fan_speed(int a1);
int __fastcall fan_control(char a1);
int __fastcall uart_open(const char *a1, _DWORD *a2);
int __fastcall uart_close(int a1);
unsigned int __fastcall check_how_many_uart_data_in_fpga(unsigned __int8 a1);
int __fastcall read_uart_data_in_fpga(unsigned __int8 a1, int a2, unsigned int a3);
size_t __fastcall uart_send(unsigned __int8 a1, const void *a2, size_t a3);
int __fastcall uart_receive(unsigned __int8 a1, int a2, unsigned int a3);
int __fastcall clear_uart_send_fifo(unsigned __int8 a1);
int __fastcall clear_uart_rx_fifo(unsigned __int8 a1);
int cgpu_init();
int cgpu_exit();
ssize_t __fastcall v9_key_read(void *a1, size_t a2);
ssize_t display_arguments();
int check_chain();
unsigned int V9_print_lcd();
unsigned int __fastcall V9_print_lcd_type(int a1);
int __fastcall is_asic_pass(int a1);
int show_stats_func_z11_3chips();
int show_stats_func_z9_4chips();
int show_stats_func_z9_16chips();
int singleBoardTest_V9_BM1744_manual();
int singleBoardTest_V9_BM1744();
void *__fastcall get_app_config(void *a1);
int __fastcall app_config_handle(const char *a1);
int __fastcall crc_itu_t_byte(__int16 a1, char a2);
int __fastcall CRC16_v1(char *a1, int a2);
int __fastcall CRC5_v1(_BYTE *a1, unsigned __int8 a2);
int power_init();
void power_exit();
int power_up();
int power_down();
int __fastcall my_log_curses(int result, const char *a2, const char *a3, char a4);
int __fastcall applog(int a1, const char *a2, char a3);
int __fastcall simplelog(int a1, const char *a2, char a3);
int patten_info_init();
int patten_info_destory();
int patten_load();
int __fastcall is_patten_match(int a1, const void *a2, const void *a3);
int display_single_board_test();
void *clear_last_test_results();
int __fastcall rt_ringbuffer_get_size(int a1);
int __fastcall rt_ringbuffer_status(int a1);
int __fastcall rt_ringbuffer_data_len(_WORD *a1);
int __fastcall rt_ringbuffer_init(int a1, int a2, __int16 a3, int a4);
int __fastcall rt_ringbuffer_lock_destory(int a1);
int __fastcall rt_ringbuffer_put(int a1, char *a2, unsigned __int16 a3);
int __fastcall rt_ringbuffer_put_force(int a1, char *a2, unsigned __int16 a3);
int __fastcall rt_ringbuffer_get(int a1, char *a2, unsigned __int16 a3);
int __fastcall rt_ringbuffer_prefetch(_WORD *a1, char *a2, unsigned __int16 a3);
int __fastcall sha256_transf(int result, int a2, int a3);
int __fastcall sha256(char *a1, unsigned int a2, int a3);
_DWORD *__fastcall sha256_init(_DWORD *result);
void *__fastcall sha256_update(_DWORD *a1, char *a2, unsigned int a3);
int __fastcall sha256_final(_DWORD *a1, int a2);
_DWORD *__fastcall Sha256_Init(_DWORD *result);
_BYTE *__fastcall Sha256_Transform(_BYTE *result, int a2);
_BYTE *__fastcall Sha256_WriteByteBlock(_BYTE *a1);
_BYTE *__fastcall Sha256_Update(_BYTE *result, _BYTE *a2, int a3);
_DWORD *__fastcall Sha256_Final(int a1, _BYTE *a2);
_DWORD *__fastcall Sha256_Onestep(_BYTE *a1, int a2, _BYTE *a3);
_DWORD *__fastcall sha2_starts(_DWORD *result);
int __fastcall sha2_process(_DWORD *a1, unsigned int *a2);
_DWORD *__fastcall sha2_update(_DWORD *result, unsigned int *a2, int a3);
_DWORD *__fastcall sha2_finish(_DWORD *a1, _BYTE *a2);
void *__fastcall sha2(unsigned int *a1, int a2, _BYTE *a3);
unsigned int __fastcall swab32(unsigned int a1);
unsigned int __fastcall flip_swab(unsigned int result, int a2, unsigned int a3);
unsigned int __fastcall flip32(unsigned int result, int a2);
int __fastcall slt_notify_ui(int result, int a2);
int slt_init();
int slt_exit();
_BYTE *__fastcall _bin2hex(_BYTE *result, int a2, int a3);
_BYTE *__fastcall bin2hex(int a1, int a2);
int __fastcall hex2bin(_BYTE *a1, unsigned __int8 *a2, int a3);
int __fastcall swap_bit(unsigned __int8 a1);
void __fastcall dump_str(FILE *a1, const char *a2, int a3, int a4);
int __fastcall bit_read(int a1, int a2);
_DWORD *__fastcall swab256(_DWORD *result, unsigned int *a2);
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2);
int _aeabi_ldiv0();
void __fastcall init(int argc, char **argv, char **envp);
void _libc_csu_fini(); // idb
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_12520; // weak
_UNKNOWN loc_12528; // weak
_UNKNOWN loc_12538; // weak
_UNKNOWN loc_1253C; // weak
_UNKNOWN loc_12540; // weak
_UNKNOWN loc_12544; // weak
_UNKNOWN locret_12548; // weak
_UNKNOWN loc_1254C; // weak
_UNKNOWN loc_12550; // weak
_UNKNOWN loc_12554; // weak
_UNKNOWN loc_333F0; // weak
_QWORD blake2b_IV[8] =
{
  7640891576956012808LL,
  -4942790177534073029LL,
  4354685564936845355LL,
  -6534734903238641935LL,
  5840696475078001361LL,
  -7276294671716946913LL,
  2270897969802886507LL,
  6620516959819538809LL
}; // weak
_BYTE chCRCHTalbe[256] =
{
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64
}; // weak
_BYTE chCRCLTalbe[256] =
{
  0,
  -64,
  -63,
  1,
  -61,
  3,
  2,
  -62,
  -58,
  6,
  7,
  -57,
  5,
  -59,
  -60,
  4,
  -52,
  12,
  13,
  -51,
  15,
  -49,
  -50,
  14,
  10,
  -54,
  -53,
  11,
  -55,
  9,
  8,
  -56,
  -40,
  24,
  25,
  -39,
  27,
  -37,
  -38,
  26,
  30,
  -34,
  -33,
  31,
  -35,
  29,
  28,
  -36,
  20,
  -44,
  -43,
  21,
  -41,
  23,
  22,
  -42,
  -46,
  18,
  19,
  -45,
  17,
  -47,
  -48,
  16,
  -16,
  48,
  49,
  -15,
  51,
  -13,
  -14,
  50,
  54,
  -10,
  -9,
  55,
  -11,
  53,
  52,
  -12,
  60,
  -4,
  -3,
  61,
  -1,
  63,
  62,
  -2,
  -6,
  58,
  59,
  -5,
  57,
  -7,
  -8,
  56,
  40,
  -24,
  -23,
  41,
  -21,
  43,
  42,
  -22,
  -18,
  46,
  47,
  -17,
  45,
  -19,
  -20,
  44,
  -28,
  36,
  37,
  -27,
  39,
  -25,
  -26,
  38,
  34,
  -30,
  -29,
  35,
  -31,
  33,
  32,
  -32,
  -96,
  96,
  97,
  -95,
  99,
  -93,
  -94,
  98,
  102,
  -90,
  -89,
  103,
  -91,
  101,
  100,
  -92,
  108,
  -84,
  -83,
  109,
  -81,
  111,
  110,
  -82,
  -86,
  106,
  107,
  -85,
  105,
  -87,
  -88,
  104,
  120,
  -72,
  -71,
  121,
  -69,
  123,
  122,
  -70,
  -66,
  126,
  127,
  -65,
  125,
  -67,
  -68,
  124,
  -76,
  116,
  117,
  -75,
  119,
  -73,
  -74,
  118,
  114,
  -78,
  -77,
  115,
  -79,
  113,
  112,
  -80,
  80,
  -112,
  -111,
  81,
  -109,
  83,
  82,
  -110,
  -106,
  86,
  87,
  -105,
  85,
  -107,
  -108,
  84,
  -100,
  92,
  93,
  -99,
  95,
  -97,
  -98,
  94,
  90,
  -102,
  -101,
  91,
  -103,
  89,
  88,
  -104,
  -120,
  72,
  73,
  -119,
  75,
  -117,
  -118,
  74,
  78,
  -114,
  -113,
  79,
  -115,
  77,
  76,
  -116,
  68,
  -124,
  -123,
  69,
  -121,
  71,
  70,
  -122,
  -126,
  66,
  67,
  -125,
  65,
  -127,
  128,
  64
}; // weak
_BYTE isl68127_i2c_dev_addr[4] = { 80, 81, 84, 85 }; // weak
_WORD crc_itu_t_table[256] =
{
  0,
  4129,
  8258,
  12387,
  16516,
  20645,
  24774,
  28903,
  -32504,
  -28375,
  -24246,
  -20117,
  -15988,
  -11859,
  -7730,
  -3601,
  4657,
  528,
  12915,
  8786,
  21173,
  17044,
  29431,
  25302,
  -27847,
  -31976,
  -19589,
  -23718,
  -11331,
  -15460,
  -3073,
  -7202,
  9314,
  13379,
  1056,
  5121,
  25830,
  29895,
  17572,
  21637,
  -23190,
  -19125,
  -31448,
  -27383,
  -6674,
  -2609,
  -14932,
  -10867,
  13907,
  9842,
  5649,
  1584,
  30423,
  26358,
  22165,
  18100,
  -18597,
  -22662,
  -26855,
  -30920,
  -2081,
  -6146,
  -10339,
  -14404,
  18628,
  22757,
  26758,
  30887,
  2112,
  6241,
  10242,
  14371,
  -13876,
  -9747,
  -5746,
  -1617,
  -30392,
  -26263,
  -22262,
  -18133,
  23285,
  19156,
  31415,
  27286,
  6769,
  2640,
  14899,
  10770,
  -9219,
  -13348,
  -1089,
  -5218,
  -25735,
  -29864,
  -17605,
  -21734,
  27814,
  31879,
  19684,
  23749,
  11298,
  15363,
  3168,
  7233,
  -4690,
  -625,
  -12820,
  -8755,
  -21206,
  -17141,
  -29336,
  -25271,
  32407,
  28342,
  24277,
  20212,
  15891,
  11826,
  7761,
  3696,
  -97,
  -4162,
  -8227,
  -12292,
  -16613,
  -20678,
  -24743,
  -28808,
  -28280,
  -32343,
  -20022,
  -24085,
  -12020,
  -16083,
  -3762,
  -7825,
  4224,
  161,
  12482,
  8419,
  20484,
  16421,
  28742,
  24679,
  -31815,
  -27752,
  -23557,
  -19494,
  -15555,
  -11492,
  -7297,
  -3234,
  689,
  4752,
  8947,
  13010,
  16949,
  21012,
  25207,
  29270,
  -18966,
  -23093,
  -27224,
  -31351,
  -2706,
  -6833,
  -10964,
  -15091,
  13538,
  9411,
  5280,
  1153,
  29798,
  25671,
  21540,
  17413,
  -22565,
  -18438,
  -30823,
  -26696,
  -6305,
  -2178,
  -14563,
  -10436,
  9939,
  14066,
  1681,
  5808,
  26199,
  30326,
  17941,
  22068,
  -9908,
  -13971,
  -1778,
  -5841,
  -26168,
  -30231,
  -18038,
  -22101,
  22596,
  18533,
  30726,
  26663,
  6336,
  2273,
  14466,
  10403,
  -13443,
  -9380,
  -5313,
  -1250,
  -29703,
  -25640,
  -21573,
  -17510,
  19061,
  23124,
  27191,
  31254,
  2801,
  6864,
  10931,
  14994,
  -722,
  -4849,
  -8852,
  -12979,
  -16982,
  -21109,
  -25112,
  -29239,
  31782,
  27655,
  23652,
  19525,
  15522,
  11395,
  7392,
  3265,
  -4321,
  -194,
  -12451,
  -8324,
  -20581,
  -16454,
  -28711,
  -24584,
  28183,
  32310,
  20053,
  24180,
  11923,
  16050,
  3793,
  7920
}; // weak
char byte_36B34[4] = { '\0', '\0', '\0', '\0' }; // weak
_DWORD K[64] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998
}; // weak
unsigned int sha2_padding[16] = { 128u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }; // weak
_DWORD hex2bin_tbl[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // weak
_BYTE hex_6139[16] = { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102 }; // weak
_UNKNOWN *_frame_dummy_init_array_entry = (_UNKNOWN *)0x111A5; // weak
_UNKNOWN *_do_global_dtors_aux_fini_array_entry = (_UNKNOWN *)0x1118D; // weak
void *(*memset_v_5089)(void *s, int c, size_t n) = &memset; // weak
char g_new_work = '\x01'; // weak
int g_pll_parameter = -2144337391; // weak
int g_ticket_mask = 5; // weak
int g_misc_control = 117455361; // weak
int g_core_timeout = -1; // weak
int g_io_drive_strength = 34677009; // weak
int g_nonce_shift = 20; // weak
int addr_interval = 85; // weak
_UNKNOWN *status_period_8880 = &unk_7A120; // weak
_UNKNOWN baud_BT8D_values; // weak
_DWORD freq_pll[404] =
{
  25,
  0,
  0,
  2359654,
  100,
  131136,
  1056,
  2097729,
  125,
  163904,
  1056,
  2622017,
  150,
  196672,
  1056,
  3146305,
  175,
  229440,
  1056,
  3670593,
  200,
  262208,
  1056,
  4194881,
  225,
  294976,
  1056,
  4719169,
  250,
  327744,
  1056,
  5243457,
  275,
  360512,
  1056,
  5767745,
  300,
  393280,
  1056,
  6292033,
  325,
  426048,
  1056,
  6816321,
  350,
  458816,
  1056,
  7340609,
  375,
  491584,
  1056,
  7864897,
  400,
  524352,
  1056,
  8389185,
  404,
  397376,
  800,
  6357553,
  406,
  266304,
  544,
  4260385,
  408,
  401472,
  800,
  6423089,
  412,
  270400,
  544,
  4325921,
  416,
  409664,
  800,
  6554161,
  418,
  274496,
  544,
  4391457,
  420,
  413760,
  800,
  6619697,
  425,
  278592,
  544,
  4456993,
  429,
  421952,
  800,
  6750769,
  431,
  282688,
  544,
  4522529,
  433,
  426048,
  800,
  6816305,
  437,
  286784,
  544,
  4588065,
  441,
  434240,
  800,
  6947377,
  443,
  290880,
  544,
  4653601,
  445,
  438336,
  800,
  7012913,
  450,
  294976,
  544,
  4719137,
  454,
  446528,
  800,
  7143985,
  456,
  299072,
  544,
  4784673,
  458,
  450624,
  800,
  7209521,
  462,
  303168,
  544,
  4850209,
  466,
  458816,
  800,
  7340593,
  468,
  307264,
  544,
  4915745,
  470,
  462912,
  800,
  7406129,
  475,
  311360,
  544,
  4981281,
  479,
  471104,
  800,
  7537201,
  481,
  315456,
  544,
  5046817,
  483,
  475200,
  800,
  7602737,
  487,
  319552,
  544,
  5112353,
  491,
  483392,
  800,
  7733809,
  493,
  323648,
  544,
  5177889,
  495,
  487488,
  800,
  7799345,
  500,
  327744,
  544,
  5243425,
  504,
  495680,
  800,
  7930417,
  506,
  331840,
  544,
  5308961,
  508,
  499776,
  800,
  7995953,
  512,
  335936,
  544,
  5374497,
  516,
  507968,
  800,
  8127025,
  518,
  340032,
  544,
  5440033,
  520,
  512064,
  800,
  8192561,
  525,
  344128,
  544,
  5505569,
  529,
  520256,
  800,
  8323633,
  531,
  348224,
  544,
  5571105,
  533,
  524352,
  800,
  8389169,
  537,
  352320,
  544,
  5636641,
  543,
  356416,
  544,
  5702177,
  550,
  360512,
  544,
  5767713,
  556,
  364608,
  544,
  5833249,
  562,
  368704,
  544,
  5898785,
  568,
  372800,
  544,
  5964321,
  575,
  376896,
  544,
  6029857,
  581,
  380992,
  544,
  6095393,
  587,
  385088,
  544,
  6160929,
  593,
  389184,
  544,
  6226465,
  600,
  393280,
  544,
  6292001,
  606,
  397376,
  544,
  6357537,
  612,
  401472,
  544,
  6423073,
  618,
  405568,
  544,
  6488609,
  625,
  409664,
  544,
  6554145,
  631,
  413760,
  544,
  6619681,
  637,
  417856,
  544,
  6685217,
  643,
  421952,
  544,
  6750753,
  650,
  426048,
  544,
  6816289,
  656,
  430144,
  544,
  6881825,
  662,
  434240,
  544,
  6947361,
  668,
  438336,
  544,
  7012897,
  675,
  442432,
  544,
  7078433,
  681,
  446528,
  544,
  7143969,
  687,
  450624,
  544,
  7209505,
  693,
  454720,
  544,
  7275041,
  700,
  458816,
  544,
  7340577,
  706,
  462912,
  544,
  7406113,
  712,
  467008,
  544,
  7471649,
  718,
  471104,
  544,
  7537185,
  725,
  475200,
  544,
  7602721,
  731,
  479296,
  544,
  7668257,
  737,
  483392,
  544,
  7733793,
  743,
  487488,
  544,
  7799329,
  750,
  491584,
  544,
  7864865,
  756,
  495680,
  544,
  7930401,
  762,
  499776,
  544,
  7995937,
  768,
  503872,
  544,
  8061473,
  775,
  507968,
  544,
  8127009,
  781,
  512064,
  544,
  8192545,
  787,
  516160,
  544,
  8258081,
  793,
  520256,
  544,
  8323617,
  800,
  524352,
  544,
  8389153,
  825,
  270400,
  288,
  4325905
}; // weak
int alive = 1; // weak
int compare_size = 3; // weak
char lcd_output[2] = " "; // weak
char dword_47B4C[] = { '\0', '\0', '\0', '\0' }; // idb
int dword_47B50 = 0; // weak
int dword_47B54 = 0; // weak
int dword_47B58 = 0; // weak
char byte_47B5C[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char s[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_BYTE isl_dev_addr[4] = { 80, 81, 84, 0 }; // weak
char gChain = '\xFF'; // weak
int opt_log_level = 2; // weak
_DWORD sha256_h0[8] =
{
  1779033703,
  -1150833019,
  1013904242,
  -1521486534,
  1359893119,
  -1694144372,
  528734635,
  1541459225
}; // weak
_DWORD sha256_k[64] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998
}; // weak
int _bss_start; // weak
int stdin; // weak
int stdout; // weak
char completed_9251; // weak
char total_work; // weak
int g_general_i2c_command; // weak
int g_pt_ctrl; // weak
int nonce_num_each_asic[]; // weak
int dword_47E00; // weak
int dword_47E04; // weak
int nonce_invalid_num_each_asic[3]; // weak
int nonce_invalid_num_each_asic_2[]; // weak
int dword_47E18; // weak
int dword_47E1C; // weak
int dword_47E20; // weak
int dword_47E24; // weak
int dword_47E28; // weak
int one_work_nonce_each_asic[]; // weak
int dword_47E30; // weak
int dword_47E34; // weak
int one_work_invalid_nonce_each_asic[3]; // weak
_DWORD one_work_invalid_nonce_each_asic_2[6]; // weak
int valid_nonce_total; // weak
int invalid_nonce_total; // weak
int submit_nonce; // weak
_DWORD asic_num[1]; // weak
char sensor_chip_addr[]; // weak
char byte_47E6D; // weak
pthread_mutex_t g_rt_nonce_mutex; // weak
pthread_mutex_t nonce_mutex; // weak
char pattern_test_crc_error; // weak
char g_txok_test_enable; // weak
char start_recv; // weak
int g_work_list_insert_index; // weak
pthread_mutex_t g_work_list_mutex; // weak
int total_8876; // weak
int golden_nonce_8875; // weak
int total_shares_8877; // weak
__int64 t1_8879; // weak
__int64 t0_8878; // weak
int txok_flag_8982; // weak
int total_error_8981; // weak
int reg_scan_items[300]; // weak
pthread_mutex_t reg_scan_mutex; // weak
int p_reg_scan; // weak
int fpga_mem_addr; // weak
int axi_fpga_addr; // weak
int red_led_fd; // weak
int green_led_fd; // weak
int set_address_test_result; // weak
int read_temp_test_result; // weak
int tempture_value_test_result; // weak
char nonce_test_asic_result[]; // weak
char byte_483E5; // weak
char byte_483E6; // weak
pthread_mutex_t i2c_mutex; // weak
pthread_mutex_t uart_send_mutex[1]; // weak
pthread_mutex_t uart_receive_mutex[1]; // weak
_BYTE gChain_exist[4]; // weak
_UNKNOWN gChain_fd; // weak
char gI2c; // weak
int show_id_alive; // weak
char use_syslog; // weak
char opt_quiet; // weak
char opt_debug; // weak
char opt_log_output; // weak
pthread_mutex_t console_lock; // weak
int p_scanhash; // weak
int g_chain[8]; // weak
_UNKNOWN g_rt_nonce; // weak
_BYTE g_work_list[1412]; // weak
char sensor_info[]; // weak
char byte_48F51; // weak
char byte_48F54; // weak
char byte_48F55; // weak
_UNKNOWN unk_493E0; // weak
_UNKNOWN g_work_header; // weak
int nonce_fifo; // weak
int dword_49DF0; // weak
int dword_49DF4; // weak
_UNKNOWN unk_61A80; // weak
_UNKNOWN unk_7A120; // weak
int fd_fpga_mem; // weak
int fd_fpga; // weak
_UNKNOWN g_work_info; // weak
_UNKNOWN unk_F32D4; // weak
int dword_F3460; // weak
_UNKNOWN cgpu; // weak
pthread_t dword_F3484; // idb
pthread_t newthread; // idb
int dword_F34A0; // weak
int dword_F34A8; // weak
int dword_F34C8; // weak
_BYTE chain_info[4]; // weak
int app_conf; // weak
char byte_F34E0[40]; // weak
int dword_F3508; // weak
int dword_F3644; // weak
int dword_F3648; // weak
int dword_F364C; // weak
int dword_F3650; // weak
int dword_F3654; // weak
int dword_F3658; // weak
int dword_F365C; // weak
char s1[16]; // idb
int dword_F3670; // weak
int dword_F3674; // weak
int dword_F3678; // weak
int dword_F367C; // weak
int dword_F3680; // weak
int dword_F3684; // weak
int dword_F3688; // weak
int dword_F368C; // weak
int g_patten; // weak
int dword_F374C; // weak
int dword_F3750; // weak
int dword_F3754; // weak
int dword_F3758; // weak
int dword_F375C; // weak
int dword_F3760; // weak
char byte_F3770[16]; // weak
int dword_F3780; // weak
int dword_F3790; // weak
int dword_F37A0; // weak
int dword_F37A4; // weak
int dword_F37A8; // weak
int dword_F37AC; // weak
int dword_F37B0; // weak
int dword_F37B4; // weak
int dword_F37B8; // weak
int dword_F37BC; // weak
int dword_F37C0; // weak
float flt_F37C4; // weak
int dword_F37C8; // weak
pthread_mutex_t mutex; // idb
// extern _UNKNOWN __gmon_start__; weak


//----- (00010DE0) --------------------------------------------------------
int init_proc()
{
  return call_weak_fn();
}

//----- (00010DEC) --------------------------------------------------------
void sub_10DEC()
{
  JUMPOUT(0);
}
// 10DF8: control flows out of bounds to 0

//----- (000110E8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main((int (*)(int, char **, char **))main, v4, (char **)va, (void (*)(void))init, _libc_csu_fini, a1, va);
  abort();
}
// 110F2: positive sp value 4 has been found
// 11104: variable 'v4' is possibly undefined

//----- (00011118) --------------------------------------------------------
int call_weak_fn()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 10FA4: using guessed type int _gmon_start__(void);

//----- (0001113C) --------------------------------------------------------
int *deregister_tm_clones()
{
  return &_bss_start;
}
// 47DA8: using guessed type int _bss_start;

//----- (00011160) --------------------------------------------------------
__int64 register_tm_clones()
{
  __int64 result; // r0

  LODWORD(result) = &_bss_start;
  HIDWORD(result) = 0;
  return result;
}
// 47DA8: using guessed type int _bss_start;

//----- (0001118C) --------------------------------------------------------
int *_do_global_dtors_aux()
{
  int *result; // r0

  if ( !completed_9251 )
  {
    result = deregister_tm_clones();
    completed_9251 = 1;
  }
  return result;
}
// 47DB8: using guessed type char completed_9251;

//----- (000111A4) --------------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}

//----- (000111C8) --------------------------------------------------------
__int64 __fastcall load64(unsigned __int8 *a1)
{
  __int64 v2; // [sp+28h] [bp+28h]

  LODWORD(v2) = *a1 | (a1[1] << 8) | (a1[2] << 16) | (a1[3] << 24);
  HIDWORD(v2) = (a1[7] << 24) | (a1[6] << 16) | (a1[5] << 8) | a1[4];
  return v2;
}

//----- (0001132C) --------------------------------------------------------
_DWORD *__fastcall store32(_DWORD *result, int a2)
{
  *result = a2;
  return result;
}

//----- (00011388) --------------------------------------------------------
_DWORD *__fastcall store64(_DWORD *result, int a2, int a3, int a4)
{
  *result = a3;
  result[1] = a4;
  return result;
}

//----- (000114B0) --------------------------------------------------------
unsigned __int64 __fastcall rotr64(unsigned __int64 a1, char a2)
{
  return (a1 << (-a2 & 0x3F)) | (a1 >> a2);
}

//----- (00011524) --------------------------------------------------------
void *__fastcall secure_zero_memory(void *a1, size_t a2)
{
  return memset_v_5089(a1, 0, a2);
}
// 47440: using guessed type void *(*memset_v_5089)(void *s, int c, size_t n);

//----- (00011548) --------------------------------------------------------
int __fastcall blake2b_set_lastnode(int a1)
{
  *(_DWORD *)(a1 + 88) = -1;
  *(_DWORD *)(a1 + 92) = -1;
  return 0;
}

//----- (0001156C) --------------------------------------------------------
bool __fastcall blake2b_is_lastblock(int a1)
{
  return *(_QWORD *)(a1 + 80) != 0;
}

//----- (00011590) --------------------------------------------------------
int __fastcall blake2b_set_lastblock(int a1)
{
  if ( *(_BYTE *)(a1 + 356) )
    blake2b_set_lastnode(a1);
  *(_DWORD *)(a1 + 80) = -1;
  *(_DWORD *)(a1 + 84) = -1;
  return 0;
}

//----- (000115C0) --------------------------------------------------------
int __fastcall blake2b_increment_counter(int a1, unsigned __int64 a2)
{
  *(_QWORD *)(a1 + 64) += a2;
  *(_QWORD *)(a1 + 72) += *(_QWORD *)(a1 + 64) < a2;
  return 0;
}

//----- (00011620) --------------------------------------------------------
int __fastcall blake2b_init0(void *a1)
{
  int i; // [sp+Ch] [bp+Ch]

  memset(a1, 0, 0x168u);
  for ( i = 0; i <= 7; ++i )
    *((_QWORD *)a1 + i) = blake2b_IV[i];
  return 0;
}
// 336B8: using guessed type _QWORD blake2b_IV[8];

//----- (00011670) --------------------------------------------------------
int __fastcall blake2b_init_param(void *a1, int a2)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  blake2b_init0(a1);
  for ( i = 0; i <= 7; ++i )
    *((_QWORD *)a1 + i) ^= load64((unsigned __int8 *)(8 * i + a2));
  return 0;
}

//----- (000116D4) --------------------------------------------------------
int __fastcall blake2b_init(void *a1, unsigned __int8 a2)
{
  _BYTE v5[4]; // [sp+8h] [bp+8h] BYREF
  int v6; // [sp+Ch] [bp+Ch] BYREF
  _DWORD v7[2]; // [sp+10h] [bp+10h] BYREF
  char v8; // [sp+18h] [bp+18h]
  char v9; // [sp+19h] [bp+19h]
  _BYTE v10[46]; // [sp+1Ah] [bp+1Ah] BYREF

  if ( !a2 || a2 > 0x40u )
    return -1;
  v5[0] = a2;
  v5[1] = 0;
  v5[2] = 1;
  v5[3] = 1;
  store32(&v6, 0);
  store64(v7, (int)v7, 0, 0);
  v8 = 0;
  v9 = 0;
  memset(v10, 0, sizeof(v10));
  return blake2b_init_param(a1, (int)v5);
}

//----- (00011774) --------------------------------------------------------
int __fastcall blake2b_init_key(void *a1, unsigned __int8 a2, const void *a3, unsigned __int8 a4)
{
  char s[128]; // [sp+10h] [bp+10h] BYREF
  _BYTE v10[4]; // [sp+90h] [bp+90h] BYREF
  int v11; // [sp+94h] [bp+94h] BYREF
  _DWORD v12[2]; // [sp+98h] [bp+98h] BYREF
  char v13; // [sp+A0h] [bp+A0h]
  char v14; // [sp+A1h] [bp+A1h]
  _BYTE v15[46]; // [sp+A2h] [bp+A2h] BYREF

  if ( !a2 || a2 > 0x40u )
    return -1;
  if ( !a3 || !a4 || a4 > 0x40u )
    return -1;
  v10[0] = a2;
  v10[1] = a4;
  v10[2] = 1;
  v10[3] = 1;
  store32(&v11, 0);
  store64(v12, (int)v12, 0, 0);
  v13 = 0;
  v14 = 0;
  memset(v15, 0, sizeof(v15));
  if ( blake2b_init_param(a1, (int)v10) < 0 )
    return -1;
  memset(s, 0, sizeof(s));
  memcpy(s, a3, a4);
  blake2b_update((int)a1, s, 0x80u);
  secure_zero_memory(s, 0x80u);
  return 0;
}

//----- (00011888) --------------------------------------------------------
int __fastcall blake2b_compress(_QWORD *a1, int a2)
{
  __int64 v2; // r0
  __int64 v6; // [sp+8h] [bp+8h] BYREF
  __int64 v7; // [sp+10h] [bp+10h]
  __int64 v8; // [sp+18h] [bp+18h]
  __int64 v9; // [sp+20h] [bp+20h]
  unsigned __int64 v10; // [sp+28h] [bp+28h]
  unsigned __int64 v11; // [sp+30h] [bp+30h]
  unsigned __int64 v12; // [sp+38h] [bp+38h]
  unsigned __int64 v13; // [sp+40h] [bp+40h]
  __int64 v14; // [sp+48h] [bp+48h]
  __int64 v15; // [sp+50h] [bp+50h]
  __int64 v16; // [sp+58h] [bp+58h]
  unsigned __int64 v17; // [sp+60h] [bp+60h]
  unsigned __int64 v18; // [sp+68h] [bp+68h]
  unsigned __int64 v19; // [sp+70h] [bp+70h]
  unsigned __int64 v20; // [sp+78h] [bp+78h]
  unsigned __int64 v21; // [sp+80h] [bp+80h]
  __int64 v22; // [sp+88h] [bp+88h]
  __int64 v23; // [sp+90h] [bp+90h]
  __int64 v24; // [sp+98h] [bp+98h]
  __int64 v25; // [sp+A0h] [bp+A0h]
  __int64 v26; // [sp+A8h] [bp+A8h]
  __int64 v27; // [sp+B0h] [bp+B0h]
  __int64 v28; // [sp+B8h] [bp+B8h]
  __int64 v29; // [sp+C0h] [bp+C0h]
  __int64 v30; // [sp+C8h] [bp+C8h]
  __int64 v31; // [sp+D0h] [bp+D0h]
  __int64 v32; // [sp+D8h] [bp+D8h]
  __int64 v33; // [sp+E0h] [bp+E0h]
  __int64 v34; // [sp+E8h] [bp+E8h]
  __int64 v35; // [sp+F0h] [bp+F0h]
  __int64 v36; // [sp+F8h] [bp+F8h]
  __int64 v37; // [sp+100h] [bp+100h]
  int i; // [sp+10Ch] [bp+10Ch]
  _BYTE v39[4]; // [sp+110h] [bp+110h] BYREF

  for ( i = 0; i <= 15; ++i )
  {
    v2 = load64((unsigned __int8 *)(8 * i + a2));
    *(_QWORD *)&v39[8 * i - 136] = v2;
  }
  for ( i = 0; i <= 7; ++i )
    *(&v6 + i) = a1[i];
  v14 = 0x6A09E667F3BCC908LL;
  v15 = loc_12520;
  v16 = loc_12528;
  v17 = 0xA54FF53A5F1D36F1LL;
  v18 = a1[8] ^ __PAIR64__(loc_1253C, loc_12538);
  v19 = a1[9] ^ __PAIR64__(loc_12544, loc_12540);
  v20 = a1[10] ^ __PAIR64__(loc_1254C, locret_12548);
  v21 = a1[11] ^ __PAIR64__(loc_12554, loc_12550);
  v6 += v22 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v23 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v24 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v25 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v26 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v27 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v28 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v29 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v30 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v31 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v32 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v33 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v34 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v35 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v36 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v37 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v36 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v32 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v26 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v30 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v31 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v37 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v35 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v28 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v23 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v34 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v22 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v24 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v33 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v29 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v27 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v25 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v33 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v30 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v34 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v22 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v27 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v24 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v37 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v35 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v32 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v36 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v25 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v28 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v29 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v23 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v31 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v26 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v29 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v31 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v25 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v23 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v35 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v34 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v33 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v36 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v24 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v28 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v27 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v32 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v26 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v22 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v37 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v30 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v31 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v22 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v27 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v29 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v24 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v26 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v32 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v37 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v36 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v23 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v33 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v34 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v28 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v30 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v25 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v35 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v24 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v34 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v28 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v32 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v22 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v33 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v30 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v25 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v26 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v35 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v29 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v27 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v37 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v36 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v23 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v31 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v34 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v27 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v23 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v37 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v36 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v35 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v26 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v32 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v22 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v29 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v28 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v25 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v31 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v24 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v30 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v33 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v35 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v33 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v29 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v36 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v34 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v23 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v25 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v31 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v27 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v22 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v37 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v26 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v30 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v28 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v24 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v32 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v28 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v37 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v36 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v31 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v33 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v25 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v22 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v30 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v34 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v24 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v35 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v29 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v23 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v26 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v32 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v27 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v32 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v24 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v30 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v26 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v29 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v28 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v23 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v27 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v37 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v33 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v31 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v36 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v25 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v34 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v35 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v22 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v22 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v23 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v24 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v25 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v26 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v27 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v28 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v29 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v30 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v31 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v32 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v33 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v34 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v35 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v36 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v37 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v36 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v32 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v26 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v30 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v31 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v37 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v35 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v28 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v23 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v34 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v22 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v24 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v33 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v29 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v27 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v25 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  for ( i = 0; i <= 7; ++i )
    a1[i] ^= *(&v6 + i + 8) ^ *(&v6 + i);
  return 0;
}

//----- (00019D14) --------------------------------------------------------
int __fastcall blake2b_update(int a1, char *a2, unsigned __int64 a3)
{
  size_t n; // [sp+10h] [bp+10h]
  int v8; // [sp+14h] [bp+14h]

  while ( a3 )
  {
    v8 = *(_DWORD *)(a1 + 352);
    n = 256 - v8;
    if ( (unsigned int)(256 - v8) >= a3 )
    {
      memcpy((void *)(v8 + a1 + 96), a2, a3);
      *(_DWORD *)(a1 + 352) += a3;
      a2 += a3;
      a3 = 0;
    }
    else
    {
      memcpy((void *)(v8 + a1 + 96), a2, n);
      *(_DWORD *)(a1 + 352) += n;
      blake2b_increment_counter(a1, 0x80u);
      blake2b_compress((_QWORD *)a1, a1 + 96);
      memcpy((void *)(a1 + 96), (const void *)(a1 + 224), 0x80u);
      *(_DWORD *)(a1 + 352) -= 128;
      a2 += n;
      a3 -= n;
    }
  }
  return 0;
}

//----- (00019E14) --------------------------------------------------------
int __fastcall blake2b_final(int a1, void *a2, unsigned __int8 a3)
{
  _DWORD s[16]; // [sp+14h] [bp+14h] BYREF
  int i; // [sp+54h] [bp+54h]

  memset(s, 0, sizeof(s));
  if ( !a2 || !a3 || a3 > 0x40u )
    return -1;
  if ( blake2b_is_lastblock(a1) )
    return -1;
  if ( *(_DWORD *)(a1 + 352) > 0x80u )
  {
    blake2b_increment_counter(a1, 0x80u);
    blake2b_compress((_QWORD *)a1, a1 + 96);
    *(_DWORD *)(a1 + 352) -= 128;
    memcpy((void *)(a1 + 96), (const void *)(a1 + 224), *(_DWORD *)(a1 + 352));
  }
  blake2b_increment_counter(a1, *(unsigned int *)(a1 + 352));
  blake2b_set_lastblock(a1);
  memset((void *)(a1 + 96 + *(_DWORD *)(a1 + 352)), 0, 256 - *(_DWORD *)(a1 + 352));
  blake2b_compress((_QWORD *)a1, a1 + 96);
  for ( i = 0; i <= 7; ++i )
    store64(&s[2 * i], (int)&s[2 * i], *(_DWORD *)(8 * i + a1), *(_DWORD *)(8 * i + a1 + 4));
  memcpy(a2, s, a3);
  return 0;
}

//----- (00019F38) --------------------------------------------------------
int __fastcall blake2b(void *a1, char *a2, const void *a3, unsigned __int8 a4, unsigned __int64 a5, unsigned __int8 a6)
{
  _BYTE v11[364]; // [sp+10h] [bp+10h] BYREF

  if ( !a2 && a5 )
    return -1;
  if ( !a1 )
    return -1;
  if ( !a3 && a6 )
    return -1;
  if ( !a4 || a4 > 0x40u )
    return -1;
  if ( a6 <= 0x40u )
  {
    if ( a6 )
    {
      if ( blake2b_init_key(v11, a4, a3, a6) < 0 )
        return -1;
    }
    else if ( blake2b_init(v11, a4) < 0 )
    {
      return -1;
    }
    blake2b_update((int)v11, a2, a5);
    blake2b_final((int)v11, a1, a4);
    return 0;
  }
  return -1;
}

//----- (0001A038) --------------------------------------------------------
__int64 now()
{
  struct timeval v1; // [sp+0h] [bp+0h] BYREF

  gettimeofday(&v1, 0);
  return v1.tv_usec + 1000000LL * v1.tv_sec;
}

//----- (0001A0B0) --------------------------------------------------------
size_t __fastcall midd_ioctl(unsigned __int8 a1, int a2, int a3)
{
  _BYTE s[300]; // [sp+10h] [bp+10h] BYREF
  signed int v9; // [sp+13Ch] [bp+13Ch]

  memset(s, 0, sizeof(s));
  v9 = pack_ioctl_pkg(s, 0x12Cu, a2, a3);
  if ( v9 >= 0 )
    return uart_send(a1, s, v9);
  else
    return v9;
}

//----- (0001A124) --------------------------------------------------------
int __fastcall target_zero_cal(int a1)
{
  _BYTE s[32]; // [sp+8h] [bp+8h] BYREF
  int k; // [sp+28h] [bp+28h]
  int j; // [sp+2Ch] [bp+2Ch]
  int i; // [sp+30h] [bp+30h]
  int v8; // [sp+34h] [bp+34h]

  v8 = 0;
  memset(s, 0, sizeof(s));
  for ( i = 0; i <= 31; ++i )
    s[i] = *(_BYTE *)(a1 + 31 - i);
  for ( j = 0; j <= 31; ++j )
  {
    for ( k = 7; k >= 0; --k )
    {
      if ( bit_read((int)&s[j], k) )
        return v8;
      ++v8;
    }
  }
  return v8;
}

//----- (0001A1B8) --------------------------------------------------------
int __fastcall targetValidator(const void *a1, const void *a2)
{
  _BYTE v5[32]; // [sp+Ch] [bp+Ch] BYREF
  _BYTE v6[32]; // [sp+2Ch] [bp+2Ch] BYREF
  _WORD s[745]; // [sp+4Ch] [bp+4Ch] BYREF
  char v8; // [sp+61Eh] [bp+61Eh]

  s[744] = 16637;
  v8 = 5;
  memset(s, 0, 0x5CFu);
  memset(v6, 0, sizeof(v6));
  memset(v5, 0, sizeof(v5));
  memcpy(s, a1, 0x8Cu);
  s[70] = 16637;
  LOBYTE(s[71]) = 5;
  memcpy((char *)&s[71] + 1, a2, 0x540u);
  Sha256_Onestep(s, 1487, v6);
  Sha256_Onestep(v6, 32, v5);
  return target_zero_cal((int)v5);
}

//----- (0001A280) --------------------------------------------------------
size_t __fastcall read_register(int a1, char a2, char a3, char a4)
{
  _BYTE v5[4]; // [sp+10h] [bp+10h] BYREF
  int v6; // [sp+14h] [bp+14h]

  v5[1] = a2;
  v5[0] = a3;
  v5[2] = a4;
  v6 = 0;
  return midd_ioctl(g_chain[8 * a1], 0, (int)v5);
}
// 4845C: using guessed type int g_chain[8];

//----- (0001A2CC) --------------------------------------------------------
size_t __fastcall write_register_2(int a1, char a2, char a3, char a4, int a5)
{
  _BYTE v6[4]; // [sp+10h] [bp+10h] BYREF
  int v7; // [sp+14h] [bp+14h]

  v6[1] = a2;
  v6[0] = a3;
  v6[2] = a4;
  v7 = a5;
  return midd_ioctl(g_chain[8 * a1], 1, (int)v6);
}
// 4845C: using guessed type int g_chain[8];

//----- (0001A318) --------------------------------------------------------
size_t __fastcall write_register(char a1, int a2)
{
  _BYTE v3[4]; // [sp+8h] [bp+8h] BYREF
  int v4; // [sp+Ch] [bp+Ch]

  v3[1] = 1;
  v3[0] = 0;
  v3[2] = a1;
  v4 = a2;
  return midd_ioctl(g_chain[0], 1, (int)v3);
}
// 4845C: using guessed type int g_chain[8];

//----- (0001A354) --------------------------------------------------------
int set_i2c_enable()
{
  int result; // r0
  char s[1024]; // [sp+Ch] [bp+4h] BYREF
  int v2; // [sp+40Ch] [bp+404h]
  _BYTE v3[4]; // [sp+410h] [bp+408h] BYREF
  int v4; // [sp+414h] [bp+40Ch]
  int j; // [sp+418h] [bp+410h]
  int i; // [sp+41Ch] [bp+414h]

  v2 = g_misc_control | 0x4060;
  for ( i = 0; i <= 0; ++i )
  {
    for ( j = 0; j <= 1; ++j )
    {
      v3[1] = 0;
      v3[0] = sensor_chip_addr[j];
      v3[2] = 28;
      v4 = v2;
      midd_ioctl(g_chain[8 * i], 1, (int)v3);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "enable i2c, chain %d sensor %08x\n", i, (unsigned __int8)sensor_chip_addr[j]);
        applog(2, s, 0);
      }
      result = usleep(0xC350u);
    }
  }
  return result;
}
// 4745C: using guessed type int g_misc_control;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001A46C) --------------------------------------------------------
int __fastcall i2c_status(unsigned __int8 a1, unsigned __int8 a2)
{
  char s[1024]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 v7[4]; // [sp+410h] [bp+408h] BYREF
  int v8; // [sp+414h] [bp+40Ch]
  _BYTE v9[8]; // [sp+41Ch] [bp+414h] BYREF
  int reg_item; // [sp+424h] [bp+41Ch]

  v9[1] = 0;
  v9[0] = a2;
  v9[2] = 32;
  midd_ioctl(g_chain[8 * a1], 0, (int)v9);
  v7[0] = a1;
  v7[1] = a2;
  v7[2] = 32;
  v8 = 0;
  reg_item = read_reg_item(v7, 500);
  if ( reg_item >= 0 )
  {
    if ( v8 >= 0 )
    {
      return 0;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 0 )
      {
        snprintf(s, 0x400u, "chain %d, chipaddr %02x - i2c is busy\n", a1, a2);
        applog(1, s, 0);
      }
      return 1;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 0 )
    {
      snprintf(s, 0x400u, "chain %d, chipaddr %02x - i2c no-response\n", a1, a2);
      applog(1, s, 0);
    }
    return -1;
  }
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001A5B8) --------------------------------------------------------
int __fastcall i2c_recv(unsigned __int8 a1, unsigned __int8 a2, char a3, char a4, _DWORD *a5)
{
  int v11; // [sp+8h] [bp+8h]
  unsigned __int8 v12[4]; // [sp+Ch] [bp+Ch] BYREF
  int v13; // [sp+10h] [bp+10h]
  unsigned __int8 v14; // [sp+18h] [bp+18h] BYREF
  char v15; // [sp+19h] [bp+19h]
  char v16; // [sp+1Ah] [bp+1Ah]
  int v17; // [sp+1Ch] [bp+1Ch]

  if ( i2c_status(a1, a2) )
    return -1;
  LOBYTE(v11) = g_general_i2c_command;
  HIBYTE(v11) = HIBYTE(g_general_i2c_command) | 1;
  BYTE2(v11) = 2 * (a3 & 0x7F);
  BYTE1(v11) = a4;
  v15 = 0;
  v14 = a2;
  v16 = 32;
  v17 = v11;
  midd_ioctl(g_chain[8 * a1], 1, (int)&v14);
  usleep(0x30D40u);
  if ( i2c_status(a1, a2) )
    return -1;
  v15 = 0;
  v14 = a2;
  v16 = 32;
  midd_ioctl(g_chain[8 * a1], 0, (int)&v14);
  v12[0] = a1;
  v12[1] = a2;
  v12[2] = 32;
  if ( read_reg_item(v12, 500) <= 0 )
    return -1;
  *a5 = v13;
  return 0;
}
// 47DE0: using guessed type int g_general_i2c_command;
// 4845C: using guessed type int g_chain[8];

//----- (0001A6CC) --------------------------------------------------------
size_t __fastcall i2c_send(unsigned __int8 a1, char a2, char a3, char a4, char a5)
{
  _BYTE v6[4]; // [sp+Ch] [bp+Ch] BYREF
  int v7; // [sp+10h] [bp+10h]
  int v8; // [sp+14h] [bp+14h]

  HIBYTE(v8) = HIBYTE(g_general_i2c_command);
  BYTE2(v8) = (2 * (a3 & 0x7F)) | 1;
  BYTE1(v8) = a4;
  LOBYTE(v8) = a5;
  v6[1] = 0;
  v6[0] = a2;
  v6[2] = 32;
  v7 = v8;
  return midd_ioctl(g_chain[8 * a1], 1, (int)v6);
}
// 47DE0: using guessed type int g_general_i2c_command;
// 4845C: using guessed type int g_chain[8];

//----- (0001A74C) --------------------------------------------------------
void asic_num_calculate()
{
  _BYTE v0[8]; // [sp+0h] [bp+0h] BYREF
  unsigned __int8 v1[4]; // [sp+8h] [bp+8h] BYREF
  int v2; // [sp+Ch] [bp+Ch]
  int i; // [sp+14h] [bp+14h]

  v0[1] = 1;
  v0[0] = 0;
  v0[2] = 0;
  for ( i = 0; i <= 0; ++i )
    midd_ioctl(g_chain[8 * i], 0, (int)v0);
  for ( i = 0; i <= 0; ++i )
  {
    v1[0] = i;
    v1[1] = 0;
    v1[2] = 0;
    v2 = 0;
    if ( read_reg_item(v1, 500) > 0 )
      ++asic_num[i];
  }
}
// 47E68: using guessed type _DWORD asic_num[1];
// 4845C: using guessed type int g_chain[8];

//----- (0001A7EC) --------------------------------------------------------
int __fastcall calculate_asic_number(unsigned int a1)
{
  char s[1024]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+40Ch] [bp+40Ch]

  v4 = 0;
  if ( a1 == 1 )
    return 1;
  if ( a1 == 2 )
    return 2;
  if ( a1 > 2 && a1 <= 4 )
    return 4;
  if ( a1 > 4 && a1 <= 8 )
    return 8;
  if ( a1 > 8 && a1 <= 0x10 )
    return 16;
  if ( a1 > 0x10 && a1 <= 0x20 )
    return 32;
  if ( a1 > 0x20 && a1 <= 0x40 )
    return 64;
  if ( a1 > 0x40 && a1 <= 0x80 )
    return 128;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 3) )
  {
    snprintf(s, 0x400u, "actual_asic_number = %d, but it is error\n", a1);
    applog(4, s, 0);
  }
  return -1;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843E: using guessed type char opt_debug;
// 4843F: using guessed type char opt_log_output;

//----- (0001A920) --------------------------------------------------------
int asic_addr_interval()
{
  int result; // r0
  char s[1024]; // [sp+Ch] [bp+4h] BYREF
  int v2; // [sp+40Ch] [bp+404h]

  v2 = calculate_asic_number(3u);
  result = 256 / v2;
  addr_interval = 256 / v2;
  sensor_chip_addr = 0;
  byte_47E6D = 2 * (256 / v2);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(s, 0x400u, "%s %u\n", "asic_addr_interval", addr_interval);
    return applog(2, s, 0);
  }
  return result;
}
// 47478: using guessed type int addr_interval;
// 47C84: using guessed type int opt_log_level;
// 47E6C: using guessed type char sensor_chip_addr;
// 47E6D: using guessed type char byte_47E6D;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001A9D8) --------------------------------------------------------
size_t __fastcall set_frequency(int a1)
{
  size_t result; // r0
  char s[1024]; // [sp+10h] [bp+8h] BYREF
  _BYTE v4[4]; // [sp+410h] [bp+408h] BYREF
  int v5; // [sp+414h] [bp+40Ch]
  int v6; // [sp+418h] [bp+410h] BYREF
  int i; // [sp+41Ch] [bp+414h]

  i = 0;
  v6 = 0;
  result = get_plldata(a1, &v6);
  v4[0] = 0;
  v4[1] = 1;
  v4[2] = 12;
  v5 = v6;
  g_pll_parameter = v6;
  for ( i = 0; i <= 0; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "%s %d, pll %08x\n", "set_frequency", a1, v6);
      applog(2, s, 0);
    }
    result = midd_ioctl(g_chain[8 * i], 1, (int)v4);
  }
  return result;
}
// 47454: using guessed type int g_pll_parameter;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001AAC8) --------------------------------------------------------
int __fastcall set_frequency_scanfreq(int result)
{
  int v1; // [sp+14h] [bp+4h]
  char s[1024]; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v3[4]; // [sp+41Ch] [bp+40Ch] BYREF
  int v4; // [sp+420h] [bp+410h]
  int v5; // [sp+424h] [bp+414h] BYREF
  int v6; // [sp+428h] [bp+418h]
  int i; // [sp+42Ch] [bp+41Ch]

  v1 = result;
  v5 = 0;
  v6 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    get_plldata(*(_DWORD *)(4 * i + v1), &v5);
    v3[0] = i * addr_interval;
    v3[1] = 0;
    v3[2] = 12;
    v4 = v5;
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        s,
        0x400u,
        "%s addr %02x %d %08x\n",
        "set_frequency_scanfreq",
        addr_interval * i,
        *(_DWORD *)(4 * i + v1),
        v5);
      applog(2, s, 0);
    }
    midd_ioctl(g_chain[8 * v6], 1, (int)v3);
    result = usleep(0xC350u);
  }
  return result;
}
// 47478: using guessed type int addr_interval;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001ABF4) --------------------------------------------------------
int __fastcall set_ticket_mask(int result)
{
  int v1; // [sp+Ch] [bp+4h]
  char s[1024]; // [sp+14h] [bp+Ch] BYREF
  _BYTE v3[4]; // [sp+414h] [bp+40Ch] BYREF
  int v4; // [sp+418h] [bp+410h]
  int i; // [sp+41Ch] [bp+414h]

  v1 = result;
  v3[1] = 1;
  v3[0] = 0;
  v3[2] = 20;
  v4 = result;
  g_ticket_mask = result;
  for ( i = 0; i <= 0; ++i )
  {
    result = midd_ioctl(g_chain[8 * i], 1, (int)v3);
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "chain %d ticket-mask %08x\n", i, v1);
      result = applog(2, s, 0);
    }
  }
  return result;
}
// 47458: using guessed type int g_ticket_mask;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001ACC8) --------------------------------------------------------
size_t set_io_drive_strength()
{
  size_t result; // r0
  char v1[1024]; // [sp+8h] [bp+0h] BYREF
  _BYTE v2[4]; // [sp+408h] [bp+400h] BYREF
  int v3; // [sp+40Ch] [bp+404h]
  int v4; // [sp+410h] [bp+408h]
  unsigned __int8 i; // [sp+417h] [bp+40Fh]

  v4 = g_io_drive_strength;
  BYTE1(v4) = BYTE1(g_io_drive_strength) & 0xF | 0x30;
  v2[1] = 1;
  v2[0] = 0;
  v2[2] = 48;
  v3 = v4;
  g_io_drive_strength = v4;
  for ( i = 0; !i; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v1, 0x400u, "%s %08x\n", "set_io_drive_strength", v3);
      applog(2, v1, 0);
    }
    result = midd_ioctl(i, 1, (int)v2);
  }
  return result;
}
// 47464: using guessed type int g_io_drive_strength;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001ADA0) --------------------------------------------------------
size_t __fastcall set_baud_chain(size_t result)
{
  size_t v1; // [sp+Ch] [bp+4h]
  char s[1024]; // [sp+10h] [bp+8h] BYREF
  _BYTE v3[4]; // [sp+410h] [bp+408h] BYREF
  int v4; // [sp+414h] [bp+40Ch]
  int v5; // [sp+418h] [bp+410h]
  unsigned __int8 i; // [sp+41Fh] [bp+417h]

  v1 = result;
  v5 = g_misc_control;
  BYTE1(v5) = BYTE1(g_misc_control) & 0xE0 | result & 0x1F;
  v3[1] = 1;
  v3[0] = 0;
  v3[2] = 28;
  v4 = v5;
  g_misc_control = v5;
  for ( i = 0; !i; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "%s bt8d=%d\n", "set_baud_chain", v1);
      applog(2, s, 0);
    }
    result = midd_ioctl(g_chain[8 * i], 1, (int)v3);
  }
  return result;
}
// 4745C: using guessed type int g_misc_control;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001AE98) --------------------------------------------------------
int set_address()
{
  int result; // r0
  char s[1024]; // [sp+Ch] [bp+4h] BYREF
  int v2; // [sp+40Ch] [bp+404h] BYREF
  int j; // [sp+410h] [bp+408h]
  int i; // [sp+414h] [bp+40Ch]

  v2 = 0;
  j = 0;
  for ( i = 0; i <= 0; ++i )
  {
    midd_ioctl(g_chain[8 * i], 4, 0);
    result = usleep(0x186A0u);
    for ( j = 0; j <= 2; ++j )
    {
      v2 = j * addr_interval;
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "%s %08x\n", "set_address", v2);
        applog(2, s, 0);
      }
      midd_ioctl(g_chain[8 * i], 3, (int)&v2);
      result = usleep(0xC350u);
    }
  }
  return result;
}
// 47478: using guessed type int addr_interval;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001AFAC) --------------------------------------------------------
size_t __fastcall set_core_timeout(size_t result)
{
  size_t v1; // [sp+Ch] [bp+4h]
  char s[1024]; // [sp+14h] [bp+Ch] BYREF
  _BYTE v3[4]; // [sp+414h] [bp+40Ch] BYREF
  size_t v4; // [sp+418h] [bp+410h]
  int i; // [sp+41Ch] [bp+414h]

  v1 = result;
  v3[1] = 1;
  v3[0] = 0;
  v3[2] = 40;
  v4 = result;
  g_core_timeout = result;
  for ( i = 0; i <= 0; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "%s %08x\n", "set_core_timeout", v1);
      applog(2, s, 0);
    }
    result = midd_ioctl(g_chain[8 * i], 1, (int)v3);
  }
  return result;
}
// 47460: using guessed type int g_core_timeout;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001B084) --------------------------------------------------------
size_t __fastcall set_txn_data(size_t result)
{
  size_t v1; // [sp+Ch] [bp+4h]
  char s[1024]; // [sp+14h] [bp+Ch] BYREF
  _BYTE v3[4]; // [sp+414h] [bp+40Ch] BYREF
  size_t v4; // [sp+418h] [bp+410h]
  int i; // [sp+41Ch] [bp+414h]

  v1 = result;
  v3[1] = 1;
  v3[0] = 0;
  v3[2] = 88;
  v4 = result;
  for ( i = 0; i <= 0; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "%s %08x\n", "set_txn_data", v1);
      applog(2, s, 0);
    }
    result = midd_ioctl(g_chain[8 * i], 1, (int)v3);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001B14C) --------------------------------------------------------
size_t __fastcall set_nonce_shift(char a1)
{
  size_t result; // r0
  char s[1024]; // [sp+10h] [bp+8h] BYREF
  int v4; // [sp+410h] [bp+408h]
  _DWORD v5[2]; // [sp+414h] [bp+40Ch] BYREF
  int i; // [sp+41Ch] [bp+414h]

  result = 5243136;
  v5[0] = 5243136;
  v4 = g_nonce_shift;
  LOBYTE(v4) = g_nonce_shift & 0xE0 | a1 & 0x1F;
  g_nonce_shift = v4;
  v5[1] = v4;
  for ( i = 0; i <= 0; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "%s %08x\n", "set_nonce_shift", g_nonce_shift);
      applog(2, s, 0);
    }
    result = midd_ioctl(g_chain[8 * i], 1, (int)v5);
  }
  return result;
}
// 47470: using guessed type int g_nonce_shift;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001B258) --------------------------------------------------------
size_t __fastcall set_pt_ctrl(size_t result, char a2)
{
  size_t v2; // [sp+Ch] [bp+4h]
  char s[1024]; // [sp+10h] [bp+8h] BYREF
  int v4; // [sp+410h] [bp+408h]
  _BYTE v5[4]; // [sp+414h] [bp+40Ch] BYREF
  int v6; // [sp+418h] [bp+410h]
  int i; // [sp+41Ch] [bp+414h]

  v2 = result;
  BYTE1(v4) = BYTE1(g_pt_ctrl);
  LOBYTE(v4) = g_pt_ctrl & 0xFE | a2 & 1;
  HIWORD(v4) = HIWORD(g_pt_ctrl) & 0xF800 | result & 0x7FF;
  v5[1] = 1;
  v5[0] = 0;
  v5[2] = 92;
  v6 = v4;
  for ( i = 0; i <= 0; ++i )
  {
    result = midd_ioctl(g_chain[8 * i], 1, (int)v5);
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(s, 0x400u, "chain %d pt_ctrl %08x\n", i, v2);
      result = applog(3, s, 0);
    }
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 47DF4: using guessed type int g_pt_ctrl;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001B360) --------------------------------------------------------
size_t __fastcall set_pt_result(size_t result, char a2)
{
  size_t v2; // [sp+Ch] [bp+4h]
  char s[1024]; // [sp+10h] [bp+8h] BYREF
  int v4; // [sp+410h] [bp+408h]
  _BYTE v5[4]; // [sp+414h] [bp+40Ch] BYREF
  int v6; // [sp+418h] [bp+410h]
  int i; // [sp+41Ch] [bp+414h]

  v2 = result;
  LOBYTE(v4) = v4 & 0xFE | a2 & 1;
  BYTE1(v4) = BYTE1(v4) & 0xF0 | result & 0xF;
  v5[1] = 1;
  v5[0] = 0;
  v5[2] = 96;
  v6 = v4;
  for ( i = 0; i <= 0; ++i )
  {
    result = midd_ioctl(g_chain[8 * i], 1, (int)v5);
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "chain %d pt_result %08x\n", i, v2);
      result = applog(2, s, 0);
    }
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001B458) --------------------------------------------------------
int __fastcall x86_tty_open(int a1, int a2)
{
  char s[1024]; // [sp+Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+40Ch] [bp+40Ch] BYREF
  char v7; // [sp+41Ch] [bp+41Ch]
  int v8; // [sp+420h] [bp+420h]
  int v9; // [sp+424h] [bp+424h]
  int v10; // [sp+428h] [bp+428h]
  int i; // [sp+42Ch] [bp+42Ch]

  v6[0] = a2;
  v6[1] = 0;
  v6[2] = 8;
  v6[3] = 1;
  v7 = 78;
  v8 = 0;
  v9 = 1024;
  for ( i = 0; ; ++i )
  {
    if ( i > 0 )
      return 0;
    sprintf((char *)&g_chain[8 * i + 1] + 1, "ttyUSB%d", a1);
    v10 = uart_open((const char *)&g_chain[8 * i + 1] + 1, v6);
    if ( v10 < 0 )
      break;
    g_chain[8 * i] = v10;
    LOBYTE(g_chain[8 * i + 1]) = i;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 0 )
  {
    snprintf(s, 0x400u, "open chain%d failed\n", i);
    applog(1, s, 0);
  }
  return -1;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001B590) --------------------------------------------------------
int x86_tty_close()
{
  int result; // r0
  char s[1024]; // [sp+4h] [bp+4h] BYREF
  int i; // [sp+404h] [bp+404h]

  for ( i = 0; i <= 0; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "uart close %s\n", (const char *)&g_chain[8 * i + 1] + 1);
      applog(2, s, 0);
    }
    result = uart_close(g_chain[8 * i]);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001B630) --------------------------------------------------------
int __fastcall x86_tty_init(int a1, int a2)
{
  int result; // r0
  size_t bt8d_from_baud; // [sp+Ch] [bp+Ch]

  result = x86_tty_open(a1, 19200);
  if ( a2 != 19200 )
  {
    bt8d_from_baud = get_bt8d_from_baud(a2);
    set_baud_chain(bt8d_from_baud);
    usleep(0x30D40u);
    x86_tty_close();
    return x86_tty_open(a1, a2);
  }
  return result;
}

//----- (0001B680) --------------------------------------------------------
int nonce_scanhash()
{
  unsigned int v0; // r0
  int v1; // r2
  _BYTE v3[360]; // [sp+18h] [bp+0h] BYREF
  char v4[1024]; // [sp+180h] [bp+168h] BYREF
  _DWORD v5[3]; // [sp+580h] [bp+568h] BYREF
  char s[140]; // [sp+58Ch] [bp+574h] BYREF
  _DWORD dest[341]; // [sp+618h] [bp+600h] BYREF
  int v8; // [sp+B6Ch] [bp+B54h]
  unsigned int v9; // [sp+B70h] [bp+B58h]
  unsigned int j; // [sp+B74h] [bp+B5Ch]
  int i; // [sp+B78h] [bp+B60h]
  unsigned int m; // [sp+B7Ch] [bp+B64h]
  int k; // [sp+B80h] [bp+B68h]
  int v14; // [sp+B84h] [bp+B6Ch]

  v9 = 0;
  v8 = 0;
  memset(s, 0, sizeof(s));
  pthread_mutex_lock(&nonce_mutex);
  v14 = dword_49DF4;
  pthread_mutex_unlock(&nonce_mutex);
  while ( v14 )
  {
    pthread_mutex_lock(&nonce_mutex);
    --v14;
    --dword_49DF4;
    memcpy(dest, (char *)&nonce_fifo + 1357 * dword_49DF0 + 12, 0x54Du);
    pthread_mutex_unlock(&nonce_mutex);
    pthread_mutex_lock(&g_rt_nonce_mutex);
    memcpy(&g_rt_nonce, dest, 0x54Du);
    pthread_mutex_unlock(&g_rt_nonce_mutex);
    if ( LOBYTE(dest[339]) && (use_syslog || opt_log_output || opt_log_level > 1) )
    {
      snprintf(v4, 0x400u, "Error:scanhash chainid=%u\n", LOBYTE(dest[339]));
      applog(2, v4, 0);
    }
    work_list_find(SBYTE1(dest[336]), s);
    *(_DWORD *)&s[136 - g_nonce_shift] = dest[338];
    v5[0] = 200;
    v5[1] = 9;
    v5[2] = v3;
    digestInit(v3, 200, 9);
    blake2b_update((int)v3, s, 0x8Cu);
    v8 = sortValidator(v5, (int)dest);
    v9 = targetValidator(s, dest);
    if ( g_new_work )
    {
      memset(one_work_nonce_each_asic, 0, 0xCu);
      memset(one_work_invalid_nonce_each_asic, 0, sizeof(one_work_invalid_nonce_each_asic));
      memset(one_work_invalid_nonce_each_asic_2, 0, sizeof(one_work_invalid_nonce_each_asic_2));
      g_new_work = 0;
      dest[340] = time(0) - 1;
    }
    if ( v8 )
    {
      ++invalid_nonce_total;
      for ( i = 0; i <= 0; ++i )
      {
        for ( j = 0; j <= 2; ++j )
        {
          if ( LOBYTE(dest[336]) / (unsigned int)addr_interval == j )
          {
            if ( v8 == 1 )
            {
              ++nonce_invalid_num_each_asic_2[6 * i + 2 * j];
              ++one_work_invalid_nonce_each_asic_2[6 * i + 2 * j];
            }
            else if ( v8 == 2 )
            {
              ++nonce_invalid_num_each_asic_2[6 * i + 1 + 2 * j];
              ++one_work_invalid_nonce_each_asic_2[6 * i + 1 + 2 * j];
            }
            ++one_work_invalid_nonce_each_asic[3 * i + j];
            ++nonce_invalid_num_each_asic[3 * i + j];
            if ( use_syslog || opt_log_output || opt_log_level >= 0 )
            {
              snprintf(
                v4,
                0x400u,
                "Fail:invalid nonce: chainid=%d chipaddr=%02x nonces=%d tm=%d errtype=%d\n",
                i,
                LOBYTE(dest[336]),
                one_work_invalid_nonce_each_asic[3 * i + j],
                v9,
                v8);
              applog(0, v4, 0);
            }
          }
        }
      }
    }
    else
    {
      ++valid_nonce_total;
      ++submit_nonce;
      for ( k = 0; k <= 0; ++k )
      {
        for ( m = 0; m <= 2; ++m )
        {
          if ( LOBYTE(dest[336]) / (unsigned int)addr_interval == m )
          {
            ++one_work_nonce_each_asic[3 * k + m];
            ++nonce_num_each_asic[3 * k + m];
            if ( dword_F37C8 )
              is_patten_match(m, &dest[338], dest);
            if ( use_syslog || opt_log_output || opt_log_level > 0 )
            {
              snprintf(
                v4,
                0x400u,
                "Success:valid nonce: chainid=%d chipaddr=%02x nonces=%d total=%d tm=%d err=%d\n",
                k,
                LOBYTE(dest[336]),
                one_work_nonce_each_asic[3 * k + m],
                submit_nonce,
                v9,
                v8);
              applog(1, v4, 0);
            }
          }
        }
      }
      if ( dword_F3508 == 1 )
      {
        v0 = target_zero_cal((int)&g_work_info);
        if ( v0 <= v9 )
        {
          ++*(_QWORD *)&total_8876;
          if ( use_syslog || opt_log_output || opt_log_level > 2 )
          {
            v1 = golden_nonce_8875++;
            snprintf(v4, 0x400u, "Golden Nonce Found! %d\n", v1);
            applog(3, v4, 0);
          }
          print_solver_line((int)dest, (int)s, dword_F3460, (int)&unk_F32D4);
          ++*(_QWORD *)&total_shares_8877;
          t1_8879 = now();
          if ( *(_QWORD *)&status_period_8880 + t0_8878 < (unsigned __int64)t1_8879 )
          {
            t0_8878 = t1_8879;
            printf("status: %lld %lld\n", *(_QWORD *)&total_8876, *(_QWORD *)&total_shares_8877);
            fflush((FILE *)stdout);
          }
        }
      }
    }
    dump_str((FILE *)app_conf, 0, (int)s, 140);
    dump_str((FILE *)app_conf, 0, (int)dest, 1344);
    pthread_mutex_lock(&nonce_mutex);
    if ( (unsigned int)dword_49DF0 >= 0x1FE )
      dword_49DF0 = 0;
    else
      ++dword_49DF0;
    pthread_mutex_unlock(&nonce_mutex);
  }
  return 0;
}
// 1B680: using guessed type int nonce_scanhash();
// 47448: using guessed type char g_new_work;
// 47470: using guessed type int g_nonce_shift;
// 47478: using guessed type int addr_interval;
// 47480: using guessed type _UNKNOWN *status_period_8880;
// 47C84: using guessed type int opt_log_level;
// 47DB4: using guessed type int stdout;
// 47DFC: using guessed type int nonce_num_each_asic[];
// 47E08: using guessed type int nonce_invalid_num_each_asic[3];
// 47E14: using guessed type int nonce_invalid_num_each_asic_2[];
// 47E2C: using guessed type int one_work_nonce_each_asic[];
// 47E38: using guessed type int one_work_invalid_nonce_each_asic[3];
// 47E44: using guessed type _DWORD one_work_invalid_nonce_each_asic_2[6];
// 47E5C: using guessed type int valid_nonce_total;
// 47E60: using guessed type int invalid_nonce_total;
// 47E64: using guessed type int submit_nonce;
// 47E70: using guessed type pthread_mutex_t g_rt_nonce_mutex;
// 47E8C: using guessed type pthread_mutex_t nonce_mutex;
// 47EC8: using guessed type int total_8876;
// 47ED0: using guessed type int golden_nonce_8875;
// 47ED8: using guessed type int total_shares_8877;
// 47EE0: using guessed type __int64 t1_8879;
// 47EE8: using guessed type __int64 t0_8878;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 49DEC: using guessed type int nonce_fifo;
// 49DF0: using guessed type int dword_49DF0;
// 49DF4: using guessed type int dword_49DF4;
// F3460: using guessed type int dword_F3460;
// F34DC: using guessed type int app_conf;
// F3508: using guessed type int dword_F3508;
// F37C8: using guessed type int dword_F37C8;

//----- (0001BF00) --------------------------------------------------------
void __noreturn nonce_scanhash_loop()
{
  pthread_t newthread; // [sp+4h] [bp+4h] BYREF

  while ( 1 )
  {
    pthread_create(&newthread, 0, (void *(*)(void *))nonce_scanhash, 0);
    pthread_join(newthread, 0);
    usleep(0x3E8u);
  }
}
// 1B680: using guessed type int nonce_scanhash();

//----- (0001BF2C) --------------------------------------------------------
int __fastcall nonce_integrality(unsigned __int8 a1, unsigned __int8 a2, int a3, int a4)
{
  char s[1026]; // [sp+24h] [bp+14h] BYREF
  unsigned __int16 s1; // [sp+426h] [bp+416h] BYREF
  void *dest; // [sp+428h] [bp+418h]
  int i; // [sp+42Ch] [bp+41Ch]

  for ( i = 0; i <= 15; ++i )
  {
    s1 = CRC16_v1((char *)(1456 * a2 + 91 * i + a4 + 1456 * a1), 89);
    s1 = HIBYTE(s1) | (s1 << 8);
    if ( memcmp(&s1, (const void *)(a4 + 1456 * a1 + 1456 * a2 + 91 * i + 89), 2u) )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(
          s,
          0x400u,
          "%s CRC error. cal-crc=%x, chip-crc=%02x%02x\n",
          "nonce_integrality",
          s1,
          *(unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1 + 89),
          *(unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1 + 90));
        applog(0, s, 0);
      }
      return -1;
    }
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( (*(_BYTE *)(1456 * a2 + 91 * i + a4 + 1456 * a1) & 0xF) != i )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(s, 0x400u, "nonce is not continous i=%d\n", i);
        applog(0, s, 0);
      }
      return -1;
    }
  }
  for ( i = 0; i <= 14; ++i )
  {
    if ( *(unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1 + 1) != *(unsigned __int8 *)(1456 * a2
                                                                                             + 91 * (i + 1)
                                                                                             + a4
                                                                                             + 1456 * a1
                                                                                             + 1) )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(
          s,
          0x400u,
          "chip_addr is different %02x != %02x\n",
          *(unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1 + 1),
          *(unsigned __int8 *)(1456 * a2 + 91 * (i + 1) + a4 + 1456 * a1 + 1));
        applog(0, s, 0);
      }
      return -1;
    }
  }
  for ( i = 0; i <= 14; ++i )
  {
    if ( *(unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1 + 2) != *(unsigned __int8 *)(1456 * a2
                                                                                             + 91 * (i + 1)
                                                                                             + a4
                                                                                             + 1456 * a1
                                                                                             + 2) )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(
          s,
          0x400u,
          "workID is different %02x != %02x\n",
          *(unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1 + 2),
          *(unsigned __int8 *)(1456 * a2 + 91 * (i + 1) + a4 + 1456 * a1 + 2));
        applog(0, s, 0);
      }
      return -1;
    }
  }
  for ( i = 0; ; ++i )
  {
    if ( i > 14 )
    {
      dest = (void *)(1357 * a2 + a3 + 1357 * a1);
      for ( i = 0; i <= 14; ++i )
      {
        memcpy(dest, (const void *)(1456 * a2 + 91 * i + 4 + a4 + 1456 * a1), 0x55u);
        dest = (char *)dest + 85;
      }
      memcpy(dest, (const void *)(1456 * a2 + 1369 + a4 + 1456 * a1), 0x45u);
      memcpy((void *)(a3 + 1357 * a1 + 1357 * a2 + 1352), (const void *)(1456 * a2 + 1450 + a4 + 1456 * a1), 4u);
      *(_BYTE *)(1357 * a2 + a3 + 1357 * a1 + 1344) = *(_BYTE *)(1456 * a2 + a4 + 1456 * a1 + 1366);
      *(_BYTE *)(1357 * a2 + a3 + 1357 * a1 + 1345) = *(_BYTE *)(1456 * a2 + a4 + 1456 * a1 + 1367);
      *(_BYTE *)(1357 * a2 + a3 + 1357 * a1 + 1346) = *(_BYTE *)(1456 * a2 + a4 + 1456 * a1 + 1368);
      *(_BYTE *)(1357 * a2 + a3 + 1357 * a1 + 1347) = *(_BYTE *)(1456 * a2 + a4 + 1456 * a1 + 1441);
      memcpy((void *)(1357 * a2 + 1344 + a3 + 1357 * a1 + 4), (const void *)(1456 * a2 + 1442 + a4 + 1456 * a1), 4u);
      return 0;
    }
    if ( *(unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1 + 3) != *(unsigned __int8 *)(1456 * a2
                                                                                             + 91 * (i + 1)
                                                                                             + a4
                                                                                             + 1456 * a1
                                                                                             + 3) )
      break;
  }
  if ( use_syslog || opt_log_output || opt_log_level >= 0 )
  {
    snprintf(
      s,
      0x400u,
      "nonceID is different %02x != %02x chipid=%d\n",
      *(unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1 + 3),
      *(unsigned __int8 *)(1456 * a2 + 91 * (i + 1) + a4 + 1456 * a1 + 3),
      a1);
    applog(0, s, 0);
  }
  return -1;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001C85C) --------------------------------------------------------
int clear_nonce_fifo()
{
  pthread_mutex_lock(&nonce_mutex);
  nonce_fifo = 0;
  dword_49DF0 = 0;
  dword_49DF4 = 0;
  return pthread_mutex_unlock(&nonce_mutex);
}
// 47E8C: using guessed type pthread_mutex_t nonce_mutex;
// 49DEC: using guessed type int nonce_fifo;
// 49DF0: using guessed type int dword_49DF0;
// 49DF4: using guessed type int dword_49DF4;

//----- (0001C8A0) --------------------------------------------------------
int __fastcall pm_handle(int a1, int a2, unsigned __int8 a3)
{
  int result; // r0
  char v5; // [sp+18h] [bp+8h]
  char s[1027]; // [sp+20h] [bp+10h] BYREF
  unsigned __int8 v8; // [sp+423h] [bp+413h]
  unsigned __int8 *v9; // [sp+424h] [bp+414h]

  v5 = a2;
  v9 = (unsigned __int8 *)a1;
  dump_str((FILE *)app_conf, 0, a1, a2);
  result = CRC5_v1((_BYTE *)(a1 + 2), 8 * (v5 - 3) + 3);
  v8 = result;
  if ( (unsigned __int8)result == (v9[8] & 0x1F) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "pmonitor[%02x] %02x %02x %02x %02x\n", v9[7], v9[3], v9[4], v9[5], v9[6]);
      return applog(2, s, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level >= 0 )
  {
    snprintf(s, 0x400u, "%s chain%d CRC error crc = %02x\n", "pm_handle", a3, v8);
    return applog(0, s, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34DC: using guessed type int app_conf;

//----- (0001CA04) --------------------------------------------------------
FILE *__fastcall pt_handle(int a1, int a2, unsigned __int8 a3)
{
  FILE *result; // r0
  char s[1024]; // [sp+18h] [bp+10h] BYREF
  FILE *stream; // [sp+418h] [bp+410h]
  unsigned __int16 v7; // [sp+41Eh] [bp+416h]
  int v8; // [sp+420h] [bp+418h]
  int i; // [sp+424h] [bp+41Ch]

  v8 = a1;
  result = (FILE *)CRC16_v1((char *)(a1 + 2), 1026);
  v7 = ((unsigned __int16)result >> 8) | ((_WORD)result << 8);
  if ( v7 == *(unsigned __int16 *)(v8 + 1028) )
  {
    result = fopen("./pattern_result.txt", "a+");
    stream = result;
    if ( result )
    {
      for ( i = 0; i <= 127; ++i )
        dump_str(stream, 0, 8 * i + v8 + 4, 8);
      return (FILE *)fclose(stream);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy(s, "open failed pattern_result.txt\n");
      return (FILE *)applog(2, s, 0);
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "chainid=%d cal crc = %04x, chip crc = %04x\n", a3, v7, *(unsigned __int16 *)(v8 + 1028));
      result = (FILE *)applog(2, s, 0);
    }
    pattern_test_crc_error = 1;
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 47EA4: using guessed type char pattern_test_crc_error;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001CB98) --------------------------------------------------------
int __fastcall reg_handle(int a1, char a2, char a3)
{
  int result; // r0
  char s[1024]; // [sp+1Ch] [bp+14h] BYREF
  int v6; // [sp+41Ch] [bp+414h]
  int v7; // [sp+424h] [bp+41Ch]
  unsigned __int8 v8; // [sp+42Bh] [bp+423h]
  int v9; // [sp+42Ch] [bp+424h]

  v9 = a1;
  result = CRC5_v1((_BYTE *)(a1 + 2), 8 * (a2 - 3) + 3);
  v8 = result;
  if ( (unsigned __int8)result == (*(_BYTE *)(v9 + 8) & 0x1F) )
  {
    v7 = 3;
    LOBYTE(v6) = a3;
    BYTE1(v6) = *(_BYTE *)(v9 + 7);
    BYTE2(v6) = *(_BYTE *)(v9 + 2);
    return add_reg_item(v6, _byteswap_ulong(*(_DWORD *)(v9 + 3)), 3);
  }
  else if ( use_syslog || opt_log_output || opt_log_level >= 0 )
  {
    snprintf(s, 0x400u, "%s CRC error crc = %02x\n", "reg_handle", v8);
    return applog(0, s, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001CCB8) --------------------------------------------------------
int __fastcall nonce_handle(int a1, int a2, _BYTE *a3, int a4, char a5)
{
  int v6; // r2
  char s[1024]; // [sp+1Ch] [bp+14h] BYREF
  unsigned int v13; // [sp+41Ch] [bp+414h]
  unsigned int v14; // [sp+420h] [bp+418h]
  int v15; // [sp+424h] [bp+41Ch]
  unsigned __int8 v16; // [sp+42Bh] [bp+423h]
  unsigned __int8 v17; // [sp+42Ch] [bp+424h]
  unsigned __int8 v18; // [sp+42Dh] [bp+425h]
  unsigned __int8 v19; // [sp+42Eh] [bp+426h]
  unsigned __int8 v20; // [sp+42Fh] [bp+427h]

  v20 = a3[2] & 0xF;
  v19 = a3[3];
  v18 = v19 / (unsigned int)addr_interval;
  v17 = a3[5];
  v16 = 0;
  v15 = 1;
  if ( v18 > 2u )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 0 )
    {
      snprintf(s, 0x400u, "%s chipid%d is not exist", "nonce_handle", v18);
      applog(1, s, 0);
    }
    return -1;
  }
  memcpy((void *)(a2 + 1456 * v18 + 1456 * v16 + 91 * v20), a3 + 2, a4 - 2);
  if ( g_txok_test_enable )
    dump_str((FILE *)app_conf, 0, (int)a3, a4);
  if ( v20 != 15 )
    return 1;
  if ( g_txok_test_enable )
  {
    if ( !txok_flag_8982 )
    {
      v14 = (v17 << 16) | 0x8000FFFE;
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "write txok %08x nonceid %02x\n", v14, v17);
        applog(2, s, 0);
      }
      write_register(36, v14);
      txok_flag_8982 = 1;
      return 1;
    }
    v13 = (v17 << 16) | 0x8000FFFF;
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "write txok %08x nonceid %02x\n", v13, v17);
      applog(2, s, 0);
    }
    write_register(36, v13);
    txok_flag_8982 = 0;
  }
  v15 = nonce_integrality(v18, v16, a1, a2);
  if ( v15 >= 0 )
  {
    pthread_mutex_lock(&nonce_mutex);
    *((_BYTE *)&nonce_fifo + 1357 * nonce_fifo + 1368) = a5;
    *((_BYTE *)&nonce_fifo + 1357 * nonce_fifo + 1356) = *(_BYTE *)(1357 * v16 + a1 + 1357 * v18 + 1344);
    *((_BYTE *)&nonce_fifo + 1357 * nonce_fifo + 1357) = *(_BYTE *)(1357 * v16 + a1 + 1357 * v18 + 1345);
    *((_BYTE *)&nonce_fifo + 1357 * nonce_fifo + 1358) = *(_BYTE *)(1357 * v16 + a1 + 1357 * v18 + 1346);
    *((_BYTE *)&nonce_fifo + 1357 * nonce_fifo + 1359) = *(_BYTE *)(1357 * v16 + a1 + 1357 * v18 + 1347);
    memcpy(
      (char *)&nonce_fifo + 1357 * nonce_fifo + 1360,
      (const void *)(1357 * v16 + 1344 + a1 + 1357 * v18 + 4),
      sizeof(int));
    memcpy(
      (char *)&nonce_fifo + 1357 * nonce_fifo + 1364,
      (const void *)(1357 * v16 + 1352 + a1 + 1357 * v18),
      sizeof(int));
    memcpy((char *)&nonce_fifo + 1357 * nonce_fifo + 12, (const void *)(1357 * v16 + a1 + 1357 * v18), 0x540u);
    if ( (unsigned int)nonce_fifo >= 0x1FE )
      nonce_fifo = 0;
    else
      ++nonce_fifo;
    if ( (unsigned int)dword_49DF4 > 0x1FE )
    {
      dword_49DF4 = 511;
      if ( use_syslog || opt_log_output || opt_log_level > 0 )
      {
        snprintf(s, 0x400u, "%s: nonce fifo full!!!\n", "nonce_handle");
        applog(1, s, 0);
      }
    }
    else
    {
      ++dword_49DF4;
    }
    pthread_mutex_unlock(&nonce_mutex);
    return 0;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 0 )
    {
      v6 = total_error_8981++;
      snprintf(s, 0x400u, "receive a error nonce. total = %u\n", v6);
      applog(1, s, 0);
    }
    return -1;
  }
}
// 47478: using guessed type int addr_interval;
// 47C84: using guessed type int opt_log_level;
// 47E8C: using guessed type pthread_mutex_t nonce_mutex;
// 47EA5: using guessed type char g_txok_test_enable;
// 47EF0: using guessed type int txok_flag_8982;
// 47EF4: using guessed type int total_error_8981;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 49DEC: using guessed type int nonce_fifo;
// 49DF4: using guessed type int dword_49DF4;
// F34DC: using guessed type int app_conf;

//----- (0001D2E0) --------------------------------------------------------
_DWORD *__fastcall add_point(_DWORD *result, int a2)
{
  if ( ++*result >= a2 )
    *result = 0;
  return result;
}

//----- (0001D310) --------------------------------------------------------
void __noreturn handle_asic_response()
{
  pthread_t v0; // r0
  int v1; // r3
  char v2[400]; // [sp+8h] [bp+0h] BYREF
  __int16 v3; // [sp+408h] [bp+400h]
  unsigned __int8 v4; // [sp+40Ah] [bp+402h]
  int v5; // [sp+40Ch] [bp+404h] BYREF
  int v6; // [sp+410h] [bp+408h] BYREF
  int v7; // [sp+1520h] [bp+1518h] BYREF
  _BYTE v8[1032]; // [sp+2508h] [bp+2500h] BYREF
  int v9; // [sp+2910h] [bp+2908h] BYREF
  int v10; // [sp+2914h] [bp+290Ch] BYREF
  _BYTE v11[74400]; // [sp+2918h] [bp+2910h] BYREF
  _BYTE v12[1488]; // [sp+14BB8h] [bp+14BB0h] BYREF
  int v13; // [sp+15188h] [bp+15180h]
  unsigned __int8 v14; // [sp+1518Fh] [bp+15187h]
  int i; // [sp+15190h] [bp+15188h]
  int v16; // [sp+15194h] [bp+1518Ch]

  memset(v12, 0, sizeof(v12));
  v14 = 0;
  v16 = 0;
  v0 = pthread_self();
  pthread_detach(v0);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v2, 0x400u, "Start A New Asic Response.Chain Id:[%d]\n", v14);
    applog(2, v2, 0);
  }
  memset(v11, 0, sizeof(v11));
  v10 = 0;
  v9 = 0;
  memset(v8, 0, 0x406u);
  v13 = 74400;
  while ( 1 )
  {
    do
    {
LABEL_6:
      while ( start_recv != 1 )
        usleep(0x186A0u);
      usleep(0x1F4u);
      v16 = uart_receive(g_chain[8 * v14], (int)v12, 0x5D0u);
      for ( i = 0; i < v16; ++i )
      {
        v11[v9] = v12[i];
        add_point(&v9, v13);
      }
    }
    while ( v10 == v9 );
    if ( v9 <= v10 )
      v1 = 74400 - v10 + v9;
    else
      v1 = v9 - v10;
    v16 = v1;
    while ( v16 > 2 )
    {
      v5 = v10;
      v3 = 0;
      v4 = 0;
      for ( i = 0; i <= 2; ++i )
      {
        *((_BYTE *)&v3 + i) = v11[v5];
        add_point(&v5, v13);
      }
      if ( (unsigned __int8)v3 == 170 && HIBYTE(v3) == 85 )
      {
        if ( (v4 & 0xF0) == 0xE0 )
        {
          if ( v16 <= 92 )
            goto LABEL_6;
          for ( i = 0; i <= 92; ++i )
          {
            v8[i] = v11[v10];
            add_point(&v10, v13);
          }
          v16 -= 93;
          nonce_handle((int)&v7, (int)&v6, v8, 93, v14);
        }
        else if ( v4 == 204 )
        {
          if ( v16 <= 8 )
            goto LABEL_6;
          for ( i = 0; i <= 8; ++i )
          {
            v8[i] = v11[v10];
            add_point(&v10, v13);
          }
          v16 -= 9;
          pm_handle((int)v8, 9, v14);
        }
        else if ( v4 == 208 )
        {
          if ( v16 <= 1029 )
            goto LABEL_6;
          for ( i = 0; i <= 1029; ++i )
          {
            v8[i] = v11[v10];
            add_point(&v10, v13);
          }
          v16 -= 1030;
          pt_handle((int)v8, 1030, v14);
        }
        else
        {
          if ( v16 <= 8 )
            goto LABEL_6;
          for ( i = 0; i <= 8; ++i )
          {
            v8[i] = v11[v10];
            add_point(&v10, v13);
          }
          v16 -= 9;
          reg_handle((int)v8, 9, v14);
        }
      }
      else
      {
        add_point(&v10, v13);
        --v16;
      }
    }
  }
}
// 47C84: using guessed type int opt_log_level;
// 47EA6: using guessed type char start_recv;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001D9E8) --------------------------------------------------------
int bm1744_app_init()
{
  char v2[1024]; // [sp+4h] [bp+4h] BYREF
  int arg; // [sp+404h] [bp+404h] BYREF

  reg_scan_init();
  start_recv = 1;
  for ( arg = 0; ; ++arg )
  {
    if ( arg > 0 )
    {
      if ( !pthread_create((pthread_t *)&p_scanhash, 0, (void *(*)(void *))nonce_scanhash_loop, 0) )
        return 0;
      if ( use_syslog || opt_log_output || opt_log_level > 0 )
      {
        strcpy(v2, "create bm1744_scanhash_loop thread failed\n");
        applog(1, v2, 0);
      }
      return -1;
    }
    if ( pthread_create((pthread_t *)&g_chain[8 * arg + 6], 0, (void *(*)(void *))handle_asic_response, &arg) )
      break;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 0 )
  {
    strcpy(v2, "create p_dispatch failed\n");
    applog(1, v2, 0);
  }
  return -1;
}
// 47C84: using guessed type int opt_log_level;
// 47EA6: using guessed type char start_recv;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 48458: using guessed type int p_scanhash;
// 4845C: using guessed type int g_chain[8];

//----- (0001DB2C) --------------------------------------------------------
int bm1744_app_exit()
{
  int result; // r0
  char s[1024]; // [sp+Ch] [bp+4h] BYREF
  int i; // [sp+40Ch] [bp+404h]

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(s, 0x400u, "%s[%d]\n", "bm1744_app_exit", 1290);
    applog(2, s, 0);
  }
  reg_scan_exit();
  for ( i = 0; i <= 0; ++i )
  {
    pthread_cancel(g_chain[8 * i + 6]);
    pthread_join(g_chain[8 * i + 6], 0);
  }
  pthread_cancel(p_scanhash);
  result = pthread_join(p_scanhash, 0);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(s, 0x400u, "%s[%d]\n", "bm1744_app_exit", 1301);
    return applog(2, s, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 48458: using guessed type int p_scanhash;
// 4845C: using guessed type int g_chain[8];

//----- (0001DC60) --------------------------------------------------------
int __fastcall work_list_insert(char a1, const void *a2)
{
  pthread_mutex_lock(&g_work_list_mutex);
  g_work_list[141 * g_work_list_insert_index] = a1;
  memcpy(&g_work_list[141 * g_work_list_insert_index + 1], a2, 0x8Cu);
  if ( ++g_work_list_insert_index > 9 )
    g_work_list_insert_index = 0;
  return pthread_mutex_unlock(&g_work_list_mutex);
}
// 47EA8: using guessed type int g_work_list_insert_index;
// 47EAC: using guessed type pthread_mutex_t g_work_list_mutex;
// 489CC: using guessed type _BYTE g_work_list[1412];

//----- (0001DD00) --------------------------------------------------------
int __fastcall work_list_find(char a1, void *a2)
{
  int i; // [sp+Ch] [bp+Ch]

  pthread_mutex_lock(&g_work_list_mutex);
  for ( i = 0; i <= 9; ++i )
  {
    if ( a1 == g_work_list[141 * i] )
    {
      memcpy(a2, &g_work_list[141 * i + 1], 0x8Cu);
      return pthread_mutex_unlock(&g_work_list_mutex);
    }
  }
  return pthread_mutex_unlock(&g_work_list_mutex);
}
// 47EAC: using guessed type pthread_mutex_t g_work_list_mutex;
// 489CC: using guessed type _BYTE g_work_list[1412];

//----- (0001DD78) --------------------------------------------------------
size_t __fastcall send_work(unsigned __int8 *a1, char a2, char a3)
{
  char v3; // r2
  size_t result; // r0
  _BYTE src[140]; // [sp+14h] [bp+14h] BYREF
  _BYTE s[148]; // [sp+A0h] [bp+A0h] BYREF
  int i; // [sp+134h] [bp+134h]

  memset(s, 0, 0x92u);
  s[2] = s[2] & 0xEF | (16 * (a2 & 1));
  s[2] = s[2] & 0xFE | a3 & 1;
  v3 = total_work++;
  s[3] = v3;
  memset(src, 0, sizeof(src));
  hex2bin(src, a1, 140);
  memcpy(&s[4], src, 0x8Cu);
  memcpy(&g_work_header, src, 0x8Cu);
  result = work_list_insert(s[3], &s[4]);
  g_new_work = 1;
  for ( i = 0; i <= 0; ++i )
    result = midd_ioctl(g_chain[8 * i], 2, (int)s);
  return result;
}
// 47448: using guessed type char g_new_work;
// 47DDC: using guessed type char total_work;
// 4845C: using guessed type int g_chain[8];

//----- (0001DE98) --------------------------------------------------------
int __fastcall read_sensor(unsigned __int8 a1, int a2, char a3, unsigned __int8 a4, _BYTE *a5)
{
  char s[1024]; // [sp+18h] [bp+10h] BYREF
  int v9; // [sp+418h] [bp+410h] BYREF
  int v10; // [sp+41Ch] [bp+414h]

  v9 = 0;
  if ( i2c_recv(a1, sensor_chip_addr[a2], a3, a4, &v9) )
  {
    v10 = 6;
    if ( !use_syslog && !opt_log_output && opt_log_level <= 0 )
      return v10;
LABEL_17:
    snprintf(
      s,
      0x400u,
      "Read i2c failed sensroid=%02x, sensor-regaddr=%02x sensor-regdata=%08x\n",
      (unsigned __int8)sensor_chip_addr[a2],
      a4,
      v9);
    applog(1, s, 0);
    return v10;
  }
  if ( (v9 & 0xC0000000) != 0 || !(_BYTE)v9 )
  {
    v10 = 6;
    if ( !use_syslog && !opt_log_output && opt_log_level <= 0 )
      return v10;
    goto LABEL_17;
  }
  v10 = 5;
  if ( a5 )
    *a5 = v9;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      s,
      0x400u,
      "Read i2c success sensroid=%02x, sensor-regaddr=%02x sensor-regdata=%08x\n",
      (unsigned __int8)sensor_chip_addr[a2],
      a4,
      v9);
    applog(3, s, 0);
  }
  return v10;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001E094) --------------------------------------------------------
void app_config_init_registers()
{
  g_ticket_mask = dword_F3644;
  g_core_timeout = dword_F3648;
  g_misc_control = dword_F364C;
}
// 47458: using guessed type int g_ticket_mask;
// 4745C: using guessed type int g_misc_control;
// 47460: using guessed type int g_core_timeout;
// F3644: using guessed type int dword_F3644;
// F3648: using guessed type int dword_F3648;
// F364C: using guessed type int dword_F364C;

//----- (0001E0E8) --------------------------------------------------------
void __noreturn rw_register_loop()
{
  while ( 1 )
  {
    write_register(88, 0);
    sleep(1u);
    read_register(0, 1, 0, 88);
    sleep(3u);
    write_register(88, 3);
    sleep(1u);
    read_register(0, 1, 0, 88);
    sleep(3u);
  }
}

//----- (0001E130) --------------------------------------------------------
int __fastcall get_bt8d_from_baud(int a1)
{
  char s[1024]; // [sp+8h] [bp+8h] BYREF
  unsigned int v4; // [sp+408h] [bp+408h]
  unsigned int i; // [sp+40Ch] [bp+40Ch]

  v4 = 5;
  for ( i = 0; ; ++i )
  {
    if ( i >= v4 )
    {
      if ( i != v4 )
        return 255;
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        strcpy(s, "get bt8d value failed!!!,use default to continue\n");
        applog(3, s, 0);
      }
      return get_bt8d_from_baud(115200);
    }
    if ( *((_DWORD *)&baud_BT8D_values + 3 * i) == a1 )
      break;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(s, 0x400u, "get bt8d %d\n", *((unsigned __int8 *)&baud_BT8D_values + 12 * i + 4));
    applog(3, s, 0);
  }
  return *((unsigned __int8 *)&baud_BT8D_values + 12 * i + 4);
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001E280) --------------------------------------------------------
int __fastcall get_index_by_freq(int a1)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 0x64; ++i )
  {
    if ( freq_pll[4 * i] == a1 )
      return i;
  }
  return -1;
}
// 474C4: using guessed type _DWORD freq_pll[404];

//----- (0001E2C4) --------------------------------------------------------
int __fastcall get_freq_by_index(int a1)
{
  return freq_pll[4 * a1];
}
// 474C4: using guessed type _DWORD freq_pll[404];

//----- (0001E2E8) --------------------------------------------------------
int __fastcall get_plldata(int result, _DWORD *a2)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 0x64 && freq_pll[4 * i] != result; ++i )
    ;
  if ( i == 101 )
    i = 4;
  *a2 = freq_pll[4 * i + 3];
  return result;
}
// 474C4: using guessed type _DWORD freq_pll[404];

//----- (0001E34C) --------------------------------------------------------
int __fastcall makeup_work_pkg(void *a1, _BYTE *a2)
{
  unsigned __int16 v5; // [sp+Ah] [bp+Ah]

  a2[2] = a2[2] & 0x1F | 0x20;
  *a2 = 85;
  a2[1] = -86;
  v5 = CRC16_v1(a2 + 2, 142);
  *((_WORD *)a2 + 72) = HIBYTE(v5) | (v5 << 8);
  memcpy(a1, a2, 0x92u);
  return 146;
}

//----- (0001E3B0) --------------------------------------------------------
int __fastcall makeup_set_address_cmd(int a1, unsigned int a2, char a3)
{
  char v4; // r0
  char s[1024]; // [sp+18h] [bp+10h] BYREF
  _DWORD v9[2]; // [sp+418h] [bp+410h] BYREF

  if ( a2 > 6 )
  {
    memset(v9, 0, 5u);
    LOBYTE(v9[0]) = v9[0] & 0x1F | 0x40;
    LOBYTE(v9[0]) &= ~0x10u;
    LOBYTE(v9[0]) &= 0xF0u;
    BYTE1(v9[0]) = 5;
    BYTE2(v9[0]) = a3;
    v4 = CRC5_v1(v9, 0x20u);
    LOBYTE(v9[1]) = v9[1] & 0xE0 | v4 & 0x1F;
    *(_BYTE *)a1 = 85;
    *(_BYTE *)(a1 + 1) = -86;
    *(_DWORD *)(a1 + 2) = v9[0];
    *(_BYTE *)(a1 + 6) = v9[1];
    return 7;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(s, 0x400u, "%s input param error: str length = %u\n", "makeup_set_address_cmd", 7);
      applog(0, s, 0);
    }
    return -1;
  }
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001E4CC) --------------------------------------------------------
int __fastcall makeup_set_config_cmd(int a1, unsigned int a2, char a3, char a4, char a5, unsigned int a6)
{
  char v7; // r0
  int v8; // r1
  char s[1024]; // [sp+18h] [bp+10h] BYREF
  _DWORD v14[4]; // [sp+41Ch] [bp+414h] BYREF

  if ( a2 > 0xA )
  {
    memset(v14, 0, 9u);
    LOBYTE(v14[0]) = v14[0] & 0x1F | 0x40;
    LOBYTE(v14[0]) = v14[0] & 0xEF | (16 * (a3 & 1));
    LOBYTE(v14[0]) = v14[0] & 0xF0 | 1;
    BYTE1(v14[0]) = 9;
    BYTE2(v14[0]) = a4;
    HIBYTE(v14[0]) = a5;
    v14[1] = bswap32(a6);
    v7 = CRC5_v1(v14, 0x40u);
    LOBYTE(v14[2]) = v14[2] & 0xE0 | v7 & 0x1F;
    *(_BYTE *)a1 = 85;
    *(_BYTE *)(a1 + 1) = -86;
    v8 = v14[1];
    *(_DWORD *)(a1 + 2) = v14[0];
    *(_DWORD *)(a1 + 6) = v8;
    *(_BYTE *)(a1 + 10) = v14[2];
    return 11;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(s, 0x400u, "%s input param error: str length = %u\n", "makeup_set_config_cmd", 11);
      applog(0, s, 0);
    }
    return -1;
  }
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001E618) --------------------------------------------------------
int __fastcall makeup_get_status_cmd(int a1, unsigned int a2, char a3, char a4, char a5)
{
  char v6; // r0
  char s[1024]; // [sp+18h] [bp+10h] BYREF
  _DWORD v12[3]; // [sp+418h] [bp+410h] BYREF

  if ( a2 > 6 )
  {
    memset(v12, 0, 5u);
    LOBYTE(v12[0]) = v12[0] & 0x1F | 0x40;
    LOBYTE(v12[0]) = v12[0] & 0xEF | (16 * (a3 & 1));
    LOBYTE(v12[0]) = v12[0] & 0xF0 | 2;
    BYTE1(v12[0]) = 5;
    BYTE2(v12[0]) = a4;
    HIBYTE(v12[0]) = a5;
    v6 = CRC5_v1(v12, 0x20u);
    LOBYTE(v12[1]) = v12[1] & 0xE0 | v6 & 0x1F;
    *(_BYTE *)a1 = 85;
    *(_BYTE *)(a1 + 1) = -86;
    *(_DWORD *)(a1 + 2) = v12[0];
    *(_BYTE *)(a1 + 6) = v12[1];
    return 7;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(s, 0x400u, "%s input param error: str length = %u\n", "makeup_get_status_cmd", 7);
      applog(0, s, 0);
    }
    return -1;
  }
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001E750) --------------------------------------------------------
int __fastcall makeup_chain_inactive_cmd(int a1, unsigned int a2)
{
  char v3; // r0
  char s[1024]; // [sp+10h] [bp+8h] BYREF
  _DWORD v7[2]; // [sp+410h] [bp+408h] BYREF

  if ( a2 > 6 )
  {
    memset(v7, 0, 5u);
    LOBYTE(v7[0]) = v7[0] & 0x1F | 0x40;
    LOBYTE(v7[0]) |= 0x10u;
    LOBYTE(v7[0]) = v7[0] & 0xF0 | 3;
    BYTE1(v7[0]) = 5;
    v3 = CRC5_v1(v7, 0x20u);
    LOBYTE(v7[1]) = v7[1] & 0xE0 | v3 & 0x1F;
    *(_BYTE *)a1 = 85;
    *(_BYTE *)(a1 + 1) = -86;
    *(_DWORD *)(a1 + 2) = v7[0];
    *(_BYTE *)(a1 + 6) = v7[1];
    return 7;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(s, 0x400u, "%s input param error: str length = %u\n", "makeup_chain_inactive_cmd", 7);
      applog(0, s, 0);
    }
    return -1;
  }
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001E854) --------------------------------------------------------
int __fastcall pack_ioctl_pkg(void *a1, unsigned int a2, int a3, int a4)
{
  int status_cmd; // r3
  char s[1024]; // [sp+18h] [bp+10h] BYREF
  int v7; // [sp+418h] [bp+410h]
  int v8; // [sp+41Ch] [bp+414h]
  int v9; // [sp+420h] [bp+418h]
  int v10; // [sp+424h] [bp+41Ch]

  switch ( a3 )
  {
    case 0:
      v10 = a4;
      status_cmd = makeup_get_status_cmd((int)a1, a2, *(_BYTE *)(a4 + 1), *(_BYTE *)a4, *(_BYTE *)(a4 + 2));
      break;
    case 1:
      v9 = a4;
      status_cmd = makeup_set_config_cmd(
                     (int)a1,
                     a2,
                     *(_BYTE *)(a4 + 1),
                     *(_BYTE *)a4,
                     *(_BYTE *)(a4 + 2),
                     *(_DWORD *)(a4 + 4));
      break;
    case 2:
      v7 = a4;
      status_cmd = makeup_work_pkg(a1, (_BYTE *)a4);
      break;
    case 3:
      v8 = a4;
      status_cmd = makeup_set_address_cmd((int)a1, a2, *(_BYTE *)a4);
      break;
    case 4:
      status_cmd = makeup_chain_inactive_cmd((int)a1, a2);
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(s, 0x400u, "unknow ioctl type %d\n", a3);
        applog(0, s, 0);
      }
      status_cmd = 0;
      break;
  }
  return status_cmd;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001E9B0) --------------------------------------------------------
int __fastcall add_reg_item(int a1, int a2, int a3)
{
  int *v3; // r3
  char s[1024]; // [sp+24h] [bp+14h] BYREF
  int i; // [sp+424h] [bp+414h]

  pthread_mutex_lock(&reg_scan_mutex);
  for ( i = 0; ; ++i )
  {
    if ( i > 99 )
    {
      pthread_mutex_unlock(&reg_scan_mutex);
      return -1;
    }
    if ( reg_scan_items[3 * i + 2] < 0 )
      break;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      s,
      0x400u,
      "ADD: chainid=%02x chipaddr=%02x regaddr=%02x regdata=%08x age=%d\n",
      (unsigned __int8)a1,
      BYTE1(a1),
      BYTE2(a1),
      a2,
      a3);
    applog(2, s, 0);
  }
  v3 = &reg_scan_items[3 * i];
  *v3 = a1;
  v3[1] = a2;
  v3[2] = a3;
  pthread_mutex_unlock(&reg_scan_mutex);
  return 1;
}
// 47C84: using guessed type int opt_log_level;
// 47EF8: using guessed type int reg_scan_items[300];
// 483A8: using guessed type pthread_mutex_t reg_scan_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001EABC) --------------------------------------------------------
int __fastcall read_reg_item(unsigned __int8 *a1, int a2)
{
  int v3; // r3
  int i; // [sp+10h] [bp+10h]
  int v7; // [sp+14h] [bp+14h]

  v7 = a2 % 50 + a2 / 50;
  do
  {
    usleep(0xC350u);
    pthread_mutex_lock(&reg_scan_mutex);
    for ( i = 0; i <= 99; ++i )
    {
      if ( *((unsigned __int8 *)&reg_scan_items + 12 * i) == *a1
        && *((unsigned __int8 *)&reg_scan_items + 12 * i + 1) == a1[1]
        && *((unsigned __int8 *)&reg_scan_items + 12 * i + 2) == a1[2]
        && *((int *)&reg_scan_items + 3 * i + 2) >= 0 )
      {
        *((_DWORD *)a1 + 1) = *((_DWORD *)&reg_scan_items + 3 * i + 1);
        *((_DWORD *)&reg_scan_items + 3 * i + 2) = -1;
        pthread_mutex_unlock(&reg_scan_mutex);
        return 1;
      }
    }
    pthread_mutex_unlock(&reg_scan_mutex);
    v3 = v7--;
  }
  while ( v3 > 0 );
  return -1;
}
// 483A8: using guessed type pthread_mutex_t reg_scan_mutex;

//----- (0001EBFC) --------------------------------------------------------
int reg_scan_aging()
{
  pthread_t v0; // r0
  int i; // [sp+4h] [bp+4h]

  v0 = pthread_self();
  pthread_detach(v0);
  while ( alive == 1 )
  {
    sleep(1u);
    pthread_mutex_lock(&reg_scan_mutex);
    for ( i = 0; i <= 99; ++i )
    {
      if ( reg_scan_items[3 * i + 2] >= 0 )
        --reg_scan_items[3 * i + 2];
    }
    pthread_mutex_unlock(&reg_scan_mutex);
  }
  return 0;
}
// 47B14: using guessed type int alive;
// 47EF8: using guessed type int reg_scan_items[300];
// 483A8: using guessed type pthread_mutex_t reg_scan_mutex;

//----- (0001ECA8) --------------------------------------------------------
int reg_scan_init()
{
  int result; // r0
  char v1[1024]; // [sp+4h] [bp+4h] BYREF
  int i; // [sp+404h] [bp+404h]

  memset(reg_scan_items, 0, sizeof(reg_scan_items));
  for ( i = 0; i <= 99; ++i )
    reg_scan_items[3 * i + 2] = -1;
  result = pthread_create((pthread_t *)&p_reg_scan, 0, (void *(*)(void *))reg_scan_aging, 0);
  if ( result && (use_syslog || opt_log_output || opt_log_level > 2) )
  {
    strcpy(v1, "create pthread failed\n");
    return applog(3, v1, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 47EF8: using guessed type int reg_scan_items[300];
// 483C0: using guessed type int p_reg_scan;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001ED7C) --------------------------------------------------------
int reg_scan_exit()
{
  alive = 0;
  usleep(0x16E360u);
  pthread_cancel(p_reg_scan);
  return pthread_join(p_reg_scan, 0);
}
// 47B14: using guessed type int alive;
// 483C0: using guessed type int p_reg_scan;

//----- (0001EDC0) --------------------------------------------------------
unsigned int __fastcall _bswap_32(unsigned int a1)
{
  return bswap32(a1);
}

//----- (0001EDD8) --------------------------------------------------------
unsigned int __fastcall compressArray(int a1, int a2, int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  unsigned int result; // r0
  unsigned int v8; // [sp+18h] [bp+18h]
  unsigned int j; // [sp+1Ch] [bp+1Ch]
  unsigned int i; // [sp+20h] [bp+20h]
  int v11; // [sp+24h] [bp+24h]
  unsigned int v12; // [sp+28h] [bp+28h]
  unsigned int v13; // [sp+2Ch] [bp+2Ch]

  if ( a5 <= 7 )
    _assert_fail("bit_len >= 8", "bm1744/driver/sort-verify.c", 0x15u, "compressArray");
  if ( a5 + 7 > 0x20 )
    _assert_fail("8 * sizeof(uint32_t) >= 7 + bit_len", "bm1744/driver/sort-verify.c", 0x16u, "compressArray");
  v8 = a6 + ((a5 + 7) >> 3);
  result = a2 * a5 / (8 * v8);
  if ( result != a4 )
    _assert_fail("out_len == bit_len * in_len / (8 * in_width)", "bm1744/driver/sort-verify.c", 0x19u, "compressArray");
  v13 = 0;
  v12 = 0;
  v11 = 0;
  for ( i = 0; i < a4; ++i )
  {
    if ( v13 <= 7 )
    {
      v12 <<= a5;
      for ( j = a6; j < v8; ++j )
        v12 |= (((unsigned int)((1 << a5) - 1) >> (8 * (v8 - j - 1))) & *(_BYTE *)(j + v11 + a1)) << (8 * (v8 - j - 1));
      v11 += v8;
      v13 += a5;
    }
    v13 -= 8;
    *(_BYTE *)(i + a3) = v12 >> v13;
  }
  return result;
}

//----- (0001EF38) --------------------------------------------------------
unsigned int __fastcall expandArray(int a1, unsigned int a2, int a3, int a4, unsigned int a5, unsigned int a6)
{
  unsigned int result; // r0
  unsigned int v8; // [sp+14h] [bp+14h]
  unsigned int k; // [sp+18h] [bp+18h]
  unsigned int j; // [sp+1Ch] [bp+1Ch]
  unsigned int i; // [sp+20h] [bp+20h]
  int v12; // [sp+24h] [bp+24h]
  unsigned int v13; // [sp+28h] [bp+28h]
  unsigned int v14; // [sp+2Ch] [bp+2Ch]

  if ( a5 <= 7 )
    _assert_fail("bit_len >= 8", "bm1744/driver/sort-verify.c", 0x3Fu, "expandArray");
  if ( a5 + 7 > 0x20 )
    _assert_fail("8 * sizeof(uint32_t) >= 7 + bit_len", "bm1744/driver/sort-verify.c", 0x40u, "expandArray");
  v8 = a6 + ((a5 + 7) >> 3);
  result = 8 * a2 * v8 / a5;
  if ( result != a4 )
    _assert_fail("out_len == 8 * out_width * in_len / bit_len", "bm1744/driver/sort-verify.c", 0x43u, "expandArray");
  v14 = 0;
  v13 = 0;
  v12 = 0;
  for ( i = 0; i < a2; ++i )
  {
    v13 = (v13 << 8) | *(unsigned __int8 *)(i + a1);
    v14 += 8;
    if ( v14 >= a5 )
    {
      v14 -= a5;
      for ( j = 0; j < a6; ++j )
        *(_BYTE *)(j + v12 + a3) = 0;
      for ( k = a6; k < v8; ++k )
      {
        result = (1 << a5) - 1;
        *(_BYTE *)(a3 + k + v12) = (result >> (8 * (v8 - k - 1))) & (v13 >> (v14 + 8 * (v8 - k - 1)));
      }
      v12 += v8;
    }
  }
  return result;
}

//----- (0001F0B0) --------------------------------------------------------
unsigned int __fastcall getIndices(int a1, int a2, int a3, int a4, int a5, unsigned int a6)
{
  if ( (unsigned int)(a4 + 8) > 0x27 )
    _assert_fail("((cBitLen + 1) + 7) / 8 <= sizeof(uint32_t)", "bm1744/driver/sort-verify.c", 0x6Du, "getIndices");
  if ( (unsigned int)(a3 * (a4 + 1)) >> 5 > a6 )
    return -1;
  if ( a5 )
    compressArray(a1 + a2, a3, a5, (unsigned int)(a3 * (a4 + 1)) >> 5, a4 + 1, 4 - ((unsigned int)(a4 + 8) >> 3));
  return (unsigned int)(a3 * (a4 + 1)) >> 5;
}

//----- (0001F138) --------------------------------------------------------
int __fastcall isZero(int a1, unsigned int a2)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i < a2; ++i )
  {
    if ( *(_BYTE *)(i + a1) )
      return 0;
  }
  return 1;
}

//----- (0001F174) --------------------------------------------------------
int __fastcall generateHash(const void *a1, int a2, void *a3, unsigned __int8 a4)
{
  _BYTE dest[364]; // [sp+10h] [bp+10h] BYREF
  char v8[8]; // [sp+17Ch] [bp+17Ch] BYREF

  *(_DWORD *)v8 = a2;
  memcpy(dest, a1, 0x168u);
  blake2b_update((int)dest, v8, 4u);
  return blake2b_final((int)dest, a3, a4);
}

//----- (0001F1E0) --------------------------------------------------------
int __fastcall compareSR(const void *a1, const void *a2)
{
  return memcmp(a1, a2, compare_size);
}
// 47B18: using guessed type int compare_size;

//----- (0001F208) --------------------------------------------------------
int __fastcall sort_pair(int result, unsigned int a2)
{
  int v2; // [sp+8h] [bp+8h]
  int v3; // [sp+Ch] [bp+Ch]
  unsigned int i; // [sp+10h] [bp+10h]
  int v5; // [sp+14h] [bp+14h]

  v3 = 4 * a2 + result;
  v5 = 0;
  for ( i = 0; i < a2; ++i )
  {
    if ( v5 || *(_DWORD *)(4 * i + result) > *(_DWORD *)(4 * i + v3) )
    {
      v5 = 1;
      v2 = *(_DWORD *)(4 * i + result);
      *(_DWORD *)(4 * i + result) = *(_DWORD *)(4 * i + v3);
      *(_DWORD *)(4 * i + v3) = v2;
    }
    else if ( *(_DWORD *)(4 * i + result) < *(_DWORD *)(4 * i + v3) )
    {
      return result;
    }
  }
  return result;
}

//----- (0001F2AC) --------------------------------------------------------
int __fastcall sortValidator(_DWORD *a1, int a2)
{
  int v2; // r3
  unsigned int v3; // r0
  int v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // r1
  int v8; // r2
  _BYTE v10[4]; // [sp+14h] [bp+Ch] BYREF
  signed int v11; // [sp+48h] [bp+40h] BYREF
  _BYTE v12[12]; // [sp+4Ch] [bp+44h] BYREF
  _BYTE v13[12]; // [sp+6Ch] [bp+64h] BYREF
  _BYTE v14[1356]; // [sp+8Ch] [bp+84h] BYREF
  _BYTE src[32]; // [sp+DCCh] [bp+DC4h] BYREF
  _DWORD s[8]; // [sp+DECh] [bp+DE4h] BYREF
  _DWORD v17[511]; // [sp+E0Ch] [bp+E04h] BYREF
  char *v18; // [sp+160Ch] [bp+1604h]
  char *v19; // [sp+1610h] [bp+1608h]
  signed int v20; // [sp+1614h] [bp+160Ch]
  _BYTE *v21; // [sp+1618h] [bp+1610h]
  int v22; // [sp+161Ch] [bp+1614h]
  unsigned int v23; // [sp+1620h] [bp+1618h]
  int v24; // [sp+1624h] [bp+161Ch]
  int v25; // [sp+1628h] [bp+1620h]
  unsigned int v26; // [sp+162Ch] [bp+1624h]
  int v27; // [sp+1630h] [bp+1628h]
  unsigned int v28; // [sp+1634h] [bp+162Ch]
  const void *v29; // [sp+1638h] [bp+1630h]
  int v30; // [sp+163Ch] [bp+1634h]
  int v31; // [sp+1640h] [bp+1638h]
  _DWORD *v32; // [sp+1644h] [bp+163Ch]
  unsigned int i4; // [sp+1648h] [bp+1640h]
  size_t i3; // [sp+164Ch] [bp+1644h]
  int i2; // [sp+1650h] [bp+1648h]
  int i1; // [sp+1654h] [bp+164Ch]
  int nn; // [sp+1658h] [bp+1650h]
  unsigned int mm; // [sp+165Ch] [bp+1654h]
  int kk; // [sp+1660h] [bp+1658h]
  unsigned int jj; // [sp+1664h] [bp+165Ch]
  size_t ii; // [sp+1668h] [bp+1660h]
  int n; // [sp+166Ch] [bp+1664h]
  unsigned int m; // [sp+1670h] [bp+1668h]
  int k; // [sp+1674h] [bp+166Ch]
  int j; // [sp+1678h] [bp+1670h]
  int i; // [sp+167Ch] [bp+1674h]
  size_t v47; // [sp+1680h] [bp+1678h]
  char *v48; // [sp+1684h] [bp+167Ch]
  char *v49; // [sp+1688h] [bp+1680h]
  int v50; // [sp+168Ch] [bp+1684h]
  size_t v51; // [sp+1690h] [bp+1688h]
  size_t v52; // [sp+1694h] [bp+168Ch]

  v32 = a1;
  v31 = *a1;
  v30 = a1[1];
  v29 = (const void *)a1[2];
  v28 = v31 / (v30 + 1);
  v2 = v28 + 7;
  if ( (int)(v28 + 7) < 0 )
    v2 = v28 + 14;
  v27 = v2 >> 3;
  v26 = (v2 >> 3) * (v30 + 1);
  v25 = 512 / v31;
  v24 = v31 * (512 / v31) / 8;
  v23 = ((v31 / (v30 + 1) + 1) << v30) / 8;
  v22 = 512;
  v52 = 4;
  v51 = 512;
  v50 = 0;
  compare_size = 3;
  expandArray(a2, v23, (int)v17, 2048, v28 + 1, 1u);
  memset(s, 0, 0x1Eu);
  v49 = (char *)malloc(0x4400u);
  v48 = (char *)malloc(0x4400u);
  v21 = 0;
  v47 = 0;
  memset(src, 0, 0x1Eu);
  for ( i = 0; i < v22; ++i )
  {
    for ( j = i + 1; j < v22; ++j )
    {
      if ( v17[i] == v17[j] )
      {
        v50 = 1;
        goto LABEL_51;
      }
    }
  }
  for ( k = 0; k < v22; ++k )
  {
    v20 = _bswap_32(v17[k]);
    generateHash(v29, v20 / v25, v10, v24);
    expandArray((int)&v10[v31 * (v20 % v25) / 8], v31 / 8, (int)v13, v26, v28, 0);
    for ( m = 0; m < v26; ++m )
      *((_BYTE *)s + m) ^= v13[m];
    memcpy(&v49[k * (v52 + v26)], v13, v26);
    memcpy(&v49[v26 + k * (v52 + v26)], &v17[k], v52);
  }
  if ( isZero((int)s, 0x1Eu) )
  {
    memset(s, 0, 0x1Eu);
    for ( n = 0; n <= 8; ++n )
    {
      qsort(v49, v51, v26 + v52, compareSR);
      v47 = 0;
      for ( ii = 0; ii < v51; ii += 2 )
      {
        for ( jj = 0; jj < v26; ++jj )
          src[jj] = v49[jj + (ii + 1) * (v52 + v26)] ^ v49[jj + ii * (v52 + v26)];
        memcpy(&v48[(ii >> 1) * (v26 + 2 * v52)], src, v26);
        memcpy(&v48[v26 + (ii >> 1) * (v26 + 2 * v52)], &v49[v26 + ii * (v52 + v26)], v52);
        memcpy(&v48[v52 + (ii >> 1) * (v26 + 2 * v52) + v26], &v49[v26 + (ii + 1) * (v52 + v26)], v52);
        ++v47;
      }
      v52 *= 2;
      v19 = v49;
      v49 = v48;
      v48 = v19;
      v51 = v47;
      compare_size += 3;
    }
    for ( kk = 0; kk < 512; ++kk )
    {
      v3 = _bswap_32(*(_DWORD *)&v49[4 * kk + v26]);
      *(_DWORD *)&v14[4 * kk + 1344] = v3;
    }
    for ( mm = 0; mm <= 8; ++mm )
    {
      for ( nn = 0; nn < 512; nn += 2 << mm )
        sort_pair((int)&v14[4 * nn + 1344], 1 << mm);
    }
    v52 = 4;
    v51 = 512;
    for ( i1 = 0; i1 < v22; ++i1 )
    {
      v11 = *(_DWORD *)&v14[4 * i1 + 1344];
      generateHash(v29, v11 / v25, v10, v24);
      expandArray((int)&v10[v31 * (v11 % v25) / 8], v31 / 8, (int)v12, v26, v28, 0);
      v11 = _bswap_32(*(_DWORD *)&v14[4 * i1 + 1344]);
      memcpy(&v49[i1 * (v52 + v26)], v12, v26);
      memcpy(&v49[v26 + i1 * (v52 + v26)], &v11, v52);
      v21 = bin2hex((int)&v49[i1 * (v52 + v26)], 34);
      free(v21);
    }
    for ( i2 = 0; i2 <= 8; ++i2 )
    {
      v47 = 0;
      for ( i3 = 0; i3 < v51; i3 += 2 )
      {
        for ( i4 = 0; i4 < v26; ++i4 )
          src[i4] = v49[i4 + (i3 + 1) * (v52 + v26)] ^ v49[i4 + i3 * (v52 + v26)];
        memcpy(&v48[(i3 >> 1) * (v26 + 2 * v52)], src, v26);
        memcpy(&v48[v26 + (i3 >> 1) * (v26 + 2 * v52)], &v49[v26 + i3 * (v52 + v26)], v52);
        memcpy(&v48[v52 + (i3 >> 1) * (v26 + 2 * v52) + v26], &v49[v26 + (i3 + 1) * (v52 + v26)], v52);
        ++v47;
      }
      v52 *= 2;
      v18 = v49;
      v49 = v48;
      v48 = v18;
      v51 = v47;
      compare_size += 3;
    }
    getIndices((int)v49, v26, 2048, 20, (int)v14, 0x540u);
    v21 = bin2hex((int)v14, 1344);
    free(v21);
    v21 = bin2hex((int)v49, v52 + v26);
    free(v21);
    v4 = *((_DWORD *)v49 + 1);
    v5 = *((_DWORD *)v49 + 2);
    v6 = *((_DWORD *)v49 + 3);
    s[0] = *(_DWORD *)v49;
    s[1] = v4;
    s[2] = v5;
    s[3] = v6;
    v7 = *((_DWORD *)v49 + 5);
    v8 = *((_DWORD *)v49 + 6);
    s[4] = *((_DWORD *)v49 + 4);
    s[5] = v7;
    s[6] = v8;
    LOWORD(s[7]) = *((_WORD *)v49 + 14);
    if ( !isZero((int)s, 0x1Eu) )
      v50 = 3;
  }
  else
  {
    v50 = 2;
  }
LABEL_51:
  free(v49);
  free(v48);
  return v50;
}
// 47B18: using guessed type int compare_size;

//----- (00020280) --------------------------------------------------------
void *__fastcall zcashPerson(_DWORD *a1, int a2, int a3)
{
  void *result; // r0

  result = memcpy(a1, "ZcashPoW", 8u);
  a1[2] = a2;
  a1[3] = a3;
  return result;
}

//----- (000202B4) --------------------------------------------------------
int __fastcall digestInit(void *a1, int a2, int a3)
{
  _DWORD s[16]; // [sp+10h] [bp+10h] BYREF

  memset(s, 0, sizeof(s));
  HIWORD(s[0]) = 257;
  LOBYTE(s[0]) = a2 * (512 / a2) / 8;
  zcashPerson(&s[12], a2, a3);
  return blake2b_init_param(a1, (int)s);
}

//----- (00020320) --------------------------------------------------------
int __fastcall CRC5(_BYTE *a1, unsigned __int8 a2)
{
  _BYTE v4[5]; // [sp+Ch] [bp+Ch]
  int v5; // [sp+14h] [bp+14h]
  char v6; // [sp+18h] [bp+18h]
  bool v7; // [sp+1Bh] [bp+1Bh]
  unsigned __int8 v8; // [sp+1Ch] [bp+1Ch]
  char v9; // [sp+1Dh] [bp+1Dh]
  unsigned __int8 v10; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v5 = 16843009;
  v6 = 1;
  v10 = 0x80;
  v9 = 0;
  for ( i = 0; i < (unsigned int)a2; ++i )
  {
    v7 = (v10 & *a1) != 0;
    v4[0] = v7 ^ v6;
    v4[1] = v5;
    v4[2] = v7 ^ v6 ^ BYTE1(v5);
    *(_WORD *)&v4[3] = HIWORD(v5);
    v10 >>= 1;
    if ( ++v9 == 8 )
    {
      v10 = 0x80;
      v9 = 0;
      ++a1;
    }
    v5 = *(_DWORD *)v4;
    v6 = v4[4];
  }
  v8 = 0;
  if ( v6 )
    v8 = 16;
  if ( HIBYTE(v5) )
    v8 |= 8u;
  if ( BYTE2(v5) )
    v8 |= 4u;
  if ( BYTE1(v5) )
    v8 |= 2u;
  if ( (_BYTE)v5 )
    v8 |= 1u;
  return v8;
}

//----- (00020440) --------------------------------------------------------
int __fastcall CRC16(_BYTE *a1, __int16 a2)
{
  _BYTE *v2; // r3
  unsigned __int16 v7; // [sp+Ch] [bp+Ch]
  unsigned __int8 v8; // [sp+Eh] [bp+Eh]
  unsigned __int8 v9; // [sp+Fh] [bp+Fh]

  v9 = -1;
  v8 = -1;
  while ( a2-- )
  {
    v2 = a1++;
    v7 = (unsigned __int8)(v8 ^ *v2);
    v8 = v9 ^ chCRCHTalbe[v8 ^ *v2];
    v9 = chCRCLTalbe[v7];
  }
  return (unsigned __int16)v8 | (unsigned __int16)(v9 << 8);
}
// 3408C: using guessed type _BYTE chCRCHTalbe[256];
// 3418C: using guessed type _BYTE chCRCLTalbe[256];

//----- (000204B0) --------------------------------------------------------
int bitmain_axi_init()
{
  char v2[1024]; // [sp+8h] [bp+0h] BYREF
  int v3; // [sp+408h] [bp+400h]
  int v4; // [sp+40Ch] [bp+404h]

  v4 = 0;
  fd_fpga = open("/dev/axi_fpga_dev", 2);
  if ( fd_fpga >= 0 )
  {
    axi_fpga_addr = (int)mmap(0, 0x1200u, 3, 1, fd_fpga, 0);
    if ( axi_fpga_addr )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v2, 0x400u, "mmap axi_fpga_addr = 0x%p\n", (const void *)axi_fpga_addr);
        applog(2, v2, 0);
      }
      v3 = (unsigned __int16)*(_DWORD *)axi_fpga_addr;
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v2, 0x400u, "axi_fpga_addr data = 0x%x\n", v3);
        applog(2, v2, 0);
      }
      fd_fpga_mem = open("/dev/fpga_mem", 2);
      if ( fd_fpga_mem >= 0 )
      {
        fpga_mem_addr = (int)mmap(0, 0x1000000u, 3, 1, fd_fpga_mem, 0);
        if ( fpga_mem_addr )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            snprintf(v2, 0x400u, "mmap fpga_mem_addr = 0x%p\n", (const void *)fpga_mem_addr);
            applog(2, v2, 0);
          }
          return v4;
        }
        else
        {
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            snprintf(v2, 0x400u, "mmap fpga_mem_addr failed. fpga_mem_addr = 0x%p\n", (const void *)fpga_mem_addr);
            applog(2, v2, 0);
          }
          return -1;
        }
      }
      else
      {
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf(v2, 0x400u, "/dev/fpga_mem open failed. fd_fpga_mem = %d\n", fd_fpga_mem);
          applog(2, v2, 0);
        }
        return -1;
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v2, 0x400u, "mmap axi_fpga_addr failed. axi_fpga_addr = 0x%p\n", (const void *)axi_fpga_addr);
        applog(2, v2, 0);
      }
      return -1;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v2, 0x400u, "/dev/axi_fpga_dev open failed. fd = %d\n", fd_fpga);
      applog(2, v2, 0);
    }
    return -1;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483C4: using guessed type int fpga_mem_addr;
// 483C8: using guessed type int axi_fpga_addr;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F32AC: using guessed type int fd_fpga_mem;
// F32B0: using guessed type int fd_fpga;

//----- (000207F0) --------------------------------------------------------
int bitmain_axi_close()
{
  char s[1024]; // [sp+4h] [bp+4h] BYREF
  int v2; // [sp+404h] [bp+404h]

  v2 = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(s, 0x400u, "--- %s\n", "bitmain_axi_close");
    applog(2, s, 0);
  }
  v2 = munmap((void *)axi_fpga_addr, 0x1200u);
  if ( v2 < 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy(s, "munmap failed!\n");
    applog(2, s, 0);
  }
  v2 = munmap((void *)fpga_mem_addr, 0x1000000u);
  if ( v2 < 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy(s, "munmap failed!\n");
    applog(2, s, 0);
  }
  close(fd_fpga);
  return close(fd_fpga_mem);
}
// 47C84: using guessed type int opt_log_level;
// 483C4: using guessed type int fpga_mem_addr;
// 483C8: using guessed type int axi_fpga_addr;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F32AC: using guessed type int fd_fpga_mem;
// F32B0: using guessed type int fd_fpga;

//----- (00020948) --------------------------------------------------------
int __fastcall read_axi_fpga(int a1)
{
  return *(_DWORD *)(4 * a1 + axi_fpga_addr);
}
// 483C8: using guessed type int axi_fpga_addr;

//----- (00020978) --------------------------------------------------------
int __fastcall write_axi_fpga(int result, int a2)
{
  *(_DWORD *)(4 * result + axi_fpga_addr) = a2;
  return result;
}
// 483C8: using guessed type int axi_fpga_addr;

//----- (000209A4) --------------------------------------------------------
int init_fpga()
{
  char s[1024]; // [sp+4h] [bp+4h] BYREF
  int v2; // [sp+404h] [bp+404h]

  v2 = -2147450880;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(s, 0x400u, "--- %s\n", "init_fpga");
    applog(2, s, 0);
  }
  write_axi_fpga(32, v2);
  while ( read_axi_fpga(32) < 0 )
    usleep(0x2710u);
  return usleep(0x186A0u);
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00020A3C) --------------------------------------------------------
int __fastcall get_return_nonce(int *a1)
{
  int result; // r0

  *a1 = read_axi_fpga(4);
  result = read_axi_fpga(5);
  a1[1] = result;
  return result;
}

//----- (00020A68) --------------------------------------------------------
int __fastcall set_BC_command_buffer(int *a1)
{
  write_axi_fpga(49, *a1);
  write_axi_fpga(50, a1[1]);
  return write_axi_fpga(51, a1[2]);
}

//----- (00020AA0) --------------------------------------------------------
int get_BC_write_command()
{
  return read_axi_fpga(48);
}

//----- (00020AC0) --------------------------------------------------------
int __fastcall set_BC_write_command(int a1)
{
  char s[1027]; // [sp+Ch] [bp+Ch] BYREF
  char v4; // [sp+40Fh] [bp+40Fh]

  v4 = 0;
  if ( a1 < 0 )
  {
    while ( get_BC_write_command() < 0 )
    {
      usleep(0x3E8u);
      if ( (unsigned __int8)++v4 > 0x64u )
      {
        v4 = 0;
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf(s, 0x400u, "%s: timeout\n\n", "set_BC_write_command");
          applog(2, s, 0);
        }
        return write_axi_fpga(48, a1);
      }
    }
  }
  return write_axi_fpga(48, a1);
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00020B74) --------------------------------------------------------
int __fastcall asic_baud_to_fpga_baud(unsigned __int8 a1)
{
  int v1; // r3
  char s[1024]; // [sp+10h] [bp+8h] BYREF

  switch ( a1 )
  {
    case 0u:
      v1 = 1;
      break;
    case 1u:
      v1 = 3;
      break;
    case 2u:
      v1 = 5;
      break;
    case 6u:
      v1 = 13;
      break;
    case 0x1Au:
      v1 = 53;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "%s: Don't support ASIC baud = %d, error!!!\n", "asic_baud_to_fpga_baud", a1);
        applog(2, s, 0);
      }
      v1 = 53;
      break;
  }
  return v1;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00020C78) --------------------------------------------------------
int __fastcall set_fpga_baud(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp+Fh]

  v2 = asic_baud_to_fpga_baud(a1);
  return write_axi_fpga(15, v2);
}

//----- (00020CA0) --------------------------------------------------------
int __fastcall i2c_write(int a1)
{
  int v3; // [sp+40Ch] [bp+40Ch]

  v3 = 0;
  while ( read_axi_fpga(12) >= 0 )
    usleep(0x1388u);
  return write_axi_fpga(12, a1);
}
// 20CC2: conditional instruction was optimized away because %var_4.4==0
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00020D3C) --------------------------------------------------------
int __fastcall i2c_read(int a1)
{
  int axi_fpga; // [sp+408h] [bp+408h]
  int v3; // [sp+40Ch] [bp+40Ch]

  v3 = 0;
  axi_fpga = 255;
  i2c_write(a1 | 0x2000000);
  do
  {
    usleep(0x1388u);
    axi_fpga = read_axi_fpga(12);
  }
  while ( axi_fpga >= 0 );
  return (unsigned __int8)axi_fpga;
}
// 20D82: conditional instruction was optimized away because %var_4.4==0
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00020DEC) --------------------------------------------------------
int __fastcall ISL_page_enable(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  _BYTE v5[8]; // [sp+Ch] [bp+4h] BYREF

  v5[3] = a1;
  v5[2] = a2;
  v5[1] = a3;
  v5[0] = a4;
  write_dc_dc(a1, a2, a3, 0, (int)v5, 1);
  return 0;
}

//----- (00020E28) --------------------------------------------------------
int __fastcall ISL_on(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  char v4; // [sp+17h] [bp+Fh] BYREF

  v4 = 0x80;
  write_dc_dc(a1, a2, a3, 1, (int)&v4, 1);
  return 0;
}

//----- (00020E60) --------------------------------------------------------
int __fastcall ISL_off(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  char v4; // [sp+17h] [bp+Fh] BYREF

  v4 = 64;
  write_dc_dc(a1, a2, a3, 1, (int)&v4, 1);
  return 0;
}

//----- (00020E98) --------------------------------------------------------
int __fastcall ISL_set_on_off_config(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  _BYTE v5[8]; // [sp+Ch] [bp+4h] BYREF

  v5[3] = a1;
  v5[2] = a2;
  v5[1] = a3;
  v5[0] = a4;
  write_dc_dc(a1, a2, a3, 2, (int)v5, 1);
  return 0;
}

//----- (00020ED4) --------------------------------------------------------
int __fastcall ISL_set_clear_faults(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  char v4; // [sp+17h] [bp+Fh] BYREF

  v4 = 1;
  write_dc_dc(a1, a2, a3, 3, (int)&v4, 1);
  return 0;
}

//----- (00020F0C) --------------------------------------------------------
int __fastcall ISL_set_write_protect(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  _BYTE v5[8]; // [sp+Ch] [bp+4h] BYREF

  v5[3] = a1;
  v5[2] = a2;
  v5[1] = a3;
  v5[0] = a4;
  write_dc_dc(a1, a2, a3, 16, (int)v5, 1);
  return 0;
}

//----- (00020F48) --------------------------------------------------------
int __fastcall ISL_set_vout_command(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int16 a4)
{
  unsigned __int16 v8; // [sp+14h] [bp+Ch] BYREF

  v8 = a4;
  printf("uint16 = 0x%04x[%u], cmd0=%02x cmd1=%02x\n", a4, a4, (unsigned __int8)a4, HIBYTE(a4));
  write_dc_dc(a1, a2, a3, 33, (int)&v8, 2);
  return 0;
}

//----- (00020FB0) --------------------------------------------------------
int __fastcall ISL_set_apply_settings(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  char v4; // [sp+17h] [bp+Fh] BYREF

  v4 = 1;
  write_dc_dc(a1, a2, a3, 231, (int)&v4, 1);
  return 0;
}

//----- (00020FE8) --------------------------------------------------------
int __fastcall ISL_get_voltage(unsigned __int8 a1, unsigned __int8 a2, char a3, _WORD *a4)
{
  _BYTE s[4]; // [sp+14h] [bp+Ch] BYREF

  memset(s, 0, 2u);
  read_dc_dc(a1, a2, a3, 33, (int)s, 2);
  *a4 = (s[1] << 8) | s[0];
  return 0;
}

//----- (00021040) --------------------------------------------------------
int __fastcall ISL_read_reg_default(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  _BYTE v7[4]; // [sp+14h] [bp+Ch] BYREF

  v7[0] = 0;
  v7[1] = 0;
  read_dc_dc(a1, a2, a3, 0, (int)v7, 1);
  read_dc_dc(a1, a2, a3, 1, (int)v7, 1);
  read_dc_dc(a1, a2, a3, 2, (int)v7, 1);
  read_dc_dc(a1, a2, a3, 3, (int)v7, 1);
  read_dc_dc(a1, a2, a3, 16, (int)v7, 1);
  read_dc_dc(a1, a2, a3, 33, (int)v7, 2);
  read_dc_dc(a1, a2, a3, 34, (int)v7, 1);
  return 0;
}

//----- (00021100) --------------------------------------------------------
int __fastcall ISL_set_voltage(unsigned __int8 a1, unsigned __int8 a2, char a3, unsigned __int16 a4)
{
  unsigned __int16 v9; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 v10; // [sp+Eh] [bp+Eh]
  unsigned __int8 v11; // [sp+Fh] [bp+Fh]

  puts("begin to read voltage");
  ISL_page_enable(a1, a2, a3, 0);
  usleep(0x186A0u);
  usleep(0x186A0u);
  ISL_set_vout_command(a1, a2, a3, a4);
  usleep(0x186A0u);
  usleep(0x186A0u);
  puts("end to read voltage");
  v11 = 0;
  v10 = 5;
  v9 = 0;
  do
  {
    usleep(0x186A0u);
    ISL_get_voltage(a1, a2, a3, &v9);
    ++v11;
  }
  while ( v11 <= (unsigned int)v10 && !v9 );
  printf("--- ISL_get_voltage, Voltage: 0.%03d V\n\n", v9);
  return v9;
}

//----- (000211D4) --------------------------------------------------------
int open_key()
{
  char v1[1024]; // [sp+0h] [bp+0h] BYREF

  dword_F34A8 = open("/sys/class/gpio/gpio943/value", 2048);
  if ( dword_F34A8 < 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy(v1, "open key failed!!!\n");
    applog(2, v1, 0);
  }
  return dword_F34A8;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34A8: using guessed type int dword_F34A8;

//----- (00021268) --------------------------------------------------------
int close_key()
{
  int result; // r0
  char v1[1028]; // [sp+0h] [bp+0h] BYREF

  result = close(dword_F34A8);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v1, "key closed!!!\n");
    return applog(2, v1, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34A8: using guessed type int dword_F34A8;

//----- (000212D8) --------------------------------------------------------
int __fastcall read_key(char a1)
{
  _BYTE buf[5]; // [sp+7h] [bp+7h] BYREF
  char s[1024]; // [sp+Ch] [bp+Ch] BYREF
  ssize_t v5; // [sp+40Ch] [bp+40Ch]

  buf[0] = a1;
  v5 = 0;
  lseek(dword_F34A8, 0, 0);
  v5 = read(dword_F34A8, buf, 1u);
  if ( v5 == 1 )
    return 1;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(s, 0x400u, "%s: can't read out key value\n", "read_key");
    applog(2, s, 0);
  }
  return -1;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34A8: using guessed type int dword_F34A8;

//----- (00021388) --------------------------------------------------------
int open_lcd()
{
  char v1[1024]; // [sp+0h] [bp+0h] BYREF

  dword_F34A0 = open("/dev/bitmain-lcd", 2178);
  if ( dword_F34A0 <= 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy(v1, "open lcd failed!!!\n");
    applog(2, v1, 0);
  }
  return dword_F34A0;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34A0: using guessed type int dword_F34A0;

//----- (0002141C) --------------------------------------------------------
int close_lcd()
{
  char v1[1024]; // [sp+4h] [bp+4h] BYREF
  int v2; // [sp+404h] [bp+404h]

  v2 = close(dword_F34A0);
  if ( v2 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy(v1, "lcd close failed!!!\n");
      applog(2, v1, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v1, "lcd closed!!!\n");
    applog(2, v1, 0);
  }
  return v2;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34A0: using guessed type int dword_F34A0;

//----- (000214F8) --------------------------------------------------------
unsigned int __fastcall write_lcd(unsigned int result, int a2, unsigned int a3)
{
  unsigned int v3; // r3
  size_t v4; // [sp+4h] [bp+4h]
  unsigned int v6; // [sp+Ch] [bp+Ch]
  char s[1024]; // [sp+14h] [bp+14h] BYREF
  int v8; // [sp+414h] [bp+414h]

  v6 = result;
  v4 = a3;
  v8 = 0;
  if ( a2 && dword_F34A0 > 0 )
  {
    if ( result <= 3 && a3 <= 0x40 )
    {
      lseek(dword_F34A0, 0, 0);
      memset(lcd_output, 32, 0x40u);
      while ( v4 )
      {
        if ( v4 <= 0x10 )
        {
          memcpy(&lcd_output[16 * v6], (const void *)(a2 + v8), v4);
          return write(dword_F34A0, lcd_output, 0x40u);
        }
        v3 = v6++;
        memcpy(&lcd_output[16 * v3], (const void *)(v8 + a2), 0x10u);
        v4 -= 16;
        v8 += 16;
      }
      return write(dword_F34A0, lcd_output, 0x40u);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "%s: write_lcd's arg is overflow\n", "write_lcd");
      return applog(2, s, 0);
    }
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34A0: using guessed type int dword_F34A0;

//----- (00021670) --------------------------------------------------------
unsigned int __fastcall write_lcd_no_memset(unsigned int result, int a2, unsigned int a3)
{
  unsigned int v3; // r3
  size_t v4; // [sp+4h] [bp+4h]
  unsigned int v6; // [sp+Ch] [bp+Ch]
  char s[1024]; // [sp+14h] [bp+14h] BYREF
  int v8; // [sp+414h] [bp+414h]

  v6 = result;
  v4 = a3;
  v8 = 0;
  if ( a2 && dword_F34A0 > 0 )
  {
    if ( result <= 3 && a3 <= 0x40 )
    {
      while ( v4 )
      {
        if ( v4 <= 0x10 )
        {
          memcpy(&lcd_output[16 * v6], (const void *)(a2 + v8), v4);
          return write(dword_F34A0, lcd_output, 0x40u);
        }
        v3 = v6++;
        memcpy(&lcd_output[16 * v3], (const void *)(v8 + a2), 0x10u);
        v4 -= 16;
        v8 += 16;
      }
      return write(dword_F34A0, lcd_output, 0x40u);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "%s: write_lcd's arg is overflow\n", "write_lcd_no_memset");
      return applog(2, s, 0);
    }
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34A0: using guessed type int dword_F34A0;

//----- (000217C0) --------------------------------------------------------
int open_red_led()
{
  char v1[1024]; // [sp+0h] [bp+0h] BYREF

  red_led_fd = open("/sys/class/gpio/gpio941/value", 2049);
  if ( red_led_fd < 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy(v1, "open red led failed!!!\n");
    applog(2, v1, 0);
  }
  return red_led_fd;
}
// 47C84: using guessed type int opt_log_level;
// 483CC: using guessed type int red_led_fd;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00021858) --------------------------------------------------------
int close_red_led()
{
  int result; // r0
  char v1[1024]; // [sp+0h] [bp+0h] BYREF

  result = close(red_led_fd);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v1, "red led closed!!!\n");
    return applog(2, v1, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 483CC: using guessed type int red_led_fd;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000218D0) --------------------------------------------------------
ssize_t red_led_on()
{
  return write(red_led_fd, "1", 1u);
}
// 483CC: using guessed type int red_led_fd;

//----- (000218F4) --------------------------------------------------------
ssize_t red_led_off()
{
  return write(red_led_fd, "0", 1u);
}
// 483CC: using guessed type int red_led_fd;

//----- (00021918) --------------------------------------------------------
int open_green_led()
{
  char v1[1024]; // [sp+0h] [bp+0h] BYREF

  green_led_fd = open("/sys/class/gpio/gpio942/value", 2049);
  if ( green_led_fd < 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy(v1, "open green led failed!!!\n");
    applog(2, v1, 0);
  }
  return green_led_fd;
}
// 47C84: using guessed type int opt_log_level;
// 483D0: using guessed type int green_led_fd;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000219B0) --------------------------------------------------------
int close_green_led()
{
  int result; // r0
  char v1[1024]; // [sp+0h] [bp+0h] BYREF

  result = close(green_led_fd);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v1, "green led closed!!!\n");
    return applog(2, v1, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 483D0: using guessed type int green_led_fd;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00021A24) --------------------------------------------------------
ssize_t green_led_on()
{
  return write(green_led_fd, "1", 1u);
}
// 483D0: using guessed type int green_led_fd;

//----- (00021A48) --------------------------------------------------------
ssize_t green_led_off()
{
  return write(green_led_fd, "0", 1u);
}
// 483D0: using guessed type int green_led_fd;

//----- (00021A6C) --------------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[1024]; // [sp+0h] [bp+0h] BYREF
  char s[32]; // [sp+400h] [bp+400h] BYREF

  app_config_handle("/mnt/card/app_config.ini");
  memset(s, 0, sizeof(s));
  sprintf(s, "%s.log", byte_F34E0);
  app_conf = (int)fopen(s, "w+");
  if ( app_conf )
  {
    start_pcba_test();
    fclose((FILE *)app_conf);
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v4, 0x400u, "open %s file error\n", s);
    applog(2, v4, 0);
  }
  return 0;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34DC: using guessed type int app_conf;

//----- (00021B44) --------------------------------------------------------
void miner_start()
{
  ;
}

//----- (00021B54) --------------------------------------------------------
void miner_join()
{
  ;
}

//----- (00021B64) --------------------------------------------------------
int __fastcall print_solver_line(int a1, int a2, int a3, int a4)
{
  return a4;
}

//----- (00021B80) --------------------------------------------------------
int __fastcall set_baud(size_t a1)
{
  unsigned __int8 v2; // [sp+4h] [bp+4h]

  v2 = a1;
  set_baud_chain(a1);
  sleep(1u);
  set_fpga_baud(v2);
  return usleep(0x2710u);
}

//----- (00021BB0) --------------------------------------------------------
int bm1744_hashboard_init()
{
  set_baud(0);
  usleep(0xC350u);
  set_core_timeout(dword_F3648);
  usleep(0x2710u);
  set_ticket_mask(dword_F3644);
  usleep(0x2710u);
  set_frequency(dword_F3678);
  usleep(0x2710u);
  set_nonce_shift(0);
  return usleep(0x2710u);
}
// F3644: using guessed type int dword_F3644;
// F3648: using guessed type int dword_F3648;
// F3678: using guessed type int dword_F3678;

//----- (00021C24) --------------------------------------------------------
void *show_nonce_detail()
{
  void *result; // r0
  _WORD v1[512]; // [sp+8h] [bp+0h] BYREF
  _DWORD v2[2]; // [sp+408h] [bp+400h] BYREF
  _DWORD src[2]; // [sp+410h] [bp+408h] BYREF
  char dest[64]; // [sp+418h] [bp+410h] BYREF
  char s[64]; // [sp+458h] [bp+450h] BYREF
  int v6; // [sp+498h] [bp+490h]
  int v7; // [sp+49Ch] [bp+494h]
  int v8; // [sp+4A0h] [bp+498h]
  int i; // [sp+4A4h] [bp+49Ch]

  v6 = (unsigned __int8)gChain;
  memset(s, 0, sizeof(s));
  result = memset(dest, 0, sizeof(dest));
  v8 = 0;
  v7 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    src[0] = 0;
    src[1] = 0;
    sprintf((char *)src, "%03d ", one_work_nonce_each_asic[3 * v6 + i]);
    strcat(s, (const char *)src);
    v2[0] = 0;
    v2[1] = 0;
    sprintf((char *)v2, "%03d ", one_work_invalid_nonce_each_asic_2[6 * v6 + 1 + 2 * i]);
    result = strcat(dest, (const char *)v2);
    v8 += one_work_nonce_each_asic[3 * v6 + i];
    v7 += one_work_invalid_nonce_each_asic_2[6 * v6 + 1 + 2 * i];
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)v1, 0x400u, "valid:    %s total=%d\n", s, v8);
    result = (void *)applog(2, (const char *)v1, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)v1, 0x400u, "invalid:  %s total=%d\n", dest, v7);
    result = (void *)applog(2, (const char *)v1, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    v1[0] = 10;
    return (void *)applog(2, (const char *)v1, 0);
  }
  return result;
}
// 47B80: using guessed type char gChain;
// 47C84: using guessed type int opt_log_level;
// 47E2C: using guessed type int one_work_nonce_each_asic[];
// 47E44: using guessed type _DWORD one_work_invalid_nonce_each_asic_2[6];
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00021E50) --------------------------------------------------------
void __noreturn singleboard_sensor_test()
{
  char v0[1024]; // [sp+8h] [bp+0h] BYREF
  int v1; // [sp+408h] [bp+400h]
  int v2; // [sp+40Ch] [bp+404h]
  int v3; // [sp+410h] [bp+408h]
  int v4; // [sp+414h] [bp+40Ch]
  unsigned __int8 v5; // [sp+41Ah] [bp+412h] BYREF
  unsigned __int8 v6; // [sp+41Bh] [bp+413h] BYREF
  int v7; // [sp+41Ch] [bp+414h]
  int v8; // [sp+420h] [bp+418h]
  int i; // [sp+424h] [bp+41Ch]
  _BYTE vars0[8]; // [sp+428h] [bp+420h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v0, 0x400u, "%s Begin\n", "singleboard_sensor_test");
    applog(2, v0, 0);
  }
  set_i2c_enable();
  usleep(0x30D40u);
  v6 = 0;
  v5 = 0;
  v8 = 0;
  v7 = 100;
  v1 = 0;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  while ( 1 )
  {
    sleep(5u);
    for ( i = 0; i <= 1; ++i )
    {
      v6 = 0;
      v5 = 0;
      if ( read_sensor(0, i, 76, 1u, &v5) == 5 )
      {
        *(_DWORD *)&vars0[8 * i - 28] = 1;
        sensor_info[4 * i + 1] = v5;
        if ( v5 > v8 )
          v8 = v5;
        if ( v5 < v7 )
          v7 = v5;
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf(v0, 0x400u, "Read Success Sensor%d ext-temp=%d\n\n", i, v5);
          applog(2, v0, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v0, 0x400u, "Read Fail ext-temp Sensor%d, try again\n", i);
        applog(2, v0, 0);
      }
      usleep(0x186A0u);
      if ( read_sensor(0, i, 76, 0, &v6) == 5 )
      {
        *(_DWORD *)&vars0[8 * i - 32] = 1;
        sensor_info[4 * i] = v6;
        if ( v6 > v8 )
          v8 = v6;
        if ( v6 < v7 )
          v7 = v6;
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf(v0, 0x400u, "Read Success Sensor%d local-temp=%d\n\n", i, v6);
          applog(2, v0, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v0, 0x400u, "Read Fail local-temp Sensor%d, try again\n", i);
        applog(2, v0, 0);
      }
      usleep(0x186A0u);
    }
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v0, 0x400u, "%s high %d low %d\n", "singleboard_sensor_test", v8, v7);
      applog(2, v0, 0);
    }
    if ( v1 <= 0 || v2 <= 0 || v3 <= 0 || v4 <= 0 )
    {
      read_temp_test_result = -1;
    }
    else
    {
      read_temp_test_result = 1;
      if ( dword_F3684 <= v8 || dword_F3688 >= v7 )
        tempture_value_test_result = -1;
      else
        tempture_value_test_result = 1;
    }
  }
}
// 21E50: using guessed type void __noreturn singleboard_sensor_test();
// 47C84: using guessed type int opt_log_level;
// 483D8: using guessed type int read_temp_test_result;
// 483DC: using guessed type int tempture_value_test_result;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F3684: using guessed type int dword_F3684;
// F3688: using guessed type int dword_F3688;

//----- (00022220) --------------------------------------------------------
int singleboard_set_address_test()
{
  int result; // r0
  char v1[1024]; // [sp+8h] [bp+0h] BYREF
  unsigned __int8 v2; // [sp+408h] [bp+400h] BYREF
  unsigned __int8 v3; // [sp+409h] [bp+401h]
  char v4; // [sp+40Ah] [bp+402h]
  int v5; // [sp+40Ch] [bp+404h]
  int v6; // [sp+410h] [bp+408h]
  int i; // [sp+414h] [bp+40Ch]

  read_register(0, 0, 0, 0);
  read_register(0, 1, 0, 0);
  usleep(0x30D40u);
  asic_addr_interval();
  set_address();
  usleep(0x30D40u);
  result = read_register(0, 1, 0, 0);
  for ( i = 0; i <= 2; ++i )
  {
    v2 = 0;
    v3 = i * addr_interval;
    v4 = 0;
    v5 = 0;
    v6 = 0;
    result = read_reg_item(&v2, 500);
    if ( result < 0 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        strcpy(v1, "read chip num timeout\n");
        result = applog(2, v1, 0);
      }
      break;
    }
    if ( (unsigned __int8)v5 != v3 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v1, 0x400u, "Set address Fail set:%02x get:%02x\n", v3, (unsigned __int8)v5);
        result = applog(2, v1, 0);
      }
      break;
    }
  }
  if ( i == 3 )
  {
    set_address_test_result = 1;
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v1, 0x400u, "%s Success\n", "singleboard_set_address_test");
      return applog(2, v1, 0);
    }
  }
  else
  {
    set_address_test_result = -1;
  }
  return result;
}
// 47478: using guessed type int addr_interval;
// 47C84: using guessed type int opt_log_level;
// 483D4: using guessed type int set_address_test_result;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00022420) --------------------------------------------------------
size_t __fastcall singleboard_step_increase_frequency(int a1, int a2)
{
  size_t result; // r0
  char v4[1024]; // [sp+14h] [bp+14h] BYREF
  int freq_by_index; // [sp+414h] [bp+414h]
  int index_by_freq; // [sp+418h] [bp+418h]
  int v7; // [sp+41Ch] [bp+41Ch]

  index_by_freq = get_index_by_freq(a2);
  v7 = get_index_by_freq(a1);
  while ( 1 )
  {
    sleep(0xAu);
    if ( index_by_freq - v7 <= 5 )
      v7 = index_by_freq;
    else
      v7 += 5;
    freq_by_index = get_freq_by_index(v7);
    result = set_frequency(freq_by_index);
    if ( v7 == index_by_freq )
      break;
    show_nonce_detail();
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v4, "init freq done\n");
    return applog(2, v4, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00022504) --------------------------------------------------------
size_t singleboard_nonce_test()
{
  size_t result; // r0
  char v2[1024]; // [sp+14h] [bp+4h] BYREF
  unsigned __int8 s[1124]; // [sp+414h] [bp+404h] BYREF
  int i; // [sp+878h] [bp+868h]
  int v5; // [sp+87Ch] [bp+86Ch]

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v2, "Begin Nonce Test...\n");
    applog(2, v2, 0);
  }
  memset(s, 0, sizeof(s));
  memcpy(
    &s[843],
    "040000005a0995c5fe39ee678b290a2636ec3c32e26bfafb5711ee687ad3750e00000000bbd08c45cf29d96c4f1e5b9d136f2f0ffc22d6be511e"
    "204773afee519a2478db00000000000000000000000000000000000000000000000000000000000000008dc7205ab0f0131c0000000000000000"
    "aaaaad5327c5d2a66bda09d1000000000000000000000000",
    0x118u);
  memcpy(
    s,
    "010203042cb3d32b0b61304401cbe540448a4cacd7e98421a850503e2f0d102f1d3454151484151215484aa0ca1932037525e2eb9a22d3d3ff15"
    "02b320f8d9ca56377f56494b2cacf3377482ccd34188c1b25e04187ccf70af6e2244c3c96e5e2e3a6015d32fe451ad000e771eccb5c5e3d6beb4"
    "70359446494d25e15f87df87c3119ebd9ca813a400000000",
    0x118u);
  memcpy(
    &s[562],
    "0400000065747d1d1299b3422670ee656f86aa07d5dfefc485c2d2206304e6030000000067669e8d830bc95a3a2b88582f06f835ecfcfe85c92a"
    "f15d001376fb544a3db40000000000000000000000000000000000000000000000000000000000000000ee060c5ba21f0f1c4809000000000000"
    "000000000000000000000400000000000000000000000000",
    0x118u);
  memcpy(
    &s[281],
    "04000000a250abe4ab99767ec31b0eec43786781bf556a27b99436d831ff8e020000000002f24739336a89e32ee1081592a1d2ebbf1321c94847"
    "89cf04d3234ad531c3d80000000000000000000000000000000000000000000000000000000000000000abe6ea5add990f1cf408000000000000"
    "cda79db66d4176ca36d5ad06000000000000000000000000",
    0x118u);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v2, "pre sending work begin\n");
    applog(2, v2, 0);
  }
  send_work(s, 0, 0);
  sleep(5u);
  show_nonce_detail();
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v2, "pre sending work end\n");
    applog(2, v2, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v2, "normal send work begin \n");
    applog(2, v2, 0);
  }
  result = send_work(s, 0, 0);
  v5 = dword_F3650;
  while ( v5-- )
  {
    sleep(1u);
    result = (size_t)show_nonce_detail();
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v2, "normal send work end \n");
    result = applog(2, v2, 0);
  }
  for ( i = 0; i <= 2; ++i )
  {
    if ( one_work_nonce_each_asic[3 * (unsigned __int8)gChain + i] >= (unsigned int)dword_F3654
      && one_work_invalid_nonce_each_asic_2[6 * (unsigned __int8)gChain + 1 + 2 * i] <= (unsigned int)dword_F3658 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          v2,
          0x400u,
          "pass : asic%d valid [%d   %d], invalid[%d   %d]\n",
          i,
          one_work_nonce_each_asic[3 * (unsigned __int8)gChain + i],
          dword_F3654,
          one_work_invalid_nonce_each_asic_2[6 * (unsigned __int8)gChain + 1 + 2 * i],
          dword_F3658);
        result = applog(2, v2, 0);
      }
      nonce_test_asic_result[i] = 79;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          v2,
          0x400u,
          "error: asic%d valid [%d   %d], invalid[%d   %d]\n",
          i,
          one_work_nonce_each_asic[3 * (unsigned __int8)gChain + i],
          dword_F3654,
          one_work_invalid_nonce_each_asic_2[6 * (unsigned __int8)gChain + 1 + 2 * i],
          dword_F3658);
        result = applog(2, v2, 0);
      }
      nonce_test_asic_result[i] = 88;
    }
  }
  return result;
}
// 47B80: using guessed type char gChain;
// 47C84: using guessed type int opt_log_level;
// 47E2C: using guessed type int one_work_nonce_each_asic[];
// 47E44: using guessed type _DWORD one_work_invalid_nonce_each_asic_2[6];
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F3650: using guessed type int dword_F3650;
// F3654: using guessed type int dword_F3654;
// F3658: using guessed type int dword_F3658;

//----- (00022994) --------------------------------------------------------
unsigned int singleboard_patten_test()
{
  unsigned int result; // r0
  unsigned __int8 *ptr; // [sp+4h] [bp+4h]
  int v2; // [sp+8h] [bp+8h]
  int k; // [sp+Ch] [bp+Ch]
  int j; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]
  int m; // [sp+14h] [bp+14h]

  v2 = dword_F3758 + dword_F3750 + dword_F3754;
  dword_F37C8 = 1;
  sleep(1u);
  for ( i = 0; g_patten > i; ++i )
  {
    for ( j = 0; dword_F374C > j; ++j )
    {
      for ( k = 0; dword_F375C > k; ++k )
      {
        pthread_mutex_lock(&mutex);
        dword_F37A4 = dword_F37A0 + v2 * j * dword_F375C + v2 * dword_F375C * i * dword_F374C + v2 * k;
        dword_F37A8 = i;
        dword_F37AC = j;
        dword_F37B0 = k;
        pthread_mutex_unlock(&mutex);
        ptr = bin2hex(dword_F37A4, dword_F3750);
        send_work(ptr, 1, 0);
        free(ptr);
        usleep(1000 * dword_F368C);
      }
    }
  }
  dword_F37C8 = 0;
  result = sleep(1u);
  for ( m = 0; g_patten > m; ++m )
  {
    if ( *(_DWORD *)(4 * m + dword_F37BC) >= (unsigned int)dword_F3654 )
      nonce_test_asic_result[m] = 79;
    else
      nonce_test_asic_result[m] = 88;
  }
  return result;
}
// F3654: using guessed type int dword_F3654;
// F368C: using guessed type int dword_F368C;
// F3748: using guessed type int g_patten;
// F374C: using guessed type int dword_F374C;
// F3750: using guessed type int dword_F3750;
// F3754: using guessed type int dword_F3754;
// F3758: using guessed type int dword_F3758;
// F375C: using guessed type int dword_F375C;
// F37A0: using guessed type int dword_F37A0;
// F37A4: using guessed type int dword_F37A4;
// F37A8: using guessed type int dword_F37A8;
// F37AC: using guessed type int dword_F37AC;
// F37B0: using guessed type int dword_F37B0;
// F37BC: using guessed type int dword_F37BC;
// F37C8: using guessed type int dword_F37C8;

//----- (00022B84) --------------------------------------------------------
int pcba_test()
{
  pthread_t newthread; // [sp+4h] [bp+4h] BYREF

  singleboard_set_address_test();
  pthread_create(&newthread, 0, (void *(*)(void *))singleboard_sensor_test, 0);
  singleboard_patten_test();
  pthread_cancel(newthread);
  return pthread_join(newthread, 0);
}
// 21E50: using guessed type void __noreturn singleboard_sensor_test();

//----- (00022BC0) --------------------------------------------------------
int __fastcall vol_init(unsigned __int16 a1)
{
  char s[1026]; // [sp+10h] [bp+8h] BYREF
  unsigned __int16 v5; // [sp+412h] [bp+40Ah]
  int i; // [sp+414h] [bp+40Ch]

  if ( a1 <= 0x384u && a1 > 0x2EDu )
  {
    if ( a1 == 800 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "setting voltage == configed voltage %d\n", a1);
        applog(2, s, 0);
      }
      return 1;
    }
    else
    {
      for ( i = 0; i <= 2; ++i )
      {
        v5 = ISL_set_voltage(gChain, 0, isl_dev_addr[i], a1);
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf(s, 0x400u, "asic%d read back voltage = %d\n", i, v5);
          applog(2, s, 0);
        }
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "illeagel setting voltage is %d\n", a1);
      applog(2, s, 0);
    }
    return -1;
  }
}
// 47B7C: using guessed type _BYTE isl_dev_addr[4];
// 47B80: using guessed type char gChain;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00022D40) --------------------------------------------------------
int __fastcall isl_communication_check(unsigned __int16 a1)
{
  char s[1026]; // [sp+18h] [bp+8h] BYREF
  unsigned __int16 v5; // [sp+41Ah] [bp+40Ah] BYREF
  int v6; // [sp+41Ch] [bp+40Ch]
  int v7; // [sp+420h] [bp+410h]
  int i; // [sp+424h] [bp+414h]

  v7 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    v6 = 0;
    while ( 1 )
    {
      v5 = 0;
      ISL_get_voltage(gChain, 0, isl_dev_addr[i], &v5);
      if ( v5 <= 0x384u && v5 >= 0x320u )
        break;
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "asic%d read voltage again voltage %d, expect voltage %d retry %d\n", i, v5, a1, v6);
        applog(2, s, 0);
      }
      usleep(0x30D40u);
      if ( ++v6 > 2 )
        goto LABEL_11;
    }
    ++v7;
LABEL_11:
    ;
  }
  if ( v7 == 3 )
    return 1;
  else
    return -1;
}
// 47B7C: using guessed type _BYTE isl_dev_addr[4];
// 47B80: using guessed type char gChain;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00022E60) --------------------------------------------------------
int start_single_board_test()
{
  bm1744_app_init();
  bm1744_hashboard_init();
  pcba_test();
  return bm1744_app_exit();
}

//----- (00022E78) --------------------------------------------------------
int hw_test_customized()
{
  int result; // r0
  char v1[1024]; // [sp+14h] [bp+4h] BYREF
  unsigned __int8 s[1124]; // [sp+414h] [bp+404h] BYREF
  int i; // [sp+878h] [bp+868h]
  int v4; // [sp+87Ch] [bp+86Ch]

  memset(s, 0, sizeof(s));
  memcpy(
    &s[843],
    "040000005a0995c5fe39ee678b290a2636ec3c32e26bfafb5711ee687ad3750e00000000bbd08c45cf29d96c4f1e5b9d136f2f0ffc22d6be511e"
    "204773afee519a2478db00000000000000000000000000000000000000000000000000000000000000008dc7205ab0f0131c0000000000000000"
    "aaaaad5327c5d2a66bda09d1000000000000000000000000",
    0x118u);
  memcpy(
    s,
    "010203042cb3d32b0b61304401cbe540448a4cacd7e98421a850503e2f0d102f1d3454151484151215484aa0ca1932037525e2eb9a22d3d3ff15"
    "02b320f8d9ca56377f56494b2cacf3377482ccd34188c1b25e04187ccf70af6e2244c3c96e5e2e3a6015d32fe451ad000e771eccb5c5e3d6beb4"
    "70359446494d25e15f87df87c3119ebd9ca813a400000000",
    0x118u);
  memcpy(
    &s[562],
    "0400000065747d1d1299b3422670ee656f86aa07d5dfefc485c2d2206304e6030000000067669e8d830bc95a3a2b88582f06f835ecfcfe85c92a"
    "f15d001376fb544a3db40000000000000000000000000000000000000000000000000000000000000000ee060c5ba21f0f1c4809000000000000"
    "000000000000000000000400000000000000000000000000",
    0x118u);
  memcpy(
    &s[281],
    "04000000a250abe4ab99767ec31b0eec43786781bf556a27b99436d831ff8e020000000002f24739336a89e32ee1081592a1d2ebbf1321c94847"
    "89cf04d3234ad531c3d80000000000000000000000000000000000000000000000000000000000000000abe6ea5add990f1cf408000000000000"
    "cda79db66d4176ca36d5ad06000000000000000000000000",
    0x118u);
  set_address();
  usleep(0x30D40u);
  read_register(0, 1, 0, 0);
  result = sleep(1u);
  v4 = 0;
  while ( v4 <= 300 )
  {
    for ( i = 0; i <= 3; ++i )
    {
      send_work(&s[281 * i], 0, 0);
      result = sleep(0x1Eu);
      v4 += 30;
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v1, 0x400u, "seconds %d\n", v4);
        result = applog(2, v1, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        strcpy(v1, "asic        1       2       3       4\n");
        result = applog(2, v1, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          v1,
          0x400u,
          "valid       %d      %d      %d      %d\n",
          nonce_num_each_asic[0],
          dword_47E00,
          dword_47E04,
          nonce_invalid_num_each_asic[0]);
        result = applog(2, v1, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          v1,
          0x400u,
          "invalid-1   %d      %d      %d      %d\n",
          nonce_invalid_num_each_asic_2[0],
          dword_47E1C,
          dword_47E24,
          one_work_nonce_each_asic[0]);
        result = applog(2, v1, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          v1,
          0x400u,
          "invalid-2   %d      %d      %d      %d\n",
          dword_47E18,
          dword_47E20,
          dword_47E28,
          dword_47E30);
        result = applog(2, v1, 0);
      }
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v1, "test finished\n");
    return applog(2, v1, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 47DFC: using guessed type int nonce_num_each_asic[];
// 47E00: using guessed type int dword_47E00;
// 47E04: using guessed type int dword_47E04;
// 47E08: using guessed type int nonce_invalid_num_each_asic[3];
// 47E14: using guessed type int nonce_invalid_num_each_asic_2[];
// 47E18: using guessed type int dword_47E18;
// 47E1C: using guessed type int dword_47E1C;
// 47E20: using guessed type int dword_47E20;
// 47E24: using guessed type int dword_47E24;
// 47E28: using guessed type int dword_47E28;
// 47E2C: using guessed type int one_work_nonce_each_asic[];
// 47E30: using guessed type int dword_47E30;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000231E0) --------------------------------------------------------
int pcba_app_manual_test()
{
  int result; // r0
  int v1; // r3
  _BYTE v2[280]; // [sp+8h] [bp+0h] BYREF
  char s[280]; // [sp+120h] [bp+118h] BYREF
  char v4[1024]; // [sp+238h] [bp+230h] BYREF
  __int16 v5; // [sp+638h] [bp+630h] BYREF
  char v6; // [sp+63Ah] [bp+632h]
  __int16 v7; // [sp+63Ch] [bp+634h] BYREF
  char v8; // [sp+63Eh] [bp+636h]
  int v9; // [sp+640h] [bp+638h] BYREF
  int v10; // [sp+644h] [bp+63Ch] BYREF
  int v11; // [sp+648h] [bp+640h] BYREF
  unsigned __int16 v12; // [sp+64Ch] [bp+644h] BYREF
  unsigned __int8 v13; // [sp+64Fh] [bp+647h] BYREF
  unsigned __int16 v14; // [sp+650h] [bp+648h] BYREF
  unsigned __int8 v15; // [sp+653h] [bp+64Bh] BYREF
  int v16; // [sp+654h] [bp+64Ch] BYREF
  int v17; // [sp+658h] [bp+650h] BYREF
  unsigned int v18; // [sp+65Ch] [bp+654h] BYREF
  int v19; // [sp+660h] [bp+658h] BYREF
  int v20; // [sp+664h] [bp+65Ch] BYREF
  __int16 v21; // [sp+668h] [bp+660h] BYREF
  int v22; // [sp+66Ch] [bp+664h]
  unsigned __int8 v23; // [sp+671h] [bp+669h]
  unsigned __int8 v24; // [sp+672h] [bp+66Ah]
  unsigned __int8 v25; // [sp+673h] [bp+66Bh]
  int i; // [sp+674h] [bp+66Ch]
  int j; // [sp+678h] [bp+670h]
  int v28; // [sp+67Ch] [bp+674h]

  v28 = 1;
  result = bm1744_app_init();
  while ( v28 )
  {
    v21 = 0;
    sleep(1u);
    setbuf((FILE *)stdin, 0);
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy(v4, "Input test paramter:");
      applog(2, v4, 0);
    }
    result = _isoc99_fscanf(stdin, "%s", &v21);
    switch ( (char)v21 )
    {
      case 'a':
        read_register(0, 1, 0, 0);
        asic_addr_interval();
        set_address();
        sleep(1u);
        result = read_register(0, 1, 0, 0);
        break;
      case 'b':
        v22 = 3;
        v7 = 21930;
        v8 = -18;
        result = write_data_to_PIC16F1704_flash(0, 0, (unsigned __int8 *)&v7, 3);
        break;
      case 'c':
        v5 = 0;
        v6 = 0;
        read_data_from_PIC16F1704_flash(0, 0, &v5, 3u);
        for ( i = 0; i <= 2; ++i )
          printf("%02x\n", *((unsigned __int8 *)&v5 + i));
        result = putchar(10);
        break;
      case 'g':
        if ( use_syslog || opt_log_output || opt_log_level > 0 )
        {
          strcpy(v4, "get reg: input reg [regaddr]\n");
          applog(1, v4, 0);
        }
        result = _isoc99_scanf("%x", &v17);
        for ( j = 0; j <= 0; ++j )
          result = read_register(j, 1, 0, v17);
        break;
      case 'i':
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          strcpy(v4, "did you init all the chips yet, 1/0\n");
          applog(2, v4, 0);
        }
        result = _isoc99_scanf("%d", &v9);
        if ( v9 == 1 )
        {
          result = hw_test_customized();
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            strcpy(v4, "Done!Done!Done!Done!");
            result = applog(2, v4, 0);
          }
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            strcpy(v4, "Done!Done!Done!Done!");
            result = applog(2, v4, 0);
          }
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            strcpy(v4, "Done!Done!Done!Done!");
            result = applog(2, v4, 0);
          }
        }
        break;
      case 'k':
        v11 = 0;
        v10 = 10;
        if ( use_syslog || opt_log_output || opt_log_level > 0 )
        {
          strcpy(v4, "Read Reg: Input [regAddr readTimes]\n");
          applog(1, v4, 0);
        }
        for ( result = _isoc99_scanf("%x %d", &v11, &v10); ; result = sleep(2u) )
        {
          v1 = v10--;
          if ( v1 <= 0 )
            break;
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            snprintf(v4, 0x400u, "read chip number %d\n", v10);
            applog(2, v4, 0);
          }
          read_register(0, 1, 0, v11);
        }
        break;
      case 'm':
        if ( use_syslog || opt_log_output || opt_log_level > 0 )
        {
          strcpy(v4, "Input Frequenfy:\n");
          applog(1, v4, 0);
        }
        result = _isoc99_scanf("%d", &v16);
        if ( v16 > 99 && v16 <= 825 )
        {
          result = set_frequency(v16);
        }
        else if ( use_syslog || opt_log_output || opt_log_level > 0 )
        {
          strcpy(v4, "Frequency: [100, 825]\n");
          result = applog(1, v4, 0);
        }
        break;
      case 'q':
        v28 = 0;
        break;
      case 's':
        if ( use_syslog || opt_log_output || opt_log_level > 0 )
        {
          strcpy(v4, "write reg: input reg [address data]\n");
          applog(1, v4, 0);
        }
        _isoc99_scanf("%x %x", &v19, &v18);
        result = write_register(v19, v18);
        if ( v19 == 80 && v18 <= 0x1C )
          result = set_nonce_shift(v18);
        break;
      case 't':
        set_i2c_enable();
        usleep(0x30D40u);
        read_sensor(0, 0, 76, 1u, 0);
        result = read_sensor(0, 0, 76, 0, 0);
        break;
      case 'u':
        v24 = 0;
        v12 = 111;
        _isoc99_scanf("%d", &v13);
        v23 = v13;
        printf("i2c_devaddr=%d\n", v13);
        puts("Input i2c reg data");
        _isoc99_scanf("%d", &v12);
        result = printf("devaddr=%d\n", v13);
        if ( v12 <= 0x352u )
        {
          v13 = v23 + 80;
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            snprintf(v4, 0x400u, "write: chain%d dev_addr=%08x, reg_data=%d\n", v24, v13, v12);
            applog(2, v4, 0);
          }
          result = ISL_set_voltage(v24, 0, v13, v12);
        }
        else if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          strcpy(v4, "Voltage: [750, 850]\n");
          result = applog(2, v4, 0);
        }
        break;
      case 'v':
        v25 = 0;
        v14 = 111;
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          strcpy(v4, "Input i2c dev addr\n");
          applog(2, v4, 0);
        }
        _isoc99_scanf("%x", &v15);
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf(v4, 0x400u, "read: chain%d dev_addr=%02x\n", v25, v15);
          applog(2, v4, 0);
        }
        result = ISL_get_voltage(v25, 0, v15, &v14);
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf(v4, 0x400u, "read: reg_data = %d\n", v14);
          result = applog(2, v4, 0);
        }
        break;
      case 'w':
        memcpy(
          v2,
          "010203042cb3d32b0b61304401cbe540448a4cacd7e98421a850503e2f0d102f1d3454151484151215484aa0ca1932037525e2eb9a22d3"
          "d3ff1502b320f8d9ca56377f56494b2cacf3377482ccd34188c1b25e04187ccf70af6e2244c3c96e5e2e3a6015d32fe451ad000e771ecc"
          "b5c5e3d6beb470359446494d25e15f87df87c3119ebd9ca813a400000000",
          sizeof(v2));
        memset(s, 0, sizeof(s));
        v20 = 0;
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          strcpy(v4, "input start nonce flag 1:enable 0:disable\n");
          applog(2, v4, 0);
        }
        _isoc99_scanf("%d", &v20);
        if ( use_syslog || opt_log_output || opt_log_level > 0 )
        {
          strcpy(v4, "input [work]\n");
          applog(1, v4, 0);
        }
        _isoc99_scanf("%s", s);
        if ( strlen(s) != 280 )
          memcpy(s, v2, sizeof(s));
        result = send_work((unsigned __int8 *)s, v20, 0);
        break;
      default:
        if ( use_syslog || opt_log_output || opt_log_level > 0 )
        {
          strcpy(v4, "unknow command\n");
          result = applog(1, v4, 0);
        }
        break;
    }
  }
  return result;
}
// 10E54: using guessed type int _isoc99_fscanf(_DWORD, const char *, ...);
// 1107C: using guessed type int _isoc99_scanf(const char *, ...);
// 47C84: using guessed type int opt_log_level;
// 47DB0: using guessed type int stdin;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00023CA4) --------------------------------------------------------
int start_pcba_test()
{
  char v2[1024]; // [sp+4h] [bp+4h] BYREF
  _BYTE s[64]; // [sp+404h] [bp+404h] BYREF
  ssize_t v4; // [sp+444h] [bp+444h]

  memset(s, 0, sizeof(s));
  if ( cgpu_init() < 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy(v2, "cgpu init failed\n");
      applog(2, v2, 0);
    }
    return -1;
  }
  display_arguments();
  while ( 1 )
  {
    memset(s, 0, sizeof(s));
    if ( strcmp(s1, "keyboard") )
      break;
    v4 = _isoc99_fscanf(stdin, "%s", s);
LABEL_16:
    if ( v4 > 0 && s[0] == 48 )
      singleBoardTest_V9_BM1744();
    usleep(0x186A0u);
  }
  if ( !strcmp(s1, "button") )
  {
    v4 = v9_key_read(s, 0x40u);
    goto LABEL_16;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v2, "please assign ctrl type: keyboard or button\n");
    applog(2, v2, 0);
  }
  cgpu_exit();
  return 0;
}
// 10E54: using guessed type int _isoc99_fscanf(_DWORD, const char *, ...);
// 47C84: using guessed type int opt_log_level;
// 47DB0: using guessed type int stdin;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00023E14) --------------------------------------------------------
int __fastcall write_pic(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  return i2c_write(a3 | (a1 << 26) | 0xA00000 | (a2 << 16));
}

//----- (00023E4C) --------------------------------------------------------
int __fastcall read_pic(unsigned __int8 a1, unsigned __int8 a2)
{
  return i2c_read((a2 << 16) | (a1 << 26) | 0xA00000);
}

//----- (00023E80) --------------------------------------------------------
int __fastcall write_dc_dc(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4, int a5, int a6)
{
  int v6; // r4
  _BYTE v13[6]; // [sp+10h] [bp+8h] BYREF
  __int16 v14; // [sp+16h] [bp+Eh]
  int v15; // [sp+18h] [bp+10h]
  int v16; // [sp+1Ch] [bp+14h]
  _DWORD s[4]; // [sp+20h] [bp+18h] BYREF
  __int16 v18; // [sp+30h] [bp+28h]
  unsigned __int8 v19; // [sp+33h] [bp+2Bh]
  int j; // [sp+34h] [bp+2Ch]
  int i; // [sp+38h] [bp+30h]
  unsigned __int8 k; // [sp+3Dh] [bp+35h]
  __int16 v23; // [sp+3Eh] [bp+36h]
  _BYTE v24[4]; // [sp+40h] [bp+38h] BYREF

  v18 = 255;
  s[0] = 255;
  memset(&s[1], 0, 12);
  v23 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v19 = a6 + 6;
  printf("%s dev addr = %02x\n", "write_dc_dc", a3);
  v13[0] = 85;
  v13[1] = -86;
  v13[2] = a6 + 6;
  v13[3] = 50;
  v13[4] = 2 * a3;
  v13[5] = a4;
  for ( i = 0; i < a6; ++i )
    v24[i - 42] = *(_BYTE *)(i + a5);
  for ( j = 2; a6 + 6 > j; ++j )
    v23 += (unsigned __int8)v13[j];
  LOBYTE(v18) = HIBYTE(v23);
  HIBYTE(v18) = v23;
  v24[a6 - 42] = HIBYTE(v23);
  v24[a6 - 41] = HIBYTE(v18);
  pthread_mutex_lock(&i2c_mutex);
  for ( k = 0; k < v19 + 2; ++k )
    write_pic(a2, a1, v24[k - 48]);
  usleep(0x186A0u);
  memset(s, 0, sizeof(s));
  for ( k = 0; k <= 4u; ++k )
  {
    v6 = k;
    *((_BYTE *)s + v6) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( BYTE1(s[0]) == 50 && BYTE2(s[0]) == 1 )
    return 0;
  printf(
    "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x\n\n",
    "write_dc_dc",
    LOBYTE(s[0]),
    BYTE1(s[0]),
    BYTE2(s[0]),
    HIBYTE(s[0]));
  return -1;
}
// 483E8: using guessed type pthread_mutex_t i2c_mutex;

//----- (00024088) --------------------------------------------------------
int __fastcall read_dc_dc(unsigned __int8 a1, unsigned __int8 a2, char a3, char a4, int a5, int a6)
{
  int v6; // r4
  int v11; // [sp+14h] [bp+Ch] BYREF
  int v12; // [sp+18h] [bp+10h]
  char v13; // [sp+1Ch] [bp+14h]
  _DWORD s[4]; // [sp+20h] [bp+18h] BYREF
  __int16 v15; // [sp+30h] [bp+28h]
  unsigned __int8 v16; // [sp+33h] [bp+2Bh]
  int k; // [sp+34h] [bp+2Ch]
  int i; // [sp+38h] [bp+30h]
  unsigned __int8 j; // [sp+3Dh] [bp+35h]
  __int16 v20; // [sp+3Eh] [bp+36h]
  _BYTE v21[4]; // [sp+40h] [bp+38h] BYREF

  v16 = 7;
  v15 = 255;
  s[0] = 255;
  memset(&s[1], 0, 12);
  v20 = 0;
  v11 = 839363157;
  v13 = 0;
  v12 = (unsigned __int8)(2 * a3) | 1;
  BYTE1(v12) = a4;
  BYTE2(v12) = a6;
  for ( i = 2; v16 > i; ++i )
    v20 += *((unsigned __int8 *)&v11 + i);
  LOBYTE(v15) = HIBYTE(v20);
  HIBYTE(v12) = HIBYTE(v20);
  HIBYTE(v15) = v20;
  v13 = v20;
  pthread_mutex_lock(&i2c_mutex);
  for ( j = 0; j < v16 + 2; ++j )
    write_pic(a2, a1, v21[j - 44]);
  usleep(0x186A0u);
  memset(s, 0, sizeof(s));
  for ( j = 0; j < a6 + 5; ++j )
  {
    v6 = j;
    *((_BYTE *)s + v6) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0xF4240u);
  if ( BYTE1(s[0]) == 50 && BYTE2(s[0]) == 1 )
  {
    for ( k = 0; k < a6; ++k )
      *(_BYTE *)(k + a5) = v21[k - 29];
    return 0;
  }
  else
  {
    printf(
      "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x\n",
      "read_dc_dc",
      LOBYTE(s[0]),
      BYTE1(s[0]),
      BYTE2(s[0]),
      HIBYTE(s[0]));
    return -1;
  }
}
// 483E8: using guessed type pthread_mutex_t i2c_mutex;

//----- (0002426C) --------------------------------------------------------
int __fastcall set_PIC16F1704_flash_pointer(
        unsigned __int8 a1,
        unsigned __int8 a2,
        unsigned __int8 a3,
        unsigned __int8 a4)
{
  __int16 v4; // r2
  int v5; // r4
  char s[1024]; // [sp+14h] [bp+Ch] BYREF
  int v12; // [sp+414h] [bp+40Ch]
  unsigned __int8 v13; // [sp+418h] [bp+410h]
  unsigned __int8 v14; // [sp+419h] [bp+411h]
  char v15; // [sp+41Ah] [bp+412h]
  char v16; // [sp+41Bh] [bp+413h]
  unsigned __int8 v17[4]; // [sp+41Ch] [bp+414h]
  char v18; // [sp+420h] [bp+418h]
  char v19; // [sp+421h] [bp+419h]
  __int16 v20; // [sp+424h] [bp+41Ch]
  char v21; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v23[4]; // [sp+428h] [bp+420h] BYREF

  v21 = 6;
  *(_WORD *)v17 = 255;
  v12 = 17214037;
  v4 = a3 + 6;
  v20 = a4 + v4 + 1;
  v18 = HIBYTE(v20);
  v19 = a4 + v4 + 1;
  v13 = a3;
  v14 = a4;
  v15 = HIBYTE(v20);
  v16 = v19;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 7u; ++i )
    write_pic(a1, a2, v23[i - 20]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v5 = i;
    v17[v5] = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( v17[0] == 1 && v17[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s ok\n\n", "set_PIC16F1704_flash_pointer");
      applog(2, s, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        s,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "set_PIC16F1704_flash_pointer",
        v17[0],
        v17[1]);
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000244A0) --------------------------------------------------------
int __fastcall send_data_to_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // r4
  char s[1024]; // [sp+1Ch] [bp+14h] BYREF
  int v9; // [sp+41Ch] [bp+414h]
  int v10; // [sp+420h] [bp+418h]
  int v11; // [sp+424h] [bp+41Ch]
  int v12; // [sp+428h] [bp+420h]
  int v13; // [sp+42Ch] [bp+424h]
  __int16 v14; // [sp+430h] [bp+428h]
  unsigned __int8 v15[4]; // [sp+434h] [bp+42Ch]
  __int16 v16; // [sp+438h] [bp+430h]
  char v17; // [sp+43Ch] [bp+434h]
  unsigned __int8 i; // [sp+43Dh] [bp+435h]
  __int16 v19; // [sp+43Eh] [bp+436h]
  _BYTE v20[4]; // [sp+440h] [bp+438h] BYREF

  v17 = 20;
  v16 = 255;
  *(_WORD *)v15 = 255;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v19 = 22;
  for ( i = 0; i <= 0xFu; ++i )
    v19 += *(unsigned __int8 *)(i + a3);
  LOBYTE(v16) = HIBYTE(v19);
  HIBYTE(v16) = v19;
  LOWORD(v9) = -21931;
  BYTE2(v9) = v17;
  HIBYTE(v9) = 2;
  for ( i = 0; i <= 0xFu; ++i )
    v20[i - 32] = *(_BYTE *)(i + a3);
  v14 = v16;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 0x15u; ++i )
    write_pic(a1, a2, v20[i - 36]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    v15[v3] = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( v15[0] == 2 && v15[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s ok\n\n", "send_data_to_PIC16F1704");
      applog(2, s, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        s,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "send_data_to_PIC16F1704",
        v15[0],
        v15[1]);
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0002471C) --------------------------------------------------------
int __fastcall read_PIC16F1704_flash_pointer(
        unsigned __int8 a1,
        unsigned __int8 a2,
        unsigned __int8 *a3,
        unsigned __int8 *a4)
{
  int v4; // r4
  char s[1024]; // [sp+28h] [bp+10h] BYREF
  int v12; // [sp+428h] [bp+410h]
  char v13; // [sp+42Ch] [bp+414h]
  char v14; // [sp+42Dh] [bp+415h]
  int v15; // [sp+430h] [bp+418h]
  __int16 v16; // [sp+434h] [bp+41Ch]
  __int16 v17; // [sp+438h] [bp+420h]
  __int16 v18; // [sp+43Ch] [bp+424h]
  char v19; // [sp+43Eh] [bp+426h]
  unsigned __int8 i; // [sp+43Fh] [bp+427h]
  _BYTE v21[4]; // [sp+440h] [bp+428h] BYREF

  v19 = 4;
  v17 = 3072;
  v15 = 255;
  v16 = 0;
  v12 = 134523477;
  v18 = 12;
  v13 = 0;
  v14 = 12;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, v21[i - 24]);
  usleep(0x186A0u);
  for ( i = 0; i <= 5u; ++i )
  {
    v4 = i;
    *((_BYTE *)&v15 + v4) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( BYTE1(v15) == 8 && (unsigned __int8)v15 == 6 )
  {
    v18 = HIBYTE(v15) + BYTE2(v15) + BYTE1(v15) + (unsigned __int8)v15;
    if ( HIBYTE(v18) == (unsigned __int8)v16 && (unsigned __int8)v18 == HIBYTE(v16) )
    {
      *a3 = BYTE2(v15);
      *a4 = HIBYTE(v15);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          s,
          0x400u,
          "--- %s ok! flash_addr_h = 0x%02x, flash_addr_l = 0x%02x\n\n",
          "read_PIC16F1704_flash_pointer",
          *a3,
          *a4);
        applog(2, s, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          s,
          0x400u,
          "--- %s failed! read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3]"
          " = 0x%x, read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n"
          "\n",
          "read_PIC16F1704_flash_pointer",
          (unsigned __int8)v15,
          BYTE1(v15),
          BYTE2(v15),
          HIBYTE(v15),
          (unsigned __int8)v16,
          HIBYTE(v16));
        applog(2, s, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        s,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] ="
        " 0x%x, read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n"
        "\n",
        "read_PIC16F1704_flash_pointer",
        (unsigned __int8)v15,
        BYTE1(v15),
        BYTE2(v15),
        HIBYTE(v15),
        (unsigned __int8)v16,
        HIBYTE(v16));
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00024A40) --------------------------------------------------------
int __fastcall read_PIC16F1704_flash_data(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // r4
  char s[1024]; // [sp+9Ch] [bp+4Ch] BYREF
  int v10; // [sp+49Ch] [bp+44Ch]
  char v11; // [sp+4A0h] [bp+450h]
  char v12; // [sp+4A1h] [bp+451h]
  int v13; // [sp+4A4h] [bp+454h]
  int v14; // [sp+4A8h] [bp+458h]
  int v15; // [sp+4ACh] [bp+45Ch]
  int v16; // [sp+4B0h] [bp+460h]
  int v17; // [sp+4B4h] [bp+464h]
  __int16 v18; // [sp+4B8h] [bp+468h]
  unsigned __int16 v19; // [sp+4BCh] [bp+46Ch]
  char v20; // [sp+4BEh] [bp+46Eh]
  unsigned __int8 i; // [sp+4BFh] [bp+46Fh]
  _BYTE v22[4]; // [sp+4C0h] [bp+470h] BYREF

  v20 = 4;
  v18 = 1792;
  v13 = 255;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v10 = 50637397;
  v19 = 7;
  v11 = 0;
  v12 = 7;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, v22[i - 36]);
  usleep((__useconds_t)&unk_493E0);
  for ( i = 0; i <= 0x13u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v13 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      s,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, \t"
      "\tread_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, \t\tread"
      "_back_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x, \t\tread_bac"
      "k_data[12] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x, \t\tread_back_"
      "data[16] = 0x%x, read_back_data[17] = 0x%x, read_back_data[18] = 0x%x, read_back_data[19] = 0x%x\n",
      "read_PIC16F1704_flash_data",
      (unsigned __int8)v13,
      BYTE1(v13),
      BYTE2(v13),
      HIBYTE(v13),
      (unsigned __int8)v14,
      BYTE1(v14),
      BYTE2(v14),
      HIBYTE(v14),
      (unsigned __int8)v15,
      BYTE1(v15),
      BYTE2(v15),
      HIBYTE(v15),
      (unsigned __int8)v16,
      BYTE1(v16),
      BYTE2(v16),
      HIBYTE(v16),
      (unsigned __int8)v17,
      BYTE1(v17),
      BYTE2(v17),
      HIBYTE(v17));
    applog(2, s, 0);
  }
  usleep(0x186A0u);
  if ( BYTE1(v13) == 3 && (unsigned __int8)v13 == 20 )
  {
    v19 = BYTE1(v17)
        + (unsigned __int8)v17
        + HIBYTE(v16)
        + BYTE2(v16)
        + BYTE1(v16)
        + (unsigned __int8)v16
        + HIBYTE(v15)
        + BYTE2(v15)
        + BYTE1(v15)
        + (unsigned __int8)v15
        + HIBYTE(v14)
        + BYTE2(v14)
        + BYTE1(v14)
        + (unsigned __int8)v14
        + HIBYTE(v13)
        + BYTE2(v13)
        + BYTE1(v13)
        + (unsigned __int8)v13;
    if ( HIBYTE(v19) == BYTE2(v17) && (unsigned __int8)v19 == HIBYTE(v17) )
    {
      for ( i = 0; i <= 0xFu; ++i )
        *(_BYTE *)(i + a3) = v22[i - 26];
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "--- %s ok\n\n", "read_PIC16F1704_flash_data");
        applog(2, s, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "--- %s failed! crc = 0x%04x\n\n", "read_PIC16F1704_flash_data", v19);
        applog(2, s, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s failed!\n\n", "read_PIC16F1704_flash_data");
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00024ED0) --------------------------------------------------------
int __fastcall erase_PIC16F1704_flash(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // r4
  char s[1024]; // [sp+14h] [bp+Ch] BYREF
  int v8; // [sp+414h] [bp+40Ch]
  char v9; // [sp+418h] [bp+410h]
  char v10; // [sp+419h] [bp+411h]
  _WORD v11[5]; // [sp+41Ch] [bp+414h]
  char v12; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v14[4]; // [sp+428h] [bp+420h] BYREF

  v12 = 4;
  v11[2] = 2048;
  v11[0] = 255;
  v8 = 67414613;
  v11[4] = 8;
  v9 = 0;
  v10 = 8;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, v14[i - 20]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v11 + v2) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( LOBYTE(v11[0]) == 4 && HIBYTE(v11[0]) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s ok\n\n", "erase_PIC16F1704_flash");
      applog(2, s, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        s,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "erase_PIC16F1704_flash",
        LOBYTE(v11[0]),
        HIBYTE(v11[0]));
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000250D8) --------------------------------------------------------
int __fastcall write_data_into_PIC16F1704_flash(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // r4
  char s[1024]; // [sp+14h] [bp+Ch] BYREF
  int v8; // [sp+414h] [bp+40Ch]
  char v9; // [sp+418h] [bp+410h]
  char v10; // [sp+419h] [bp+411h]
  _WORD v11[5]; // [sp+41Ch] [bp+414h]
  char v12; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v14[4]; // [sp+428h] [bp+420h] BYREF

  v12 = 4;
  v11[2] = 2304;
  v11[0] = 255;
  v8 = 84191829;
  v11[4] = 9;
  v9 = 0;
  v10 = 9;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, v14[i - 20]);
  usleep(0x30D40u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v11 + v2) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( LOBYTE(v11[0]) == 5 && HIBYTE(v11[0]) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s ok\n\n", "write_data_into_PIC16F1704_flash");
      applog(2, s, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        s,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "write_data_into_PIC16F1704_flash",
        LOBYTE(v11[0]),
        HIBYTE(v11[0]));
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000252E0) --------------------------------------------------------
int __fastcall jump_from_loader_to_app_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // r4
  char s[1024]; // [sp+14h] [bp+Ch] BYREF
  int v8; // [sp+414h] [bp+40Ch]
  char v9; // [sp+418h] [bp+410h]
  char v10; // [sp+419h] [bp+411h]
  _WORD v11[5]; // [sp+41Ch] [bp+414h]
  char v12; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v14[4]; // [sp+428h] [bp+420h] BYREF

  v12 = 4;
  v11[2] = 2560;
  v11[0] = 255;
  v8 = 100969045;
  v11[4] = 10;
  v9 = 0;
  v10 = 10;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, v14[i - 20]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v11 + v2) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_493E0);
  if ( LOBYTE(v11[0]) == 6 && HIBYTE(v11[0]) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s ok\n\n", "jump_from_loader_to_app_PIC16F1704");
      applog(2, s, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        s,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "jump_from_loader_to_app_PIC16F1704",
        LOBYTE(v11[0]),
        HIBYTE(v11[0]));
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000254E8) --------------------------------------------------------
int __fastcall reset_PIC16F1704_pic(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // r4
  char s[1024]; // [sp+14h] [bp+Ch] BYREF
  int v8; // [sp+414h] [bp+40Ch]
  char v9; // [sp+418h] [bp+410h]
  char v10; // [sp+419h] [bp+411h]
  _WORD v11[5]; // [sp+41Ch] [bp+414h]
  char v12; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v14[4]; // [sp+428h] [bp+420h] BYREF

  v12 = 4;
  v11[2] = 2816;
  v11[0] = 255;
  v8 = 117746261;
  v11[4] = 11;
  v9 = 0;
  v10 = 11;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, v14[i - 20]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v11 + v2) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0xF4240u);
  if ( LOBYTE(v11[0]) == 7 && HIBYTE(v11[0]) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s ok\n\n", "reset_PIC16F1704_pic");
      applog(2, s, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        s,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "reset_PIC16F1704_pic",
        LOBYTE(v11[0]),
        HIBYTE(v11[0]));
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000256F0) --------------------------------------------------------
int __fastcall set_PIC16F1704_voltage(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  int v3; // r4
  char s[1024]; // [sp+14h] [bp+Ch] BYREF
  __int16 v9; // [sp+414h] [bp+40Ch]
  char v10; // [sp+416h] [bp+40Eh]
  char v11; // [sp+417h] [bp+40Fh]
  unsigned __int8 v12; // [sp+418h] [bp+410h]
  char v13; // [sp+419h] [bp+411h]
  char v14; // [sp+41Ah] [bp+412h]
  unsigned __int8 v15[4]; // [sp+41Ch] [bp+414h]
  char v16; // [sp+420h] [bp+418h]
  char v17; // [sp+421h] [bp+419h]
  __int16 v18; // [sp+424h] [bp+41Ch]
  char v19; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v21[4]; // [sp+428h] [bp+420h] BYREF

  v19 = 5;
  *(_WORD *)v15 = 255;
  v9 = -21931;
  v11 = 16;
  v18 = a3 + 21;
  v16 = HIBYTE(v18);
  v17 = a3 + 21;
  v10 = 5;
  v12 = a3;
  v13 = HIBYTE(v18);
  v14 = a3 + 21;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 6u; ++i )
    write_pic(a2, a1, v21[i - 20]);
  usleep(0x30D40u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    v15[v3] = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( v15[0] == 16 && v15[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s ok\n\n", "set_PIC16F1704_voltage");
      applog(2, s, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        s,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "set_PIC16F1704_voltage",
        v15[0],
        v15[1]);
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00025918) --------------------------------------------------------
int __fastcall write_hash_ID_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // r4
  char s[1024]; // [sp+18h] [bp+10h] BYREF
  int v9; // [sp+418h] [bp+410h]
  int v10; // [sp+41Ch] [bp+414h]
  int v11; // [sp+420h] [bp+418h]
  int v12; // [sp+424h] [bp+41Ch]
  __int16 v13; // [sp+428h] [bp+420h]
  unsigned __int8 v14[4]; // [sp+42Ch] [bp+424h]
  __int16 v15; // [sp+430h] [bp+428h]
  char v16; // [sp+434h] [bp+42Ch]
  unsigned __int8 i; // [sp+435h] [bp+42Dh]
  __int16 v18; // [sp+436h] [bp+42Eh]
  _BYTE v19[4]; // [sp+438h] [bp+430h] BYREF

  v16 = 16;
  v15 = 255;
  *(_WORD *)v14 = 255;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v18 = 34;
  for ( i = 0; i <= 0xBu; ++i )
    v18 += *(unsigned __int8 *)(i + a3);
  LOBYTE(v15) = HIBYTE(v18);
  HIBYTE(v15) = v18;
  LOWORD(v9) = -21931;
  BYTE2(v9) = v16;
  HIBYTE(v9) = 18;
  for ( i = 0; i <= 0xBu; ++i )
    v19[i - 28] = *(_BYTE *)(i + a3);
  v13 = v15;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 0x11u; ++i )
    write_pic(a2, a1, v19[i - 32]);
  usleep((__useconds_t)&unk_61A80);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    v14[v3] = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( v14[0] == 18 && v14[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s ok\n\n", "write_hash_ID_PIC16F1704");
      applog(2, s, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        s,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "write_hash_ID_PIC16F1704",
        v14[0],
        v14[1]);
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00025BA0) --------------------------------------------------------
int __fastcall read_hash_id_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // r4
  char s[1024]; // [sp+78h] [bp+38h] BYREF
  int v10; // [sp+478h] [bp+438h]
  char v11; // [sp+47Ch] [bp+43Ch]
  char v12; // [sp+47Dh] [bp+43Dh]
  int v13; // [sp+480h] [bp+440h]
  int v14; // [sp+484h] [bp+444h]
  int v15; // [sp+488h] [bp+448h]
  int v16; // [sp+48Ch] [bp+44Ch]
  __int16 v17; // [sp+490h] [bp+450h]
  unsigned __int16 v18; // [sp+494h] [bp+454h]
  char v19; // [sp+496h] [bp+456h]
  unsigned __int8 i; // [sp+497h] [bp+457h]
  _BYTE v21[4]; // [sp+498h] [bp+458h] BYREF

  v19 = 4;
  v17 = 5888;
  v13 = 255;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v10 = 319072853;
  v18 = 23;
  v11 = 0;
  v12 = 23;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, v21[i - 32]);
  usleep(0x30D40u);
  for ( i = 0; i <= 0xFu; ++i )
  {
    v3 = i;
    *((_BYTE *)&v13 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      s,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,\t\t"
      "read_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,\t\tread_ba"
      "ck_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x,\t\tread_back_da"
      "ta[12] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x\n",
      "read_hash_id_PIC16F1704",
      (unsigned __int8)v13,
      BYTE1(v13),
      BYTE2(v13),
      HIBYTE(v13),
      (unsigned __int8)v14,
      BYTE1(v14),
      BYTE2(v14),
      HIBYTE(v14),
      (unsigned __int8)v15,
      BYTE1(v15),
      BYTE2(v15),
      HIBYTE(v15),
      (unsigned __int8)v16,
      BYTE1(v16),
      BYTE2(v16),
      HIBYTE(v16));
    applog(2, s, 0);
  }
  if ( BYTE1(v13) == 19 && (unsigned __int8)v13 == 16 )
  {
    v18 = BYTE1(v16)
        + (unsigned __int8)v16
        + HIBYTE(v15)
        + BYTE2(v15)
        + BYTE1(v15)
        + (unsigned __int8)v15
        + HIBYTE(v14)
        + BYTE2(v14)
        + BYTE1(v14)
        + (unsigned __int8)v14
        + HIBYTE(v13)
        + BYTE2(v13)
        + BYTE1(v13)
        + (unsigned __int8)v13;
    if ( HIBYTE(v18) == BYTE2(v16) && (unsigned __int8)v18 == HIBYTE(v16) )
    {
      for ( i = 0; i <= 0xBu; ++i )
        *(_BYTE *)(i + a3) = v21[i - 22];
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "--- %s ok\n\n", "read_hash_id_PIC16F1704");
        applog(2, s, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "--- %s failed! crc = 0x%04x\n\n", "read_hash_id_PIC16F1704", v18);
        applog(2, s, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s failed!\n\n", "read_hash_id_PIC16F1704");
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00025FD0) --------------------------------------------------------
int __fastcall enable_PIC16F1704_dc_dc(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  int v3; // r4
  char s[1024]; // [sp+14h] [bp+Ch] BYREF
  __int16 v9; // [sp+414h] [bp+40Ch]
  char v10; // [sp+416h] [bp+40Eh]
  char v11; // [sp+417h] [bp+40Fh]
  unsigned __int8 v12; // [sp+418h] [bp+410h]
  char v13; // [sp+419h] [bp+411h]
  char v14; // [sp+41Ah] [bp+412h]
  unsigned __int8 v15[4]; // [sp+41Ch] [bp+414h]
  char v16; // [sp+420h] [bp+418h]
  char v17; // [sp+421h] [bp+419h]
  __int16 v18; // [sp+424h] [bp+41Ch]
  char v19; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v21[4]; // [sp+428h] [bp+420h] BYREF

  v19 = 5;
  *(_WORD *)v15 = 255;
  v9 = -21931;
  v11 = 21;
  v18 = a3 + 26;
  v16 = HIBYTE(v18);
  v17 = a3 + 26;
  v10 = 5;
  v12 = a3;
  v13 = HIBYTE(v18);
  v14 = a3 + 26;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 6u; ++i )
    write_pic(a2, a1, v21[i - 20]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    v15[v3] = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( v15[0] == 21 && v15[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s ok\n\n", "enable_PIC16F1704_dc_dc");
      applog(2, s, 0);
    }
    usleep((__useconds_t)&unk_7A120);
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        s,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "enable_PIC16F1704_dc_dc",
        v15[0],
        v15[1]);
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000261F8) --------------------------------------------------------
int __fastcall heart_beat_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // r4
  char s[1024]; // [sp+8h] [bp+8h] BYREF
  int v8; // [sp+408h] [bp+408h]
  char v9; // [sp+40Ch] [bp+40Ch]
  char v10; // [sp+40Dh] [bp+40Dh]
  int v11; // [sp+410h] [bp+410h]
  __int16 v12; // [sp+414h] [bp+414h]
  __int16 v13; // [sp+418h] [bp+418h]
  __int16 v14; // [sp+41Ch] [bp+41Ch]
  char v15; // [sp+41Eh] [bp+41Eh]
  unsigned __int8 i; // [sp+41Fh] [bp+41Fh]
  _BYTE v17[4]; // [sp+420h] [bp+420h] BYREF

  v15 = 4;
  v13 = 6656;
  v11 = 255;
  v12 = 0;
  v8 = 369404501;
  v14 = 26;
  v9 = 0;
  v10 = 26;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, v17[i - 24]);
  usleep(0x186A0u);
  for ( i = 0; i <= 5u; ++i )
  {
    v2 = i;
    *((_BYTE *)&v11 + v2) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( BYTE1(v11) == 22 && BYTE2(v11) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s ok\n\n", "heart_beat_PIC16F1704");
      applog(2, s, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s failed!\n\n", "heart_beat_PIC16F1704");
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000263EC) --------------------------------------------------------
void __fastcall __noreturn pic_heart_beat_func(unsigned __int8 *a1)
{
  unsigned __int8 v1; // [sp+Ah] [bp+Ah]
  unsigned __int8 v2; // [sp+Bh] [bp+Bh]

  v2 = *a1;
  v1 = a1[1];
  while ( 1 )
  {
    heart_beat_PIC16F1704(v2, v1);
    sleep(0xAu);
  }
}

//----- (00026418) --------------------------------------------------------
int __fastcall get_PIC16F1704_software_version(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 *a3)
{
  int v3; // r4
  char s[1024]; // [sp+28h] [bp+10h] BYREF
  int v10; // [sp+428h] [bp+410h]
  char v11; // [sp+42Ch] [bp+414h]
  char v12; // [sp+42Dh] [bp+415h]
  int v13; // [sp+430h] [bp+418h]
  unsigned __int8 v14; // [sp+434h] [bp+41Ch]
  __int16 v15; // [sp+438h] [bp+420h]
  unsigned __int16 v16; // [sp+43Ch] [bp+424h]
  char v17; // [sp+43Eh] [bp+426h]
  unsigned __int8 i; // [sp+43Fh] [bp+427h]
  _BYTE vars0[16]; // [sp+440h] [bp+428h] BYREF

  v17 = 4;
  v15 = 6912;
  v13 = 255;
  v14 = 0;
  v10 = 386181717;
  v16 = 27;
  v11 = 0;
  v12 = 27;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, vars0[i - 24]);
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v13 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      s,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, re"
      "ad_back_data[4] = 0x%x\n",
      "get_PIC16F1704_software_version",
      (unsigned __int8)v13,
      BYTE1(v13),
      BYTE2(v13),
      HIBYTE(v13),
      v14);
    applog(2, s, 0);
  }
  if ( BYTE1(v13) == 23 && (unsigned __int8)v13 == 5 )
  {
    v16 = BYTE2(v13) + BYTE1(v13) + (unsigned __int8)v13;
    if ( HIBYTE(v16) == HIBYTE(v13) && (unsigned __int8)v16 == v14 )
    {
      *a3 = BYTE2(v13);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "--- %s ok, version = 0x%02x\n\n", "get_PIC16F1704_software_version", *a3);
        applog(2, s, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_software_version", v16);
        applog(2, s, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s failed!\n\n", "get_PIC16F1704_software_version");
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0002674C) --------------------------------------------------------
int __fastcall PIC16F1704_i2c_forward_send(
        unsigned __int8 a1,
        unsigned __int8 a2,
        char a3,
        int a4,
        char a5,
        size_t n,
        unsigned __int8 *src)
{
  char v13[1024]; // [sp+18h] [bp+10h] BYREF
  _BYTE v14[12]; // [sp+418h] [bp+410h] BYREF
  _BYTE s[32]; // [sp+424h] [bp+41Ch] BYREF
  signed int k; // [sp+444h] [bp+43Ch]
  int i; // [sp+448h] [bp+440h]
  signed int j; // [sp+44Ch] [bp+444h]
  int v19; // [sp+450h] [bp+448h]
  unsigned __int16 v20; // [sp+456h] [bp+44Eh]
  _BYTE v21[4]; // [sp+458h] [bp+450h] BYREF

  memset(s, 0, sizeof(s));
  memset(v14, 0, sizeof(v14));
  v20 = 0;
  v19 = 0;
  j = 0;
  s[0] = 85;
  s[1] = -86;
  s[2] = 0;
  s[3] = 38;
  s[4] = a4 | (2 * a3);
  s[5] = a5;
  if ( a4 )
  {
    v19 = 5;
    s[6] = n;
  }
  else
  {
    v19 = n + 4;
    memcpy(&s[6], src, n);
  }
  s[2] = v19 + 2;
  for ( i = 0; i < v19; ++i )
    v20 += (unsigned __int8)v21[i - 50];
  v21[v19 - 50] = HIBYTE(v20);
  v21[v19 - 49] = v20;
  pthread_mutex_lock(&i2c_mutex);
  for ( j = 0; v19 + 4 > j; ++j )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v13, 0x400u, "write pic i2c[%d] %02x\n", j, (unsigned __int8)s[j]);
      applog(2, v13, 0);
    }
    write_pic(a1, a2, s[j]);
  }
  usleep(0x30D40u);
  if ( a4 != 1 )
    goto LABEL_40;
  for ( j = 0; (int)(n + 5) > j; ++j )
  {
    v14[j] = read_pic(a1, a2);
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v13, 0x400u, "read pic i2c[%d] %02x\n", j, (unsigned __int8)v14[j]);
      applog(2, v13, 0);
    }
  }
  for ( k = 0; (int)(n + 3) > k; ++k )
    v20 += (unsigned __int8)v14[k];
  if ( v20 == *(unsigned __int16 *)&v14[n + 3] )
  {
    if ( v14[0] != v19 + 2 || v14[1] != 38 || v14[2] != 1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v13, 0x400u, "pic read failed %d %d %d\n", *src, src[1], src[2]);
        applog(2, v13, 0);
      }
      goto LABEL_30;
    }
    memcpy(src, &v14[3], n);
LABEL_40:
    pthread_mutex_unlock(&i2c_mutex);
    return 0;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v13, 0x400u, "crc failed 0x%x\n", v20);
    applog(2, v13, 0);
  }
LABEL_30:
  pthread_mutex_unlock(&i2c_mutex);
  return -1;
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00026B68) --------------------------------------------------------
int __fastcall set_PIC16F1704_voltage_z9(int result, unsigned __int8 a2, __int16 a3)
{
  unsigned __int8 src[3]; // [sp+10h] [bp+0h] BYREF
  unsigned __int8 v4[9]; // [sp+13h] [bp+3h]
  unsigned int i; // [sp+1Ch] [bp+Ch]

  *(_DWORD *)&v4[1] = result;
  v4[0] = a2;
  *(_WORD *)src = a3;
  for ( i = 0; i <= 3; ++i )
  {
    PIC16F1704_i2c_forward_send(v4[1], v4[0], isl68127_i2c_dev_addr[i], 0, 0, 1u, 0);
    result = PIC16F1704_i2c_forward_send(v4[1], v4[0], isl68127_i2c_dev_addr[i], 0, 33, 2u, src);
  }
  return result;
}
// 35954: using guessed type _BYTE isl68127_i2c_dev_addr[4];

//----- (00026BE0) --------------------------------------------------------
int __fastcall get_PIC16F1704_voltage_z9(int result, unsigned __int8 a2)
{
  unsigned __int8 v3; // [sp+14h] [bp+4h]
  char s[1024]; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int8 src[12]; // [sp+41Ch] [bp+40Ch] BYREF
  int v6; // [sp+428h] [bp+418h]
  unsigned int i; // [sp+42Ch] [bp+41Ch]

  v3 = result;
  for ( i = 0; i <= 3; ++i )
  {
    memset(src, 0, sizeof(src));
    result = PIC16F1704_i2c_forward_send(v3, a2, isl68127_i2c_dev_addr[i], 1, 33, 2u, src);
    v6 = result;
    if ( result )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          s,
          0x400u,
          "read %02x vol failed, 0x%02x%02x\n",
          (unsigned __int8)isl68127_i2c_dev_addr[i],
          src[0],
          src[1]);
        result = applog(2, s, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        s,
        0x400u,
        "read %02x vol success, 0x%02x%02x\n",
        (unsigned __int8)isl68127_i2c_dev_addr[i],
        src[0],
        src[1]);
      result = applog(2, s, 0);
    }
  }
  return result;
}
// 35954: using guessed type _BYTE isl68127_i2c_dev_addr[4];
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00026D38) --------------------------------------------------------
int __fastcall get_PIC16F1704_voltage(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 *a3)
{
  int v3; // r4
  char s[1024]; // [sp+28h] [bp+10h] BYREF
  int v10; // [sp+428h] [bp+410h]
  char v11; // [sp+42Ch] [bp+414h]
  char v12; // [sp+42Dh] [bp+415h]
  int v13; // [sp+430h] [bp+418h]
  unsigned __int8 v14; // [sp+434h] [bp+41Ch]
  __int16 v15; // [sp+438h] [bp+420h]
  unsigned __int16 v16; // [sp+43Ch] [bp+424h]
  char v17; // [sp+43Eh] [bp+426h]
  unsigned __int8 i; // [sp+43Fh] [bp+427h]
  _BYTE vars0[16]; // [sp+440h] [bp+428h] BYREF

  v17 = 4;
  v15 = 7168;
  v13 = 255;
  v14 = 0;
  v10 = 402958933;
  v16 = 28;
  v11 = 0;
  v12 = 28;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, vars0[i - 24]);
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v13 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      s,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, re"
      "ad_back_data[4] = 0x%x\n",
      "get_PIC16F1704_voltage",
      (unsigned __int8)v13,
      BYTE1(v13),
      BYTE2(v13),
      HIBYTE(v13),
      v14);
    applog(2, s, 0);
  }
  if ( BYTE1(v13) == 24 && (unsigned __int8)v13 == 5 )
  {
    v16 = BYTE2(v13) + BYTE1(v13) + (unsigned __int8)v13;
    if ( HIBYTE(v16) == HIBYTE(v13) && (unsigned __int8)v16 == v14 )
    {
      *a3 = BYTE2(v13);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "--- %s ok, voltage = 0x%02x\n\n", "get_PIC16F1704_voltage", *a3);
        applog(2, s, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_voltage", v16);
        applog(2, s, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s failed!\n\n", "get_PIC16F1704_voltage");
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00027060) --------------------------------------------------------
int __fastcall write_temperature_offset_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // r4
  char s[1024]; // [sp+1Ch] [bp+14h] BYREF
  int v9; // [sp+41Ch] [bp+414h]
  int v10; // [sp+420h] [bp+418h]
  int v11; // [sp+424h] [bp+41Ch]
  __int16 v12; // [sp+428h] [bp+420h]
  unsigned __int8 v13[4]; // [sp+42Ch] [bp+424h]
  __int16 v14; // [sp+430h] [bp+428h]
  char v15; // [sp+434h] [bp+42Ch]
  unsigned __int8 i; // [sp+435h] [bp+42Dh]
  __int16 v17; // [sp+436h] [bp+42Eh]
  _BYTE v18[4]; // [sp+438h] [bp+430h] BYREF

  v15 = 12;
  v14 = 255;
  *(_WORD *)v13 = 255;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v17 = 46;
  for ( i = 0; i <= 7u; ++i )
    v17 += *(unsigned __int8 *)(i + a3);
  LOBYTE(v14) = HIBYTE(v17);
  HIBYTE(v14) = v17;
  LOWORD(v9) = -21931;
  BYTE2(v9) = v15;
  HIBYTE(v9) = 34;
  for ( i = 0; i <= 7u; ++i )
    v18[i - 24] = *(_BYTE *)(i + a3);
  v12 = v14;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 0xDu; ++i )
    write_pic(a1, a2, v18[i - 28]);
  usleep(0x30D40u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    v13[v3] = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( v13[0] == 34 && v13[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s ok\n\n", "write_temperature_offset_PIC16F1704");
      applog(2, s, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        s,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "write_temperature_offset_PIC16F1704",
        v13[0],
        v13[1]);
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000272E4) --------------------------------------------------------
int __fastcall read_temperature_offset_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // r4
  char s[1024]; // [sp+5Ch] [bp+2Ch] BYREF
  int v10; // [sp+45Ch] [bp+42Ch]
  char v11; // [sp+460h] [bp+430h]
  char v12; // [sp+461h] [bp+431h]
  int v13; // [sp+464h] [bp+434h]
  int v14; // [sp+468h] [bp+438h]
  int v15; // [sp+46Ch] [bp+43Ch]
  __int16 v16; // [sp+470h] [bp+440h]
  unsigned __int16 v17; // [sp+474h] [bp+444h]
  char v18; // [sp+476h] [bp+446h]
  unsigned __int8 i; // [sp+477h] [bp+447h]
  _BYTE v20[4]; // [sp+478h] [bp+448h] BYREF

  v18 = 4;
  v16 = 9984;
  v13 = 255;
  v14 = 0;
  v15 = 0;
  v10 = 587508309;
  v17 = 39;
  v11 = 0;
  v12 = 39;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, v20[i - 28]);
  usleep(0x30D40u);
  for ( i = 0; i <= 0xBu; ++i )
  {
    v3 = i;
    *((_BYTE *)&v13 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      s,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, \t"
      "\tread_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, \t\tread"
      "_back_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x\n",
      "read_temperature_offset_PIC16F1704",
      (unsigned __int8)v13,
      BYTE1(v13),
      BYTE2(v13),
      HIBYTE(v13),
      (unsigned __int8)v14,
      BYTE1(v14),
      BYTE2(v14),
      HIBYTE(v14),
      (unsigned __int8)v15,
      BYTE1(v15),
      BYTE2(v15),
      HIBYTE(v15));
    applog(2, s, 0);
  }
  if ( BYTE1(v13) == 35 && (unsigned __int8)v13 == 12 )
  {
    v17 = BYTE1(v15)
        + (unsigned __int8)v15
        + HIBYTE(v14)
        + BYTE2(v14)
        + BYTE1(v14)
        + (unsigned __int8)v14
        + HIBYTE(v13)
        + BYTE2(v13)
        + BYTE1(v13)
        + (unsigned __int8)v13;
    if ( HIBYTE(v17) == BYTE2(v15) && (unsigned __int8)v17 == HIBYTE(v15) )
    {
      for ( i = 0; i <= 7u; ++i )
        *(_BYTE *)(i + a3) = v20[i - 18];
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "--- %s ok\n\n", "read_temperature_offset_PIC16F1704");
        applog(2, s, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "--- %s failed! crc = 0x%04x\n\n", "read_temperature_offset_PIC16F1704", v17);
        applog(2, s, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s failed!\n\n", "read_temperature_offset_PIC16F1704");
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000276C8) --------------------------------------------------------
int __fastcall erase_PIC16F1704_app_flash(unsigned __int8 a1, unsigned __int8 a2)
{
  char s[1024]; // [sp+10h] [bp+8h] BYREF
  int v6; // [sp+410h] [bp+408h]
  char v7; // [sp+414h] [bp+40Ch]
  char v8; // [sp+415h] [bp+40Dh]
  char v9; // [sp+416h] [bp+40Eh]
  char v10; // [sp+417h] [bp+40Fh]
  unsigned int v11; // [sp+418h] [bp+410h]
  unsigned int i; // [sp+41Ch] [bp+414h]

  i = 0;
  v10 = 6;
  v9 = 0;
  v8 = 15;
  v7 = 127;
  set_PIC16F1704_flash_pointer(a1, a2, 6u, 0);
  v6 = 2432;
  v11 = 76;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(s, 0x400u, "%s: erase_loop = %d\n", "erase_PIC16F1704_app_flash", v11);
    applog(2, s, 0);
  }
  for ( i = 0; i < v11; ++i )
    erase_PIC16F1704_flash(a1, a2);
  return 1;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000277D0) --------------------------------------------------------
int __fastcall PIC1704_update_pic_app_program(unsigned __int8 a1, unsigned __int8 a2)
{
  int *v3; // r3
  int v4; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3
  char v11[24]; // [sp+8h] [bp+8h] BYREF
  int v12; // [sp+408h] [bp+408h] BYREF
  int v13; // [sp+40Ch] [bp+40Ch]
  int v14; // [sp+410h] [bp+410h]
  int v15; // [sp+414h] [bp+414h]
  int v16; // [sp+418h] [bp+418h] BYREF
  char v17; // [sp+41Ch] [bp+41Ch]
  _BYTE s[5000]; // [sp+420h] [bp+420h] BYREF
  FILE *v19; // [sp+17A8h] [bp+17A8h]
  int v20; // [sp+17ACh] [bp+17ACh]
  unsigned int v21; // [sp+17B0h] [bp+17B0h]
  unsigned __int8 v22; // [sp+17B4h] [bp+17B4h]
  unsigned __int8 v23; // [sp+17B5h] [bp+17B5h]
  unsigned __int8 v24; // [sp+17B6h] [bp+17B6h]
  unsigned __int8 v25; // [sp+17B7h] [bp+17B7h]
  unsigned int v26; // [sp+17B8h] [bp+17B8h]
  unsigned int i; // [sp+17BCh] [bp+17BCh]

  memset(s, 0, sizeof(s));
  i = 0;
  v16 = 0;
  v17 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v26 = 0;
  v25 = 6;
  v24 = 0;
  v23 = 15;
  v22 = 127;
  v21 = 0;
  v20 = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v11, "--- update pic program\n");
    applog(2, v11, 0);
  }
  v19 = fopen("/mnt/card/pic16f1704_app.txt", "r");
  if ( v19 )
  {
    fseek(v19, 0, 0);
    memset(s, 0, sizeof(s));
    v21 = (v23 << 8) + v22 - (v24 + (v25 << 8)) + 1;
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v11, 0x400u, "pic_flash_length = %d\n", v21);
      applog(2, v11, 0);
    }
    for ( i = 0; i < v21; ++i )
    {
      fgets((char *)&v16, 1023, v19);
      v26 = strtoul((const char *)&v16, 0, 16);
      s[2 * i] = BYTE1(v26);
      s[2 * i + 1] = v26;
    }
    fclose(v19);
    v20 = reset_PIC16F1704_pic(a1, a2);
    if ( v20 )
    {
      v20 = erase_PIC16F1704_app_flash(a1, a2);
      if ( v20 )
      {
        v20 = set_PIC16F1704_flash_pointer(a1, a2, 6u, 0);
        if ( v20 )
        {
          for ( i = 0; 4 * (v21 >> 5) > i; ++i )
          {
            v3 = (int *)&s[16 * i];
            v4 = *v3;
            v5 = v3[1];
            v6 = v3[2];
            v7 = v3[3];
            v12 = v4;
            v13 = v5;
            v14 = v6;
            v15 = v7;
            if ( use_syslog || opt_log_output || opt_log_level > 1 )
            {
              snprintf(v11, 0x400u, "send pic program time: %d\n", i);
              applog(2, v11, 0);
            }
            send_data_to_PIC16F1704(a1, a2, (int)&v12);
            write_data_into_PIC16F1704_flash(a1, a2);
          }
          v20 = reset_PIC16F1704_pic(a1, a2);
          if ( v20 )
          {
            return 1;
          }
          else
          {
            if ( use_syslog || opt_log_output || opt_log_level > 1 )
            {
              snprintf(v11, 0x400u, "!!! %s: reset pic error!\n\n", "PIC1704_update_pic_app_program");
              applog(2, v11, 0);
            }
            return 0;
          }
        }
        else
        {
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            snprintf(v11, 0x400u, "!!! %s: set flash pointer error!\n\n", "PIC1704_update_pic_app_program");
            applog(2, v11, 0);
          }
          return 0;
        }
      }
      else
      {
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf(v11, 0x400u, "!!! %s: erase flash error!\n\n", "PIC1704_update_pic_app_program");
          applog(2, v11, 0);
        }
        return 0;
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v11, 0x400u, "!!! %s: reset pic error!\n\n", "PIC1704_update_pic_app_program");
        applog(2, v11, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v11, 0x400u, "%s: open pic16f1704_app.txt failed\n", "PIC1704_update_pic_app_program");
      applog(2, v11, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00027DF8) --------------------------------------------------------
int __fastcall save_freq_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, unsigned __int16 a3)
{
  __int16 v3; // r2
  int v4; // r4
  char s[1024]; // [sp+14h] [bp+Ch] BYREF
  int v11; // [sp+414h] [bp+40Ch]
  char v12; // [sp+418h] [bp+410h]
  char v13; // [sp+419h] [bp+411h]
  char v14; // [sp+41Ah] [bp+412h]
  char v15; // [sp+41Bh] [bp+413h]
  unsigned __int8 v16[4]; // [sp+41Ch] [bp+414h]
  char v17; // [sp+420h] [bp+418h]
  char v18; // [sp+421h] [bp+419h]
  __int16 v19; // [sp+424h] [bp+41Ch]
  char v20; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v22[4]; // [sp+428h] [bp+420h] BYREF

  v20 = 6;
  *(_WORD *)v16 = 255;
  v11 = 604416597;
  v3 = HIBYTE(a3) + 6;
  v19 = (unsigned __int8)a3 + v3 + 36;
  v17 = HIBYTE(v19);
  v18 = a3 + v3 + 36;
  v12 = HIBYTE(a3);
  v13 = a3;
  v14 = HIBYTE(v19);
  v15 = v18;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 7u; ++i )
    write_pic(a2, a1, v22[i - 20]);
  usleep((__useconds_t)&unk_493E0);
  for ( i = 0; i <= 1u; ++i )
  {
    v4 = i;
    v16[v4] = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( v16[0] == 36 && v16[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s ok\n\n", "save_freq_PIC16F1704");
      applog(2, s, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        s,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "save_freq_PIC16F1704",
        v16[0],
        v16[1]);
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0002803C) --------------------------------------------------------
int __fastcall get_PIC16F1704_freq(unsigned __int8 a1, unsigned __int8 a2, unsigned __int16 *a3)
{
  int v3; // r4
  char s[1024]; // [sp+28h] [bp+10h] BYREF
  int v10; // [sp+428h] [bp+410h]
  char v11; // [sp+42Ch] [bp+414h]
  char v12; // [sp+42Dh] [bp+415h]
  int v13; // [sp+430h] [bp+418h]
  __int16 v14; // [sp+434h] [bp+41Ch]
  __int16 v15; // [sp+438h] [bp+420h]
  unsigned __int16 v16; // [sp+43Ch] [bp+424h]
  char v17; // [sp+43Eh] [bp+426h]
  unsigned __int8 i; // [sp+43Fh] [bp+427h]
  _BYTE v19[4]; // [sp+440h] [bp+428h] BYREF

  v17 = 4;
  v15 = 10496;
  v13 = 255;
  v14 = 0;
  v10 = 621062741;
  v16 = 41;
  v11 = 0;
  v12 = 41;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, v19[i - 24]);
  usleep((__useconds_t)&unk_493E0);
  for ( i = 0; i <= 5u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v13 + v3) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      s,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, re"
      "ad_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
      "get_PIC16F1704_freq",
      (unsigned __int8)v13,
      BYTE1(v13),
      BYTE2(v13),
      HIBYTE(v13),
      (unsigned __int8)v14,
      HIBYTE(v14));
    applog(2, s, 0);
  }
  if ( BYTE1(v13) == 37 && (unsigned __int8)v13 == 6 )
  {
    v16 = HIBYTE(v13) + BYTE2(v13) + BYTE1(v13) + (unsigned __int8)v13;
    if ( HIBYTE(v16) == (unsigned __int8)v14 && (unsigned __int8)v16 == HIBYTE(v14) )
    {
      *a3 = _byteswap_ushort(HIWORD(v13));
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "--- %s ok, freq = %d\n\n", "get_PIC16F1704_freq", *a3);
        applog(2, s, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_freq", v16);
        applog(2, s, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "--- %s failed!\n\n", "get_PIC16F1704_freq");
      applog(2, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00028390) --------------------------------------------------------
int __fastcall set_temperature_offset_value(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char s[1024]; // [sp+10h] [bp+10h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(s, 0x400u, "--- %s\n", "set_temperature_offset_value");
    applog(2, s, 0);
  }
  write_temperature_offset_PIC16F1704(a1, a2, a3);
  return usleep(0x186A0u);
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00028428) --------------------------------------------------------
int __fastcall write_PIC16F1705_iic_slave(unsigned __int8 a1, unsigned __int8 a2, int a3, unsigned __int8 a4)
{
  int v4; // r4
  char v11[1124]; // [sp+2Ch] [bp+14h] BYREF
  int v12; // [sp+490h] [bp+478h]
  unsigned __int8 v13; // [sp+494h] [bp+47Ch]
  __int16 v14; // [sp+498h] [bp+480h]
  unsigned __int8 v15; // [sp+49Ch] [bp+484h]
  unsigned __int8 i; // [sp+49Dh] [bp+485h]
  __int16 v17; // [sp+49Eh] [bp+486h]
  _BYTE vars0[16]; // [sp+4A0h] [bp+488h] BYREF

  v15 = a4 + 4;
  v14 = 255;
  v12 = 255;
  v13 = 0;
  v17 = 0;
  memset(&v11[1024], 0, 0x64u);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v11, 0x400u, "--- %s\n", "write_PIC16F1705_iic_slave");
    applog(2, v11, 0);
  }
  v17 = v15 + 38;
  for ( i = 0; i < (unsigned int)a4; ++i )
    v17 += *(unsigned __int8 *)(i + a3);
  LOBYTE(v14) = HIBYTE(v17);
  HIBYTE(v14) = v17;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      v11,
      0x400u,
      "--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n",
      "write_PIC16F1705_iic_slave",
      (unsigned __int8)v14,
      HIBYTE(v14));
    applog(2, v11, 0);
  }
  v11[1024] = 85;
  v11[1025] = -86;
  v11[1026] = v15;
  v11[1027] = 38;
  for ( i = 0; i < (unsigned int)a4; ++i )
    vars0[i - 112] = *(_BYTE *)(i + a3);
  vars0[a4 - 112] = v14;
  vars0[a4 - 111] = HIBYTE(v14);
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i < v15 + 2; ++i )
    write_pic(a1, a2, vars0[i - 116]);
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
  {
    v4 = i;
    *((_BYTE *)&v12 + v4) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( BYTE1(v12) == 38 && BYTE2(v12) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v11, 0x400u, "--- %s ok\n\n", "write_PIC16F1705_iic_slave");
      applog(2, v11, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        v11,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_dat"
        "a[3] = 0x%02x, read_back_data[4] = 0x%02x\n"
        "\n",
        "write_PIC16F1705_iic_slave",
        (unsigned __int8)v12,
        BYTE1(v12),
        BYTE2(v12),
        HIBYTE(v12),
        v13);
      applog(2, v11, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000287BC) --------------------------------------------------------
int __fastcall read_PIC16F1705_iic_slave(unsigned __int8 a1, unsigned __int8 a2, int a3, unsigned __int8 a4)
{
  int v4; // r4
  char v11[1124]; // [sp+18h] [bp+10h] BYREF
  _BYTE s[100]; // [sp+47Ch] [bp+474h] BYREF
  __int16 v13; // [sp+4E0h] [bp+4D8h]
  unsigned __int8 v14; // [sp+4E4h] [bp+4DCh]
  unsigned __int8 i; // [sp+4E5h] [bp+4DDh]
  __int16 v16; // [sp+4E6h] [bp+4DEh]
  _BYTE v17[4]; // [sp+4E8h] [bp+4E0h] BYREF

  v14 = a4 + 4;
  v13 = 255;
  memset(s, 0, sizeof(s));
  s[0] = -1;
  v16 = 0;
  memset(&v11[1024], 0, 0x64u);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v11, 0x400u, "--- %s\n", "read_PIC16F1705_iic_slave");
    applog(2, v11, 0);
  }
  v16 = v14 + 38;
  for ( i = 0; i < (unsigned int)a4; ++i )
    v16 += *(unsigned __int8 *)(i + a3);
  LOBYTE(v13) = HIBYTE(v16);
  HIBYTE(v13) = v16;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      v11,
      0x400u,
      "--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n",
      "read_PIC16F1705_iic_slave",
      (unsigned __int8)v13,
      HIBYTE(v13));
    applog(2, v11, 0);
  }
  v11[1024] = 85;
  v11[1025] = -86;
  v11[1026] = v14;
  v11[1027] = 38;
  for ( i = 0; i < (unsigned int)a4; ++i )
    v17[i - 204] = *(_BYTE *)(i + a3);
  v17[a4 - 204] = v13;
  v17[a4 - 203] = HIBYTE(v13);
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i < v14 + 2; ++i )
    write_pic(a1, a2, v17[i - 208]);
  usleep(0x30D40u);
  for ( i = 0; i < *(unsigned __int8 *)(a3 + 2) + 3; ++i )
  {
    v4 = i;
    s[v4] = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( s[1] == 38 && s[2] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v11, 0x400u, "--- %s ok\n\n", "read_PIC16F1705_iic_slave");
      applog(2, v11, 0);
    }
    return 1;
  }
  else
  {
    for ( i = 0; i < *(unsigned __int8 *)(a3 + 2) + 3; ++i )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          v11,
          0x400u,
          "--- %s failed! read_back_data[%d] = 0x%02x\n\n",
          "read_PIC16F1705_iic_slave",
          i,
          (unsigned __int8)v17[i - 108]);
        applog(2, v11, 0);
      }
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00028B74) --------------------------------------------------------
int __fastcall write_data_to_PIC16F1704_flash(
        unsigned __int8 a1,
        unsigned __int8 a2,
        unsigned __int8 *a3,
        signed int a4)
{
  int v4; // r4
  char s[1024]; // [sp+24h] [bp+14h] BYREF
  int v12; // [sp+424h] [bp+414h]
  _DWORD v13[2]; // [sp+428h] [bp+418h] BYREF
  int v14; // [sp+430h] [bp+420h]
  char v15; // [sp+434h] [bp+424h]
  __int16 v16; // [sp+438h] [bp+428h]
  int v17; // [sp+43Ch] [bp+42Ch]
  char v18; // [sp+443h] [bp+433h]
  unsigned __int8 v19; // [sp+444h] [bp+434h]
  unsigned __int8 i; // [sp+445h] [bp+435h]
  __int16 v21; // [sp+446h] [bp+436h]
  _BYTE v22[4]; // [sp+448h] [bp+438h] BYREF

  v19 = 6;
  v16 = 255;
  v14 = 255;
  v15 = 0;
  v21 = 0;
  v12 = 0;
  v13[0] = 0;
  v13[1] = 0;
  v18 = 0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 3) )
  {
    snprintf(s, 0x400u, "\n--- %s\n", "write_data_to_PIC16F1704_flash");
    applog(4, s, 0);
  }
  v21 = a4 + a4 + v19 + 51;
  for ( i = 0; i < a4; ++i )
    v21 += a3[i];
  LOBYTE(v16) = HIBYTE(v21);
  HIBYTE(v16) = v21;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      s,
      0x400u,
      "--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n",
      "write_data_to_PIC16F1704_flash",
      (unsigned __int8)v16,
      HIBYTE(v16));
    applog(2, s, 0);
  }
  LOWORD(v12) = -21931;
  BYTE2(v12) = v19 + a4;
  HIBYTE(v12) = 51;
  LOBYTE(v13[0]) = 0;
  BYTE1(v13[0]) = a4;
  memcpy((char *)v13 + 2, a3, a4);
  v22[a4 - 30] = v16;
  v22[a4 - 29] = HIBYTE(v16);
  for ( i = 0; i < a4 + 8; ++i )
    printf("%02x ", (unsigned __int8)v22[i - 36]);
  putchar(10);
  v17 = a4 + v19 + 2;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i < v17; ++i )
    write_pic(a2, a1, v22[i - 36]);
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
  {
    v4 = i;
    *((_BYTE *)&v14 + v4) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
    printf("%02x ", (unsigned __int8)v22[i - 24]);
  putchar(10);
  if ( (unsigned __int8)v14 == 5 && BYTE1(v14) == 51 && BYTE2(v14) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "\n--- %s ok\n\n", "write_data_to_PIC16F1704_flash");
      applog(2, s, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(
        s,
        0x400u,
        "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n",
        "write_data_to_PIC16F1704_flash",
        (unsigned __int8)v14,
        BYTE1(v14),
        BYTE2(v14));
      applog(0, s, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843E: using guessed type char opt_debug;
// 4843F: using guessed type char opt_log_output;

//----- (00028F90) --------------------------------------------------------
int __fastcall read_data_from_PIC16F1704_flash(unsigned __int8 a1, unsigned __int8 a2, void *a3, unsigned __int8 a4)
{
  int v4; // r4
  char v11[1024]; // [sp+20h] [bp+10h] BYREF
  int v12; // [sp+420h] [bp+410h]
  int v13; // [sp+424h] [bp+414h]
  _BYTE s[40]; // [sp+428h] [bp+418h] BYREF
  __int16 v15; // [sp+450h] [bp+440h]
  unsigned __int8 v16; // [sp+454h] [bp+444h]
  unsigned __int8 i; // [sp+455h] [bp+445h]
  unsigned __int16 v18; // [sp+456h] [bp+446h]
  _BYTE v19[4]; // [sp+458h] [bp+448h] BYREF

  v16 = 6;
  v15 = 255;
  memset(s, 0, sizeof(s));
  s[0] = -1;
  v18 = 0;
  v12 = 0;
  v13 = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v11, 0x400u, "\n--- %s\n", "read_data_from_PIC16F1704_flash");
    applog(2, v11, 0);
  }
  v18 = a4 + v16 + 52;
  LOBYTE(v15) = HIBYTE(v18);
  HIBYTE(v15) = a4 + v16 + 52;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      v11,
      0x400u,
      "--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n",
      "read_data_from_PIC16F1704_flash",
      (unsigned __int8)v15,
      HIBYTE(v15));
    applog(2, v11, 0);
  }
  LOWORD(v12) = -21931;
  BYTE2(v12) = v16;
  HIBYTE(v12) = 52;
  LOBYTE(v13) = 0;
  BYTE1(v13) = a4;
  HIWORD(v13) = v15;
  for ( i = 0; i <= 7u; ++i )
    printf("%02x ", (unsigned __int8)v19[i - 56]);
  putchar(10);
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 7u; ++i )
    write_pic(a2, a1, v19[i - 56]);
  usleep(0x30D40u);
  for ( i = 0; i < a4 + 5; ++i )
  {
    v4 = i;
    s[v4] = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  for ( i = 0; i < a4 + 5; ++i )
    printf("%02x ", (unsigned __int8)v19[i - 48]);
  putchar(10);
  if ( s[1] == 52 && s[0] == a4 + 5 && s[2] == 1 )
  {
    v18 = 0;
    for ( i = 0; i < a4 + 3; ++i )
      v18 += (unsigned __int8)v19[i - 48];
    if ( HIBYTE(v18) == (unsigned __int8)v19[a4 - 45] && (unsigned __int8)v18 == (unsigned __int8)v19[a4 - 44] )
    {
      memcpy(a3, &s[3], a4);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v11, 0x400u, "\n--- %s ok\n\n", "read_data_from_PIC16F1704_flash");
        applog(2, v11, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(v11, 0x400u, "\n--- %s failed! crc = 0x%04x\n\n", "read_data_from_PIC16F1704_flash", v18);
        applog(0, v11, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(
        v11,
        0x400u,
        "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n",
        "read_data_from_PIC16F1704_flash",
        s[0],
        s[1],
        s[2]);
      applog(0, v11, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00029408) --------------------------------------------------------
int get_fan_speed()
{
  return read_axi_fpga(1);
}

//----- (00029418) --------------------------------------------------------
int __fastcall set_fan_speed(int a1)
{
  return write_axi_fpga(33, a1);
}

//----- (00029430) --------------------------------------------------------
int __fastcall fan_control(char a1)
{
  int result; // r0

  switch ( a1 )
  {
    case 0:
      result = set_fan_speed(100);
      break;
    case 1:
      result = set_fan_speed(655450);
      break;
    case 2:
      result = set_fan_speed(1310800);
      break;
    case 3:
      result = set_fan_speed(1966150);
      break;
    case 4:
      result = set_fan_speed(2621500);
      break;
    case 5:
      result = set_fan_speed(3276850);
      break;
    case 6:
      result = set_fan_speed(3932200);
      break;
    case 7:
      result = set_fan_speed(4587550);
      break;
    case 8:
      result = set_fan_speed(5242900);
      break;
    case 9:
      result = set_fan_speed(5898250);
      break;
    default:
      result = set_fan_speed(6553600);
      break;
  }
  return result;
}

//----- (000294F4) --------------------------------------------------------
int __fastcall uart_open(const char *a1, _DWORD *a2)
{
  char s[1024]; // [sp+14h] [bp+Ch] BYREF
  _DWORD *v4; // [sp+414h] [bp+40Ch]

  v4 = a2;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(s, 0x400u, "%s name=%s baudrate=%d\n", "uart_open", a1, *v4);
    applog(2, s, 0);
  }
  return 0;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0002957C) --------------------------------------------------------
int __fastcall uart_close(int a1)
{
  char s[1024]; // [sp+10h] [bp+8h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(s, 0x400u, "%s fd=%d\n", "uart_close", a1);
    applog(2, s, 0);
  }
  return 0;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000295F0) --------------------------------------------------------
unsigned int __fastcall check_how_many_uart_data_in_fpga(unsigned __int8 a1)
{
  unsigned int v1; // r3
  char s[1024]; // [sp+10h] [bp+8h] BYREF

  switch ( a1 )
  {
    case 0u:
      v1 = ((unsigned int)read_axi_fpga(1088) >> 16) & 0x3FF;
      break;
    case 1u:
      v1 = read_axi_fpga(1088) & 0x3FF;
      break;
    case 2u:
      v1 = ((unsigned int)read_axi_fpga(1089) >> 16) & 0x3FF;
      break;
    case 3u:
      v1 = read_axi_fpga(1089) & 0x3FF;
      break;
    case 4u:
      v1 = ((unsigned int)read_axi_fpga(1090) >> 16) & 0x3FF;
      break;
    case 5u:
      v1 = read_axi_fpga(1090) & 0x3FF;
      break;
    case 6u:
      v1 = ((unsigned int)read_axi_fpga(1091) >> 16) & 0x3FF;
      break;
    case 7u:
      v1 = read_axi_fpga(1091) & 0x3FF;
      break;
    case 8u:
      v1 = ((unsigned int)read_axi_fpga(1092) >> 16) & 0x3FF;
      break;
    case 9u:
      v1 = read_axi_fpga(1092) & 0x3FF;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "%s: The uart%d is not supported!!!\n", "check_how_many_uart_data_in_fpga", a1);
        applog(2, s, 0);
      }
      v1 = 0;
      break;
  }
  return v1;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00029744) --------------------------------------------------------
int __fastcall read_uart_data_in_fpga(unsigned __int8 a1, int a2, unsigned int a3)
{
  int v3; // r3
  char s[1024]; // [sp+1Ch] [bp+14h] BYREF
  int axi_fpga; // [sp+41Ch] [bp+414h]
  unsigned int v10; // [sp+420h] [bp+418h]
  unsigned int v11; // [sp+424h] [bp+41Ch]
  int v12; // [sp+428h] [bp+420h]
  unsigned int i; // [sp+42Ch] [bp+424h]
  int v14; // [sp+430h] [bp+428h]
  int v15; // [sp+434h] [bp+42Ch]

  v15 = 0;
  v14 = 0;
  v11 = 0;
  v10 = 0;
  i = 0;
  axi_fpga = 0;
  v12 = 0;
  switch ( a1 )
  {
    case 0u:
      v15 = 1100;
      v14 = 1101;
      goto LABEL_17;
    case 1u:
      v15 = 1102;
      v14 = 1103;
      goto LABEL_17;
    case 2u:
      v15 = 1104;
      v14 = 1105;
      goto LABEL_17;
    case 3u:
      v15 = 1106;
      v14 = 1107;
      goto LABEL_17;
    case 4u:
      v15 = 1108;
      v14 = 1109;
      goto LABEL_17;
    case 5u:
      v15 = 1110;
      v14 = 1111;
      goto LABEL_17;
    case 6u:
      v15 = 1112;
      v14 = 1113;
      goto LABEL_17;
    case 7u:
      v15 = 1114;
      v14 = 1115;
      goto LABEL_17;
    case 8u:
      v15 = 1116;
      v14 = 1117;
      goto LABEL_17;
    case 9u:
      v15 = 1118;
      v14 = 1119;
LABEL_17:
      v11 = a3 & 0x3FF | 0x80000000;
      write_axi_fpga(v15, v11);
      v10 = a3 >> 2;
      for ( i = 0; i < v10; ++i )
      {
        axi_fpga = read_axi_fpga(v14);
        *(_BYTE *)(4 * i + a2) = HIBYTE(axi_fpga);
        *(_BYTE *)(4 * i + 1 + a2) = BYTE2(axi_fpga);
        *(_BYTE *)(4 * i + 2 + a2) = BYTE1(axi_fpga);
        *(_BYTE *)(4 * i + 3 + a2) = axi_fpga;
      }
      v12 = 4 * v10;
      v10 = a3 & 3;
      if ( (a3 & 3) != 0 )
      {
        axi_fpga = read_axi_fpga(v14);
        switch ( v10 )
        {
          case 2u:
            *(_BYTE *)(4 * i + a2) = HIBYTE(axi_fpga);
            *(_BYTE *)(4 * i + 1 + a2) = BYTE2(axi_fpga);
            v12 += 2;
            break;
          case 3u:
            *(_BYTE *)(4 * i + a2) = HIBYTE(axi_fpga);
            *(_BYTE *)(4 * i + 1 + a2) = BYTE2(axi_fpga);
            *(_BYTE *)(4 * i + 2 + a2) = BYTE1(axi_fpga);
            v12 += 3;
            break;
          case 1u:
            *(_BYTE *)(4 * i + a2) = HIBYTE(axi_fpga);
            ++v12;
            break;
          default:
            if ( use_syslog || opt_log_output || opt_log_level > 1 )
            {
              snprintf(s, 0x400u, "%s: the uart%d left data is 4*N length, error!!!\n", "read_uart_data_in_fpga", a1);
              applog(2, s, 0);
            }
            break;
        }
      }
      v3 = v12;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "%s: The uart%d is not supported!!!\n", "read_uart_data_in_fpga", a1);
        applog(2, s, 0);
      }
      v3 = 0;
      break;
  }
  return v3;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00029AEC) --------------------------------------------------------
size_t __fastcall uart_send(unsigned __int8 a1, const void *a2, size_t a3)
{
  unsigned int axi_fpga; // r0
  char v9[1024]; // [sp+18h] [bp+10h] BYREF
  _BYTE s[512]; // [sp+418h] [bp+410h] BYREF
  size_t v11; // [sp+618h] [bp+610h]
  size_t v12; // [sp+61Ch] [bp+614h]
  signed int v13; // [sp+620h] [bp+618h]
  int v14; // [sp+624h] [bp+61Ch]
  int v15; // [sp+628h] [bp+620h]
  int v16; // [sp+62Ch] [bp+624h]
  int v17; // [sp+630h] [bp+628h]
  int v18; // [sp+634h] [bp+62Ch]
  signed int i; // [sp+638h] [bp+630h]
  int v20; // [sp+63Ch] [bp+634h]

  v20 = 0;
  v13 = 0;
  i = 0;
  memset(s, 0, sizeof(s));
  v12 = a3;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v11 = 0;
  v14 = 0;
  pthread_mutex_lock(&uart_send_mutex[a1]);
  switch ( a1 )
  {
    case 0u:
      v14 = 24;
      v17 = 1024;
      v16 = 1028;
      v15 = 1029;
      goto LABEL_17;
    case 1u:
      v14 = 16;
      v17 = 1024;
      v16 = 1030;
      v15 = 1031;
      goto LABEL_17;
    case 2u:
      v14 = 8;
      v17 = 1024;
      v16 = 1032;
      v15 = 1033;
      goto LABEL_17;
    case 3u:
      v14 = 0;
      v17 = 1024;
      v16 = 1034;
      v15 = 1035;
      goto LABEL_17;
    case 4u:
      v14 = 24;
      v17 = 1025;
      v16 = 1036;
      v15 = 1037;
      goto LABEL_17;
    case 5u:
      v14 = 16;
      v17 = 1025;
      v16 = 1038;
      v15 = 1039;
      goto LABEL_17;
    case 6u:
      v14 = 8;
      v17 = 1025;
      v16 = 1040;
      v15 = 1041;
      goto LABEL_17;
    case 7u:
      v14 = 0;
      v17 = 1025;
      v16 = 1042;
      v15 = 1043;
      goto LABEL_17;
    case 8u:
      v14 = 24;
      v17 = 1026;
      v16 = 1044;
      v15 = 1045;
      goto LABEL_17;
    case 9u:
      v14 = 16;
      v17 = 1026;
      v16 = 1046;
      v15 = 1047;
LABEL_17:
      v20 = 0;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v9, 0x400u, "%s: The uart%d is not supported!!!\n", "uart_send", a1);
        applog(2, v9, 0);
      }
      return 0;
  }
  while ( 1 )
  {
    axi_fpga = read_axi_fpga(v17);
    v11 = (unsigned __int8)(axi_fpga >> v14);
    if ( v11 >= a3 )
      break;
    usleep(0xBB8u);
    if ( ++v20 > 20 )
    {
      pthread_mutex_unlock(&uart_send_mutex[a1]);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v9, 0x400u, "%s: uart%d always dose not has enough send fifo space, break\n", "uart_send", a1);
        applog(2, v9, 0);
      }
      return 0;
    }
  }
  v20 = 0;
  while ( 1 )
  {
    if ( read_axi_fpga(v16) >= 0 )
    {
      memcpy(s, a2, a3);
      v13 = v12 >> 2;
      for ( i = 0; i < v13; ++i )
      {
        v18 = ((unsigned __int8)s[4 * i + 2] << 8)
            | ((unsigned __int8)s[4 * i] << 24)
            | ((unsigned __int8)s[4 * i + 1] << 16)
            | (unsigned __int8)s[4 * i + 3];
        write_axi_fpga(v15, v18);
      }
      v13 = v12 & 3;
      if ( (v12 & 3) != 0 )
      {
        switch ( v13 )
        {
          case 2:
            v18 = ((unsigned __int8)s[4 * i + 1] << 16) | ((unsigned __int8)s[4 * i] << 24);
            break;
          case 3:
            v18 = ((unsigned __int8)s[4 * i + 2] << 8)
                | ((unsigned __int8)s[4 * i] << 24)
                | ((unsigned __int8)s[4 * i + 1] << 16);
            break;
          case 1:
            v18 = (unsigned __int8)s[4 * i] << 24;
            break;
          default:
            if ( use_syslog || opt_log_output || opt_log_level > 1 )
            {
              snprintf(v9, 0x400u, "%s: the uart%d send left data is 4*N length, error!!!\n", "uart_send", a1);
              applog(2, v9, 0);
            }
            break;
        }
        write_axi_fpga(v15, v18);
      }
      write_axi_fpga(v16, v12 | 0x80000000);
      pthread_mutex_unlock(&uart_send_mutex[a1]);
      return v12;
    }
    if ( v20 > 20 )
      break;
    ++v20;
    usleep(0xBB8u);
  }
  pthread_mutex_unlock(&uart_send_mutex[a1]);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v9, 0x400u, "%s: uart%d always busy, break\n", "uart_send", a1);
    applog(2, v9, 0);
  }
  return 0;
}
// 47C84: using guessed type int opt_log_level;
// 48400: using guessed type pthread_mutex_t uart_send_mutex[1];
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0002A08C) --------------------------------------------------------
int __fastcall uart_receive(unsigned __int8 a1, int a2, unsigned int a3)
{
  unsigned int v7; // [sp+10h] [bp+10h]
  int uart_data_in_fpga; // [sp+14h] [bp+14h]

  pthread_mutex_lock(&uart_receive_mutex[a1]);
  v7 = check_how_many_uart_data_in_fpga(a1);
  if ( v7 < a3 )
  {
    if ( v7 )
      uart_data_in_fpga = read_uart_data_in_fpga(a1, a2, v7);
    else
      uart_data_in_fpga = 0;
  }
  else
  {
    uart_data_in_fpga = read_uart_data_in_fpga(a1, a2, a3);
  }
  pthread_mutex_unlock(&uart_receive_mutex[a1]);
  return uart_data_in_fpga;
}
// 48418: using guessed type pthread_mutex_t uart_receive_mutex[1];

//----- (0002A11C) --------------------------------------------------------
int __fastcall clear_uart_send_fifo(unsigned __int8 a1)
{
  unsigned int axi_fpga; // r0
  char s[1024]; // [sp+10h] [bp+8h] BYREF
  int v6; // [sp+410h] [bp+408h]
  int v7; // [sp+414h] [bp+40Ch]
  int v8; // [sp+418h] [bp+410h]
  unsigned int v9; // [sp+41Ch] [bp+414h]
  int v10; // [sp+420h] [bp+418h]
  int v11; // [sp+424h] [bp+41Ch]

  v11 = 0;
  v8 = 0;
  v7 = 0;
  v10 = 0;
  v9 = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(s, 0x400u, "--- %s\n", "clear_uart_send_fifo");
    applog(2, s, 0);
  }
  pthread_mutex_lock(&uart_send_mutex[a1]);
  switch ( a1 )
  {
    case 0u:
      v10 = 24;
      v11 = 1024;
      v8 = 1028;
      v6 = 1029;
      goto LABEL_21;
    case 1u:
      v10 = 16;
      v11 = 1024;
      v8 = 1030;
      v6 = 1031;
      goto LABEL_21;
    case 2u:
      v10 = 8;
      v11 = 1024;
      v8 = 1032;
      v6 = 1033;
      goto LABEL_21;
    case 3u:
      v10 = 0;
      v11 = 1024;
      v8 = 1034;
      v6 = 1035;
      goto LABEL_21;
    case 4u:
      v10 = 24;
      v11 = 1025;
      v8 = 1036;
      v6 = 1037;
      goto LABEL_21;
    case 5u:
      v10 = 16;
      v11 = 1025;
      v8 = 1038;
      v6 = 1039;
      goto LABEL_21;
    case 6u:
      v10 = 8;
      v11 = 1025;
      v8 = 1040;
      v6 = 1041;
      goto LABEL_21;
    case 7u:
      v10 = 0;
      v11 = 1025;
      v8 = 1042;
      v6 = 1043;
      goto LABEL_21;
    case 8u:
      v10 = 24;
      v11 = 1026;
      v8 = 1044;
      v6 = 1045;
      goto LABEL_21;
    case 9u:
      v10 = 16;
      v11 = 1026;
      v8 = 1046;
      v6 = 1047;
LABEL_21:
      v9 = 0;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "%s: The uart%d is not supported!!!\n", "clear_uart_send_fifo", a1);
        applog(2, s, 0);
      }
      pthread_mutex_unlock(&uart_send_mutex[a1]);
      return 1;
  }
  do
  {
    axi_fpga = read_axi_fpga(v11);
    v7 = (unsigned __int8)(axi_fpga >> v10);
    if ( v7 == 255 )
    {
      pthread_mutex_unlock(&uart_send_mutex[a1]);
      return 0;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "%s: waiting fpga uart%d clear send fifo space ...\n", "clear_uart_send_fifo", a1);
      applog(2, s, 0);
    }
    usleep(0xBB8u);
    ++v9;
  }
  while ( v9 <= 0x14 );
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(s, 0x400u, "%s: uart%d always dose not has enough send fifo space, break\n", "clear_uart_send_fifo", a1);
    applog(2, s, 0);
  }
  pthread_mutex_unlock(&uart_send_mutex[a1]);
  return v7;
}
// 47C84: using guessed type int opt_log_level;
// 48400: using guessed type pthread_mutex_t uart_send_mutex[1];
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0002A4E8) --------------------------------------------------------
int __fastcall clear_uart_rx_fifo(unsigned __int8 a1)
{
  char s[1024]; // [sp+1Ch] [bp+Ch] BYREF
  void *ptr; // [sp+41Ch] [bp+40Ch]
  size_t size; // [sp+420h] [bp+410h]
  int uart_data_in_fpga; // [sp+424h] [bp+414h]

  uart_data_in_fpga = 0;
  size = 0;
  ptr = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(s, 0x400u, "--- %s\n", "clear_uart_rx_fifo");
    applog(2, s, 0);
  }
  pthread_mutex_lock(&uart_receive_mutex[a1]);
  size = check_how_many_uart_data_in_fpga(a1);
  if ( size )
  {
    ptr = malloc(size);
    if ( ptr )
    {
      uart_data_in_fpga = read_uart_data_in_fpga(a1, (int)ptr, size);
      if ( uart_data_in_fpga != size && (use_syslog || opt_log_output || opt_log_level > 1) )
      {
        snprintf(
          s,
          0x400u,
          "%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n",
          "clear_uart_rx_fifo",
          a1,
          size,
          uart_data_in_fpga);
        applog(2, s, 0);
      }
      free(ptr);
      ptr = 0;
      usleep(0x2710u);
      pthread_mutex_unlock(&uart_receive_mutex[a1]);
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(s, 0x400u, "%s: uart%d malloc buffer error\n", "clear_uart_rx_fifo", a1);
        applog(2, s, 0);
      }
      ptr = 0;
      usleep((__useconds_t)&unk_7A120);
      pthread_mutex_unlock(&uart_receive_mutex[a1]);
      return 1;
    }
  }
  else
  {
    pthread_mutex_unlock(&uart_receive_mutex[a1]);
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 48418: using guessed type pthread_mutex_t uart_receive_mutex[1];
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0002A74C) --------------------------------------------------------
int cgpu_init()
{
  char s[1024]; // [sp+4h] [bp+4h] BYREF
  int v3; // [sp+404h] [bp+404h]

  v3 = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(s, 0x400u, "--- %s\n", "cgpu_init");
    applog(2, s, 0);
  }
  memset(&cgpu, 0, 0x5Cu);
  v3 = open_lcd();
  if ( v3 <= 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "!!! %s: open lcd driver error\n", "cgpu_init");
      applog(2, s, 0);
    }
    goto LABEL_31;
  }
  memset(lcd_output, 32, 0x40u);
  write(dword_F34A0, lcd_output, 0x40u);
  v3 = open_key();
  if ( v3 <= 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "!!! %s: open start key error\n", "cgpu_init");
      applog(2, s, 0);
    }
    goto LABEL_30;
  }
  v3 = open_red_led();
  if ( v3 <= 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "!!! %s: open red led error\n", "cgpu_init");
      applog(2, s, 0);
    }
    goto LABEL_29;
  }
  v3 = open_green_led();
  if ( v3 <= 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "!!! %s: open green led error\n", "cgpu_init");
      applog(2, s, 0);
    }
    goto LABEL_28;
  }
  v3 = bitmain_axi_init();
  if ( v3 < 0 )
  {
    bitmain_axi_close();
LABEL_28:
    close_green_led();
LABEL_29:
    close_red_led();
LABEL_30:
    close_key();
LABEL_31:
    close_lcd();
    return -1;
  }
  patten_info_init();
  patten_load();
  return 0;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34A0: using guessed type int dword_F34A0;

//----- (0002A9C0) --------------------------------------------------------
int cgpu_exit()
{
  bitmain_axi_close();
  close_green_led();
  close_red_led();
  close_key();
  close_lcd();
  return patten_info_destory();
}

//----- (0002A9E0) --------------------------------------------------------
ssize_t __fastcall v9_key_read(void *a1, size_t a2)
{
  lseek(dword_F34A8, 0, 0);
  return read(dword_F34A8, a1, a2);
}
// F34A8: using guessed type int dword_F34A8;

//----- (0002AA1C) --------------------------------------------------------
ssize_t display_arguments()
{
  size_t v0; // r0
  char s[64]; // [sp+4h] [bp+4h] BYREF
  _BYTE v3[4]; // [sp+44h] [bp+44h] BYREF
  char v4[400]; // [sp+48h] [bp+48h] BYREF
  int v5; // [sp+1D8h] [bp+1D8h]
  int v6; // [sp+1E0h] [bp+1E0h]
  int v7; // [sp+1E4h] [bp+1E4h]

  get_app_config(v3);
  memset(s, 0, sizeof(s));
  lseek(dword_F34A0, 0, 0);
  memset(s, 32, sizeof(s));
  v0 = strlen(v4);
  memcpy(s, v4, v0);
  sprintf(&s[16], "IC:%2d", v5);
  sprintf(&s[32], "FREQ: %d", v6);
  sprintf(&s[48], "Voltage: %d", v7);
  return write(dword_F34A0, s, 0x40u);
}
// F34A0: using guessed type int dword_F34A0;

//----- (0002AAE4) --------------------------------------------------------
int check_chain()
{
  char v2[1024]; // [sp+8h] [bp+0h] BYREF
  int axi_fpga; // [sp+408h] [bp+400h]
  unsigned __int8 i; // [sp+40Fh] [bp+407h]

  i = -1;
  axi_fpga = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v2, 0x400u, "--- %s\n", "check_chain");
    applog(2, v2, 0);
  }
  dword_F34C8 = 0;
  axi_fpga = read_axi_fpga(2);
  if ( axi_fpga == 1 || axi_fpga == 2 || axi_fpga == 4 || axi_fpga == 8 )
  {
    for ( i = 0; !i; ++i )
    {
      chain_info[0] = 0;
      chain_info[1] = 0;
      if ( (axi_fpga & 1) != 0 )
      {
        *((_DWORD *)&cgpu + i + 21) = 1;
        ++dword_F34C8;
        gChain_exist[i] = 1;
        *((_BYTE *)&gChain_fd + i) = i;
        gChain = i;
        gI2c = 0;
        chain_info[2 * i] = i;
        chain_info[2 * i + 1] = gI2c;
        g_chain[8 * i] = *((unsigned __int8 *)&gChain_fd + i);
        LOBYTE(g_chain[8 * i + 1]) = i;
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf(
            v2,
            0x400u,
            "%s: gChain = %d, gI2c = %d\n",
            "check_chain",
            (unsigned __int8)gChain,
            (unsigned __int8)gI2c);
          applog(2, v2, 0);
        }
      }
      else
      {
        *((_DWORD *)&cgpu + i + 21) = 0;
      }
    }
    return 0;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v2, 0x400u, "%s: Test zhiju only support 1 plug, but now is 0x%08x\n", "check_chain", axi_fpga);
      applog(2, v2, 0);
    }
    return -1;
  }
}
// 47B80: using guessed type char gChain;
// 47C84: using guessed type int opt_log_level;
// 48430: using guessed type _BYTE gChain_exist[4];
// 48435: using guessed type char gI2c;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];
// F34C8: using guessed type int dword_F34C8;
// F34D8: using guessed type _BYTE chain_info[4];

//----- (0002AD98) --------------------------------------------------------
unsigned int V9_print_lcd()
{
  _DWORD s[4]; // [sp+Ch] [bp+4h] BYREF
  char v2; // [sp+1Ch] [bp+14h]

  if ( set_address_test_result <= 0 )
    write_lcd_no_memset(0, (int)"Address NG      ", 0x10u);
  else
    write_lcd_no_memset(0, (int)"Address OK      ", 0x10u);
  memset(s, 0, sizeof(s));
  v2 = 0;
  sprintf(
    (char *)s,
    "Pattern %c %c %c   ",
    (unsigned __int8)nonce_test_asic_result[0],
    (unsigned __int8)byte_483E5,
    (unsigned __int8)byte_483E6);
  write_lcd_no_memset(1u, (int)s, 0x10u);
  if ( read_temp_test_result <= 0 )
    write_lcd_no_memset(2u, (int)"Sensor NG       ", 0x10u);
  else
    write_lcd_no_memset(2u, (int)"Sensor OK       ", 0x10u);
  if ( tempture_value_test_result <= 0 )
    return write_lcd_no_memset(3u, (int)"Temperature NG  ", 0x10u);
  else
    return write_lcd_no_memset(3u, (int)"Temperature OK  ", 0x10u);
}
// 483D4: using guessed type int set_address_test_result;
// 483D8: using guessed type int read_temp_test_result;
// 483DC: using guessed type int tempture_value_test_result;
// 483E5: using guessed type char byte_483E5;
// 483E6: using guessed type char byte_483E6;

//----- (0002AE84) --------------------------------------------------------
unsigned int __fastcall V9_print_lcd_type(int a1)
{
  if ( a1 != 1 )
    return V9_print_lcd();
  write_lcd_no_memset(0, (int)" hardware error ", 0x10u);
  write_lcd_no_memset(1u, (int)"     check      ", 0x10u);
  write_lcd_no_memset(2u, (int)" u2 u44 u16 u23 ", 0x10u);
  return write_lcd_no_memset(3u, (int)" u30            ", 0x10u);
}

//----- (0002AEE0) --------------------------------------------------------
int __fastcall is_asic_pass(int a1)
{
  return nonce_num_each_asic[a1];
}
// 47DFC: using guessed type int nonce_num_each_asic[];

//----- (0002AF04) --------------------------------------------------------
int show_stats_func_z11_3chips()
{
  int v1; // [sp+8h] [bp+0h] BYREF
  int v2; // [sp+Ch] [bp+4h]
  int v3; // [sp+10h] [bp+8h]
  int v4; // [sp+14h] [bp+Ch]
  size_t v5; // [sp+18h] [bp+10h]
  int v6; // [sp+1Ch] [bp+14h]

  v6 = 0;
  while ( show_id_alive )
  {
    usleep(0xF4240u);
    memset(lcd_output, 32, 0x40u);
    sprintf(lcd_output, "time %ds", v6);
    v1 = 0;
    v2 = 0;
    v3 = 0;
    v4 = 0;
    sprintf(
      (char *)&v1,
      "nonce=%d %d %d",
      *(_DWORD *)dword_F37BC,
      *(_DWORD *)(dword_F37BC + 4),
      *(_DWORD *)(dword_F37BC + 8));
    v5 = strlen((const char *)&v1);
    memset((char *)&v1 + v5, 32, 16 - v5);
    *(_DWORD *)dword_47B4C = v1;
    dword_47B50 = v2;
    dword_47B54 = v3;
    dword_47B58 = v4;
    sprintf(
      s,
      "%d-%d'C %d-%d'C",
      (unsigned __int8)byte_48F51,
      (unsigned __int8)sensor_info,
      (unsigned __int8)byte_48F55,
      (unsigned __int8)byte_48F54);
    ++v6;
    write(dword_F34A0, lcd_output, 0x40u);
  }
  return 0;
}
// 47B50: using guessed type int dword_47B50;
// 47B54: using guessed type int dword_47B54;
// 47B58: using guessed type int dword_47B58;
// 48438: using guessed type int show_id_alive;
// 48F50: using guessed type char sensor_info;
// 48F51: using guessed type char byte_48F51;
// 48F54: using guessed type char byte_48F54;
// 48F55: using guessed type char byte_48F55;
// F34A0: using guessed type int dword_F34A0;
// F37BC: using guessed type int dword_F37BC;

//----- (0002B044) --------------------------------------------------------
int show_stats_func_z9_4chips()
{
  int v1; // [sp+Ch] [bp+4h]

  v1 = 0;
  while ( show_id_alive )
  {
    usleep(0xF4240u);
    memset(lcd_output, 32, 0x40u);
    sprintf(lcd_output, "time %ds", v1);
    sprintf(dword_47B4C, "nonce=%d %d", one_work_nonce_each_asic, dword_47E30);
    sprintf(byte_47B5C, "      %d %d", dword_47E34, one_work_invalid_nonce_each_asic);
    sprintf(
      s,
      "%d-%d'C %d-%d'C",
      (unsigned __int8)byte_48F51,
      (unsigned __int8)sensor_info,
      (unsigned __int8)byte_48F55,
      (unsigned __int8)byte_48F54);
    ++v1;
    write(dword_F34A0, lcd_output, 0x40u);
  }
  return 0;
}
// 47E2C: using guessed type int one_work_nonce_each_asic;
// 47E30: using guessed type int dword_47E30;
// 47E34: using guessed type int dword_47E34;
// 47E38: using guessed type int one_work_invalid_nonce_each_asic;
// 48438: using guessed type int show_id_alive;
// 48F50: using guessed type char sensor_info;
// 48F51: using guessed type char byte_48F51;
// 48F54: using guessed type char byte_48F54;
// 48F55: using guessed type char byte_48F55;
// F34A0: using guessed type int dword_F34A0;

//----- (0002B150) --------------------------------------------------------
int show_stats_func_z9_16chips()
{
  _BOOL4 v0; // r8
  _BOOL4 v1; // r9
  _BOOL4 v2; // r4
  _BOOL4 v3; // r5
  _BOOL4 v4; // r6
  bool v5; // r3
  _BOOL4 v6; // r8
  _BOOL4 v7; // r9
  _BOOL4 v8; // r4
  _BOOL4 v9; // r5
  _BOOL4 v10; // r6
  bool v11; // r3
  _BOOL4 v13; // [sp+18h] [bp+0h]
  _BOOL4 v14; // [sp+18h] [bp+0h]
  _BOOL4 v15; // [sp+1Ch] [bp+4h]
  _BOOL4 v16; // [sp+1Ch] [bp+4h]
  int v17; // [sp+24h] [bp+Ch]

  v17 = 0;
  while ( show_id_alive )
  {
    usleep(0xF4240u);
    memset(lcd_output, 32, 0x40u);
    sprintf(lcd_output, "time %ds", v17);
    v0 = is_asic_pass(0) != 0;
    v1 = is_asic_pass(1) != 0;
    v2 = is_asic_pass(2) != 0;
    v3 = is_asic_pass(3) != 0;
    v4 = is_asic_pass(4) != 0;
    v15 = is_asic_pass(5) != 0;
    v13 = is_asic_pass(6) != 0;
    v5 = is_asic_pass(7) != 0;
    sprintf(dword_47B4C, "nonce=%d%d%d%d %d%d%d%d", v0, v1, v2, v3, v4, v15, v13, v5);
    v6 = is_asic_pass(8) != 0;
    v7 = is_asic_pass(9) != 0;
    v8 = is_asic_pass(10) != 0;
    v9 = is_asic_pass(11) != 0;
    v10 = is_asic_pass(12) != 0;
    v16 = is_asic_pass(13) != 0;
    v14 = is_asic_pass(14) != 0;
    v11 = is_asic_pass(15) != 0;
    sprintf(byte_47B5C, "      %d%d%d%d %d%d%d%d", v6, v7, v8, v9, v10, v16, v14, v11);
    sprintf(
      s,
      "%d-%d'C %d-%d'C",
      (unsigned __int8)byte_48F51,
      (unsigned __int8)sensor_info[0],
      (unsigned __int8)byte_48F55,
      (unsigned __int8)byte_48F54);
    ++v17;
    write(dword_F34A0, lcd_output, 0x40u);
  }
  return 0;
}
// 48438: using guessed type int show_id_alive;
// 48F51: using guessed type char byte_48F51;
// 48F54: using guessed type char byte_48F54;
// 48F55: using guessed type char byte_48F55;
// F34A0: using guessed type int dword_F34A0;

//----- (0002B39C) --------------------------------------------------------
int singleBoardTest_V9_BM1744_manual()
{
  char s[1024]; // [sp+Ch] [bp+4h] BYREF
  _BYTE v3[620]; // [sp+40Ch] [bp+404h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(s, 0x400u, "%s[%d]\n", "singleBoardTest_V9_BM1744_manual", 345);
    applog(2, s, 0);
  }
  get_app_config(v3);
  memset(sensor_info, 0, 8u);
  memset(nonce_num_each_asic, 0, 0xCu);
  init_fpga();
  set_fpga_baud(0x1Au);
  check_chain();
  if ( (unsigned __int8)gChain == 255 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy(s, "--- Chain Check Fail\n");
      applog(2, s, 0);
    }
    return -1;
  }
  else
  {
    reset_PIC16F1704_pic(gChain, gI2c);
    jump_from_loader_to_app_PIC16F1704(gChain, gI2c);
    pthread_create(&newthread, 0, (void *(*)(void *))pic_heart_beat_func, &chain_info[2 * (unsigned __int8)gChain]);
    write_axi_fpga(13, 0xFFFF);
    usleep((__useconds_t)&unk_493E0);
    enable_PIC16F1704_dc_dc(gChain, gI2c, 1u);
    usleep((__useconds_t)&unk_493E0);
    write_axi_fpga(13, 0);
    usleep((__useconds_t)&unk_493E0);
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(s, 0x400u, "%s[%d]\n", "singleBoardTest_V9_BM1744_manual", 375);
      applog(2, s, 0);
    }
    pcba_app_manual_test();
    write_axi_fpga(13, 0xFFFF);
    usleep((__useconds_t)&unk_493E0);
    write_axi_fpga(13, 0);
    usleep((__useconds_t)&unk_493E0);
    enable_PIC16F1704_dc_dc(gChain, gI2c, 0);
    pthread_mutex_lock(&i2c_mutex);
    pthread_cancel(newthread);
    pthread_join(newthread, 0);
    pthread_mutex_unlock(&i2c_mutex);
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy(s, "Test finished\n");
      applog(2, s, 0);
    }
    return 1;
  }
}
// 47B80: using guessed type char gChain;
// 47C84: using guessed type int opt_log_level;
// 47DFC: using guessed type int nonce_num_each_asic[];
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 48435: using guessed type char gI2c;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34D8: using guessed type _BYTE chain_info[4];

//----- (0002B688) --------------------------------------------------------
int singleBoardTest_V9_BM1744()
{
  char v2[1024]; // [sp+4h] [bp+4h] BYREF
  int v3; // [sp+404h] [bp+404h]

  v3 = 0;
  memset(&sensor_info, 0, 8u);
  memset(one_work_nonce_each_asic, 0, 0xCu);
  memset(one_work_invalid_nonce_each_asic_2, 0, sizeof(one_work_invalid_nonce_each_asic_2));
  show_id_alive = 1;
  pthread_create(&dword_F3484, 0, (void *(*)(void *))show_stats_func_z11_3chips, 0);
  init_fpga();
  set_fpga_baud(0x1Au);
  check_chain();
  if ( (unsigned __int8)gChain == 255 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy(v2, "--- Chain Check Fail\n");
      applog(2, v2, 0);
    }
    return -1;
  }
  else
  {
    reset_PIC16F1704_pic(gChain, gI2c);
    jump_from_loader_to_app_PIC16F1704(gChain, gI2c);
    pthread_create(&newthread, 0, (void *(*)(void *))pic_heart_beat_func, &chain_info[2 * (unsigned __int8)gChain]);
    write_axi_fpga(13, 0xFFFF);
    usleep((__useconds_t)&unk_493E0);
    enable_PIC16F1704_dc_dc(gChain, gI2c, 1u);
    usleep((__useconds_t)&unk_493E0);
    write_axi_fpga(13, 0);
    if ( isl_communication_check(dword_F367C) <= 0 )
    {
      v3 = 1;
    }
    else
    {
      if ( dword_F3680 == 1 )
        vol_init(dword_F367C);
      usleep((__useconds_t)&unk_493E0);
      start_single_board_test();
      v3 = 0;
    }
    show_id_alive = 0;
    sleep(1u);
    pthread_cancel(dword_F3484);
    pthread_join(dword_F3484, 0);
    V9_print_lcd_type(v3);
    write_axi_fpga(13, 0xFFFF);
    usleep((__useconds_t)&unk_493E0);
    write_axi_fpga(13, 0);
    usleep((__useconds_t)&unk_493E0);
    enable_PIC16F1704_dc_dc(gChain, gI2c, 0);
    pthread_mutex_lock(&i2c_mutex);
    pthread_cancel(newthread);
    pthread_join(newthread, 0);
    pthread_mutex_unlock(&i2c_mutex);
    clear_last_test_results();
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy(v2, "Test finished\n");
      applog(2, v2, 0);
    }
    return 1;
  }
}
// 263EC: using guessed type void __noreturn pic_heart_beat_func();
// 47B80: using guessed type char gChain;
// 47C84: using guessed type int opt_log_level;
// 47E2C: using guessed type int one_work_nonce_each_asic[];
// 47E44: using guessed type _DWORD one_work_invalid_nonce_each_asic_2[6];
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 48435: using guessed type char gI2c;
// 48438: using guessed type int show_id_alive;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 48F50: using guessed type char sensor_info;
// F34D8: using guessed type _BYTE chain_info[4];
// F367C: using guessed type int dword_F367C;
// F3680: using guessed type int dword_F3680;

//----- (0002B984) --------------------------------------------------------
void *__fastcall get_app_config(void *a1)
{
  return memcpy(a1, &app_conf, 0x26Cu);
}
// F34DC: using guessed type int app_conf;

//----- (0002B9A8) --------------------------------------------------------
int __fastcall app_config_handle(const char *a1)
{
  int result; // r0
  char v3[1024]; // [sp+Ch] [bp+Ch] BYREF
  char s[1024]; // [sp+40Ch] [bp+40Ch] BYREF
  FILE *stream; // [sp+80Ch] [bp+80Ch]
  char *v6; // [sp+810h] [bp+810h]
  int *v7; // [sp+814h] [bp+814h]

  v7 = &app_conf;
  memset(s, 0, sizeof(s));
  v6 = 0;
  stream = fopen(a1, "r");
  if ( !stream && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    snprintf(v3, 0x400u, "open %s failed\n", a1);
    applog(2, v3, 0);
  }
  while ( fgets(s, 1023, stream) )
  {
    if ( s[0] != 35 && s[1] != 35 )
    {
      v6 = strstr(s, "Name=");
      if ( v6 )
      {
        v6 += 5;
        _isoc99_sscanf(v6, "%s", v7 + 1);
      }
      else
      {
        v6 = strstr(s, "type=");
        if ( v6 )
        {
          v6 += 5;
          _isoc99_sscanf(v6, "%s", v7 + 6);
        }
        else
        {
          v6 = strstr(s, "comport=");
          if ( v6 )
          {
            v6 += 8;
            _isoc99_sscanf(v6, "%d", v7 + 5);
          }
          else
          {
            v6 = strstr(s, "baudrate=");
            if ( v6 )
            {
              v6 += 9;
              _isoc99_sscanf(v6, "%d", v7 + 10);
            }
            else
            {
              v6 = strstr(s, "miner_mode=");
              if ( v6 )
              {
                v6 += 11;
                _isoc99_sscanf(v6, "%d", v7 + 11);
              }
              else
              {
                v6 = strstr(s, "reg_ticket_mask=");
                if ( v6 )
                {
                  v6 += 16;
                  _isoc99_sscanf(v6, "%d", v7 + 90);
                }
                else
                {
                  v6 = strstr(s, "reg_core_timeout=");
                  if ( v6 )
                  {
                    v6 += 17;
                    _isoc99_sscanf(v6, "%x", v7 + 91);
                  }
                  else
                  {
                    v6 = strstr(s, "reg_misc=");
                    if ( v6 )
                    {
                      v6 += 9;
                      _isoc99_sscanf(v6, "%x", v7 + 92);
                    }
                    else
                    {
                      v6 = strstr(s, "workstr=");
                      if ( v6 )
                      {
                        v6 += 8;
                        _isoc99_sscanf(v6, "%s", v7 + 20);
                      }
                      else
                      {
                        v6 = strstr(s, "single_pattern_send_timeout=");
                        if ( v6 )
                        {
                          v6 += 28;
                          _isoc99_sscanf(v6, "%d", v7 + 93);
                        }
                        else
                        {
                          v6 = strstr(s, "single_chip_return_nonce=");
                          if ( v6 )
                          {
                            v6 += 25;
                            _isoc99_sscanf(v6, "%d", v7 + 94);
                          }
                          else
                          {
                            v6 = strstr(s, "single_chip_hw=");
                            if ( v6 )
                            {
                              v6 += 15;
                              _isoc99_sscanf(v6, "%d", v7 + 95);
                            }
                            else
                            {
                              v6 = strstr(s, "TunelPath=");
                              if ( v6 )
                              {
                                v6 += 10;
                                _isoc99_sscanf(v6, "%s", v7 + 109);
                              }
                              else
                              {
                                v6 = strstr(s, "CP210xRuntime=");
                                if ( v6 )
                                {
                                  v6 += 14;
                                  _isoc99_sscanf(v6, "%s", v7 + 125);
                                }
                                else
                                {
                                  v6 = strstr(s, "pattern_number=");
                                  if ( v6 )
                                  {
                                    v6 += 15;
                                    _isoc99_sscanf(v6, "%d", v7 + 96);
                                  }
                                  else
                                  {
                                    v6 = strstr(s, "repeat_ctrl=");
                                    if ( v6 )
                                    {
                                      v6 += 12;
                                      _isoc99_sscanf(v6, "%s", v7 + 97);
                                    }
                                    else
                                    {
                                      v6 = strstr(s, "AsicNum=");
                                      if ( v6 )
                                      {
                                        v6 += 8;
                                        _isoc99_sscanf(v6, "%d", v7 + 101);
                                      }
                                      else
                                      {
                                        v6 = strstr(s, "CoreNum=");
                                        if ( v6 )
                                        {
                                          v6 += 8;
                                          _isoc99_sscanf(v6, "%d", v7 + 102);
                                        }
                                        else
                                        {
                                          v6 = strstr(s, "Freq=");
                                          if ( v6 )
                                          {
                                            v6 += 5;
                                            _isoc99_sscanf(v6, "%d", v7 + 103);
                                          }
                                          else
                                          {
                                            v6 = strstr(s, "Voltage=");
                                            if ( v6 )
                                            {
                                              v6 += 8;
                                              _isoc99_sscanf(v6, "%d", v7 + 104);
                                            }
                                            else
                                            {
                                              v6 = strstr(s, "slt_method=");
                                              if ( v6 )
                                              {
                                                v6 += 11;
                                                _isoc99_sscanf(v6, "%d", v7 + 141);
                                              }
                                              else
                                              {
                                                v6 = strstr(s, "bin1_freq=");
                                                if ( v6 )
                                                {
                                                  v6 += 10;
                                                  _isoc99_sscanf(v6, "%d", v7 + 142);
                                                }
                                                else
                                                {
                                                  v6 = strstr(s, "bin2_freq=");
                                                  if ( v6 )
                                                  {
                                                    v6 += 10;
                                                    _isoc99_sscanf(v6, "%d", v7 + 143);
                                                  }
                                                  else
                                                  {
                                                    v6 = strstr(s, "bin3_freq=");
                                                    if ( v6 )
                                                    {
                                                      v6 += 10;
                                                      _isoc99_sscanf(v6, "%d", v7 + 144);
                                                    }
                                                    else
                                                    {
                                                      v6 = strstr(s, "bin1_require_nonce=");
                                                      if ( v6 )
                                                      {
                                                        v6 += 19;
                                                        _isoc99_sscanf(v6, "%d", v7 + 145);
                                                      }
                                                      else
                                                      {
                                                        v6 = strstr(s, "bin2_require_nonce=");
                                                        if ( v6 )
                                                        {
                                                          v6 += 19;
                                                          _isoc99_sscanf(v6, "%d", v7 + 146);
                                                        }
                                                        else
                                                        {
                                                          v6 = strstr(s, "bin3_require_nonce=");
                                                          if ( v6 )
                                                          {
                                                            v6 += 19;
                                                            _isoc99_sscanf(v6, "%d", v7 + 147);
                                                          }
                                                          else
                                                          {
                                                            v6 = strstr(s, "bin1_max_hw=");
                                                            if ( v6 )
                                                            {
                                                              v6 += 12;
                                                              _isoc99_sscanf(v6, "%d", v7 + 148);
                                                            }
                                                            else
                                                            {
                                                              v6 = strstr(s, "bin2_max_hw=");
                                                              if ( v6 )
                                                              {
                                                                v6 += 12;
                                                                _isoc99_sscanf(v6, "%d", v7 + 149);
                                                              }
                                                              else
                                                              {
                                                                v6 = strstr(s, "bin3_max_hw=");
                                                                if ( v6 )
                                                                {
                                                                  v6 += 12;
                                                                  _isoc99_sscanf(v6, "%d", v7 + 150);
                                                                }
                                                                else
                                                                {
                                                                  v6 = strstr(s, "bin1_rate=");
                                                                  if ( v6 )
                                                                  {
                                                                    v6 += 10;
                                                                    _isoc99_sscanf(v6, "%f", v7 + 151);
                                                                  }
                                                                  else
                                                                  {
                                                                    v6 = strstr(s, "bin2_rate=");
                                                                    if ( v6 )
                                                                    {
                                                                      v6 += 10;
                                                                      _isoc99_sscanf(v6, "%f", v7 + 152);
                                                                    }
                                                                    else
                                                                    {
                                                                      v6 = strstr(s, "bin3_rate=");
                                                                      if ( v6 )
                                                                      {
                                                                        v6 += 10;
                                                                        _isoc99_sscanf(v6, "%f", v7 + 153);
                                                                      }
                                                                      else
                                                                      {
                                                                        v6 = strstr(s, "tempture_high=");
                                                                        if ( v6 )
                                                                        {
                                                                          v6 += 14;
                                                                          _isoc99_sscanf(v6, "%d", v7 + 106);
                                                                        }
                                                                        else
                                                                        {
                                                                          v6 = strstr(s, "tempture_low=");
                                                                          if ( v6 )
                                                                          {
                                                                            v6 += 13;
                                                                            _isoc99_sscanf(v6, "%d", v7 + 107);
                                                                          }
                                                                          else
                                                                          {
                                                                            v6 = strstr(s, "slt_delay=");
                                                                            if ( v6 )
                                                                            {
                                                                              v6 += 10;
                                                                              _isoc99_sscanf(v6, "%d", v7 + 154);
                                                                            }
                                                                            else
                                                                            {
                                                                              v6 = strstr(s, "enable_adjust_vol=");
                                                                              if ( v6 )
                                                                              {
                                                                                v6 += 18;
                                                                                _isoc99_sscanf(v6, "%d", v7 + 105);
                                                                              }
                                                                              else
                                                                              {
                                                                                v6 = strstr(s, "timeout=");
                                                                                if ( v6 )
                                                                                {
                                                                                  v6 += 8;
                                                                                  _isoc99_sscanf(v6, "%d", v7 + 108);
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  result = fclose(stream);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v3, 0x400u, "%s done=========\n ", "app_config_handle");
    return applog(2, v3, 0);
  }
  return result;
}
// 11004: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34DC: using guessed type int app_conf;

//----- (0002C500) --------------------------------------------------------
int __fastcall crc_itu_t_byte(__int16 a1, char a2)
{
  return crc_itu_t_table[(unsigned __int8)(a2 ^ HIBYTE(a1))] ^ (unsigned __int16)(a1 << 8);
}
// 368F8: using guessed type _WORD crc_itu_t_table[256];

//----- (0002C544) --------------------------------------------------------
int __fastcall CRC16_v1(char *a1, int a2)
{
  char *v2; // r3
  unsigned __int16 i; // [sp+Eh] [bp+Eh]

  for ( i = -1; a2--; i = crc_itu_t_byte(i, *v2) )
    v2 = a1++;
  return i;
}

//----- (0002C580) --------------------------------------------------------
int __fastcall CRC5_v1(_BYTE *a1, unsigned __int8 a2)
{
  _BYTE v4[5]; // [sp+Ch] [bp+Ch]
  int v5; // [sp+14h] [bp+14h]
  char v6; // [sp+18h] [bp+18h]
  bool v7; // [sp+1Bh] [bp+1Bh]
  unsigned __int8 v8; // [sp+1Ch] [bp+1Ch]
  char v9; // [sp+1Dh] [bp+1Dh]
  unsigned __int8 v10; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v5 = 16843009;
  v6 = 1;
  v10 = 0x80;
  v9 = 0;
  for ( i = 0; i < (unsigned int)a2; ++i )
  {
    v7 = (v10 & *a1) != 0;
    v4[0] = v7 ^ v6;
    v4[1] = v5;
    v4[2] = v7 ^ v6 ^ BYTE1(v5);
    *(_WORD *)&v4[3] = HIWORD(v5);
    v10 >>= 1;
    if ( ++v9 == 8 )
    {
      v10 = 0x80;
      v9 = 0;
      ++a1;
    }
    v5 = *(_DWORD *)v4;
    v6 = v4[4];
  }
  v8 = 0;
  if ( v6 )
    v8 = 16;
  if ( HIBYTE(v5) )
    v8 |= 8u;
  if ( BYTE2(v5) )
    v8 |= 4u;
  if ( BYTE1(v5) )
    v8 |= 2u;
  if ( (_BYTE)v5 )
    v8 |= 1u;
  return v8;
}

//----- (0002C6A0) --------------------------------------------------------
int power_init()
{
  return 0;
}

//----- (0002C6B0) --------------------------------------------------------
void power_exit()
{
  ;
}

//----- (0002C6C0) --------------------------------------------------------
int power_up()
{
  return 0;
}

//----- (0002C6D0) --------------------------------------------------------
int power_down()
{
  return 0;
}

//----- (0002C6E0) --------------------------------------------------------
int __fastcall my_log_curses(int result, const char *a2, const char *a3, char a4)
{
  if ( !opt_quiet || !result )
  {
    if ( a4 )
    {
      pthread_mutex_trylock(&console_lock);
      pthread_mutex_unlock(&console_lock);
    }
    pthread_mutex_lock(&console_lock);
    fprintf((FILE *)_bss_start, "%s%s", a2, a3);
    fflush((FILE *)_bss_start);
    return pthread_mutex_unlock(&console_lock);
  }
  return result;
}
// 47DA8: using guessed type int _bss_start;
// 4843D: using guessed type char opt_quiet;
// 48440: using guessed type pthread_mutex_t console_lock;

//----- (0002C76C) --------------------------------------------------------
int __fastcall applog(int a1, const char *a2, char a3)
{
  int result; // r0
  int v4; // r0
  char s[64]; // [sp+2Ch] [bp+14h] BYREF
  time_t timer; // [sp+6Ch] [bp+54h] BYREF
  timeval tv; // [sp+70h] [bp+58h] BYREF
  struct tm *v11; // [sp+78h] [bp+60h]
  int v12; // [sp+7Ch] [bp+64h]

  tv.tv_sec = 0;
  tv.tv_usec = 0;
  gettimeofday(&tv, 0);
  timer = tv.tv_sec;
  v12 = tv.tv_usec / 1000;
  v11 = localtime(&timer);
  result = snprintf(
             s,
             0x40u,
             " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
             v11->tm_year + 1900,
             v11->tm_mon + 1,
             v11->tm_mday,
             v11->tm_hour,
             v11->tm_min,
             v11->tm_sec,
             v12);
  if ( app_conf )
  {
    v4 = fileno((FILE *)app_conf);
    result = isatty(v4);
    if ( !result )
    {
      fprintf((FILE *)app_conf, "%s%s", s, a2);
      result = fflush((FILE *)app_conf);
    }
  }
  if ( dword_F3508 != 1 )
    return my_log_curses(a1, s, a2, a3);
  return result;
}
// F34DC: using guessed type int app_conf;
// F3508: using guessed type int dword_F3508;

//----- (0002C874) --------------------------------------------------------
int __fastcall simplelog(int a1, const char *a2, char a3)
{
  int v3; // r0

  v3 = fileno((FILE *)_bss_start);
  if ( !isatty(v3) )
  {
    fprintf((FILE *)_bss_start, "%s\n", a2);
    fflush((FILE *)_bss_start);
  }
  return my_log_curses(a1, byte_36B34, a2, a3);
}
// 47DA8: using guessed type int _bss_start;

//----- (0002C8E4) --------------------------------------------------------
int patten_info_init()
{
  memset(&g_patten, 0, 0x9Cu);
  g_patten = dword_F3670;
  dword_F374C = dword_F3674;
  dword_F375C = dword_F365C;
  strcpy((char *)&dword_F3760, "patten");
  strcpy(byte_F3770, "zec-z11");
  strcpy((char *)&dword_F3780, "asic");
  strcpy((char *)&dword_F3790, "core");
  dword_F3750 = 140;
  dword_F3754 = 4;
  dword_F3758 = 1344;
  dword_F37C0 = dword_F365C * dword_F3674 * dword_F3670;
  dword_F37A0 = (int)malloc(1488 * dword_F365C * dword_F3674 * dword_F3670);
  if ( !dword_F37A0 )
  {
    printf("%s[%d] malloc failed\n", "patten_info_init", 29);
    exit(1);
  }
  memset((void *)dword_F37A0, 0, 1488 * dword_F375C * dword_F374C * g_patten);
  dword_F37B4 = (int)malloc(dword_F375C * dword_F374C * g_patten);
  if ( !dword_F37B4 )
  {
    printf("%s[%d] malloc failed\n", "patten_info_init", 35);
    exit(1);
  }
  memset((void *)dword_F37B4, 0, dword_F375C * dword_F374C * g_patten);
  dword_F37BC = (int)malloc(4 * g_patten);
  if ( !dword_F37BC )
  {
    printf("%s[%d] malloc failed\n", "patten_info_init", 41);
    exit(1);
  }
  memset((void *)dword_F37BC, 0, 4 * g_patten);
  return pthread_mutex_init(&mutex, 0);
}
// F365C: using guessed type int dword_F365C;
// F3670: using guessed type int dword_F3670;
// F3674: using guessed type int dword_F3674;
// F3748: using guessed type int g_patten;
// F374C: using guessed type int dword_F374C;
// F3750: using guessed type int dword_F3750;
// F3754: using guessed type int dword_F3754;
// F3758: using guessed type int dword_F3758;
// F375C: using guessed type int dword_F375C;
// F3760: using guessed type int dword_F3760;
// F3780: using guessed type int dword_F3780;
// F3790: using guessed type int dword_F3790;
// F37A0: using guessed type int dword_F37A0;
// F37B4: using guessed type int dword_F37B4;
// F37BC: using guessed type int dword_F37BC;
// F37C0: using guessed type int dword_F37C0;

//----- (0002CBDC) --------------------------------------------------------
int patten_info_destory()
{
  if ( dword_F37A0 )
    free((void *)dword_F37A0);
  if ( dword_F37B4 )
    free((void *)dword_F37B4);
  if ( dword_F37BC )
    free((void *)dword_F37BC);
  return pthread_mutex_destroy(&mutex);
}
// F37A0: using guessed type int dword_F37A0;
// F37B4: using guessed type int dword_F37B4;
// F37BC: using guessed type int dword_F37BC;

//----- (0002CC48) --------------------------------------------------------
int patten_load()
{
  char v1[128]; // [sp+14h] [bp+4h] BYREF
  char v2[4096]; // [sp+94h] [bp+84h] BYREF
  unsigned __int8 *v3; // [sp+1094h] [bp+1084h]
  _BYTE *v4; // [sp+1098h] [bp+1088h]
  FILE *v5; // [sp+109Ch] [bp+108Ch]
  int v6; // [sp+10A0h] [bp+1090h]
  int k; // [sp+10A4h] [bp+1094h]
  int j; // [sp+10A8h] [bp+1098h]
  int i; // [sp+10ACh] [bp+109Ch]

  v6 = dword_F3758 + dword_F3750 + dword_F3754;
  for ( i = 0; g_patten > i; ++i )
  {
    for ( j = 0; dword_F374C > j; ++j )
    {
      memset(v1, 0, sizeof(v1));
      sprintf(
        v1,
        "/mnt/card/%s/%s/%s-0x%02x/%s-0x%02x.txt",
        (const char *)&dword_F3760,
        byte_F3770,
        (const char *)&dword_F3780,
        i,
        (const char *)&dword_F3790,
        j);
      printf("fname %s\n", v1);
      v5 = fopen(v1, "r");
      for ( k = 0; dword_F375C > k; ++k )
      {
        v4 = (_BYTE *)(v6 * j * dword_F375C + v6 * dword_F375C * i * dword_F374C + v6 * k + dword_F37A0);
        memset(v2, 0, sizeof(v2));
        fgets(v2, 4096, v5);
        v3 = (unsigned __int8 *)strstr(v2, "work");
        hex2bin(v4, v3 + 5, dword_F3750);
        v3 = (unsigned __int8 *)strstr(v2, "nonce");
        hex2bin(&v4[dword_F3750], v3 + 6, dword_F3754);
        v3 = (unsigned __int8 *)strstr(v2, "sol");
        hex2bin(&v4[dword_F3754 + dword_F3750], v3 + 4, dword_F3758);
        printf("load asic%d core%d patten%d\n", i, j, k);
      }
      fclose(v5);
    }
  }
  return puts("Load Patten Done");
}
// F3748: using guessed type int g_patten;
// F374C: using guessed type int dword_F374C;
// F3750: using guessed type int dword_F3750;
// F3754: using guessed type int dword_F3754;
// F3758: using guessed type int dword_F3758;
// F375C: using guessed type int dword_F375C;
// F3760: using guessed type int dword_F3760;
// F3780: using guessed type int dword_F3780;
// F3790: using guessed type int dword_F3790;
// F37A0: using guessed type int dword_F37A0;

//----- (0002CFC0) --------------------------------------------------------
int __fastcall is_patten_match(int a1, const void *a2, const void *a3)
{
  int v6; // [sp+24h] [bp+14h]
  int v7; // [sp+28h] [bp+18h]
  int v8; // [sp+2Ch] [bp+1Ch]

  pthread_mutex_lock(&mutex);
  v7 = memcmp((const void *)(dword_F37A4 + dword_F3750), a2, dword_F3754);
  v6 = memcmp((const void *)(dword_F37A4 + dword_F3754 + dword_F3750), a3, dword_F3758);
  if ( v7 || v6 )
  {
    v8 = -1;
  }
  else
  {
    *(_BYTE *)(dword_F37B0 + dword_F375C * (dword_F374C * dword_F37A8 + dword_F37AC) + dword_F37B4) = 1;
    flt_F37C4 = (float)++dword_F37B8 / (float)dword_F37C0;
    ++*(_DWORD *)(4 * dword_F37A8 + dword_F37BC);
    dump_str((FILE *)_bss_start, "Match Recv:", (int)a2, dword_F3754);
    dump_str((FILE *)_bss_start, "Match Expect:", dword_F37A4 + dword_F3750, dword_F3754);
    printf(
      "Patten Success Rate %.2f recv %d total %d asic %d recv %d\n",
      (float)(flt_F37C4 * 100.0),
      dword_F37B8,
      dword_F37C0,
      dword_F37A8,
      *(_DWORD *)(4 * dword_F37A8 + dword_F37BC));
    v8 = 0;
  }
  pthread_mutex_unlock(&mutex);
  return v8;
}
// 47DA8: using guessed type int _bss_start;
// F374C: using guessed type int dword_F374C;
// F3750: using guessed type int dword_F3750;
// F3754: using guessed type int dword_F3754;
// F3758: using guessed type int dword_F3758;
// F375C: using guessed type int dword_F375C;
// F37A4: using guessed type int dword_F37A4;
// F37A8: using guessed type int dword_F37A8;
// F37AC: using guessed type int dword_F37AC;
// F37B0: using guessed type int dword_F37B0;
// F37B4: using guessed type int dword_F37B4;
// F37B8: using guessed type int dword_F37B8;
// F37BC: using guessed type int dword_F37BC;
// F37C0: using guessed type int dword_F37C0;
// F37C4: using guessed type float flt_F37C4;

//----- (0002D1E4) --------------------------------------------------------
int display_single_board_test()
{
  return puts("******************Display Results*******************");
}

//----- (0002D1F8) --------------------------------------------------------
void *clear_last_test_results()
{
  void *result; // r0

  memset((void *)dword_F37B4, 0, dword_F375C * dword_F374C * g_patten);
  result = memset((void *)dword_F37BC, 0, 4 * g_patten);
  dword_F37B8 = 0;
  flt_F37C4 = 0.0;
  return result;
}
// F3748: using guessed type int g_patten;
// F374C: using guessed type int dword_F374C;
// F375C: using guessed type int dword_F375C;
// F37B4: using guessed type int dword_F37B4;
// F37B8: using guessed type int dword_F37B8;
// F37BC: using guessed type int dword_F37BC;
// F37C4: using guessed type float flt_F37C4;

//----- (0002D270) --------------------------------------------------------
int __fastcall rt_ringbuffer_get_size(int a1)
{
  return *(unsigned __int16 *)(a1 + 12);
}

//----- (0002D288) --------------------------------------------------------
int __fastcall rt_ringbuffer_status(int a1)
{
  if ( *(_WORD *)(a1 + 4) >> 1 == *(_WORD *)(a1 + 6) >> 1 )
    return (*(_BYTE *)(a1 + 4) & 1) != (*(_BYTE *)(a1 + 6) & 1);
  else
    return 2;
}

//----- (0002D2D8) --------------------------------------------------------
int __fastcall rt_ringbuffer_data_len(_WORD *a1)
{
  int v1; // r0

  v1 = rt_ringbuffer_status((int)a1);
  if ( !v1 )
    return 0;
  if ( v1 == 1 )
    return (unsigned __int16)a1[6];
  if ( a1[3] >> 1 <= a1[2] >> 1 )
    return (unsigned __int16)((a1[3] >> 1) - (a1[2] >> 1) + a1[6]);
  return (unsigned __int16)((a1[3] >> 1) - (a1[2] >> 1));
}

//----- (0002D35C) --------------------------------------------------------
int __fastcall rt_ringbuffer_init(int a1, int a2, __int16 a3, int a4)
{
  int result; // r0

  *(_WORD *)(a1 + 4) &= 1u;
  *(_BYTE *)(a1 + 4) = *(_BYTE *)(a1 + 4) & 0xFE | ((*(_WORD *)(a1 + 4) & 2) != 0);
  *(_WORD *)(a1 + 6) &= 1u;
  *(_BYTE *)(a1 + 6) = *(_BYTE *)(a1 + 6) & 0xFE | ((*(_WORD *)(a1 + 6) & 2) != 0);
  *(_DWORD *)a1 = a2;
  *(_WORD *)(a1 + 12) = a3 & 0xFFFC;
  *(_DWORD *)(a1 + 136) = a4;
  result = pthread_mutex_init((pthread_mutex_t *)(a1 + 16), 0);
  if ( !*(_DWORD *)(a1 + 136) )
  {
    pthread_cond_init((pthread_cond_t *)(a1 + 40), 0);
    return pthread_cond_init((pthread_cond_t *)(a1 + 88), 0);
  }
  return result;
}

//----- (0002D408) --------------------------------------------------------
int __fastcall rt_ringbuffer_lock_destory(int a1)
{
  int result; // r0

  result = pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  if ( !*(_DWORD *)(a1 + 136) )
  {
    pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
    return pthread_cond_destroy((pthread_cond_t *)(a1 + 88));
  }
  return result;
}

//----- (0002D440) --------------------------------------------------------
int __fastcall rt_ringbuffer_put(int a1, char *a2, unsigned __int16 a3)
{
  __int16 v3; // r4
  __int16 v5; // r4
  unsigned __int16 v10; // [sp+16h] [bp+16h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v3 = *(_WORD *)(a1 + 12);
  v10 = v3 - rt_ringbuffer_data_len((_WORD *)a1);
  if ( *(_DWORD *)(a1 + 136) == 1 )
  {
    if ( !v10 )
    {
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
      return 0;
    }
    if ( v10 < (unsigned int)a3 )
      a3 = v10;
  }
  else if ( !*(_DWORD *)(a1 + 136) )
  {
    while ( v10 < (unsigned int)a3 )
    {
      pthread_cond_wait((pthread_cond_t *)(a1 + 40), (pthread_mutex_t *)(a1 + 16));
      v5 = *(_WORD *)(a1 + 12);
      v10 = v5 - rt_ringbuffer_data_len((_WORD *)a1);
    }
  }
  if ( *(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 6) >> 1) <= a3 )
  {
    memcpy(
      (void *)(*(_DWORD *)a1 + (*(_WORD *)(a1 + 6) >> 1)),
      a2,
      *(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 6) >> 1));
    memcpy(
      *(void **)a1,
      &a2[*(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 6) >> 1)],
      a3 - (*(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 6) >> 1)));
    *(_BYTE *)(a1 + 6) = *(_BYTE *)(a1 + 6) & 0xFE | ((*(_BYTE *)(a1 + 6) & 1) == 0);
    *(_WORD *)(a1 + 6) = *(_WORD *)(a1 + 6) & 1
                       | (2 * ((a3 + (*(_WORD *)(a1 + 6) >> 1) - *(_WORD *)(a1 + 12)) & 0x7FFF));
  }
  else
  {
    memcpy((void *)(*(_DWORD *)a1 + (*(_WORD *)(a1 + 6) >> 1)), a2, a3);
    *(_WORD *)(a1 + 6) = *(_WORD *)(a1 + 6) & 1 | (2 * ((a3 + (*(_WORD *)(a1 + 6) >> 1)) & 0x7FFF));
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 88));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  return a3;
}

//----- (0002D600) --------------------------------------------------------
int __fastcall rt_ringbuffer_put_force(int a1, char *a2, unsigned __int16 a3)
{
  __int16 v3; // r4
  unsigned __int16 v8; // [sp+16h] [bp+16h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v3 = *(_WORD *)(a1 + 12);
  v8 = v3 - rt_ringbuffer_data_len((_WORD *)a1);
  if ( a3 > (unsigned int)v8 )
    a3 = *(_WORD *)(a1 + 12);
  if ( *(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 6) >> 1) <= a3 )
  {
    memcpy(
      (void *)(*(_DWORD *)a1 + (*(_WORD *)(a1 + 6) >> 1)),
      a2,
      *(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 6) >> 1));
    memcpy(
      *(void **)a1,
      &a2[*(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 6) >> 1)],
      a3 - (*(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 6) >> 1)));
    *(_BYTE *)(a1 + 6) = *(_BYTE *)(a1 + 6) & 0xFE | ((*(_BYTE *)(a1 + 6) & 1) == 0);
    *(_WORD *)(a1 + 6) = *(_WORD *)(a1 + 6) & 1
                       | (2 * ((a3 + (*(_WORD *)(a1 + 6) >> 1) - *(_WORD *)(a1 + 12)) & 0x7FFF));
    if ( a3 > (unsigned int)v8 )
    {
      *(_BYTE *)(a1 + 4) = *(_BYTE *)(a1 + 4) & 0xFE | ((*(_BYTE *)(a1 + 4) & 1) == 0);
      *(_WORD *)(a1 + 4) = *(_WORD *)(a1 + 4) & 1 | (2 * ((*(_WORD *)(a1 + 6) >> 1) & 0x7FFF));
    }
  }
  else
  {
    memcpy((void *)(*(_DWORD *)a1 + (*(_WORD *)(a1 + 6) >> 1)), a2, a3);
    *(_WORD *)(a1 + 6) = *(_WORD *)(a1 + 6) & 1 | (2 * ((a3 + (*(_WORD *)(a1 + 6) >> 1)) & 0x7FFF));
    if ( a3 > (unsigned int)v8 )
      *(_WORD *)(a1 + 4) = *(_WORD *)(a1 + 4) & 1 | (2 * ((*(_WORD *)(a1 + 6) >> 1) & 0x7FFF));
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 88));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  return a3;
}

//----- (0002D7C0) --------------------------------------------------------
int __fastcall rt_ringbuffer_get(int a1, char *a2, unsigned __int16 a3)
{
  unsigned int v8; // [sp+14h] [bp+14h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v8 = rt_ringbuffer_data_len((_WORD *)a1);
  if ( *(_DWORD *)(a1 + 136) == 1 )
  {
    if ( !v8 )
    {
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
      return 0;
    }
    if ( a3 > v8 )
      a3 = v8;
  }
  else if ( !*(_DWORD *)(a1 + 136) )
  {
    while ( a3 > v8 )
    {
      pthread_cond_wait((pthread_cond_t *)(a1 + 88), (pthread_mutex_t *)(a1 + 16));
      v8 = rt_ringbuffer_data_len((_WORD *)a1);
    }
  }
  if ( *(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 4) >> 1) <= a3 )
  {
    memcpy(
      a2,
      (const void *)(*(_DWORD *)a1 + (*(_WORD *)(a1 + 4) >> 1)),
      *(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 4) >> 1));
    memcpy(
      &a2[*(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 4) >> 1)],
      *(const void **)a1,
      a3 - (*(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 4) >> 1)));
    *(_BYTE *)(a1 + 4) = *(_BYTE *)(a1 + 4) & 0xFE | ((*(_BYTE *)(a1 + 4) & 1) == 0);
    *(_WORD *)(a1 + 4) = *(_WORD *)(a1 + 4) & 1
                       | (2 * ((a3 + (*(_WORD *)(a1 + 4) >> 1) - *(_WORD *)(a1 + 12)) & 0x7FFF));
    pthread_cond_signal((pthread_cond_t *)(a1 + 40));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  }
  else
  {
    memcpy(a2, (const void *)(*(_DWORD *)a1 + (*(_WORD *)(a1 + 4) >> 1)), a3);
    *(_WORD *)(a1 + 4) = *(_WORD *)(a1 + 4) & 1 | (2 * ((a3 + (*(_WORD *)(a1 + 4) >> 1)) & 0x7FFF));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  }
  return a3;
}

//----- (0002D974) --------------------------------------------------------
int __fastcall rt_ringbuffer_prefetch(_WORD *a1, char *a2, unsigned __int16 a3)
{
  unsigned int v8; // [sp+14h] [bp+14h]

  v8 = rt_ringbuffer_data_len(a1);
  if ( !v8 )
    return 0;
  if ( a3 > v8 )
    a3 = v8;
  if ( (unsigned __int16)a1[6] - (a1[2] >> 1) <= a3 )
  {
    memcpy(a2, (const void *)(*(_DWORD *)a1 + (a1[2] >> 1)), (unsigned __int16)a1[6] - (a1[2] >> 1));
    memcpy(
      &a2[(unsigned __int16)a1[6] - (a1[2] >> 1)],
      *(const void **)a1,
      a3 - ((unsigned __int16)a1[6] - (a1[2] >> 1)));
  }
  else
  {
    memcpy(a2, (const void *)(*(_DWORD *)a1 + (a1[2] >> 1)), a3);
  }
  return a3;
}

//----- (0002DA44) --------------------------------------------------------
int __fastcall sha256_transf(int result, int a2, int a3)
{
  int v3; // [sp+Ch] [bp+Ch]
  int v4; // [sp+14h] [bp+14h]
  int v5; // [sp+18h] [bp+18h]
  int v6; // [sp+1Ch] [bp+1Ch]
  int v7; // [sp+20h] [bp+20h]
  int v8; // [sp+24h] [bp+24h]
  int v9; // [sp+28h] [bp+28h]
  int v10; // [sp+2Ch] [bp+2Ch]
  int v11; // [sp+30h] [bp+30h]
  _DWORD v12[64]; // [sp+34h] [bp+34h]
  int v13; // [sp+134h] [bp+134h]
  int v14; // [sp+138h] [bp+138h]
  int v15; // [sp+13Ch] [bp+13Ch]
  int j; // [sp+140h] [bp+140h]
  int i; // [sp+144h] [bp+144h]

  v3 = result;
  for ( i = 0; i < a3; ++i )
  {
    v15 = a2 + (i << 6);
    for ( j = 0; j <= 15; ++j )
      v12[j] = *(unsigned __int8 *)(4 * j + 3 + v15)
             | (*(unsigned __int8 *)(4 * j + 2 + v15) << 8)
             | (*(unsigned __int8 *)(4 * j + 1 + v15) << 16)
             | (*(unsigned __int8 *)(v15 + 4 * j) << 24);
    for ( j = 16; j <= 63; ++j )
    {
      result = j - 15;
      v12[j] = (__ROR4__(v12[j - 2], 17) ^ __ROR4__(v12[j - 2], 19) ^ (v12[j - 2] >> 10))
             + v12[j - 7]
             + ((v12[j - 15] >> 3) ^ __ROR4__(v12[j - 15], 7) ^ __ROR4__(v12[j - 15], 18))
             + v12[j - 16];
    }
    for ( j = 0; j <= 7; ++j )
      *(&v4 + j) = *(_DWORD *)(v3 + 4 * (j + 34));
    for ( j = 0; j <= 63; ++j )
    {
      v14 = v12[j] + v11 + (__ROR4__(v8, 25) ^ __ROR4__(v8, 6) ^ __ROR4__(v8, 11)) + (v10 & ~v8 ^ v8 & v9) + sha256_k[j];
      result = v5;
      v13 = (v6 & v5 ^ v4 & v5 ^ v6 & v4) + (__ROR4__(v4, 2) ^ __ROR4__(v4, 13) ^ __ROR4__(v4, 22));
      v11 = v10;
      v10 = v9;
      v9 = v8;
      v8 = v7 + v14;
      v7 = v6;
      v6 = v5;
      v5 = v4;
      v4 = v14 + v13;
    }
    for ( j = 0; j <= 7; ++j )
      *(_DWORD *)(v3 + 4 * (j + 34)) += *(&v4 + j);
  }
  return result;
}
// 47CA8: using guessed type _DWORD sha256_k[64];

//----- (0002DDA0) --------------------------------------------------------
int __fastcall sha256(char *a1, unsigned int a2, int a3)
{
  _DWORD v7[42]; // [sp+10h] [bp+10h] BYREF

  sha256_init(v7);
  sha256_update(v7, a1, a2);
  return sha256_final(v7, a3);
}

//----- (0002DDD8) --------------------------------------------------------
_DWORD *__fastcall sha256_init(_DWORD *result)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 7; ++i )
    result[i + 34] = sha256_h0[i];
  result[1] = 0;
  *result = 0;
  return result;
}
// 47C88: using guessed type _DWORD sha256_h0[8];

//----- (0002DE24) --------------------------------------------------------
void *__fastcall sha256_update(_DWORD *a1, char *a2, unsigned int a3)
{
  size_t v3; // r3
  void *result; // r0
  char *v8; // [sp+14h] [bp+14h]
  unsigned int v9; // [sp+18h] [bp+18h]
  size_t n; // [sp+20h] [bp+20h]
  int na; // [sp+20h] [bp+20h]

  v3 = a3;
  if ( a3 >= 64 - a1[1] )
    v3 = 64 - a1[1];
  n = v3;
  result = memcpy((char *)a1 + a1[1] + 8, a2, v3);
  if ( a3 + a1[1] > 0x3F )
  {
    v9 = (a3 - n) >> 6;
    v8 = &a2[n];
    sha256_transf((int)a1, (int)(a1 + 2), 1);
    sha256_transf((int)a1, (int)&a2[n], v9);
    na = (a3 - n) & 0x3F;
    result = memcpy(a1 + 2, &v8[64 * v9], na);
    a1[1] = na;
    *a1 += (v9 + 1) << 6;
  }
  else
  {
    a1[1] += a3;
  }
  return result;
}

//----- (0002DEDC) --------------------------------------------------------
int __fastcall sha256_final(_DWORD *a1, int a2)
{
  int v2; // r3
  int result; // r0
  int v6; // [sp+8h] [bp+8h]
  int v7; // [sp+Ch] [bp+Ch]
  int v8; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  if ( (a1[1] & 0x3Fu) <= 0x37 )
    v2 = 1;
  else
    v2 = 2;
  v8 = v2;
  v7 = 8 * (a1[1] + *a1);
  v6 = v2 << 6;
  memset((char *)a1 + a1[1] + 8, 0, (v2 << 6) - a1[1]);
  *((_BYTE *)a1 + a1[1] + 8) = 0x80;
  *((_BYTE *)a1 + v6 + 7) = v7;
  *((_BYTE *)a1 + v6 + 6) = BYTE1(v7);
  *((_BYTE *)a1 + v6 + 5) = BYTE2(v7);
  *((_BYTE *)a1 + v6 + 4) = HIBYTE(v7);
  result = sha256_transf((int)a1, (int)(a1 + 2), v8);
  for ( i = 0; i <= 7; ++i )
  {
    *(_BYTE *)(4 * i + 3 + a2) = a1[i + 34];
    *(_BYTE *)(4 * i + 2 + a2) = BYTE1(a1[i + 34]);
    *(_BYTE *)(4 * i + 1 + a2) = BYTE2(a1[i + 34]);
    *(_BYTE *)(a2 + 4 * i) = HIBYTE(a1[i + 34]);
  }
  return result;
}

//----- (0002E014) --------------------------------------------------------
_DWORD *__fastcall Sha256_Init(_DWORD *result)
{
  *result = 1779033703;
  result[1] = -1150833019;
  result[2] = 1013904242;
  result[3] = -1521486534;
  result[4] = 1359893119;
  result[5] = -1694144372;
  result[6] = 528734635;
  result[7] = 1541459225;
  result[8] = 0;
  result[9] = 0;
  return result;
}

//----- (0002E094) --------------------------------------------------------
_BYTE *__fastcall Sha256_Transform(_BYTE *result, int a2)
{
  int v2; // r1
  unsigned int v3; // r2
  int v4; // r3
  _BYTE *v6; // [sp+4h] [bp+4h]
  unsigned int j; // [sp+68h] [bp+68h]
  unsigned int i; // [sp+6Ch] [bp+6Ch]
  _BYTE v9[4]; // [sp+70h] [bp+70h] BYREF

  v6 = result;
  for ( i = 0; i <= 7; ++i )
    *(_DWORD *)&v9[4 * i - 104] = *(_DWORD *)&result[4 * i];
  for ( i = 0; i <= 0x3F; i += 16 )
  {
    for ( j = 0; j <= 0xF; ++j )
    {
      v2 = (__ROR4__(*(_DWORD *)&v9[4 * ((4 - (_BYTE)j) & 7) - 104], 6)
          ^ __ROR4__(*(_DWORD *)&v9[4 * ((4 - (_BYTE)j) & 7) - 104], 11)
          ^ __ROR4__(*(_DWORD *)&v9[4 * ((4 - (_BYTE)j) & 7) - 104], 25))
         + ((*(_DWORD *)&v9[4 * ((6 - (_BYTE)j) & 7) - 104]
           ^ *(_DWORD *)&v9[4 * ((5 - (_BYTE)j) & 7) - 104])
          & *(_DWORD *)&v9[4 * ((4 - (_BYTE)j) & 7) - 104]
          ^ *(_DWORD *)&v9[4 * ((6 - (_BYTE)j) & 7) - 104])
         + K[j + i];
      if ( i )
      {
        v3 = j;
        *(_DWORD *)&v9[4 * j - 72] = *(_DWORD *)&v9[4 * (j & 0xF) - 72]
                                   + ((*(_DWORD *)&v9[4 * (((_BYTE)j - 15) & 0xF) - 72] >> 3)
                                    ^ __ROR4__(*(_DWORD *)&v9[4 * (((_BYTE)j - 15) & 0xF) - 72], 7)
                                    ^ __ROR4__(*(_DWORD *)&v9[4 * (((_BYTE)j - 15) & 0xF) - 72], 18))
                                   + (__ROR4__(*(_DWORD *)&v9[4 * (((_BYTE)j - 2) & 0xF) - 72], 17)
                                    ^ __ROR4__(*(_DWORD *)&v9[4 * (((_BYTE)j - 2) & 0xF) - 72], 19)
                                    ^ (*(_DWORD *)&v9[4 * (((_BYTE)j - 2) & 0xF) - 72] >> 10))
                                   + *(_DWORD *)&v9[4 * (((_BYTE)j - 7) & 0xF) - 72];
        v4 = *(_DWORD *)&v9[4 * v3 - 72];
      }
      else
      {
        *(_DWORD *)&v9[4 * j - 72] = *(_DWORD *)(4 * j + a2);
        v4 = *(_DWORD *)&v9[4 * j - 72];
      }
      *(_DWORD *)&v9[4 * ((7 - (_BYTE)j) & 7) - 104] += v2 + v4;
      *(_DWORD *)&v9[4 * ((3 - (_BYTE)j) & 7) - 104] += *(_DWORD *)&v9[4 * ((7 - (_BYTE)j) & 7) - 104];
      result = (_BYTE *)(__ROR4__(*(_DWORD *)&v9[4 * (-j & 7) - 104], 2)
                       ^ __ROR4__(*(_DWORD *)&v9[4 * (-j & 7) - 104], 13)
                       ^ __ROR4__(*(_DWORD *)&v9[4 * (-j & 7) - 104], 22));
      *(_DWORD *)&v9[4 * ((7 - (_BYTE)j) & 7) - 104] += &result[(*(_DWORD *)&v9[4 * ((1 - (_BYTE)j) & 7) - 104]
                                                               | *(_DWORD *)&v9[4 * (-j & 7) - 104])
                                                              & *(_DWORD *)&v9[4 * ((2 - (_BYTE)j) & 7) - 104]
                                                              | *(_DWORD *)&v9[4 * (-j & 7) - 104]
                                                              & *(_DWORD *)&v9[4 * ((1 - (_BYTE)j) & 7) - 104]];
    }
  }
  for ( i = 0; i <= 7; ++i )
  {
    result = v9;
    *(_DWORD *)&v6[4 * i] += *(_DWORD *)&v9[4 * i - 104];
  }
  return result;
}
// 2E1A2: masking with 0xF was optimized away because %var_C.4 <= 0xF
// 36C94: using guessed type _DWORD K[64];

//----- (0002E464) --------------------------------------------------------
_BYTE *__fastcall Sha256_WriteByteBlock(_BYTE *a1)
{
  _BYTE v2[64]; // [sp+Ch] [bp+Ch] BYREF
  unsigned int i; // [sp+4Ch] [bp+4Ch]
  _DWORD vars0[2]; // [sp+50h] [bp+50h] BYREF

  for ( i = 0; i <= 0xF; ++i )
    vars0[i - 17] = (unsigned __int8)a1[4 * i + 43]
                  + ((unsigned __int8)a1[4 * i + 42] << 8)
                  + ((unsigned __int8)a1[4 * i + 40] << 24)
                  + ((unsigned __int8)a1[4 * i + 41] << 16);
  return Sha256_Transform(a1, (int)v2);
}

//----- (0002E4E4) --------------------------------------------------------
_BYTE *__fastcall Sha256_Update(_BYTE *result, _BYTE *a2, int a3)
{
  int v3; // r3
  _BYTE *v4; // r2
  _BYTE *v7; // [sp+Ch] [bp+Ch]
  int v8; // [sp+14h] [bp+14h]

  v7 = result;
  v8 = *((_QWORD *)result + 4) & 0x3F;
  while ( a3 )
  {
    v3 = v8++;
    v4 = a2++;
    v7[v3 + 40] = *v4;
    ++*((_QWORD *)v7 + 4);
    --a3;
    if ( v8 == 64 )
    {
      v8 = 0;
      result = Sha256_WriteByteBlock(v7);
    }
  }
  return result;
}

//----- (0002E54C) --------------------------------------------------------
_DWORD *__fastcall Sha256_Final(int a1, _BYTE *a2)
{
  int v2; // r3
  int v3; // r3
  int v4; // r1
  _BYTE *v5; // r3
  unsigned int i; // [sp+8h] [bp+8h]
  unsigned int j; // [sp+8h] [bp+8h]
  int v11; // [sp+Ch] [bp+Ch]
  int v12; // [sp+Ch] [bp+Ch]
  __int64 v13; // [sp+10h] [bp+10h]

  v13 = 8LL * *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 32) & 0x3F;
  v11 = v2 + 1;
  *(_BYTE *)(v2 + a1 + 40) = 0x80;
  while ( v11 != 56 )
  {
    v12 = v11 & 0x3F;
    if ( !v12 )
      Sha256_WriteByteBlock((_BYTE *)a1);
    v3 = v12;
    v11 = v12 + 1;
    *(_BYTE *)(v3 + a1 + 40) = 0;
  }
  for ( i = 0; i <= 7; ++i )
  {
    v4 = v11++;
    *(_BYTE *)(a1 + v4 + 40) = HIBYTE(v13);
    v13 <<= 8;
  }
  Sha256_WriteByteBlock((_BYTE *)a1);
  for ( j = 0; j <= 7; ++j )
  {
    *a2 = HIBYTE(*(_DWORD *)(a1 + 4 * j));
    a2[1] = BYTE2(*(_DWORD *)(a1 + 4 * j));
    a2[2] = BYTE1(*(_DWORD *)(a1 + 4 * j));
    v5 = a2 + 3;
    a2 += 4;
    *v5 = *(_DWORD *)(a1 + 4 * j);
  }
  return Sha256_Init((_DWORD *)a1);
}

//----- (0002E66C) --------------------------------------------------------
_DWORD *__fastcall Sha256_Onestep(_BYTE *a1, int a2, _BYTE *a3)
{
  _DWORD v7[26]; // [sp+10h] [bp+10h] BYREF

  Sha256_Init(v7);
  Sha256_Update(v7, a1, a2);
  return Sha256_Final((int)v7, a3);
}

//----- (0002E6A4) --------------------------------------------------------
_DWORD *__fastcall sha2_starts(_DWORD *result)
{
  *result = 0;
  result[1] = 0;
  result[2] = 1779033703;
  result[3] = -1150833019;
  result[4] = 1013904242;
  result[5] = -1521486534;
  result[6] = 1359893119;
  result[7] = -1694144372;
  result[8] = 528734635;
  result[9] = 1541459225;
  return result;
}

//----- (0002E724) --------------------------------------------------------
int __fastcall sha2_process(_DWORD *a1, unsigned int *a2)
{
  int result; // r0
  unsigned int v4; // [sp+8h] [bp+8h]
  unsigned int v5; // [sp+Ch] [bp+Ch]
  unsigned int v6; // [sp+10h] [bp+10h]
  unsigned int v7; // [sp+14h] [bp+14h]
  unsigned int v8; // [sp+18h] [bp+18h]
  unsigned int v9; // [sp+1Ch] [bp+1Ch]
  unsigned int v10; // [sp+20h] [bp+20h]
  unsigned int v11; // [sp+24h] [bp+24h]
  unsigned int v12; // [sp+28h] [bp+28h]
  unsigned int v13; // [sp+2Ch] [bp+2Ch]
  unsigned int v14; // [sp+30h] [bp+30h]
  unsigned int v15; // [sp+34h] [bp+34h]
  unsigned int v16; // [sp+38h] [bp+38h]
  unsigned int v17; // [sp+3Ch] [bp+3Ch]
  unsigned int v18; // [sp+40h] [bp+40h]
  unsigned int v19; // [sp+44h] [bp+44h]
  unsigned int v20; // [sp+48h] [bp+48h]
  unsigned int v21; // [sp+4Ch] [bp+4Ch]
  unsigned int v22; // [sp+50h] [bp+50h]
  unsigned int v23; // [sp+54h] [bp+54h]
  unsigned int v24; // [sp+58h] [bp+58h]
  unsigned int v25; // [sp+5Ch] [bp+5Ch]
  unsigned int v26; // [sp+60h] [bp+60h]
  unsigned int v27; // [sp+64h] [bp+64h]
  unsigned int v28; // [sp+68h] [bp+68h]
  unsigned int v29; // [sp+6Ch] [bp+6Ch]
  unsigned int v30; // [sp+70h] [bp+70h]
  unsigned int v31; // [sp+74h] [bp+74h]
  unsigned int v32; // [sp+78h] [bp+78h]
  unsigned int v33; // [sp+7Ch] [bp+7Ch]
  unsigned int v34; // [sp+80h] [bp+80h]
  unsigned int v35; // [sp+84h] [bp+84h]
  unsigned int v36; // [sp+88h] [bp+88h]
  unsigned int v37; // [sp+8Ch] [bp+8Ch]
  unsigned int v38; // [sp+90h] [bp+90h]
  unsigned int v39; // [sp+94h] [bp+94h]
  unsigned int v40; // [sp+98h] [bp+98h]
  unsigned int v41; // [sp+9Ch] [bp+9Ch]
  unsigned int v42; // [sp+A0h] [bp+A0h]
  unsigned int v43; // [sp+A4h] [bp+A4h]
  unsigned int v44; // [sp+A8h] [bp+A8h]
  unsigned int v45; // [sp+ACh] [bp+ACh]
  unsigned int v46; // [sp+B0h] [bp+B0h]
  unsigned int v47; // [sp+B4h] [bp+B4h]
  unsigned int v48; // [sp+B8h] [bp+B8h]
  unsigned int v49; // [sp+BCh] [bp+BCh]
  unsigned int v50; // [sp+C0h] [bp+C0h]
  unsigned int v51; // [sp+C4h] [bp+C4h]
  unsigned int v52; // [sp+C8h] [bp+C8h]
  unsigned int v53; // [sp+CCh] [bp+CCh]
  unsigned int v54; // [sp+D0h] [bp+D0h]
  unsigned int v55; // [sp+D4h] [bp+D4h]
  unsigned int v56; // [sp+D8h] [bp+D8h]
  unsigned int v57; // [sp+DCh] [bp+DCh]
  unsigned int v58; // [sp+E0h] [bp+E0h]
  unsigned int v59; // [sp+E4h] [bp+E4h]
  unsigned int v60; // [sp+E8h] [bp+E8h]
  unsigned int v61; // [sp+ECh] [bp+ECh]
  unsigned int v62; // [sp+F0h] [bp+F0h]
  unsigned int v63; // [sp+F4h] [bp+F4h]
  unsigned int v64; // [sp+F8h] [bp+F8h]
  unsigned int v65; // [sp+FCh] [bp+FCh]
  int v66; // [sp+10Ch] [bp+10Ch]
  int v67; // [sp+10Ch] [bp+10Ch]
  int v68; // [sp+10Ch] [bp+10Ch]
  int v69; // [sp+10Ch] [bp+10Ch]
  int v70; // [sp+10Ch] [bp+10Ch]
  int v71; // [sp+10Ch] [bp+10Ch]
  int v72; // [sp+10Ch] [bp+10Ch]
  int v73; // [sp+10Ch] [bp+10Ch]
  int v74; // [sp+10Ch] [bp+10Ch]
  int v75; // [sp+10Ch] [bp+10Ch]
  int v76; // [sp+10Ch] [bp+10Ch]
  int v77; // [sp+10Ch] [bp+10Ch]
  int v78; // [sp+10Ch] [bp+10Ch]
  int v79; // [sp+10Ch] [bp+10Ch]
  int v80; // [sp+10Ch] [bp+10Ch]
  int v81; // [sp+10Ch] [bp+10Ch]
  int v82; // [sp+10Ch] [bp+10Ch]
  int v83; // [sp+10Ch] [bp+10Ch]
  int v84; // [sp+10Ch] [bp+10Ch]
  int v85; // [sp+10Ch] [bp+10Ch]
  int v86; // [sp+10Ch] [bp+10Ch]
  int v87; // [sp+10Ch] [bp+10Ch]
  int v88; // [sp+10Ch] [bp+10Ch]
  int v89; // [sp+10Ch] [bp+10Ch]
  int v90; // [sp+10Ch] [bp+10Ch]
  int v91; // [sp+10Ch] [bp+10Ch]
  int v92; // [sp+10Ch] [bp+10Ch]
  int v93; // [sp+10Ch] [bp+10Ch]
  int v94; // [sp+10Ch] [bp+10Ch]
  int v95; // [sp+10Ch] [bp+10Ch]
  int v96; // [sp+10Ch] [bp+10Ch]
  int v97; // [sp+10Ch] [bp+10Ch]
  int v98; // [sp+10Ch] [bp+10Ch]
  int v99; // [sp+10Ch] [bp+10Ch]
  int v100; // [sp+10Ch] [bp+10Ch]
  int v101; // [sp+10Ch] [bp+10Ch]
  int v102; // [sp+10Ch] [bp+10Ch]
  int v103; // [sp+10Ch] [bp+10Ch]
  int v104; // [sp+10Ch] [bp+10Ch]
  int v105; // [sp+10Ch] [bp+10Ch]
  int v106; // [sp+10Ch] [bp+10Ch]
  int v107; // [sp+10Ch] [bp+10Ch]
  int v108; // [sp+10Ch] [bp+10Ch]
  int v109; // [sp+10Ch] [bp+10Ch]
  int v110; // [sp+10Ch] [bp+10Ch]
  int v111; // [sp+10Ch] [bp+10Ch]
  int v112; // [sp+10Ch] [bp+10Ch]
  int v113; // [sp+10Ch] [bp+10Ch]
  int v114; // [sp+10Ch] [bp+10Ch]
  int v115; // [sp+10Ch] [bp+10Ch]
  int v116; // [sp+10Ch] [bp+10Ch]
  int v117; // [sp+10Ch] [bp+10Ch]
  int v118; // [sp+10Ch] [bp+10Ch]
  int v119; // [sp+10Ch] [bp+10Ch]
  int v120; // [sp+10Ch] [bp+10Ch]
  int v121; // [sp+10Ch] [bp+10Ch]
  int v122; // [sp+10Ch] [bp+10Ch]
  int v123; // [sp+10Ch] [bp+10Ch]
  int v124; // [sp+10Ch] [bp+10Ch]
  int v125; // [sp+10Ch] [bp+10Ch]
  int v126; // [sp+10Ch] [bp+10Ch]
  int v127; // [sp+10Ch] [bp+10Ch]
  int v128; // [sp+10Ch] [bp+10Ch]
  int v129; // [sp+10Ch] [bp+10Ch]
  int v130; // [sp+110h] [bp+110h]
  int v131; // [sp+110h] [bp+110h]
  int v132; // [sp+110h] [bp+110h]
  int v133; // [sp+110h] [bp+110h]
  int v134; // [sp+110h] [bp+110h]
  int v135; // [sp+110h] [bp+110h]
  int v136; // [sp+110h] [bp+110h]
  int v137; // [sp+110h] [bp+110h]
  int v138; // [sp+110h] [bp+110h]
  int v139; // [sp+110h] [bp+110h]
  int v140; // [sp+110h] [bp+110h]
  int v141; // [sp+110h] [bp+110h]
  int v142; // [sp+110h] [bp+110h]
  int v143; // [sp+110h] [bp+110h]
  int v144; // [sp+110h] [bp+110h]
  int v145; // [sp+110h] [bp+110h]
  int v146; // [sp+114h] [bp+114h]
  int v147; // [sp+114h] [bp+114h]
  int v148; // [sp+114h] [bp+114h]
  int v149; // [sp+114h] [bp+114h]
  int v150; // [sp+114h] [bp+114h]
  int v151; // [sp+114h] [bp+114h]
  int v152; // [sp+114h] [bp+114h]
  int v153; // [sp+114h] [bp+114h]
  int v154; // [sp+114h] [bp+114h]
  int v155; // [sp+114h] [bp+114h]
  int v156; // [sp+114h] [bp+114h]
  int v157; // [sp+114h] [bp+114h]
  int v158; // [sp+114h] [bp+114h]
  int v159; // [sp+114h] [bp+114h]
  int v160; // [sp+114h] [bp+114h]
  int v161; // [sp+114h] [bp+114h]
  int v162; // [sp+114h] [bp+114h]
  int v163; // [sp+118h] [bp+118h]
  int v164; // [sp+118h] [bp+118h]
  int v165; // [sp+118h] [bp+118h]
  int v166; // [sp+118h] [bp+118h]
  int v167; // [sp+118h] [bp+118h]
  int v168; // [sp+118h] [bp+118h]
  int v169; // [sp+118h] [bp+118h]
  int v170; // [sp+118h] [bp+118h]
  int v171; // [sp+118h] [bp+118h]
  int v172; // [sp+118h] [bp+118h]
  int v173; // [sp+118h] [bp+118h]
  int v174; // [sp+118h] [bp+118h]
  int v175; // [sp+118h] [bp+118h]
  int v176; // [sp+118h] [bp+118h]
  int v177; // [sp+118h] [bp+118h]
  int v178; // [sp+118h] [bp+118h]
  int v179; // [sp+118h] [bp+118h]
  int v180; // [sp+11Ch] [bp+11Ch]
  int v181; // [sp+11Ch] [bp+11Ch]
  int v182; // [sp+11Ch] [bp+11Ch]
  int v183; // [sp+11Ch] [bp+11Ch]
  int v184; // [sp+11Ch] [bp+11Ch]
  int v185; // [sp+11Ch] [bp+11Ch]
  int v186; // [sp+11Ch] [bp+11Ch]
  int v187; // [sp+11Ch] [bp+11Ch]
  int v188; // [sp+11Ch] [bp+11Ch]
  int v189; // [sp+11Ch] [bp+11Ch]
  int v190; // [sp+11Ch] [bp+11Ch]
  int v191; // [sp+11Ch] [bp+11Ch]
  int v192; // [sp+11Ch] [bp+11Ch]
  int v193; // [sp+11Ch] [bp+11Ch]
  int v194; // [sp+11Ch] [bp+11Ch]
  int v195; // [sp+11Ch] [bp+11Ch]
  int v196; // [sp+120h] [bp+120h]
  int v197; // [sp+120h] [bp+120h]
  int v198; // [sp+120h] [bp+120h]
  int v199; // [sp+120h] [bp+120h]
  int v200; // [sp+120h] [bp+120h]
  int v201; // [sp+120h] [bp+120h]
  int v202; // [sp+120h] [bp+120h]
  int v203; // [sp+120h] [bp+120h]
  int v204; // [sp+120h] [bp+120h]
  int v205; // [sp+120h] [bp+120h]
  int v206; // [sp+120h] [bp+120h]
  int v207; // [sp+120h] [bp+120h]
  int v208; // [sp+120h] [bp+120h]
  int v209; // [sp+120h] [bp+120h]
  int v210; // [sp+120h] [bp+120h]
  int v211; // [sp+120h] [bp+120h]
  int v212; // [sp+124h] [bp+124h]
  int v213; // [sp+124h] [bp+124h]
  int v214; // [sp+124h] [bp+124h]
  int v215; // [sp+124h] [bp+124h]
  int v216; // [sp+124h] [bp+124h]
  int v217; // [sp+124h] [bp+124h]
  int v218; // [sp+124h] [bp+124h]
  int v219; // [sp+124h] [bp+124h]
  int v220; // [sp+124h] [bp+124h]
  int v221; // [sp+124h] [bp+124h]
  int v222; // [sp+124h] [bp+124h]
  int v223; // [sp+124h] [bp+124h]
  int v224; // [sp+124h] [bp+124h]
  int v225; // [sp+124h] [bp+124h]
  int v226; // [sp+124h] [bp+124h]
  int v227; // [sp+124h] [bp+124h]
  int v228; // [sp+124h] [bp+124h]
  int v229; // [sp+128h] [bp+128h]
  int v230; // [sp+128h] [bp+128h]
  int v231; // [sp+128h] [bp+128h]
  int v232; // [sp+128h] [bp+128h]
  int v233; // [sp+128h] [bp+128h]
  int v234; // [sp+128h] [bp+128h]
  int v235; // [sp+128h] [bp+128h]
  int v236; // [sp+128h] [bp+128h]
  int v237; // [sp+128h] [bp+128h]
  int v238; // [sp+128h] [bp+128h]
  int v239; // [sp+128h] [bp+128h]
  int v240; // [sp+128h] [bp+128h]
  int v241; // [sp+128h] [bp+128h]
  int v242; // [sp+128h] [bp+128h]
  int v243; // [sp+128h] [bp+128h]
  int v244; // [sp+128h] [bp+128h]
  int v245; // [sp+128h] [bp+128h]
  int v246; // [sp+12Ch] [bp+12Ch]
  int v247; // [sp+12Ch] [bp+12Ch]
  int v248; // [sp+12Ch] [bp+12Ch]
  int v249; // [sp+12Ch] [bp+12Ch]
  int v250; // [sp+12Ch] [bp+12Ch]
  int v251; // [sp+12Ch] [bp+12Ch]
  int v252; // [sp+12Ch] [bp+12Ch]
  int v253; // [sp+12Ch] [bp+12Ch]
  int v254; // [sp+12Ch] [bp+12Ch]
  int v255; // [sp+12Ch] [bp+12Ch]
  int v256; // [sp+12Ch] [bp+12Ch]
  int v257; // [sp+12Ch] [bp+12Ch]
  int v258; // [sp+12Ch] [bp+12Ch]
  int v259; // [sp+12Ch] [bp+12Ch]
  int v260; // [sp+12Ch] [bp+12Ch]
  int v261; // [sp+12Ch] [bp+12Ch]

  v4 = _byteswap_ulong(*a2);
  v5 = _byteswap_ulong(a2[1]);
  v6 = _byteswap_ulong(a2[2]);
  v7 = _byteswap_ulong(a2[3]);
  v8 = _byteswap_ulong(a2[4]);
  v9 = _byteswap_ulong(a2[5]);
  v10 = _byteswap_ulong(a2[6]);
  v11 = _byteswap_ulong(a2[7]);
  v12 = _byteswap_ulong(a2[8]);
  v13 = _byteswap_ulong(a2[9]);
  v14 = _byteswap_ulong(a2[10]);
  v15 = _byteswap_ulong(a2[11]);
  v16 = _byteswap_ulong(a2[12]);
  v17 = _byteswap_ulong(a2[13]);
  v18 = _byteswap_ulong(a2[14]);
  v19 = _byteswap_ulong(a2[15]);
  v246 = a1[2];
  v229 = a1[3];
  v212 = a1[4];
  v180 = a1[6];
  v163 = a1[7];
  v146 = a1[8];
  v66 = (__ROR4__(v180, 6) ^ __ROR4__(v180, 11) ^ __ROR4__(v180, 25))
      + a1[9]
      + (v146 ^ (v163 ^ v146) & v180)
      + v4
      + 1116352408;
  v196 = v66 + a1[5];
  v130 = (v212 & (v246 | v229) | v246 & v229) + (__ROR4__(v246, 2) ^ __ROR4__(v246, 13) ^ __ROR4__(v246, 22)) + v66;
  v67 = (__ROR4__(v196, 6) ^ __ROR4__(v196, 11) ^ __ROR4__(v196, 25))
      + v146
      + (v163 ^ (v180 ^ v163) & v196)
      + v5
      + 1899447441;
  v213 = v67 + v212;
  v147 = (v229 & (v130 | v246) | v130 & v246) + (__ROR4__(v130, 2) ^ __ROR4__(v130, 13) ^ __ROR4__(v130, 22)) + v67;
  v68 = (__ROR4__(v213, 6) ^ __ROR4__(v213, 11) ^ __ROR4__(v213, 25))
      + v163
      + (v180 ^ (v196 ^ v180) & v213)
      + v6
      - 1245643825;
  v230 = v68 + v229;
  v164 = (v246 & (v147 | v130) | v147 & v130) + (__ROR4__(v147, 2) ^ __ROR4__(v147, 13) ^ __ROR4__(v147, 22)) + v68;
  v69 = (__ROR4__(v230, 6) ^ __ROR4__(v230, 11) ^ __ROR4__(v230, 25))
      + v180
      + (v196 ^ (v213 ^ v196) & v230)
      + v7
      - 373957723;
  v247 = v69 + v246;
  v181 = (v130 & (v164 | v147) | v164 & v147) + (__ROR4__(v164, 2) ^ __ROR4__(v164, 13) ^ __ROR4__(v164, 22)) + v69;
  v70 = (__ROR4__(v247, 6) ^ __ROR4__(v247, 11) ^ __ROR4__(v247, 25))
      + v196
      + (v213 ^ (v230 ^ v213) & v247)
      + v8
      + 961987163;
  v131 = v70 + v130;
  v197 = (v147 & (v181 | v164) | v181 & v164) + (__ROR4__(v181, 2) ^ __ROR4__(v181, 13) ^ __ROR4__(v181, 22)) + v70;
  v71 = (__ROR4__(v131, 6) ^ __ROR4__(v131, 11) ^ __ROR4__(v131, 25))
      + v213
      + (v230 ^ (v247 ^ v230) & v131)
      + v9
      + 1508970993;
  v148 = v71 + v147;
  v214 = (v164 & (v197 | v181) | v197 & v181) + (__ROR4__(v197, 2) ^ __ROR4__(v197, 13) ^ __ROR4__(v197, 22)) + v71;
  v72 = (__ROR4__(v148, 6) ^ __ROR4__(v148, 11) ^ __ROR4__(v148, 25))
      + v230
      + (v247 ^ (v131 ^ v247) & v148)
      + v10
      - 1841331548;
  v165 = v72 + v164;
  v231 = (v181 & (v214 | v197) | v214 & v197) + (__ROR4__(v214, 2) ^ __ROR4__(v214, 13) ^ __ROR4__(v214, 22)) + v72;
  v73 = (__ROR4__(v165, 6) ^ __ROR4__(v165, 11) ^ __ROR4__(v165, 25))
      + v247
      + (v131 ^ (v148 ^ v131) & v165)
      + v11
      - 1424204075;
  v182 = v73 + v181;
  v248 = (v197 & (v231 | v214) | v231 & v214) + (__ROR4__(v231, 2) ^ __ROR4__(v231, 13) ^ __ROR4__(v231, 22)) + v73;
  v74 = (__ROR4__(v182, 6) ^ __ROR4__(v182, 11) ^ __ROR4__(v182, 25))
      + v131
      + (v148 ^ (v165 ^ v148) & v182)
      + v12
      - 670586216;
  v198 = v74 + v197;
  v132 = (v214 & (v248 | v231) | v248 & v231) + (__ROR4__(v248, 2) ^ __ROR4__(v248, 13) ^ __ROR4__(v248, 22)) + v74;
  v75 = (__ROR4__(v198, 6) ^ __ROR4__(v198, 11) ^ __ROR4__(v198, 25))
      + v148
      + (v165 ^ (v182 ^ v165) & v198)
      + v13
      + 310598401;
  v215 = v75 + v214;
  v149 = (v231 & (v132 | v248) | v132 & v248) + (__ROR4__(v132, 2) ^ __ROR4__(v132, 13) ^ __ROR4__(v132, 22)) + v75;
  v76 = (__ROR4__(v215, 6) ^ __ROR4__(v215, 11) ^ __ROR4__(v215, 25))
      + v165
      + (v182 ^ (v198 ^ v182) & v215)
      + v14
      + 607225278;
  v232 = v76 + v231;
  v166 = (v248 & (v149 | v132) | v149 & v132) + (__ROR4__(v149, 2) ^ __ROR4__(v149, 13) ^ __ROR4__(v149, 22)) + v76;
  v77 = (__ROR4__(v232, 6) ^ __ROR4__(v232, 11) ^ __ROR4__(v232, 25))
      + v182
      + (v198 ^ (v215 ^ v198) & v232)
      + v15
      + 1426881987;
  v249 = v77 + v248;
  v183 = (v132 & (v166 | v149) | v166 & v149) + (__ROR4__(v166, 2) ^ __ROR4__(v166, 13) ^ __ROR4__(v166, 22)) + v77;
  v78 = (__ROR4__(v249, 6) ^ __ROR4__(v249, 11) ^ __ROR4__(v249, 25))
      + v198
      + (v215 ^ (v232 ^ v215) & v249)
      + v16
      + 1925078388;
  v133 = v78 + v132;
  v199 = (v149 & (v183 | v166) | v183 & v166) + (__ROR4__(v183, 2) ^ __ROR4__(v183, 13) ^ __ROR4__(v183, 22)) + v78;
  v79 = (__ROR4__(v133, 6) ^ __ROR4__(v133, 11) ^ __ROR4__(v133, 25))
      + v215
      + (v232 ^ (v249 ^ v232) & v133)
      + v17
      - 2132889090;
  v150 = v79 + v149;
  v216 = (v166 & (v199 | v183) | v199 & v183) + (__ROR4__(v199, 2) ^ __ROR4__(v199, 13) ^ __ROR4__(v199, 22)) + v79;
  v80 = (__ROR4__(v150, 6) ^ __ROR4__(v150, 11) ^ __ROR4__(v150, 25))
      + v232
      + (v249 ^ (v133 ^ v249) & v150)
      + v18
      - 1680079193;
  v167 = v80 + v166;
  v233 = (v183 & (v216 | v199) | v216 & v199) + (__ROR4__(v216, 2) ^ __ROR4__(v216, 13) ^ __ROR4__(v216, 22)) + v80;
  v81 = (__ROR4__(v167, 6) ^ __ROR4__(v167, 11) ^ __ROR4__(v167, 25))
      + v249
      + (v133 ^ (v150 ^ v133) & v167)
      + v19
      - 1046744716;
  v184 = v81 + v183;
  v250 = (v199 & (v233 | v216) | v233 & v216) + (__ROR4__(v233, 2) ^ __ROR4__(v233, 13) ^ __ROR4__(v233, 22)) + v81;
  v20 = (__ROR4__(v18, 17) ^ __ROR4__(v18, 19) ^ (v18 >> 10))
      + v13
      + ((v5 >> 3) ^ __ROR4__(v5, 7) ^ __ROR4__(v5, 18))
      + v4;
  v82 = (__ROR4__(v184, 6) ^ __ROR4__(v184, 11) ^ __ROR4__(v184, 25))
      + v133
      + (v150 ^ (v167 ^ v150) & v184)
      + v20
      - 459576895;
  v200 = v82 + v199;
  v134 = (v216 & (v250 | v233) | v250 & v233) + (__ROR4__(v250, 2) ^ __ROR4__(v250, 13) ^ __ROR4__(v250, 22)) + v82;
  v21 = (__ROR4__(v19, 17) ^ __ROR4__(v19, 19) ^ (v19 >> 10))
      + v14
      + ((v6 >> 3) ^ __ROR4__(v6, 7) ^ __ROR4__(v6, 18))
      + v5;
  v83 = (__ROR4__(v200, 6) ^ __ROR4__(v200, 11) ^ __ROR4__(v200, 25))
      + v150
      + (v167 ^ (v184 ^ v167) & v200)
      + v21
      - 272742522;
  v217 = v83 + v216;
  v151 = (v233 & (v134 | v250) | v134 & v250) + (__ROR4__(v134, 2) ^ __ROR4__(v134, 13) ^ __ROR4__(v134, 22)) + v83;
  v22 = (__ROR4__(v20, 17) ^ __ROR4__(v20, 19) ^ (v20 >> 10))
      + v15
      + ((v7 >> 3) ^ __ROR4__(v7, 7) ^ __ROR4__(v7, 18))
      + v6;
  v84 = (__ROR4__(v217, 6) ^ __ROR4__(v217, 11) ^ __ROR4__(v217, 25))
      + v167
      + (v184 ^ (v200 ^ v184) & v217)
      + v22
      + 264347078;
  v234 = v84 + v233;
  v168 = (v250 & (v151 | v134) | v151 & v134) + (__ROR4__(v151, 2) ^ __ROR4__(v151, 13) ^ __ROR4__(v151, 22)) + v84;
  v23 = (__ROR4__(v21, 17) ^ __ROR4__(v21, 19) ^ (v21 >> 10))
      + v16
      + ((v8 >> 3) ^ __ROR4__(v8, 7) ^ __ROR4__(v8, 18))
      + v7;
  v85 = (__ROR4__(v234, 6) ^ __ROR4__(v234, 11) ^ __ROR4__(v234, 25))
      + v184
      + (v200 ^ (v217 ^ v200) & v234)
      + v23
      + 604807628;
  v251 = v85 + v250;
  v185 = (v134 & (v168 | v151) | v168 & v151) + (__ROR4__(v168, 2) ^ __ROR4__(v168, 13) ^ __ROR4__(v168, 22)) + v85;
  v24 = (__ROR4__(v22, 17) ^ __ROR4__(v22, 19) ^ (v22 >> 10))
      + v17
      + ((v9 >> 3) ^ __ROR4__(v9, 7) ^ __ROR4__(v9, 18))
      + v8;
  v86 = (__ROR4__(v251, 6) ^ __ROR4__(v251, 11) ^ __ROR4__(v251, 25))
      + v200
      + (v217 ^ (v234 ^ v217) & v251)
      + v24
      + 770255983;
  v135 = v86 + v134;
  v201 = (v151 & (v185 | v168) | v185 & v168) + (__ROR4__(v185, 2) ^ __ROR4__(v185, 13) ^ __ROR4__(v185, 22)) + v86;
  v25 = (__ROR4__(v23, 17) ^ __ROR4__(v23, 19) ^ (v23 >> 10))
      + v18
      + ((v10 >> 3) ^ __ROR4__(v10, 7) ^ __ROR4__(v10, 18))
      + v9;
  v87 = (__ROR4__(v135, 6) ^ __ROR4__(v135, 11) ^ __ROR4__(v135, 25))
      + v217
      + (v234 ^ (v251 ^ v234) & v135)
      + v25
      + 1249150122;
  v152 = v87 + v151;
  v218 = (v168 & (v201 | v185) | v201 & v185) + (__ROR4__(v201, 2) ^ __ROR4__(v201, 13) ^ __ROR4__(v201, 22)) + v87;
  v26 = (__ROR4__(v24, 17) ^ __ROR4__(v24, 19) ^ (v24 >> 10))
      + v19
      + ((v11 >> 3) ^ __ROR4__(v11, 7) ^ __ROR4__(v11, 18))
      + v10;
  v88 = (__ROR4__(v152, 6) ^ __ROR4__(v152, 11) ^ __ROR4__(v152, 25))
      + v234
      + (v251 ^ (v135 ^ v251) & v152)
      + v26
      + 1555081692;
  v169 = v88 + v168;
  v235 = (v185 & (v218 | v201) | v218 & v201) + (__ROR4__(v218, 2) ^ __ROR4__(v218, 13) ^ __ROR4__(v218, 22)) + v88;
  v27 = (__ROR4__(v25, 17) ^ __ROR4__(v25, 19) ^ (v25 >> 10))
      + v20
      + ((v12 >> 3) ^ __ROR4__(v12, 7) ^ __ROR4__(v12, 18))
      + v11;
  v89 = (__ROR4__(v169, 6) ^ __ROR4__(v169, 11) ^ __ROR4__(v169, 25))
      + v251
      + (v135 ^ (v152 ^ v135) & v169)
      + v27
      + 1996064986;
  v186 = v89 + v185;
  v252 = (v201 & (v235 | v218) | v235 & v218) + (__ROR4__(v235, 2) ^ __ROR4__(v235, 13) ^ __ROR4__(v235, 22)) + v89;
  v28 = (__ROR4__(v26, 17) ^ __ROR4__(v26, 19) ^ (v26 >> 10))
      + v21
      + ((v13 >> 3) ^ __ROR4__(v13, 7) ^ __ROR4__(v13, 18))
      + v12;
  v90 = (__ROR4__(v186, 6) ^ __ROR4__(v186, 11) ^ __ROR4__(v186, 25))
      + v135
      + (v152 ^ (v169 ^ v152) & v186)
      + v28
      - 1740746414;
  v202 = v90 + v201;
  v136 = (v218 & (v252 | v235) | v252 & v235) + (__ROR4__(v252, 2) ^ __ROR4__(v252, 13) ^ __ROR4__(v252, 22)) + v90;
  v29 = (__ROR4__(v27, 17) ^ __ROR4__(v27, 19) ^ (v27 >> 10))
      + v22
      + ((v14 >> 3) ^ __ROR4__(v14, 7) ^ __ROR4__(v14, 18))
      + v13;
  v91 = (__ROR4__(v202, 6) ^ __ROR4__(v202, 11) ^ __ROR4__(v202, 25))
      + v152
      + (v169 ^ (v186 ^ v169) & v202)
      + v29
      - 1473132947;
  v219 = v91 + v218;
  v153 = (v235 & (v136 | v252) | v136 & v252) + (__ROR4__(v136, 2) ^ __ROR4__(v136, 13) ^ __ROR4__(v136, 22)) + v91;
  v30 = (__ROR4__(v28, 17) ^ __ROR4__(v28, 19) ^ (v28 >> 10))
      + v23
      + ((v15 >> 3) ^ __ROR4__(v15, 7) ^ __ROR4__(v15, 18))
      + v14;
  v92 = (__ROR4__(v219, 6) ^ __ROR4__(v219, 11) ^ __ROR4__(v219, 25))
      + v169
      + (v186 ^ (v202 ^ v186) & v219)
      + v30
      - 1341970488;
  v236 = v92 + v235;
  v170 = (v252 & (v153 | v136) | v153 & v136) + (__ROR4__(v153, 2) ^ __ROR4__(v153, 13) ^ __ROR4__(v153, 22)) + v92;
  v31 = (__ROR4__(v29, 17) ^ __ROR4__(v29, 19) ^ (v29 >> 10))
      + v24
      + ((v16 >> 3) ^ __ROR4__(v16, 7) ^ __ROR4__(v16, 18))
      + v15;
  v93 = (__ROR4__(v236, 6) ^ __ROR4__(v236, 11) ^ __ROR4__(v236, 25))
      + v186
      + (v202 ^ (v219 ^ v202) & v236)
      + v31
      - 1084653625;
  v253 = v93 + v252;
  v187 = (v136 & (v170 | v153) | v170 & v153) + (__ROR4__(v170, 2) ^ __ROR4__(v170, 13) ^ __ROR4__(v170, 22)) + v93;
  v32 = (__ROR4__(v30, 17) ^ __ROR4__(v30, 19) ^ (v30 >> 10))
      + v25
      + ((v17 >> 3) ^ __ROR4__(v17, 7) ^ __ROR4__(v17, 18))
      + v16;
  v94 = (__ROR4__(v253, 6) ^ __ROR4__(v253, 11) ^ __ROR4__(v253, 25))
      + v202
      + (v219 ^ (v236 ^ v219) & v253)
      + v32
      - 958395405;
  v137 = v94 + v136;
  v203 = (v153 & (v187 | v170) | v187 & v170) + (__ROR4__(v187, 2) ^ __ROR4__(v187, 13) ^ __ROR4__(v187, 22)) + v94;
  v33 = (__ROR4__(v31, 17) ^ __ROR4__(v31, 19) ^ (v31 >> 10))
      + v26
      + ((v18 >> 3) ^ __ROR4__(v18, 7) ^ __ROR4__(v18, 18))
      + v17;
  v95 = (__ROR4__(v137, 6) ^ __ROR4__(v137, 11) ^ __ROR4__(v137, 25))
      + v219
      + (v236 ^ (v253 ^ v236) & v137)
      + v33
      - 710438585;
  v154 = v95 + v153;
  v220 = (v170 & (v203 | v187) | v203 & v187) + (__ROR4__(v203, 2) ^ __ROR4__(v203, 13) ^ __ROR4__(v203, 22)) + v95;
  v34 = (__ROR4__(v32, 17) ^ __ROR4__(v32, 19) ^ (v32 >> 10))
      + v27
      + ((v19 >> 3) ^ __ROR4__(v19, 7) ^ __ROR4__(v19, 18))
      + v18;
  v96 = (__ROR4__(v154, 6) ^ __ROR4__(v154, 11) ^ __ROR4__(v154, 25))
      + v236
      + (v253 ^ (v137 ^ v253) & v154)
      + v34
      + 113926993;
  v171 = v96 + v170;
  v237 = (v187 & (v220 | v203) | v220 & v203) + (__ROR4__(v220, 2) ^ __ROR4__(v220, 13) ^ __ROR4__(v220, 22)) + v96;
  v35 = (__ROR4__(v33, 17) ^ __ROR4__(v33, 19) ^ (v33 >> 10))
      + v28
      + ((v20 >> 3) ^ __ROR4__(v20, 7) ^ __ROR4__(v20, 18))
      + v19;
  v97 = (__ROR4__(v171, 6) ^ __ROR4__(v171, 11) ^ __ROR4__(v171, 25))
      + v253
      + (v137 ^ (v154 ^ v137) & v171)
      + v35
      + 338241895;
  v188 = v97 + v187;
  v254 = (v203 & (v237 | v220) | v237 & v220) + (__ROR4__(v237, 2) ^ __ROR4__(v237, 13) ^ __ROR4__(v237, 22)) + v97;
  v36 = (__ROR4__(v34, 17) ^ __ROR4__(v34, 19) ^ (v34 >> 10))
      + v29
      + ((v21 >> 3) ^ __ROR4__(v21, 7) ^ __ROR4__(v21, 18))
      + v20;
  v98 = (__ROR4__(v188, 6) ^ __ROR4__(v188, 11) ^ __ROR4__(v188, 25))
      + v137
      + (v154 ^ (v171 ^ v154) & v188)
      + v36
      + 666307205;
  v204 = v98 + v203;
  v138 = (v220 & (v254 | v237) | v254 & v237) + (__ROR4__(v254, 2) ^ __ROR4__(v254, 13) ^ __ROR4__(v254, 22)) + v98;
  v37 = (__ROR4__(v35, 17) ^ __ROR4__(v35, 19) ^ (v35 >> 10))
      + v30
      + ((v22 >> 3) ^ __ROR4__(v22, 7) ^ __ROR4__(v22, 18))
      + v21;
  v99 = (__ROR4__(v204, 6) ^ __ROR4__(v204, 11) ^ __ROR4__(v204, 25))
      + v154
      + (v171 ^ (v188 ^ v171) & v204)
      + v37
      + 773529912;
  v221 = v99 + v220;
  v155 = (v237 & (v138 | v254) | v138 & v254) + (__ROR4__(v138, 2) ^ __ROR4__(v138, 13) ^ __ROR4__(v138, 22)) + v99;
  v38 = (__ROR4__(v36, 17) ^ __ROR4__(v36, 19) ^ (v36 >> 10))
      + v31
      + ((v23 >> 3) ^ __ROR4__(v23, 7) ^ __ROR4__(v23, 18))
      + v22;
  v100 = (__ROR4__(v221, 6) ^ __ROR4__(v221, 11) ^ __ROR4__(v221, 25))
       + v171
       + (v188 ^ (v204 ^ v188) & v221)
       + v38
       + 1294757372;
  v238 = v100 + v237;
  v172 = (v254 & (v155 | v138) | v155 & v138) + (__ROR4__(v155, 2) ^ __ROR4__(v155, 13) ^ __ROR4__(v155, 22)) + v100;
  v39 = (__ROR4__(v37, 17) ^ __ROR4__(v37, 19) ^ (v37 >> 10))
      + v32
      + ((v24 >> 3) ^ __ROR4__(v24, 7) ^ __ROR4__(v24, 18))
      + v23;
  v101 = (__ROR4__(v238, 6) ^ __ROR4__(v238, 11) ^ __ROR4__(v238, 25))
       + v188
       + (v204 ^ (v221 ^ v204) & v238)
       + v39
       + 1396182291;
  v255 = v101 + v254;
  v189 = (v138 & (v172 | v155) | v172 & v155) + (__ROR4__(v172, 2) ^ __ROR4__(v172, 13) ^ __ROR4__(v172, 22)) + v101;
  v40 = (__ROR4__(v38, 17) ^ __ROR4__(v38, 19) ^ (v38 >> 10))
      + v33
      + ((v25 >> 3) ^ __ROR4__(v25, 7) ^ __ROR4__(v25, 18))
      + v24;
  v102 = (__ROR4__(v255, 6) ^ __ROR4__(v255, 11) ^ __ROR4__(v255, 25))
       + v204
       + (v221 ^ (v238 ^ v221) & v255)
       + v40
       + 1695183700;
  v139 = v102 + v138;
  v205 = (v155 & (v189 | v172) | v189 & v172) + (__ROR4__(v189, 2) ^ __ROR4__(v189, 13) ^ __ROR4__(v189, 22)) + v102;
  v41 = (__ROR4__(v39, 17) ^ __ROR4__(v39, 19) ^ (v39 >> 10))
      + v34
      + ((v26 >> 3) ^ __ROR4__(v26, 7) ^ __ROR4__(v26, 18))
      + v25;
  v103 = (__ROR4__(v139, 6) ^ __ROR4__(v139, 11) ^ __ROR4__(v139, 25))
       + v221
       + (v238 ^ (v255 ^ v238) & v139)
       + v41
       + 1986661051;
  v156 = v103 + v155;
  v222 = (v172 & (v205 | v189) | v205 & v189) + (__ROR4__(v205, 2) ^ __ROR4__(v205, 13) ^ __ROR4__(v205, 22)) + v103;
  v42 = (__ROR4__(v40, 17) ^ __ROR4__(v40, 19) ^ (v40 >> 10))
      + v35
      + ((v27 >> 3) ^ __ROR4__(v27, 7) ^ __ROR4__(v27, 18))
      + v26;
  v104 = (__ROR4__(v156, 6) ^ __ROR4__(v156, 11) ^ __ROR4__(v156, 25))
       + v238
       + (v255 ^ (v139 ^ v255) & v156)
       + v42
       - 2117940946;
  v173 = v104 + v172;
  v239 = (v189 & (v222 | v205) | v222 & v205) + (__ROR4__(v222, 2) ^ __ROR4__(v222, 13) ^ __ROR4__(v222, 22)) + v104;
  v43 = (__ROR4__(v41, 17) ^ __ROR4__(v41, 19) ^ (v41 >> 10))
      + v36
      + ((v28 >> 3) ^ __ROR4__(v28, 7) ^ __ROR4__(v28, 18))
      + v27;
  v105 = (__ROR4__(v173, 6) ^ __ROR4__(v173, 11) ^ __ROR4__(v173, 25))
       + v255
       + (v139 ^ (v156 ^ v139) & v173)
       + v43
       - 1838011259;
  v190 = v105 + v189;
  v256 = (v205 & (v239 | v222) | v239 & v222) + (__ROR4__(v239, 2) ^ __ROR4__(v239, 13) ^ __ROR4__(v239, 22)) + v105;
  v44 = (__ROR4__(v42, 17) ^ __ROR4__(v42, 19) ^ (v42 >> 10))
      + v37
      + ((v29 >> 3) ^ __ROR4__(v29, 7) ^ __ROR4__(v29, 18))
      + v28;
  v106 = (__ROR4__(v190, 6) ^ __ROR4__(v190, 11) ^ __ROR4__(v190, 25))
       + v139
       + (v156 ^ (v173 ^ v156) & v190)
       + v44
       - 1564481375;
  v206 = v106 + v205;
  v140 = (v222 & (v256 | v239) | v256 & v239) + (__ROR4__(v256, 2) ^ __ROR4__(v256, 13) ^ __ROR4__(v256, 22)) + v106;
  v45 = (__ROR4__(v43, 17) ^ __ROR4__(v43, 19) ^ (v43 >> 10))
      + v38
      + ((v30 >> 3) ^ __ROR4__(v30, 7) ^ __ROR4__(v30, 18))
      + v29;
  v107 = (__ROR4__(v206, 6) ^ __ROR4__(v206, 11) ^ __ROR4__(v206, 25))
       + v156
       + (v173 ^ (v190 ^ v173) & v206)
       + v45
       - 1474664885;
  v223 = v107 + v222;
  v157 = (v239 & (v140 | v256) | v140 & v256) + (__ROR4__(v140, 2) ^ __ROR4__(v140, 13) ^ __ROR4__(v140, 22)) + v107;
  v46 = (__ROR4__(v44, 17) ^ __ROR4__(v44, 19) ^ (v44 >> 10))
      + v39
      + ((v31 >> 3) ^ __ROR4__(v31, 7) ^ __ROR4__(v31, 18))
      + v30;
  v108 = (__ROR4__(v223, 6) ^ __ROR4__(v223, 11) ^ __ROR4__(v223, 25))
       + v173
       + (v190 ^ (v206 ^ v190) & v223)
       + v46
       - 1035236496;
  v240 = v108 + v239;
  v174 = (v256 & (v157 | v140) | v157 & v140) + (__ROR4__(v157, 2) ^ __ROR4__(v157, 13) ^ __ROR4__(v157, 22)) + v108;
  v47 = (__ROR4__(v45, 17) ^ __ROR4__(v45, 19) ^ (v45 >> 10))
      + v40
      + ((v32 >> 3) ^ __ROR4__(v32, 7) ^ __ROR4__(v32, 18))
      + v31;
  v109 = (__ROR4__(v240, 6) ^ __ROR4__(v240, 11) ^ __ROR4__(v240, 25))
       + v190
       + (v206 ^ (v223 ^ v206) & v240)
       + v47
       - 949202525;
  v257 = v109 + v256;
  v191 = (v140 & (v174 | v157) | v174 & v157) + (__ROR4__(v174, 2) ^ __ROR4__(v174, 13) ^ __ROR4__(v174, 22)) + v109;
  v48 = (__ROR4__(v46, 17) ^ __ROR4__(v46, 19) ^ (v46 >> 10))
      + v41
      + ((v33 >> 3) ^ __ROR4__(v33, 7) ^ __ROR4__(v33, 18))
      + v32;
  v110 = (__ROR4__(v257, 6) ^ __ROR4__(v257, 11) ^ __ROR4__(v257, 25))
       + v206
       + (v223 ^ (v240 ^ v223) & v257)
       + v48
       - 778901479;
  v141 = v110 + v140;
  v207 = (v157 & (v191 | v174) | v191 & v174) + (__ROR4__(v191, 2) ^ __ROR4__(v191, 13) ^ __ROR4__(v191, 22)) + v110;
  v49 = (__ROR4__(v47, 17) ^ __ROR4__(v47, 19) ^ (v47 >> 10))
      + v42
      + ((v34 >> 3) ^ __ROR4__(v34, 7) ^ __ROR4__(v34, 18))
      + v33;
  v111 = (__ROR4__(v141, 6) ^ __ROR4__(v141, 11) ^ __ROR4__(v141, 25))
       + v223
       + (v240 ^ (v257 ^ v240) & v141)
       + v49
       - 694614492;
  v158 = v111 + v157;
  v224 = (v174 & (v207 | v191) | v207 & v191) + (__ROR4__(v207, 2) ^ __ROR4__(v207, 13) ^ __ROR4__(v207, 22)) + v111;
  v50 = (__ROR4__(v48, 17) ^ __ROR4__(v48, 19) ^ (v48 >> 10))
      + v43
      + ((v35 >> 3) ^ __ROR4__(v35, 7) ^ __ROR4__(v35, 18))
      + v34;
  v112 = (__ROR4__(v158, 6) ^ __ROR4__(v158, 11) ^ __ROR4__(v158, 25))
       + v240
       + (v257 ^ (v141 ^ v257) & v158)
       + v50
       - 200395387;
  v175 = v112 + v174;
  v241 = (v191 & (v224 | v207) | v224 & v207) + (__ROR4__(v224, 2) ^ __ROR4__(v224, 13) ^ __ROR4__(v224, 22)) + v112;
  v51 = (__ROR4__(v49, 17) ^ __ROR4__(v49, 19) ^ (v49 >> 10))
      + v44
      + ((v36 >> 3) ^ __ROR4__(v36, 7) ^ __ROR4__(v36, 18))
      + v35;
  v113 = (__ROR4__(v175, 6) ^ __ROR4__(v175, 11) ^ __ROR4__(v175, 25))
       + v257
       + (v141 ^ (v158 ^ v141) & v175)
       + v51
       + 275423344;
  v192 = v113 + v191;
  v258 = (v207 & (v241 | v224) | v241 & v224) + (__ROR4__(v241, 2) ^ __ROR4__(v241, 13) ^ __ROR4__(v241, 22)) + v113;
  v52 = (__ROR4__(v50, 17) ^ __ROR4__(v50, 19) ^ (v50 >> 10))
      + v45
      + ((v37 >> 3) ^ __ROR4__(v37, 7) ^ __ROR4__(v37, 18))
      + v36;
  v114 = (__ROR4__(v192, 6) ^ __ROR4__(v192, 11) ^ __ROR4__(v192, 25))
       + v141
       + (v158 ^ (v175 ^ v158) & v192)
       + v52
       + 430227734;
  v208 = v114 + v207;
  v142 = (v224 & (v258 | v241) | v258 & v241) + (__ROR4__(v258, 2) ^ __ROR4__(v258, 13) ^ __ROR4__(v258, 22)) + v114;
  v53 = (__ROR4__(v51, 17) ^ __ROR4__(v51, 19) ^ (v51 >> 10))
      + v46
      + ((v38 >> 3) ^ __ROR4__(v38, 7) ^ __ROR4__(v38, 18))
      + v37;
  v115 = (__ROR4__(v208, 6) ^ __ROR4__(v208, 11) ^ __ROR4__(v208, 25))
       + v158
       + (v175 ^ (v192 ^ v175) & v208)
       + v53
       + 506948616;
  v225 = v115 + v224;
  v159 = (v241 & (v142 | v258) | v142 & v258) + (__ROR4__(v142, 2) ^ __ROR4__(v142, 13) ^ __ROR4__(v142, 22)) + v115;
  v54 = (__ROR4__(v52, 17) ^ __ROR4__(v52, 19) ^ (v52 >> 10))
      + v47
      + ((v39 >> 3) ^ __ROR4__(v39, 7) ^ __ROR4__(v39, 18))
      + v38;
  v116 = (__ROR4__(v225, 6) ^ __ROR4__(v225, 11) ^ __ROR4__(v225, 25))
       + v175
       + (v192 ^ (v208 ^ v192) & v225)
       + v54
       + 659060556;
  v242 = v116 + v241;
  v176 = (v258 & (v159 | v142) | v159 & v142) + (__ROR4__(v159, 2) ^ __ROR4__(v159, 13) ^ __ROR4__(v159, 22)) + v116;
  v55 = (__ROR4__(v53, 17) ^ __ROR4__(v53, 19) ^ (v53 >> 10))
      + v48
      + ((v40 >> 3) ^ __ROR4__(v40, 7) ^ __ROR4__(v40, 18))
      + v39;
  v117 = (__ROR4__(v242, 6) ^ __ROR4__(v242, 11) ^ __ROR4__(v242, 25))
       + v192
       + (v208 ^ (v225 ^ v208) & v242)
       + v55
       + 883997877;
  v259 = v117 + v258;
  v193 = (v142 & (v176 | v159) | v176 & v159) + (__ROR4__(v176, 2) ^ __ROR4__(v176, 13) ^ __ROR4__(v176, 22)) + v117;
  v56 = (__ROR4__(v54, 17) ^ __ROR4__(v54, 19) ^ (v54 >> 10))
      + v49
      + ((v41 >> 3) ^ __ROR4__(v41, 7) ^ __ROR4__(v41, 18))
      + v40;
  v118 = (__ROR4__(v259, 6) ^ __ROR4__(v259, 11) ^ __ROR4__(v259, 25))
       + v208
       + (v225 ^ (v242 ^ v225) & v259)
       + v56
       + 958139571;
  v143 = v118 + v142;
  v209 = (v159 & (v193 | v176) | v193 & v176) + (__ROR4__(v193, 2) ^ __ROR4__(v193, 13) ^ __ROR4__(v193, 22)) + v118;
  v57 = (__ROR4__(v55, 17) ^ __ROR4__(v55, 19) ^ (v55 >> 10))
      + v50
      + ((v42 >> 3) ^ __ROR4__(v42, 7) ^ __ROR4__(v42, 18))
      + v41;
  v119 = (__ROR4__(v143, 6) ^ __ROR4__(v143, 11) ^ __ROR4__(v143, 25))
       + v225
       + (v242 ^ (v259 ^ v242) & v143)
       + v57
       + 1322822218;
  v160 = v119 + v159;
  v226 = (v176 & (v209 | v193) | v209 & v193) + (__ROR4__(v209, 2) ^ __ROR4__(v209, 13) ^ __ROR4__(v209, 22)) + v119;
  v58 = (__ROR4__(v56, 17) ^ __ROR4__(v56, 19) ^ (v56 >> 10))
      + v51
      + ((v43 >> 3) ^ __ROR4__(v43, 7) ^ __ROR4__(v43, 18))
      + v42;
  v120 = (__ROR4__(v160, 6) ^ __ROR4__(v160, 11) ^ __ROR4__(v160, 25))
       + v242
       + (v259 ^ (v143 ^ v259) & v160)
       + v58
       + 1537002063;
  v177 = v120 + v176;
  v243 = (v193 & (v226 | v209) | v226 & v209) + (__ROR4__(v226, 2) ^ __ROR4__(v226, 13) ^ __ROR4__(v226, 22)) + v120;
  v59 = (__ROR4__(v57, 17) ^ __ROR4__(v57, 19) ^ (v57 >> 10))
      + v52
      + ((v44 >> 3) ^ __ROR4__(v44, 7) ^ __ROR4__(v44, 18))
      + v43;
  v121 = (__ROR4__(v177, 6) ^ __ROR4__(v177, 11) ^ __ROR4__(v177, 25))
       + v259
       + (v143 ^ (v160 ^ v143) & v177)
       + v59
       + 1747873779;
  v194 = v121 + v193;
  v260 = (v209 & (v243 | v226) | v243 & v226) + (__ROR4__(v243, 2) ^ __ROR4__(v243, 13) ^ __ROR4__(v243, 22)) + v121;
  v60 = (__ROR4__(v58, 17) ^ __ROR4__(v58, 19) ^ (v58 >> 10))
      + v53
      + ((v45 >> 3) ^ __ROR4__(v45, 7) ^ __ROR4__(v45, 18))
      + v44;
  v122 = (__ROR4__(v194, 6) ^ __ROR4__(v194, 11) ^ __ROR4__(v194, 25))
       + v143
       + (v160 ^ (v177 ^ v160) & v194)
       + v60
       + 1955562222;
  v210 = v122 + v209;
  v144 = (v226 & (v260 | v243) | v260 & v243) + (__ROR4__(v260, 2) ^ __ROR4__(v260, 13) ^ __ROR4__(v260, 22)) + v122;
  v61 = (__ROR4__(v59, 17) ^ __ROR4__(v59, 19) ^ (v59 >> 10))
      + v54
      + ((v46 >> 3) ^ __ROR4__(v46, 7) ^ __ROR4__(v46, 18))
      + v45;
  v123 = (__ROR4__(v210, 6) ^ __ROR4__(v210, 11) ^ __ROR4__(v210, 25))
       + v160
       + (v177 ^ (v194 ^ v177) & v210)
       + v61
       + 2024104815;
  v227 = v123 + v226;
  v161 = (v243 & (v144 | v260) | v144 & v260) + (__ROR4__(v144, 2) ^ __ROR4__(v144, 13) ^ __ROR4__(v144, 22)) + v123;
  v62 = (__ROR4__(v60, 17) ^ __ROR4__(v60, 19) ^ (v60 >> 10))
      + v55
      + ((v47 >> 3) ^ __ROR4__(v47, 7) ^ __ROR4__(v47, 18))
      + v46;
  v124 = (__ROR4__(v227, 6) ^ __ROR4__(v227, 11) ^ __ROR4__(v227, 25))
       + v177
       + (v194 ^ (v210 ^ v194) & v227)
       + v62
       - 2067236844;
  v244 = v124 + v243;
  v178 = (v260 & (v161 | v144) | v161 & v144) + (__ROR4__(v161, 2) ^ __ROR4__(v161, 13) ^ __ROR4__(v161, 22)) + v124;
  v63 = (__ROR4__(v61, 17) ^ __ROR4__(v61, 19) ^ (v61 >> 10))
      + v56
      + ((v48 >> 3) ^ __ROR4__(v48, 7) ^ __ROR4__(v48, 18))
      + v47;
  v125 = (__ROR4__(v244, 6) ^ __ROR4__(v244, 11) ^ __ROR4__(v244, 25))
       + v194
       + (v210 ^ (v227 ^ v210) & v244)
       + v63
       - 1933114872;
  v261 = v125 + v260;
  v195 = (v144 & (v178 | v161) | v178 & v161) + (__ROR4__(v178, 2) ^ __ROR4__(v178, 13) ^ __ROR4__(v178, 22)) + v125;
  v64 = (__ROR4__(v62, 17) ^ __ROR4__(v62, 19) ^ (v62 >> 10))
      + v57
      + ((v49 >> 3) ^ __ROR4__(v49, 7) ^ __ROR4__(v49, 18))
      + v48;
  v126 = (__ROR4__(v261, 6) ^ __ROR4__(v261, 11) ^ __ROR4__(v261, 25))
       + v210
       + (v227 ^ (v244 ^ v227) & v261)
       + v64
       - 1866530822;
  v145 = v126 + v144;
  v211 = (v161 & (v195 | v178) | v195 & v178) + (__ROR4__(v195, 2) ^ __ROR4__(v195, 13) ^ __ROR4__(v195, 22)) + v126;
  v65 = (__ROR4__(v63, 17) ^ __ROR4__(v63, 19) ^ (v63 >> 10))
      + v58
      + ((v50 >> 3) ^ __ROR4__(v50, 7) ^ __ROR4__(v50, 18))
      + v49;
  v127 = (__ROR4__(v145, 6) ^ __ROR4__(v145, 11) ^ __ROR4__(v145, 25))
       + v227
       + (v244 ^ (v261 ^ v244) & v145)
       + v65
       - 1538233109;
  v162 = v127 + v161;
  v228 = (v178 & (v211 | v195) | v211 & v195) + (__ROR4__(v211, 2) ^ __ROR4__(v211, 13) ^ __ROR4__(v211, 22)) + v127;
  v128 = (__ROR4__(v162, 6) ^ __ROR4__(v162, 11) ^ __ROR4__(v162, 25))
       + v244
       + (v261 ^ (v145 ^ v261) & v162)
       + (__ROR4__(v64, 17) ^ __ROR4__(v64, 19) ^ (v64 >> 10))
       + v59
       + ((v51 >> 3) ^ __ROR4__(v51, 7) ^ __ROR4__(v51, 18))
       + v50
       - 1090935817;
  v179 = v128 + v178;
  v245 = (v195 & (v228 | v211) | v228 & v211) + (__ROR4__(v228, 2) ^ __ROR4__(v228, 13) ^ __ROR4__(v228, 22)) + v128;
  v129 = (__ROR4__(v179, 6) ^ __ROR4__(v179, 11) ^ __ROR4__(v179, 25))
       + v261
       + (v145 ^ (v162 ^ v145) & v179)
       + (__ROR4__(v65, 17) ^ __ROR4__(v65, 19) ^ (v65 >> 10))
       + v60
       + ((v52 >> 3) ^ __ROR4__(v52, 7) ^ __ROR4__(v52, 18))
       + v51
       - 965641998;
  result = v245 | v228;
  a1[2] += (v211 & (v245 | v228) | v245 & v228) + (__ROR4__(v245, 2) ^ __ROR4__(v245, 13) ^ __ROR4__(v245, 22)) + v129;
  a1[3] += v245;
  a1[4] += v228;
  a1[5] += v211;
  a1[6] += v129 + v195;
  a1[7] += v179;
  a1[8] += v162;
  a1[9] += v145;
  return result;
}

//----- (0003282C) --------------------------------------------------------
_DWORD *__fastcall sha2_update(_DWORD *result, unsigned int *a2, int a3)
{
  int v3; // [sp+4h] [bp+4h]
  unsigned int *src; // [sp+8h] [bp+8h]
  _DWORD *v5; // [sp+Ch] [bp+Ch]
  signed int n; // [sp+10h] [bp+10h]
  int v7; // [sp+14h] [bp+14h]

  v5 = result;
  src = a2;
  v3 = a3;
  if ( a3 > 0 )
  {
    v7 = *result & 0x3F;
    n = 64 - v7;
    *result += a3;
    *result = *result;
    if ( *result < (unsigned int)a3 )
      ++result[1];
    if ( v7 && a3 >= n )
    {
      memcpy((char *)result + v7 + 40, a2, n);
      result = (_DWORD *)sha2_process(v5, v5 + 10);
      src = (unsigned int *)((char *)src + n);
      v3 -= n;
      v7 = 0;
    }
    while ( v3 > 63 )
    {
      result = (_DWORD *)sha2_process(v5, src);
      src += 16;
      v3 -= 64;
    }
    if ( v3 > 0 )
      return memcpy((char *)v5 + v7 + 40, src, v3);
  }
  return result;
}

//----- (000328FC) --------------------------------------------------------
_DWORD *__fastcall sha2_finish(_DWORD *a1, _BYTE *a2)
{
  int v2; // r3
  _DWORD *result; // r0
  unsigned int v6; // [sp+8h] [bp+8h] BYREF
  char v7; // [sp+Ch] [bp+Ch]
  char v8; // [sp+Dh] [bp+Dh]
  char v9; // [sp+Eh] [bp+Eh]
  char v10; // [sp+Fh] [bp+Fh]
  int v11; // [sp+10h] [bp+10h]
  unsigned int v12; // [sp+14h] [bp+14h]
  __int64 v13; // [sp+18h] [bp+18h]

  v13 = 8LL * *(_QWORD *)a1;
  LOBYTE(v6) = HIBYTE(v13);
  BYTE1(v6) = BYTE6(v13);
  BYTE2(v6) = BYTE5(v13);
  HIBYTE(v6) = BYTE4(v13);
  v7 = BYTE3(v13);
  v8 = BYTE2(v13);
  v9 = BYTE1(v13);
  v10 = v13;
  v12 = *a1 & 0x3F;
  if ( v12 > 0x37 )
    v2 = 120 - v12;
  else
    v2 = 56 - v12;
  v11 = v2;
  sha2_update(a1, sha2_padding, v2);
  result = sha2_update(a1, &v6, 8);
  *a2 = HIBYTE(a1[2]);
  a2[1] = BYTE2(a1[2]);
  a2[2] = BYTE1(a1[2]);
  a2[3] = a1[2];
  a2[4] = HIBYTE(a1[3]);
  a2[5] = BYTE2(a1[3]);
  a2[6] = BYTE1(a1[3]);
  a2[7] = a1[3];
  a2[8] = HIBYTE(a1[4]);
  a2[9] = BYTE2(a1[4]);
  a2[10] = BYTE1(a1[4]);
  a2[11] = a1[4];
  a2[12] = HIBYTE(a1[5]);
  a2[13] = BYTE2(a1[5]);
  a2[14] = BYTE1(a1[5]);
  a2[15] = a1[5];
  a2[16] = HIBYTE(a1[6]);
  a2[17] = BYTE2(a1[6]);
  a2[18] = BYTE1(a1[6]);
  a2[19] = a1[6];
  a2[20] = HIBYTE(a1[7]);
  a2[21] = BYTE2(a1[7]);
  a2[22] = BYTE1(a1[7]);
  a2[23] = a1[7];
  a2[24] = HIBYTE(a1[8]);
  a2[25] = BYTE2(a1[8]);
  a2[26] = BYTE1(a1[8]);
  a2[27] = a1[8];
  a2[28] = HIBYTE(a1[9]);
  a2[29] = BYTE2(a1[9]);
  a2[30] = BYTE1(a1[9]);
  a2[31] = a1[9];
  return result;
}
// 36D94: using guessed type unsigned int sha2_padding[16];

//----- (00032B50) --------------------------------------------------------
void *__fastcall sha2(unsigned int *a1, int a2, _BYTE *a3)
{
  _DWORD s[58]; // [sp+10h] [bp+10h] BYREF

  sha2_starts(s);
  sha2_update(s, a1, a2);
  sha2_finish(s, a3);
  return memset(s, 0, sizeof(s));
}

//----- (00032B98) --------------------------------------------------------
unsigned int __fastcall swab32(unsigned int a1)
{
  return bswap32(a1);
}

//----- (00032BB0) --------------------------------------------------------
unsigned int __fastcall flip_swab(unsigned int result, int a2, unsigned int a3)
{
  unsigned int v5; // [sp+18h] [bp+18h]
  unsigned int i; // [sp+1Ch] [bp+1Ch]

  v5 = result;
  for ( i = 0; a3 >> 2 > i; ++i )
  {
    result = swab32(*(_DWORD *)(4 * i + a2));
    *(_DWORD *)(v5 + 4 * i) = result;
  }
  return result;
}

//----- (00032C00) --------------------------------------------------------
unsigned int __fastcall flip32(unsigned int result, int a2)
{
  unsigned int v3; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  v3 = result;
  for ( i = 0; i <= 7; ++i )
  {
    result = swab32(*(_DWORD *)(4 * i + a2));
    *(_DWORD *)(v3 + 4 * i) = result;
  }
  return result;
}

//----- (00032C48) --------------------------------------------------------
int __fastcall slt_notify_ui(int result, int a2)
{
  char s[1024]; // [sp+10h] [bp+8h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(s, 0x400u, "pass %d bin %d\n", result, a2);
    return applog(2, s, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00032CB8) --------------------------------------------------------
int slt_init()
{
  return 0;
}

//----- (00032CC8) --------------------------------------------------------
int slt_exit()
{
  return 0;
}

//----- (00032CD8) --------------------------------------------------------
_BYTE *__fastcall _bin2hex(_BYTE *result, int a2, int a3)
{
  _BYTE *v3; // r2
  _BYTE *v5; // [sp+Ch] [bp+Ch]
  int i; // [sp+14h] [bp+14h]

  v5 = result;
  for ( i = 0; i < a3; ++i )
  {
    *v5 = hex_6139[*(_BYTE *)(i + a2) >> 4];
    v3 = v5 + 1;
    v5 += 2;
    *v3 = hex_6139[*(_BYTE *)(i + a2) & 0xF];
  }
  *v5 = 0;
  return result;
}
// 3720C: using guessed type _BYTE hex_6139[16];

//----- (00032D4C) --------------------------------------------------------
_BYTE *__fastcall bin2hex(int a1, int a2)
{
  _BYTE *v5; // [sp+8h] [bp+8h]
  int nmemb; // [sp+Ch] [bp+Ch]

  nmemb = 2 * a2 + 1;
  if ( (nmemb & 3) != 0 )
    nmemb = (nmemb & 0xFFFFFFFC) + 4;
  v5 = calloc(nmemb, 1u);
  if ( !v5 )
    fwrite("Failed to calloc", 1u, 0x10u, (FILE *)_bss_start);
  _bin2hex(v5, a1, a2);
  return v5;
}
// 47DA8: using guessed type int _bss_start;

//----- (00032DB4) --------------------------------------------------------
int __fastcall hex2bin(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v4; // r3
  _BYTE *v5; // r3
  int v10; // [sp+10h] [bp+10h]
  int v11; // [sp+14h] [bp+14h]
  int v12; // [sp+1Ch] [bp+1Ch]

  v12 = 0;
  while ( *a2 && a3 )
  {
    if ( !a2[1] )
      return 0;
    v11 = hex2bin_tbl[*a2];
    v4 = a2 + 1;
    a2 += 2;
    v10 = hex2bin_tbl[*v4];
    if ( v11 < 0 || v10 < 0 )
      return 0;
    v5 = a1++;
    *v5 = v10 | (16 * v11);
    --a3;
  }
  if ( !a3 && !*a2 )
    return 1;
  return v12;
}
// 36DF8: using guessed type _DWORD hex2bin_tbl[256];

//----- (00032E68) --------------------------------------------------------
int __fastcall swap_bit(unsigned __int8 a1)
{
  int i; // [sp+8h] [bp+8h]
  unsigned __int8 v3; // [sp+Fh] [bp+Fh]

  v3 = 0;
  for ( i = 0; i <= 7; ++i )
  {
    if ( (((int)a1 >> i) & 1) != 0 )
      v3 |= 1 << (7 - i);
  }
  return v3;
}

//----- (00032EC0) --------------------------------------------------------
void __fastcall dump_str(FILE *a1, const char *a2, int a3, int a4)
{
  char *ptr; // [sp+1Ch] [bp+14h]

  if ( a1 )
  {
    ptr = bin2hex(a3, a4);
    if ( a2 )
      fprintf(a1, "%s %s len=%d\n", a2, ptr, a4);
    else
      fprintf(a1, "%s\n", ptr);
    fflush(a1);
    free(ptr);
  }
}

//----- (00032F24) --------------------------------------------------------
int __fastcall bit_read(int a1, int a2)
{
  int v2; // r3
  int v3; // r3

  v2 = a2 & 7;
  if ( a2 <= 0 )
    v2 = -(-a2 & 7);
  switch ( v2 )
  {
    case 0:
      v3 = (*(_BYTE *)(a1 + a2 / 8) & 1) != 0;
      break;
    case 1:
      v3 = (*(_BYTE *)(a1 + a2 / 8) & 2) != 0;
      break;
    case 2:
      v3 = (*(_BYTE *)(a1 + a2 / 8) & 4) != 0;
      break;
    case 3:
      v3 = (*(_BYTE *)(a1 + a2 / 8) & 8) != 0;
      break;
    case 4:
      v3 = (*(_BYTE *)(a1 + a2 / 8) & 0x10) != 0;
      break;
    case 5:
      v3 = (*(_BYTE *)(a1 + a2 / 8) & 0x20) != 0;
      break;
    case 6:
      v3 = (*(_BYTE *)(a1 + a2 / 8) & 0x40) != 0;
      break;
    case 7:
      v3 = *(_BYTE *)(a1 + a2 / 8) >> 7;
      break;
    default:
      v3 = 0;
      break;
  }
  return v3;
}

//----- (000330A4) --------------------------------------------------------
_DWORD *__fastcall swab256(_DWORD *result, unsigned int *a2)
{
  *result = bswap32(a2[7]);
  result[1] = bswap32(a2[6]);
  result[2] = bswap32(a2[5]);
  result[3] = bswap32(a2[4]);
  result[4] = bswap32(a2[3]);
  result[5] = bswap32(a2[2]);
  result[6] = bswap32(a2[1]);
  result[7] = bswap32(*a2);
  return result;
}

//----- (000333AE) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_333F0 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 333B2: variable 'v2' is possibly undefined

//----- (00033658) --------------------------------------------------------
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (00033664) --------------------------------------------------------
void __fastcall init(int argc, char **argv, char **envp)
{
  int v6; // r5
  int i; // r4
  void (__fastcall *v8)(int, char **, char **); // r3

  init_proc();
  v6 = &_do_global_dtors_aux_fini_array_entry - &_frame_dummy_init_array_entry;
  if ( v6 )
  {
    for ( i = 0; i != v6; ++i )
    {
      v8 = (void (__fastcall *)(int, char **, char **))*(&_frame_dummy_init_array_entry + i);
      v8(argc, argv, envp);
    }
  }
}
// 47228: using guessed type _UNKNOWN *_frame_dummy_init_array_entry;
// 4722C: using guessed type _UNKNOWN *_do_global_dtors_aux_fini_array_entry;

//----- (000336A8) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=404 queued=275 decompiled=275 lumina nreq=0 worse=0 better=0
// ALL OK, 275 function(s) have been successfully decompiled

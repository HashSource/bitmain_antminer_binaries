;
; +-------------------------------------------------------------------------+
; |      This file was generated by The Interactive Disassembler (IDA)      |
; |           Copyright (c) 2025 Hex-Rays, <support@hex-rays.com>           |
; |                      License info: 48-2137-ACAB-99                      |
; |                              elf <elv@ven>                              |
; +-------------------------------------------------------------------------+
;
; Input SHA256 : 58095F70F9D7FA8CD68D221FF9647BD5D5B52B6B11FE87742A3183DB28BBDE12
; Input MD5    : 781C2D73BE3D87AE4DAE779CB669440B
; Input CRC32  : 46061135
; Compiler     : GNU C++

; File Name   : /home/danielsokil/Lab/HashSource/bitmain_antminer_binaries/S17pro/single-board-test
; Format      : ELF for ARM (Executable)
; Imagebase   : 10000
; Interpreter '/lib/ld-linux-armhf.so.3'
; Needed Library 'libpthread.so.0'
; Needed Library 'libc.so.6'
;
; Options     : EF_ARM_VFP_FLOAT
; EABI version: 5
;
; Source File : '/home/tcwg-buildslave/workspace/tcwg-make-release/builder_arch/amd64/label/tcwg-x86_64-build/target/arm-linux-gnueabihf/_build/builds/x86_64-unknown-linux-gnu/arm-linux-gnueabihf/glibc.git~linaro~2.21~master/csu/abi-note.o'
; Source File : '/home/tcwg-buildslave/workspace/tcwg-make-release/builder_arch/amd64/label/tcwg-x86_64-build/target/arm-linux-gnueabihf/_build/builds/x86_64-unknown-linux-gnu/arm-linux-gnueabihf/glibc.git~linaro~2.21~master/csu/start.o'
; Source File : 'init.c'
; Source File : '/opt/toolchains/xilinx/gcc-linaro-5.5.0-2017.10-x86_64_arm-linux-gnueabihf/bin/../arm-linux-gnueabihf/libc/usr/lib/crti.o'
; Source File : '/opt/toolchains/xilinx/gcc-linaro-5.5.0-2017.10-x86_64_arm-linux-gnueabihf/bin/../arm-linux-gnueabihf/libc/usr/lib/crtn.o'
; Source File : 'main.c'
; Source File : 'crtstuff.c'
; Source File : 'BM1385.c'
; Source File : 'crc.c'
; Source File : 'reset.c'
; Source File : 'BM1391.c'
; Source File : 'plug.c'
; Source File : 'lcd.c'
; Source File : 'uart.c'
; Source File : 'bhb91603.c'
; Source File : 'config.c'
; Source File : 'v9.c'
; Source File : 'i2c.c'
; Source File : 'power.c'
; Source File : 'pwm.c'
; Source File : 'sha2.c'
; Source File : 'bhb91601.c'
; Source File : 'key.c'
; Source File : 'sha2_c5.c'
; Source File : 'bhb07601.c'
; Source File : 'global.c'
; Source File : 'led.c'
; Source File : 'pic.c'
; Source File : 'temperature.c'
; Source File : 'eeprom.c'
; Source File : 'pattern.c'
; Source File : 'fpga.c'
; Source File : 'BM1397.c'
; Source File : '_udivsi3.o'
; Source File : '_dvmd_lnx.o'
; Source File : 'elf-init.c'
; Source File : 'crtstuff.c'

; Processor       : ARM
; ARM architecture: ARMv7-A
; Target assembler: Generic assembler for ARM
; Byte sex        : Little endian


; Segment type: Pure code
AREA LOAD, CODE, ALIGN=0
; ORG 0x10000
CODE32
dword_10000 DCD 0x464C457F ; File format: \x7FELF
DCB 1                   ; File class: 32-bit
DCB 1                   ; Data encoding: little-endian
DCB 1                   ; File version
DCB 0                   ; OS/ABI: UNIX System V ABI
DCB 0                   ; ABI Version
DCB 0, 0, 0, 0, 0, 0, 0 ; Padding
DCW 2                   ; File type: Executable
DCW 0x28                ; Machine: ARM
DCD 1                   ; File version
DCD _start+1            ; Entry point
DCD 0x34                ; PHT file offset
DCD 0x8F6F8             ; SHT file offset
DCD 0x5000402           ; Processor-specific flags
DCW 0x34                ; ELF header size
DCW 0x20                ; PHT entry size
DCW 8                   ; Number of entries in PHT
DCW 0x28                ; SHT entry size
DCW 0x26                ; Number of entries in SHT
DCW 0x23                ; SHT entry index for string table
; LOAD ends

; ELF32 Program Header
; PHT Entry 0

; Segment type: Pure code
AREA PHDR, CODE
; ORG 0x10034
CODE32
dword_10034 DCD 0x70000001 ; Type: EXIDX
DCD 0x1F404             ; File offset
DCD unk_2F404           ; Virtual address
DCD 0x2F404             ; Physical address
DCD 8                   ; Size in file image
DCD 8                   ; Size in memory image
DCD 4                   ; Flags
DCD 4                   ; Alignment
; PHT Entry 1
DCD 6                   ; Type: PHDR
DCD 0x34                ; File offset
DCD dword_10034         ; Virtual address
DCD 0x10034             ; Physical address
DCD 0x100               ; Size in file image
DCD 0x100               ; Size in memory image
DCD 5                   ; Flags
DCD 4                   ; Alignment
; PHT Entry 2
DCD 3                   ; Type: INTERP
DCD 0x134               ; File offset
DCD aLibLdLinuxArmh     ; Virtual address
DCD 0x10134             ; Physical address
DCD 0x19                ; Size in file image
DCD 0x19                ; Size in memory image
DCD 4                   ; Flags
DCD 1                   ; Alignment
; PHT Entry 3
DCD 1                   ; Type: LOAD
DCD 0                   ; File offset
DCD dword_10000         ; Virtual address
DCD 0x10000             ; Physical address
DCD 0x1F410             ; Size in file image
DCD 0x1F410             ; Size in memory image
DCD 5                   ; Flags
DCD 0x10000             ; Alignment
; PHT Entry 4
DCD 1                   ; Type: LOAD
DCD 0x20000             ; File offset
DCD __frame_dummy_init_array_entry ; Virtual address
DCD 0x30000             ; Physical address
DCD 0xD4C               ; Size in file image
DCD 0x309CA4            ; Size in memory image
DCD 6                   ; Flags
DCD 0x10000             ; Alignment
; PHT Entry 5
DCD 2                   ; Type: DYNAMIC
DCD 0x2000C             ; File offset
DCD _DYNAMIC            ; Virtual address
DCD 0x3000C             ; Physical address
DCD 0xF0                ; Size in file image
DCD 0xF0                ; Size in memory image
DCD 6                   ; Flags
DCD 4                   ; Alignment
; PHT Entry 6
DCD 4                   ; Type: NOTE
DCD 0x150               ; File offset
DCD dword_10150         ; Virtual address
DCD 0x10150             ; Physical address
DCD 0x44                ; Size in file image
DCD 0x44                ; Size in memory image
DCD 4                   ; Flags
DCD 4                   ; Alignment
; PHT Entry 7
DCD 0x6474E551          ; Type: STACK
DCD 0                   ; File offset
DCD 0                   ; Virtual address
DCD 0                   ; Physical address
DCD 0                   ; Size in file image
DCD 0                   ; Size in memory image
DCD 6                   ; Flags
DCD 0x10                ; Alignment
; PHDR ends


; Segment type: Pure code
AREA LOAD, CODE, ALIGN=0
; ORG 0x10134
CODE32
aLibLdLinuxArmh DCB "/lib/ld-linux-armhf.so.3",0
DCB 0, 0, 0
; ELF Note Entry
dword_10150 DCD 4       ; Name Size
DCD 0x10                ; Desc Size
DCD 1                   ; Type: NT_GNU_ABI_TAG
aGnu DCB "GNU",0        ; Name
DCD 0, 2, 6, 0x20       ; ABI: Linux 2.6.32
; ELF Note Entry
DCD 4                   ; Name Size
DCD 0x14                ; Desc Size
DCD 3                   ; Type: NT_GNU_BUILD_ID
aGnu_0 DCB "GNU",0      ; Name
DCB 0xF8, 0x10, 5, 0xD, 0xEF, 0xE, 0xE1 ; Desc
DCB 0xD1, 0x9D, 0xBF, 0xAE, 0x27, 0x21, 0xC3
DCB 0x5A, 0x48, 0x6D, 0xDF, 0xF1, 0xB
; ELF Hash Table
elf_hash_nbucket DCD 0x25
elf_hash_nchain DCD 0x2F
elf_hash_bucket DCD 0x2C, 0x28, 0xD, 0, 0x26, 0, 0x23, 0xE
DCD 0x1B, 0xC, 0xA, 0, 0x14, 0, 0x19, 0x25
DCD 0x2E, 0x1D, 0x17, 0x29, 0, 0x27, 0, 0x18
DCD 0, 0, 2, 0x2B, 0x22, 0x1E, 3, 9, 0x21
DCD 0x2D, 0, 0, 0
elf_hash_chain DCD 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 1
DCD 0, 0, 5, 0, 7, 0, 8, 0, 0xB, 0, 0, 0
DCD 0x11, 0, 0x16, 0x13, 0xF, 0, 0x12, 0
DCD 0, 0, 0x15, 0x20, 6, 0, 0x1C, 0x1A, 0x10
DCD 0x24, 0x1F, 0, 0, 0x2A
; ELF Symbol Table
Elf32_Sym <0>
Elf32_Sym <aPthreadMutexUn - byte_105DC,\ ; "pthread_mutex_unlock"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aCalloc - byte_105DC, 0, 0, \ ; "calloc"
           0x12, 0, 0>
Elf32_Sym <aStrstr - byte_105DC, 0, 0, \ ; "strstr"
           0x12, 0, 0>
Elf32_Sym <aRaise - byte_105DC, 0, 0, \ ; "raise"
           0x12, 0, 0>
Elf32_Sym <aItmDeregistert - byte_105DC,\ ; "_ITM_deregisterTMCloneTable"
           0, 0, 0x20, 0, 0>
Elf32_Sym <aSprintf+1 - byte_105DC, 0, \ ; "printf"
           0, 0x12, 0, 0>
Elf32_Sym <aFopen - byte_105DC, 0, 0, \ ; "fopen"
           0x12, 0, 0>
Elf32_Sym <aRead - byte_105DC, 0, 0, \ ; "read"
           0x12, 0, 0>
Elf32_Sym <aFree - byte_105DC, 0, 0, \ ; "free"
           0x12, 0, 0>
Elf32_Sym <aFgets - byte_105DC, 0, 0, \ ; "fgets"
           0x12, 0, 0>
Elf32_Sym <aPthreadMutexLo - byte_105DC,\ ; "pthread_mutex_lock"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aPthreadSelf - byte_105DC, 0,\ ; "pthread_self"
           0, 0x12, 0, 0>
Elf32_Sym <aMemcpy - byte_105DC, 0, 0, \ ; "memcpy"
           0x12, 0, 0>
Elf32_Sym <aPthreadMutexIn - byte_105DC,\ ; "pthread_mutex_init"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aLseek - byte_105DC, 0, 0, \ ; "lseek"
           0x12, 0, 0>
Elf32_Sym <aMemcmp - byte_105DC, 0, 0, \ ; "memcmp"
           0x12, 0, 0>
Elf32_Sym <aUsleep+1 - byte_105DC, 0, 0,\ ; "sleep"
           0x12, 0, 0>
Elf32_Sym <aUsleep - byte_105DC, 0, 0, \ ; "usleep"
           0x12, 0, 0>
Elf32_Sym <aStrcpy - byte_105DC, 0, 0, \ ; "strcpy"
           0x12, 0, 0>
Elf32_Sym <aGettimeofday - byte_105DC, \ ; "gettimeofday"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aPthreadCreate - byte_105DC, \ ; "pthread_create"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aSchedGetPriori - byte_105DC,\ ; "sched_get_priority_max"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aPuts - byte_105DC, 0, 0, \ ; "puts"
           0x12, 0, 0>
Elf32_Sym <aMalloc - byte_105DC, 0, 0, \ ; "malloc"
           0x12, 0, 0>
Elf32_Sym <aLibcStartMain - byte_105DC, \ ; "__libc_start_main"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aSystem - byte_105DC, 0, 0, \ ; "system"
           0x12, 0, 0>
Elf32_Sym <aGmonStart - byte_105DC, 0, \ ; "__gmon_start__"
           0, 0x20, 0, 0>
Elf32_Sym <aFopen+1 - byte_105DC, 0, 0, \ ; "open"
           0x12, 0, 0>
Elf32_Sym <aStrtoul - byte_105DC, 0, 0, \ ; "strtoul"
           0x12, 0, 0>
Elf32_Sym <aStrlen - byte_105DC, 0, 0, \ ; "strlen"
           0x12, 0, 0>
Elf32_Sym <aMmap - byte_105DC, 0, 0, \ ; "mmap"
           0x12, 0, 0>
Elf32_Sym <aIsoc99Sscanf - byte_105DC, \ ; "__isoc99_sscanf"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aMemset - byte_105DC, 0, 0, \ ; "memset"
           0x12, 0, 0>
Elf32_Sym <aPutchar - byte_105DC, 0, 0, \ ; "putchar"
           0x12, 0, 0>
Elf32_Sym <aPthreadCancel - byte_105DC, \ ; "pthread_cancel"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aWrite - byte_105DC, 0, 0, \ ; "write"
           0x12, 0, 0>
Elf32_Sym <aFclose - byte_105DC, 0, 0, \ ; "fclose"
           0x12, 0, 0>
Elf32_Sym <aMunmap - byte_105DC, 0, 0, \ ; "munmap"
           0x12, 0, 0>
Elf32_Sym <aPthreadJoin - byte_105DC, 0,\ ; "pthread_join"
           0, 0x12, 0, 0>
Elf32_Sym <aJvRegisterclas - byte_105DC,\ ; "_Jv_RegisterClasses"
           0, 0, 0x20, 0, 0>
Elf32_Sym <aSprintf - byte_105DC, 0, 0, \ ; "sprintf"
           0x12, 0, 0>
Elf32_Sym <aPthreadSetsche - byte_105DC,\ ; "pthread_setschedparam"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aItmRegistertmc - byte_105DC,\ ; "_ITM_registerTMCloneTable"
           0, 0, 0x20, 0, 0>
Elf32_Sym <aFseek - byte_105DC, 0, 0, \ ; "fseek"
           0x12, 0, 0>
Elf32_Sym <aAbort - byte_105DC, 0, 0, \ ; "abort"
           0x12, 0, 0>
Elf32_Sym <aFclose+1 - byte_105DC, 0, 0,\ ; "close"
           0x12, 0, 0>
; ELF String Table
byte_105DC DCB 0
aLibpthreadSo0 DCB "libpthread.so.0",0
aItmDeregistert DCB "_ITM_deregisterTMCloneTable",0
aJvRegisterclas DCB "_Jv_RegisterClasses",0
aItmRegistertmc DCB "_ITM_registerTMCloneTable",0
aPthreadMutexUn DCB "pthread_mutex_unlock",0
aPthreadJoin DCB "pthread_join",0
aPthreadCreate DCB "pthread_create",0
aPthreadCancel DCB "pthread_cancel",0
aRaise DCB "raise",0
aLseek DCB "lseek",0
aPthreadMutexLo DCB "pthread_mutex_lock",0
aPthreadSelf DCB "pthread_self",0
aRead DCB "read",0
aWrite DCB "write",0
aPthreadSetsche DCB "pthread_setschedparam",0
aSystem DCB "system",0
aPthreadMutexIn DCB "pthread_mutex_init",0
aLibcSo6 DCB "libc.so.6",0
aStrcpy DCB "strcpy",0
aSprintf DCB "sprintf",0
aFopen DCB "fopen",0
aIsoc99Sscanf DCB "__isoc99_sscanf",0
aPuts DCB "puts",0
aPutchar DCB "putchar",0
aAbort DCB "abort",0
aMmap DCB "mmap",0
aFgets DCB "fgets",0
aCalloc DCB "calloc",0
aStrlen DCB "strlen",0
aMemset DCB "memset",0
aStrstr DCB "strstr",0
aFseek DCB "fseek",0
aMemcmp DCB "memcmp",0
aMemcpy DCB "memcpy",0
aFclose DCB "fclose",0
aStrtoul DCB "strtoul",0
aMalloc DCB "malloc",0
aMunmap DCB "munmap",0
aUsleep DCB "usleep",0
aGettimeofday DCB "gettimeofday",0
aSchedGetPriori DCB "sched_get_priority_max",0
aLibcStartMain DCB "__libc_start_main",0
aFree DCB "free",0
aGmonStart DCB "__gmon_start__",0
aGlibc27 DCB "GLIBC_2.7",0
aGlibc24 DCB "GLIBC_2.4",0
DCB 0
; ELF GNU Symbol Version Table
DCW 0
DCW 2                   ; pthread_mutex_unlock@@GLIBC_2.4
DCW 3                   ; calloc@@GLIBC_2.4
DCW 3                   ; strstr@@GLIBC_2.4
DCW 2                   ; raise@@GLIBC_2.4
DCW 0                   ; local  symbol: _ITM_deregisterTMCloneTable
DCW 3                   ; printf@@GLIBC_2.4
DCW 3                   ; fopen@@GLIBC_2.4
DCW 2                   ; read@@GLIBC_2.4
DCW 3                   ; free@@GLIBC_2.4
DCW 3                   ; fgets@@GLIBC_2.4
DCW 2                   ; pthread_mutex_lock@@GLIBC_2.4
DCW 2                   ; pthread_self@@GLIBC_2.4
DCW 3                   ; memcpy@@GLIBC_2.4
DCW 2                   ; pthread_mutex_init@@GLIBC_2.4
DCW 2                   ; lseek@@GLIBC_2.4
DCW 3                   ; memcmp@@GLIBC_2.4
DCW 3                   ; sleep@@GLIBC_2.4
DCW 3                   ; usleep@@GLIBC_2.4
DCW 3                   ; strcpy@@GLIBC_2.4
DCW 3                   ; gettimeofday@@GLIBC_2.4
DCW 2                   ; pthread_create@@GLIBC_2.4
DCW 3                   ; sched_get_priority_max@@GLIBC_2.4
DCW 3                   ; puts@@GLIBC_2.4
DCW 3                   ; malloc@@GLIBC_2.4
DCW 3                   ; __libc_start_main@@GLIBC_2.4
DCW 2                   ; system@@GLIBC_2.4
DCW 0                   ; local  symbol: __gmon_start__
DCW 2                   ; open@@GLIBC_2.4
DCW 3                   ; strtoul@@GLIBC_2.4
DCW 3                   ; strlen@@GLIBC_2.4
DCW 3                   ; mmap@@GLIBC_2.4
DCW 4                   ; __isoc99_sscanf@@GLIBC_2.7
DCW 3                   ; memset@@GLIBC_2.4
DCW 3                   ; putchar@@GLIBC_2.4
DCW 2                   ; pthread_cancel@@GLIBC_2.4
DCW 2                   ; write@@GLIBC_2.4
DCW 3                   ; fclose@@GLIBC_2.4
DCW 3                   ; munmap@@GLIBC_2.4
DCW 2                   ; pthread_join@@GLIBC_2.4
DCW 0                   ; local  symbol: _Jv_RegisterClasses
DCW 3                   ; sprintf@@GLIBC_2.4
DCW 2                   ; pthread_setschedparam@@GLIBC_2.4
DCW 0                   ; local  symbol: _ITM_registerTMCloneTable
DCW 3                   ; fseek@@GLIBC_2.4
DCW 3                   ; abort@@GLIBC_2.4
DCW 2                   ; close@@GLIBC_2.4
; ELF GNU Symbol Version Requirements
Elf32_Verneed <1, 2, \  ; "libc.so.6"
               aLibcSo6 - byte_105DC, \
               0x10, 0x30>
Elf32_Vernaux <0xD696917, 0, 4, \ ; "GLIBC_2.7"
               aGlibc27 - byte_105DC, \
               0x10>
Elf32_Vernaux <0xD696914, 0, 3, \ ; "GLIBC_2.4"
               aGlibc24 - byte_105DC, 0>
Elf32_Verneed <1, 1, \  ; "libpthread.so.0"
               aLibpthreadSo0 - byte_105DC,\
               0x10, 0>
Elf32_Vernaux <0xD696914, 0, 2, \ ; "GLIBC_2.4"
               aGlibc24 - byte_105DC, 0>
; ELF REL Relocation Table
Elf32_Rel <0x301B4, 0x1B15> ; R_ARM_GLOB_DAT __gmon_start__
; ELF JMPREL Relocation Table
Elf32_Rel <0x30108, 0x116> ; R_ARM_JUMP_SLOT pthread_mutex_unlock
Elf32_Rel <0x3010C, 0x216> ; R_ARM_JUMP_SLOT calloc
Elf32_Rel <0x30110, 0x316> ; R_ARM_JUMP_SLOT strstr
Elf32_Rel <0x30114, 0x416> ; R_ARM_JUMP_SLOT raise
Elf32_Rel <0x30118, 0x616> ; R_ARM_JUMP_SLOT printf
Elf32_Rel <0x3011C, 0x716> ; R_ARM_JUMP_SLOT fopen
Elf32_Rel <0x30120, 0x816> ; R_ARM_JUMP_SLOT read
Elf32_Rel <0x30124, 0x916> ; R_ARM_JUMP_SLOT free
Elf32_Rel <0x30128, 0xA16> ; R_ARM_JUMP_SLOT fgets
Elf32_Rel <0x3012C, 0xB16> ; R_ARM_JUMP_SLOT pthread_mutex_lock
Elf32_Rel <0x30130, 0xC16> ; R_ARM_JUMP_SLOT pthread_self
Elf32_Rel <0x30134, 0xD16> ; R_ARM_JUMP_SLOT memcpy
Elf32_Rel <0x30138, 0xE16> ; R_ARM_JUMP_SLOT pthread_mutex_init
Elf32_Rel <0x3013C, 0xF16> ; R_ARM_JUMP_SLOT lseek
Elf32_Rel <0x30140, 0x1016> ; R_ARM_JUMP_SLOT memcmp
Elf32_Rel <0x30144, 0x1116> ; R_ARM_JUMP_SLOT sleep
Elf32_Rel <0x30148, 0x1216> ; R_ARM_JUMP_SLOT usleep
Elf32_Rel <0x3014C, 0x1316> ; R_ARM_JUMP_SLOT strcpy
Elf32_Rel <0x30150, 0x1416> ; R_ARM_JUMP_SLOT gettimeofday
Elf32_Rel <0x30154, 0x1516> ; R_ARM_JUMP_SLOT pthread_create
Elf32_Rel <0x30158, 0x1616> ; R_ARM_JUMP_SLOT sched_get_priority_max
Elf32_Rel <0x3015C, 0x1716> ; R_ARM_JUMP_SLOT puts
Elf32_Rel <0x30160, 0x1816> ; R_ARM_JUMP_SLOT malloc
Elf32_Rel <0x30164, 0x1916> ; R_ARM_JUMP_SLOT __libc_start_main
Elf32_Rel <0x30168, 0x1A16> ; R_ARM_JUMP_SLOT system
Elf32_Rel <0x3016C, 0x1B16> ; R_ARM_JUMP_SLOT __gmon_start__
Elf32_Rel <0x30170, 0x1C16> ; R_ARM_JUMP_SLOT open
Elf32_Rel <0x30174, 0x1D16> ; R_ARM_JUMP_SLOT strtoul
Elf32_Rel <0x30178, 0x1E16> ; R_ARM_JUMP_SLOT strlen
Elf32_Rel <0x3017C, 0x1F16> ; R_ARM_JUMP_SLOT mmap
Elf32_Rel <0x30180, 0x2016> ; R_ARM_JUMP_SLOT __isoc99_sscanf
Elf32_Rel <0x30184, 0x2116> ; R_ARM_JUMP_SLOT memset
Elf32_Rel <0x30188, 0x2216> ; R_ARM_JUMP_SLOT putchar
Elf32_Rel <0x3018C, 0x2316> ; R_ARM_JUMP_SLOT pthread_cancel
Elf32_Rel <0x30190, 0x2416> ; R_ARM_JUMP_SLOT write
Elf32_Rel <0x30194, 0x2516> ; R_ARM_JUMP_SLOT fclose
Elf32_Rel <0x30198, 0x2616> ; R_ARM_JUMP_SLOT munmap
Elf32_Rel <0x3019C, 0x2716> ; R_ARM_JUMP_SLOT pthread_join
Elf32_Rel <0x301A0, 0x2916> ; R_ARM_JUMP_SLOT sprintf
Elf32_Rel <0x301A4, 0x2A16> ; R_ARM_JUMP_SLOT pthread_setschedparam
Elf32_Rel <0x301A8, 0x2C16> ; R_ARM_JUMP_SLOT fseek
Elf32_Rel <0x301AC, 0x2D16> ; R_ARM_JUMP_SLOT abort
Elf32_Rel <0x301B0, 0x2E16> ; R_ARM_JUMP_SLOT close
; LOAD ends


; Segment type: Pure code
AREA .init, CODE
; ORG 0x109EC
CODE32


; Alternative name is '_init'

; int init_proc()
EXPORT .init_proc
.init_proc
PUSH            {R3,LR}
BL              call_weak_fn
POP             {R3,PC}
; End of function .init_proc

; .init ends


; Segment type: Pure code
AREA .plt, CODE
; ORG 0x109F8
CODE32



; void sub_109F8()
sub_109F8
PUSH            {LR}
LDR             LR, =_GLOBAL_OFFSET_TABLE_ ; PIC mode
NOP
LDR             PC, [LR,#(off_30104 - 0x300FC)]!
; End of function sub_109F8

off_10A08 DCD _GLOBAL_OFFSET_TABLE_
CODE16
; [00000004 BYTES: COLLAPSED FUNCTION j_pthread_mutex_unlock]
CODE32
; [0000000C BYTES: COLLAPSED FUNCTION pthread_mutex_unlock]
; [0000000C BYTES: COLLAPSED FUNCTION calloc]
; [0000000C BYTES: COLLAPSED FUNCTION strstr]
; [0000000C BYTES: COLLAPSED FUNCTION raise]
CODE16
; [00000004 BYTES: COLLAPSED FUNCTION j_printf]
CODE32
; [0000000C BYTES: COLLAPSED FUNCTION printf]
; [0000000C BYTES: COLLAPSED FUNCTION fopen]
; [0000000C BYTES: COLLAPSED FUNCTION read]
; [0000000C BYTES: COLLAPSED FUNCTION free]
; [0000000C BYTES: COLLAPSED FUNCTION fgets]
; [0000000C BYTES: COLLAPSED FUNCTION pthread_mutex_lock]
; [0000000C BYTES: COLLAPSED FUNCTION pthread_self]
CODE16
; [00000004 BYTES: COLLAPSED FUNCTION j_memcpy]
CODE32
; [0000000C BYTES: COLLAPSED FUNCTION memcpy]
; [0000000C BYTES: COLLAPSED FUNCTION pthread_mutex_init]
; [0000000C BYTES: COLLAPSED FUNCTION lseek]
; [0000000C BYTES: COLLAPSED FUNCTION memcmp]
; [0000000C BYTES: COLLAPSED FUNCTION sleep]
CODE16
; [00000004 BYTES: COLLAPSED FUNCTION j_usleep]
CODE32
; [0000000C BYTES: COLLAPSED FUNCTION usleep]
; [0000000C BYTES: COLLAPSED FUNCTION strcpy]
; [0000000C BYTES: COLLAPSED FUNCTION gettimeofday]
; [0000000C BYTES: COLLAPSED FUNCTION pthread_create]
; [0000000C BYTES: COLLAPSED FUNCTION sched_get_priority_max]
CODE16
; [00000004 BYTES: COLLAPSED FUNCTION j_puts]
CODE32
; [0000000C BYTES: COLLAPSED FUNCTION puts]
; [0000000C BYTES: COLLAPSED FUNCTION malloc]
; [0000000C BYTES: COLLAPSED FUNCTION __libc_start_main]
; [0000000C BYTES: COLLAPSED FUNCTION system]
; [0000000C BYTES: COLLAPSED FUNCTION __gmon_start__]
; [0000000C BYTES: COLLAPSED FUNCTION open]
; [0000000C BYTES: COLLAPSED FUNCTION strtoul]
; [0000000C BYTES: COLLAPSED FUNCTION strlen]
; [0000000C BYTES: COLLAPSED FUNCTION mmap]
; [0000000C BYTES: COLLAPSED FUNCTION __isoc99_sscanf]
CODE16
; [00000004 BYTES: COLLAPSED FUNCTION j_memset]
CODE32
; [0000000C BYTES: COLLAPSED FUNCTION memset]
; [0000000C BYTES: COLLAPSED FUNCTION putchar]
; [0000000C BYTES: COLLAPSED FUNCTION pthread_cancel]
CODE16
; [00000004 BYTES: COLLAPSED FUNCTION j_write]
CODE32
; [0000000C BYTES: COLLAPSED FUNCTION write]
; [0000000C BYTES: COLLAPSED FUNCTION fclose]
; [0000000C BYTES: COLLAPSED FUNCTION munmap]
; [0000000C BYTES: COLLAPSED FUNCTION pthread_join]
; [0000000C BYTES: COLLAPSED FUNCTION sprintf]
; [0000000C BYTES: COLLAPSED FUNCTION pthread_setschedparam]
; [0000000C BYTES: COLLAPSED FUNCTION fseek]
; [0000000C BYTES: COLLAPSED FUNCTION abort]
CODE16
; [00000004 BYTES: COLLAPSED FUNCTION j_close]
CODE32
; [0000000C BYTES: COLLAPSED FUNCTION close]

; Segment type: Pure code
AREA .text, CODE, ALIGN=3
; ORG 0x10C30
CODE16



; int __fastcall main(int argc, const char **argv, const char **envp)
EXPORT main
main

command= -1

MOVW            R0, #:lower16:aVersion ; "--- version:"
PUSH            {R4,LR}
MOVT            R0, #:upper16:aVersion ; "--- version:"
SUB             SP, SP, #8
BLX             puts
MOV             R0, #aLastCommitVers ; "last commit version: 4e0ba0e commit tim"...
BLX             puts
BL              cgpu_init
ret = R0                ; int
CMP             ret, #0
BLT             loc_10C94
BL              configMiner
ret = R0                ; int
CMP             ret, #0
BLT             loc_10C94
BL              display_arguments
MOVW            R0, #:lower16:aReadyBeginTest ; "\n\nReady begin test\n"
MOVW            R4, #:lower16:aPressTestKeyTo ; "\nPress 'test' key to continue"
MOVT            R0, #:upper16:aReadyBeginTest ; "\n\nReady begin test\n"
MOVT            R4, #:upper16:aPressTestKeyTo ; "\nPress 'test' key to continue"
BLX             puts

loc_10C74               ; value
ADD.W           R0, SP, #8+command
BL              read_key
ret = R0                ; int
CMP             ret, #0
BLE             loc_10C74
LDRB.W          R3, [SP,#8+command]
CMP             R3, #0x30 ; '0'
BNE             loc_10C74
BL              hash_board_test
MOV             R0, R4  ; s
BLX             puts
B               loc_10C74

loc_10C94
ret = R0                ; int
ADD             SP, SP, #8
POP             {R4,PC}
; End of function main



; Attributes: noreturn

; void __noreturn start(void (*)(), int, int, int, ...)
EXPORT _start
_start

arg_0=  0

MOV.W           R11, #0
MOV.W           LR, #0
POP             {R1}    ; argc
MOV             R2, SP  ; ubp_av
PUSH            {R2}    ; stack_end
PUSH            {R0}    ; rtld_fini
LDR.W           R12, =(__libc_csu_fini+1)
PUSH.W          {R12}   ; fini
LDR             R0, =(main+1) ; main
LDR             R3, =(init+1) ; init
BLX             __libc_start_main
BLX             abort
; End of function _start

off_10CBC DCD __libc_csu_fini+1
off_10CC0 DCD main+1
off_10CC4 DCD init+1
CODE32



; int call_weak_fn()
call_weak_fn
LDR             R3, =(_GLOBAL_OFFSET_TABLE_ - 0x10CD8)
LDR             R2, =(__gmon_start___ptr_0 - 0x300FC)
ADD             R3, PC, R3 ; _GLOBAL_OFFSET_TABLE_
LDR             R2, [R3,R2] ; __imp___gmon_start__
CMP             R2, #0
BXEQ            LR
B               __gmon_start__
; End of function call_weak_fn

off_10CE4 DCD _GLOBAL_OFFSET_TABLE_ - 0x10CD8
off_10CE8 DCD __gmon_start___ptr_0 - 0x300FC
CODE16



; char *deregister_tm_clones()
deregister_tm_clones
LDR             R3, =0x30D4F
MOV             R0, #__TMC_END__
SUBS            R3, R3, R0
CMP             R3, #6
BLS             locret_10D08
MOV             R3, #0
CBZ             R3, locret_10D08
BX              R3

locret_10D08
BX              LR
; End of function deregister_tm_clones

ALIGN 4
dword_10D0C DCD 0x30D4F



; __int64 register_tm_clones()
register_tm_clones
MOVW            R3, #:lower16:__TMC_END__
MOVW            R0, #:lower16:__TMC_END__
MOVT            R3, #:upper16:__TMC_END__
MOVT            R0, #:upper16:__TMC_END__
SUBS            R1, R3, R0
ASRS            R1, R1, #2
ADD.W           R1, R1, R1,LSR#31
ASRS            R1, R1, #1
BEQ             locret_10D38
MOV             R3, #0
CBZ             R3, locret_10D38
BX              R3

locret_10D38
BX              LR
; End of function register_tm_clones

ALIGN 4



; char *_do_global_dtors_aux()
__do_global_dtors_aux
PUSH            {R4,LR}
MOV             R4, #__TMC_END__
LDRB            R3, [R4]
CBNZ            R3, locret_10D52
BL              deregister_tm_clones
MOVS            R3, #1
STRB            R3, [R4]

locret_10D52
POP             {R4,PC}
; End of function __do_global_dtors_aux




; __int64 frame_dummy()
frame_dummy
MOVW            R0, #:lower16:__JCR_LIST__
PUSH            {R3,LR}
MOVT            R0, #:upper16:__JCR_LIST__
LDR             R3, [R0]
CBNZ            R3, loc_10D68

loc_10D62
POP.W           {R3,LR}
B               register_tm_clones

loc_10D68
MOV             R3, #0
CMP             R3, #0
BEQ             loc_10D62
BLX             R3
B               loc_10D62
; End of function frame_dummy



; Attributes: noreturn

; void *__fastcall __noreturn single_BM1385_show_status_func(void *arg)
EXPORT single_BM1385_show_status_func
single_BM1385_show_status_func
chain_info = R0         ; chain_info *
which_chain = R9        ; unsigned __int8
PUSH.W          {R4-R10,LR}
MOVS            R3, #0
MOVW            R8, #:lower16:gValid_Nonce_Num
MOVW            R7, #:lower16:lcd_fd
MOVW            R5, #:lower16:lcd_output
MOVW            R6, #:lower16:aTimeDs ; "   time %ds"
MOVW            R4, #:lower16:time_counter
MOVT            R8, #:upper16:gValid_Nonce_Num
MOVT            R7, #:upper16:lcd_fd
MOVT            R5, #:upper16:lcd_output
MOVT            R6, #:upper16:aTimeDs ; "   time %ds"
MOV             R10, R3
MOVT            R4, #:upper16:time_counter
LDRB.W          which_chain, [chain_info]
STR             R3, [R4]

loc_10DAE               ; n
MOVS            R2, #0x40 ; '@'
MOVS            R1, #0x20 ; ' ' ; c
MOV             R0, R5  ; s
BLX             memset
MOV             R2, R10
MOV             R1, R6  ; format
LDR             R0, =(lcd_output+0x10) ; s
BLX             sprintf
MOVW            R1, #:lower16:aNonceD ; "   nonce=%d"
LDR.W           R2, [R8,which_chain,LSL#2]
MOVT            R1, #:upper16:aNonceD ; "   nonce=%d"
LDR             R0, =(lcd_output+0x20) ; s
BLX             sprintf
LDR             R3, [R4]
MOVS            R2, #0x40 ; '@' ; n
MOV             R1, R5  ; buf
LDR             R0, [R7] ; fd
ADDS            R3, #1
STR             R3, [R4]
BLX             write
MOVS            R0, #0xA ; speed
BL              set_fan_speed
MOV             R0, #(gAsic_Core_Nonce_Num+0xC33FC) ; useconds
BLX             usleep
LDR.W           R10, [R4]
B               loc_10DAE
; End of function single_BM1385_show_status_func

off_10DFC DCD lcd_output+0x10
off_10E00 DCD lcd_output+0x20



; void *__fastcall single_BM1385_send_func(void *arg)
EXPORT single_BM1385_send_func
single_BM1385_send_func

var_6C= -0x6C
var_64= -0x64
mutex= -0x60
work= -0x5C
var_58= -0x58
var_54= -0x54
test_core_number= -0x50
test_core_index= -0x4C
var_48= -0x48
data_fil= -0x44

chain_info = R0         ; chain_info *
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x6C
LDRB.W          R8, [chain_info]
which_chain = R8        ; unsigned __int8
MOVS            R2, #0x40 ; '@' ; n
MOVS            R1, #0  ; c
MOVW            R11, #:lower16:Conf
ADD             chain_info, SP, #0x6C+data_fil ; s
MOVT            R11, #:upper16:Conf
BLX             memset
MOVS            R3, #0
LDR.W           R0, [R11,#configuration.OpenCoreNum1]
MOV             R6, R3
LDR.W           R1, [R11,#configuration.OpenCoreNum2]
LDR.W           R2, [R11,#configuration.OpenCoreNum3]
MOVS            R4, #0xFF
LDR.W           R3, [R11,#configuration.OpenCoreNum4]
MOVS            R5, #0x20 ; ' '
STRB.W          R4, [SP,#0x6C+data_fil]
OpenCoreNum1 = R0       ; unsigned int
OpenCoreNum2 = R1       ; unsigned int
OpenCoreNum3 = R2       ; unsigned int
OpenCoreNum4 = R3       ; unsigned int
MOV             R4, R6

loc_10E3E
test_core_number_0 = R4 ; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum1 = R0       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum2 = R1       ; unsigned int
TST.W           OpenCoreNum3, #1
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum3 = R2       ; unsigned int
TST.W           OpenCoreNum4, #1
MOV.W           OpenCoreNum4, OpenCoreNum4,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum4 = R3       ; unsigned int
SUBS            R5, #1
BNE             loc_10E3E
MOVW            OpenCoreNum2, #:lower16:__FUNCTION__.8222 ; "single_BM1385_send_func"
MOVW            OpenCoreNum1, #:lower16:aSThereAreDCore ; "%s: There are %d cores should be test\n"...
MOVT            R1, #:upper16:__FUNCTION__.8222 ; "single_BM1385_send_func"
MOVT            R0, #:upper16:aSThereAreDCore ; "%s: There are %d cores should be test\n"...
MOV             OpenCoreNum3, test_core_number_0
STR             test_core_number_0, [SP,#0x6C+test_core_number]
BLX             printf
CMP             test_core_number_0, #0
BEQ.W           loc_11002
ADD.W           test_core_number_0, which_chain, which_chain,LSL#4
LDR             R6, =(cgpu.workdataFilePrefix+0x3C)
MOVW            R3, #:lower16:HW_check_mutex
ADD.W           R1, which_chain, which_chain,LSL#1
LSLS            R4, R4, #9
MOVW            R0, #:lower16:gWorks_For_Hw_Check
MOVT            R3, #:upper16:HW_check_mutex
LDR.W           R2, [R11,#configuration.pattern_number]
MOVT            R0, #:upper16:gWorks_For_Hw_Check
ADD.W           R3, R3, R1,LSL#3
MOVW            R9, #:lower16:gSend_Work_Num
STR             R6, [SP,#0x6C+var_48]
MOVT            R9, #:upper16:gSend_Work_Num
ADD.W           R6, R4, #0x2180
ADD             R4, R0
STR             R3, [SP,#0x6C+mutex]
ADD.W           R3, R6, #0x3C ; '<'
STR             R0, [SP,#0x6C+var_58]
STR             R5, [SP,#0x6C+test_core_index]
STR             R3, [SP,#0x6C+var_54]
STR.W           R11, [SP,#0x6C+var_64]

loc_10ED4
LDR             R3, [SP,#0x6C+var_48]
LDR.W           R6, [R3,#4]!
STR             R3, [SP,#0x6C+var_48]
works = R6              ; work *
CMP             R2, #0
BEQ             loc_10FB0
MOVW            R10, #:lower16:gWork_Num_For_Hw_Check
ADDS            works, #0x13
MOVT            R10, #:upper16:gWork_Num_For_Hw_Check
MOVS            R7, #0
ADD.W           R5, SP, #0x6C+data_fil+0x1F

loc_10EF0
which_pattern = R7      ; unsigned int
SUB.W           R3, R6, #0x13
MOVS            R2, #0x40 ; '@' ; n
MOVS            R1, #0  ; c
ADD             R0, SP, #0x6C+data_fil ; s
STR             R3, [SP,#0x6C+work]
work_0 = R3             ; work *
BLX             memset
ADD.W           R3, SP, #0x6C+var_48+3
MOV             R2, R6

loc_10F06
LDRB.W          R1, [R2,#1]!
STRB.W          R1, [R3,#1]!
CMP             R3, R5
BNE             loc_10F06
LDR.W           R1, [R6,#-0xF]
temp_nonce = R1         ; unsigned int
SUB.W           R3, R6, #0xC
ADD.W           R2, SP, #0x6C+data_fil+0x33
STRB.W          which_pattern, [SP,#0x6C+data_fil+0x33]
STRB.W          temp_nonce, [SP,#0x6C+data_fil+0x2F]
MOV.W           LR, temp_nonce,LSR#24
LSRS            R0, temp_nonce, #0x10
LSRS            temp_nonce, temp_nonce, #8
STRB.W          LR, [SP,#0x6C+data_fil+0x2C]
STRB.W          R0, [SP,#0x6C+data_fil+0x2D]
STRB.W          R1, [SP,#0x6C+data_fil+0x2E]

loc_10F3A
LDRB.W          R1, [R3,#1]!
CMP             R3, R6
STRB.W          R1, [R2,#1]!
BNE             loc_10F3A
MOVS            R2, #0x40 ; '@' ; length
ADD             R1, SP, #0x6C+data_fil ; buf
MOV             R0, which_chain ; which_uart
BL              uart_send
LDR             R0, [SP,#0x6C+mutex] ; mutex
BLX             pthread_mutex_lock
LDR             R3, [SP,#0x6C+var_58]
LDR             R2, [SP,#0x6C+var_54]
ADDS            R0, R3, R2 ; dest

loc_10F5C
SUB.W           R11, R0, #0x44 ; 'D'
MOVS            R2, #0x44 ; 'D' ; n
MOV             R1, R11 ; src
BLX             memcpy
CMP             R4, R11
MOV             R0, R11
BNE             loc_10F5C
LDRB.W          R3, [R10]
MOVS            R2, #0x44 ; 'D' ; n
LDR             R1, [SP,#0x6C+work] ; src
MOV             R0, R4  ; dest
ADDS            which_pattern, #1
ADDS            R6, #0x44 ; 'D'
ADDS            R3, #1
UXTB            R3, R3
CMP             R3, #0x7E ; '~'
IT HI
MOVHI           R3, #0x7F
STRB.W          R3, [R10]
BLX             memcpy
LDR             R0, [SP,#0x6C+mutex] ; mutex
BLX             pthread_mutex_unlock
LDR.W           R3, [R9,which_chain,LSL#2]
LDR             R2, [SP,#0x6C+var_64]
ADDS            R3, #1
LDR.W           R0, [R2,#configuration.timeout] ; useconds
STR.W           R3, [R9,which_chain,LSL#2]
BLX             usleep
which_pattern = R7      ; unsigned int
LDR             R2, [SP,#0x6C+var_64]
LDR             R2, [R2,#configuration.pattern_number]
CMP             R2, which_pattern
BHI             loc_10EF0

loc_10FB0
LDR             R3, [SP,#0x6C+test_core_index]
LDR             R1, [SP,#0x6C+test_core_number]
ADDS            R3, #1
CMP             R1, R3
STR             R3, [SP,#0x6C+test_core_index]
test_core_index_0 = R3  ; unsigned int
BNE             loc_10ED4
MUL             R1, R2, R1
LDR.W           test_core_index_0, [R9,which_chain,LSL#2]
LDR.W           R11, [SP,#0x6C+var_64]
CMP             R1, R3
BLS             loc_1100E
MOVW            R5, #:lower16:__FUNCTION__.8222 ; "single_BM1385_send_func"
MOVW            R4, #:lower16:aSChainDSendWor ; "\n\n---%s: Chain%d send work num : %d, "...
MOVT            R5, #:upper16:__FUNCTION__.8222 ; "single_BM1385_send_func"
MOVT            R4, #:upper16:aSChainDSendWor ; "\n\n---%s: Chain%d send work num : %d, "...
MOVS            R6, #0x32 ; '2'

loc_10FDE
MUL             R7, R6, R2
MOV             R1, R5
MOV             R2, which_chain
MOV             R0, R4  ; format
STR             R7, [SP,#0x6C+var_6C]
BLX             printf
LDR.W           R2, [R11,#configuration.pattern_number]
LDR             R1, [SP,#0x6C+test_core_number]
LDR.W           R3, [R9,which_chain,LSL#2]
MUL             R1, R2, R1
CMP             R3, R1
BCC             loc_10FDE
B               loc_1100E

loc_11002
test_core_number_0 = R4 ; unsigned int
MOV             R3, #gSend_Work_Num
LDR.W           R3, [R3,which_chain,LSL#2]

loc_1100E
MOVW            R1, #:lower16:__FUNCTION__.8222 ; "single_BM1385_send_func"
MOVW            R0, #:lower16:aSChainDSendWor_0 ; "\n\n---%s: Chain%d send work num : %d\n"
MOV             R2, which_chain
MOVT            R1, #:upper16:__FUNCTION__.8222 ; "single_BM1385_send_func"
MOVT            R0, #:upper16:aSChainDSendWor_0 ; "\n\n---%s: Chain%d send work num : %d\n"
MOVS            R4, #0
BLX             printf
MOV             R0, #aSendTestPatter ; "\nsend test pattern done"
BLX             puts
MOV             R0, #aDate ; "date"
BLX             system
MOVS            R0, #0xA ; c
BLX             putchar
MOVW            R0, #0xC350 ; useconds
BLX             usleep
MOVW            R3, #:lower16:start_receive
MOVW            R0, #:lower16:aToStopReceive ; "to stop receive"
MOVT            R3, #:upper16:start_receive
MOVT            R0, #:upper16:aToStopReceive ; "to stop receive"
STRB            R4, [R3]
BLX             puts
MOV             R0, R4
ADD             SP, SP, #0x6C ; 'l'
POP.W           {R4-R11,PC}
; End of function single_BM1385_send_func

ALIGN 4
off_1106C DCD cgpu.workdataFilePrefix+0x3C



; void __fastcall get_BM1385_plldata(unsigned int freq, uint32_t *reg_data, uint16_t *reg_data2, uint32_t *vil_data)
EXPORT get_BM1385_plldata
get_BM1385_plldata

var_7C= -0x7C
var_78= -0x78
freq_str= -0x70
plldivider1= -0x64
plldivider2= -0x44
vildivider= -0x24

freq = R0               ; unsigned int
reg_data = R1           ; uint32_t *
reg_data2 = R2          ; uint16_t *
vil_data = R3           ; uint32_t *
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x7C
MOV             R4, freq
MOV             R9, reg_data
MOV             R10, reg_data2
ADD             freq, SP, #0x7C+plldivider1 ; s
freq = R4               ; unsigned int
MOVS            reg_data2, #0x20 ; ' ' ; n
reg_data2 = R10         ; uint16_t *
MOVS            reg_data, #0 ; c
reg_data = R9           ; uint32_t *
MOV             R11, vil_data
ADD.W           R8, SP, #0x7C+vildivider
BLX             memset
ADD             R0, SP, #0x7C+plldivider2 ; s
MOVS            R2, #0x20 ; ' ' ; n
MOVS            R1, #0  ; c
MOVW            R6, #:lower16:freq_pll_1385
BLX             memset
MOV             R0, R8  ; s
MOVS            R2, #0x20 ; ' ' ; n
MOVS            R1, #0  ; c
MOVT            R6, #:upper16:freq_pll_1385
BLX             memset
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
MOV             R2, freq
ADD             R0, SP, #0x7C+freq_str ; s
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; format
MOVS            freq, #0
freq = R2               ; unsigned int
BLX             sprintf
B               loc_110C2

loc_110BC
ADDS            R4, #1
i = R4                  ; unsigned int
CMP             i, #0x7C ; '|'
BEQ             loc_11166

loc_110C2
LSLS            R5, R4, #4
LDR             R7, [R6,R5]
MOV             R0, R7  ; s
BLX             strlen
ADD             R1, SP, #0x7C+freq_str ; s2
MOV             R2, R0  ; n
MOV             R0, R7  ; s1
BLX             memcmp
CMP             R0, #0
BNE             loc_110BC
MOVW            R0, #:lower16:aSIDSizeofFreqP ; "%s: i = %d, sizeof(freq_pll_1385)/sizeo"...
MOV             R2, R4
MOVT            R0, #:upper16:aSIDSizeofFreqP ; "%s: i = %d, sizeof(freq_pll_1385)/sizeo"...
MOVS            R3, #0x7C ; '|'
LDR             R1, =__FUNCTION__.7992 ; "get_BM1385_plldata"
BLX             printf

loc_110EC
ADD             R5, R6
MOVW            R1, #:lower16:a08x ; "%08x"
LDR             R2, [R5,#4]
MOVT            R1, #:upper16:a08x ; "%08x"
ADD             R0, SP, #0x7C+plldivider1 ; s
BLX             sprintf
MOVW            R1, #:lower16:a04x ; "%04x"
LDR             R2, [R5,#8]
MOVT            R1, #:upper16:a04x ; "%04x"
ADD             R0, SP, #0x7C+plldivider2 ; s
BLX             sprintf
MOVW            R1, #:lower16:a04x ; "%04x"
LDR             R2, [R5,#0xC]
MOVT            R1, #:upper16:a04x ; "%04x"
MOV             R0, R8  ; s
BLX             sprintf
ADD             R3, SP, #0x7C+plldivider2
MOVW            R0, #:lower16:aSFreqSPll1SPll ; "%s: Freq %s, PLL1 %s, PLL2 %s, vilpll %"...
STR             R3, [SP,#0x7C+var_7C]
ADD             R2, SP, #0x7C+freq_str
ADD             R3, SP, #0x7C+plldivider1
STR.W           R8, [SP,#0x7C+var_78]
LDR             R1, =__FUNCTION__.7992 ; "get_BM1385_plldata"
MOVT            R0, #:upper16:aSFreqSPll1SPll ; "%s: Freq %s, PLL1 %s, PLL2 %s, vilpll %"...
BLX             printf
LDR             R3, [R5,#4]
MOVW            R0, #:lower16:aSPll1XPll2XVil ; "%s: PLL1 %#x, PLL2 %#x, vilpll %#x\n"
LDR             R1, =__FUNCTION__.7992 ; "get_BM1385_plldata"
MOVT            R0, #:upper16:aSPll1XPll2XVil ; "%s: PLL1 %#x, PLL2 %#x, vilpll %#x\n"
STR.W           R3, [reg_data]
LDR             R3, [R5,#8]
LDR             R4, [R5,#0xC]
STRH.W          R3, [reg_data2]
STR.W           R4, [vil_data]
UXTH            R3, R3
LDR.W           R2, [reg_data]
STR             R4, [SP,#0x7C+var_7C]
BLX             printf
ADD             SP, SP, #0x7C ; '|'
POP.W           {R4-vil_data,PC}

loc_11166
i = R4                  ; unsigned int
MOVW            R0, #:lower16:aSIDSizeofFreqP ; "%s: i = %d, sizeof(freq_pll_1385)/sizeo"...
MOV             R3, i
MOV             R2, i
LDR             R1, =__FUNCTION__.7992 ; "get_BM1385_plldata"
MOVT            R0, #:upper16:aSIDSizeofFreqP ; "%s: i = %d, sizeof(freq_pll_1385)/sizeo"...
MOVS            R5, #0x40 ; '@'
BLX             printf
MOVW            R0, #:lower16:aSFreqSetErr ; "%s: Freq set Err!!!!\n"
LDR             R1, =__FUNCTION__.7992 ; "get_BM1385_plldata"
MOVT            R0, #:upper16:aSFreqSetErr ; "%s: Freq set Err!!!!\n"
BLX             printf
MOVW            R0, #:lower16:aSUsing200m ; "%s: Using 200M\n"
LDR             R1, =__FUNCTION__.7992 ; "get_BM1385_plldata"
MOVT            R0, #:upper16:aSUsing200m ; "%s: Using 200M\n"
BLX             printf
B               loc_110EC
; End of function get_BM1385_plldata

off_11198 DCD __FUNCTION__.7992 ; "get_BM1385_plldata"



; void __fastcall read_BM1385_asic_register(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 reg_addr, bool mode)
EXPORT read_BM1385_asic_register
read_BM1385_asic_register

var_10= -0x10
var_C= -0xC
ptr= -4

which_chain = R0        ; unsigned __int8
chip_addr_0 = R1        ; unsigned __int8
reg_addr = R2           ; unsigned __int8
mode = R3               ; bool
PUSH            {R4-R6,LR}
MOVS            R6, #0
SUB             SP, SP, #0x10
MOVS            R4, #4
MOV             R5, which_chain
STR             R6, [SP,#0x10+ptr]
STRB.W          chip_addr_0, [SP,#0x10+ptr+1]
STRB.W          reg_addr, [SP,#0x10+ptr+2]
STRB.W          R4, [SP,#0x10+ptr]
CBZ             mode, loc_111BC
MOVS            mode, #0x84
STRB.W          R3, [SP,#0x10+ptr]

loc_111BC               ; len
MOVS            chip_addr_0, #0x1B
ADD             which_chain, SP, #0x10+ptr ; ptr
BL              CRC5
LDRB.W          R6, [SP,#0x10+ptr+2]
MOV             R4, R0
MOVW            R0, #:lower16:aSBuf00xXBuf10x ; "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x"...
LDRB.W          R3, [SP,#0x10+ptr+1]
LDRB.W          R2, [SP,#0x10+ptr]
MOVT            R0, #:upper16:aSBuf00xXBuf10x ; "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x"...
STR             R4, [SP,#0x10+var_C]
LDR             R1, =__FUNCTION__.8000 ; "read_BM1385_asic_register"
STR             R6, [SP,#0x10+var_10]
STRB.W          R4, [SP,#0x10+ptr+3]
BLX             printf
ADD             R1, SP, #0x10+ptr ; buf
MOV             R0, R5  ; which_uart
MOVS            R2, #4  ; length
BL              uart_send
ADD             SP, SP, #0x10
POP             {R4-R6,PC}
; End of function read_BM1385_asic_register

ALIGN 4
off_111F8 DCD __FUNCTION__.8000 ; "read_BM1385_asic_register"



; void __fastcall set_BM1385_freq(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int freq, bool mode)
EXPORT set_BM1385_freq
set_BM1385_freq

reg_data_pll2= -0x1A
buf= -0x18
reg_data_pll= -0x14
reg_data_vil= -0x10
cmd_buf= -0xC

which_chain = R0        ; unsigned __int8
chip_addr = R1          ; unsigned __int8
freq = R2               ; unsigned int
mode = R3               ; bool
PUSH.W          {R4-R8,LR}
MOV             R5, which_chain
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
SUB             SP, SP, #0x20
MOVS            R4, #0
MOV             R8, freq
MOV             R6, chip_addr
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             chip_addr, =__FUNCTION__.8012 ; "set_BM1385_freq"
MOV             R7, mode
STR             R4, [SP,#0x20+buf]
STR             R4, [SP,#0x20+reg_data_pll]
STR             R4, [SP,#0x20+reg_data_vil]
STRH.W          R4, [SP,#0x20+reg_data_pll2]
BLX             printf
MOV             R0, freq ; freq
ADD             R3, SP, #0x20+reg_data_vil ; vil_data
ADD.W           R2, SP, #0x20+reg_data_pll2 ; reg_data2
ADD             R1, SP, #0x20+reg_data_pll ; reg_data
BL              get_BM1385_plldata
LDR             R3, [SP,#0x20+reg_data_pll]
MOVS            R2, #7
STRB.W          R2, [SP,#0x20+buf]
ADD             R0, SP, #0x20+buf ; ptr
MOVS            R1, #0x1B ; len
STRB.W          R3, [SP,#0x20+buf+3]
LSRS            R2, R3, #0x10
LSRS            R3, R3, #8
STRB.W          R2, [SP,#0x20+buf+1]
STRB.W          R3, [SP,#0x20+buf+2]
BL              CRC5
LDRB.W          R3, [SP,#0x20+buf+3]
ADD             R1, SP, #0x20+buf ; buf
MOVS            R2, #4  ; length
ORRS            R3, R0
MOV             R0, R5  ; which_uart
STRB.W          R3, [SP,#0x20+buf+3]
BL              uart_send
MOVW            R0, #0xBB8 ; useconds
BLX             usleep
LDRH.W          R3, [SP,#0x20+reg_data_pll2]
CMP             R7, R4
ITE NE
MOVNE           R7, #0x82
MOVEQ           R7, #2
ADD             R0, SP, #0x20+buf ; ptr
MOVS            R1, #0x1B ; len
STRB.W          R3, [SP,#0x20+buf+3]
LSRS            R2, R3, #8
STR             R4, [SP,#0x20+cmd_buf]
STRB.W          R6, [SP,#0x20+buf+1]
STRB.W          R2, [SP,#0x20+buf+2]
STRB.W          R7, [SP,#0x20+buf]
STR             R4, [SP,#0x20+cmd_buf+4]
STR             R4, [SP,#0x20+cmd_buf+8]
BL              CRC5
LDRB.W          R3, [SP,#0x20+buf+3]
ADD             R1, SP, #0x20+buf ; buf
MOVS            R2, #4  ; length
ORRS            R3, R0
MOV             R0, R5  ; which_uart
STRB.W          R3, [SP,#0x20+buf+3]
BL              uart_send
MOVW            R0, #0x1388 ; useconds
BLX             usleep
ADD             SP, SP, #0x20 ; ' '
POP.W           {R4-freq,PC}
; End of function set_BM1385_freq

off_112BC DCD __FUNCTION__.8012 ; "set_BM1385_freq"



; void __fastcall check_BM1385_asic_reg(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 reg, bool mode)
EXPORT check_BM1385_asic_reg
check_BM1385_asic_reg

var_18= -0x18
var_14= -0x14
var_10= -0x10
reg_buf= -0xC

which_chain = R0        ; unsigned __int8
chip_addr = R1          ; unsigned __int8
reg = R2                ; unsigned __int8
mode = R3               ; bool
PUSH.W          {R4-R11,LR}
MOVS            R4, #0
SUB             SP, SP, #0x1C
MOV             R5, mode
ADDS            mode, which_chain, #1
MOV             R8, reg
MOV             R7, R3
MOV             R6, which_chain
STR             R3, [SP,#0x1C+var_10]
STR             reg, [SP,#0x1C+var_14]
STRB.W          R4, [SP,#0x1C+reg_buf+4]
STR             R4, [SP,#0x1C+reg_buf]
BL              clear_register_value_buf
MOVW            R0, #:lower16:aSCheckChainJD ; "%s: check chain J%d \n"
MOV             R2, R7
LDR             R1, =__FUNCTION__.8023 ; "check_BM1385_asic_reg"
MOVT            R0, #:upper16:aSCheckChainJD ; "%s: check chain J%d \n"
BLX             printf
MOV             R3, R5  ; mode
MOV             R5, R8
MOV             R2, R8  ; reg_addr
MOV             R1, R4  ; chip_addr
MOV             R0, R6  ; which_chain
BL              read_BM1385_asic_register
CBNZ            R5, loc_11308
LDR             R3, =(cgpu.subid+0x7FD54)
ADD             R3, R6
STRB.W          R8, [R3,#0x30C]

loc_11308
MOVW            R9, #:lower16:cgpu
MOVW            R7, #:lower16:reg_value_buf
MOVT            R9, #:upper16:cgpu
MOVW            R5, #:lower16:reg_mutex
ADD             R9, R6
MOVT            R7, #:upper16:reg_value_buf
MOVT            R5, #:upper16:reg_mutex
MOVS            R4, #0

loc_11324               ; useconds
not_reg_data_time = R4  ; unsigned int
MOV             R0, #(gAsic_Core_Nonce_Num+0x1859C)
BLX             usleep
MOV             R0, R5  ; mutex
BLX             pthread_mutex_lock
LDR             R3, [R7]
MOV             R0, R5  ; mutex
LDR.W           R8, [R3,#8]
reg_value_num = R8      ; unsigned int
BLX             pthread_mutex_unlock
CMP.W           reg_value_num, #0
BEQ             loc_11432
MOVS            not_reg_data_time, #0
ADD.W           R10, R9, #0x100000
STR             R7, [SP,#0x1C+var_18]
B               loc_1138C

loc_11352
i = R4                  ; unsigned int
LDR             R1, [R2,#8]
ADDS            R3, #1
CMP.W           R3, #0x200
STR             R3, [R2,#4]
MOVW            R0, #:lower16:aSTheReturnData ; "%s: the return data is from chain%d, bu"...
ADD.W           R1, R1, #0xFFFFFFFF
MOVT            R0, #:upper16:aSTheReturnData ; "%s: the return data is from chain%d, bu"...
STR             R1, [R2,#8]
ITTT EQ
MOVEQ           R1, #0
MOVEQ           R3, R1
STREQ           R1, [R2,#4]
ADD.W           R3, R2, R3,LSL#3
LDR             R1, =__FUNCTION__.8023 ; "check_BM1385_asic_reg"
LDRB            R2, [R3,#0x17]
MOV             R3, R6
BLX             printf
MOV             R0, R5  ; mutex
BLX             pthread_mutex_unlock

loc_11386
ADDS            i, #1
CMP             reg_value_num, i
BEQ             loc_1142C

loc_1138C               ; mutex
MOV             R0, R5
BLX             pthread_mutex_lock
LDR             R3, [SP,#0x1C+var_18]
LDR             R2, [R3]
LDR             R3, [R2,#4]
ADD.W           R1, R2, R3,LSL#3
LDRB            R1, [R1,#0x17]
CMP             R1, R6
BNE             loc_11352
MOV.W           R11, #0
MOVS            R1, #0x23 ; '#' ; len
STR.W           R11, [SP,#0x1C+reg_buf]
ADD             R0, SP, #0x1C+reg_buf ; ptr
STRB.W          R11, [SP,#0x1C+reg_buf+4]
LDR             R3, [R2,#4]
ADDS            R3, #2
LDR.W           R3, [R2,R3,LSL#3]
STRB.W          R3, [SP,#0x1C+reg_buf+3]
MOV.W           LR, R3,LSR#8
LSRS            R2, R3, #0x10
LSRS            R3, R3, #0x18
STRB.W          LR, [SP,#0x1C+reg_buf+2]
STRB.W          R2, [SP,#0x1C+reg_buf+1]
STRB.W          R3, [SP,#0x1C+reg_buf]
BL              CRC5
LDR             R3, [SP,#0x1C+var_18]
LDR             R3, [R3]
LDR             R2, [R3,#4]
ADD.W           R1, R3, R2,LSL#3
LDRB.W          LR, [R1,#0x16]
CMP             LR, R0
BEQ             loc_11496
LDR             R1, [R3,#8]
ADDS            R2, #1
CMP.W           R2, #0x200
STR             R2, [R3,#4]
ADD             R0, SP, #0x1C+reg_buf ; ptr
IT EQ
STREQ.W         R11, [R3,#4]
SUBS            R1, #1
ADDS            i, #1
STR             R1, [R3,#8]
MOVS            R1, #0x23 ; '#' ; len
BL              CRC5
LDR             R3, [SP,#0x1C+var_18]
MOV             R2, R0
MOVW            R0, #:lower16:aSCrcIs0xXButIt ; "%s: crc is 0x%x, but it should be 0x%x"...
LDR             R1, =__FUNCTION__.8023 ; "check_BM1385_asic_reg"
MOVT            R0, #:upper16:aSCrcIs0xXButIt ; "%s: crc is 0x%x, but it should be 0x%x"...
LDR             R3, [R3]
LDR             R7, [R3,#4]
ADD.W           R3, R3, R7,LSL#3
LDRB            R3, [R3,#0x16]
BLX             printf
MOV             R0, R5  ; mutex
BLX             pthread_mutex_unlock
i = R4                  ; unsigned int
CMP             reg_value_num, i
BNE             loc_1138C

loc_1142C
LDR             R7, [SP,#0x1C+var_18]
MOVS            i, #0
B               loc_11324

loc_11432
not_reg_data_time = R4  ; unsigned int
MOVW            R0, #:lower16:loc_186A0
ADDS            not_reg_data_time, #1
MOVT            R0, #:upper16:loc_186A0 ; useconds
BLX             usleep
not_reg_data_time = R4  ; unsigned int
MOVW            R0, #:lower16:aSNoAsicAddress ; "%s: no asic address register come back "...
MOV             R2, not_reg_data_time
MOVT            R0, #:upper16:aSNoAsicAddress ; "%s: no asic address register come back "...
LDR             R1, =__FUNCTION__.8023 ; "check_BM1385_asic_reg"
BLX             printf
CMP             not_reg_data_time, #3
BNE.W           loc_11324
LDR             R3, [SP,#0x1C+var_14]
CBNZ            R3, loc_1148C
MOVW            R2, #:lower16:cgpu
MOVW            R0, #:lower16:aSChainJDHasDAs ; "%s: chain J%d has %d ASIC\n"
MOVT            R2, #:upper16:cgpu
MOVT            R0, #:upper16:aSChainJDHasDAs ; "%s: chain J%d has %d ASIC\n"
ADDS            R3, R2, R6
ADD.W           R2, R2, #0x100000
ADD.W           R3, R3, #0x100000
LDR.W           R1, [R2,#(cgpu.max_asic_num_in_one_chain - 0x330FC4)]
LDRB.W          R3, [R3,#0x30C]
CMP             R3, R1
LDR             R1, =__FUNCTION__.8023 ; "check_BM1385_asic_reg"
IT HI
STRHI.W         R3, [R2,#(cgpu.max_asic_num_in_one_chain - 0x330FC4)]
LDR             R2, [SP,#0x1C+var_10]
BLX             printf

loc_1148C
BL              clear_register_value_buf
ADD             SP, SP, #0x1C
POP.W           {R4-R11,PC}

loc_11496
i = R4                  ; unsigned int
LDR             R0, [SP,#0x1C+var_14]
CBNZ            R0, loc_114C6
LDRB.W          R2, [R10,#0x30C]
ADDS            R2, #1
STRB.W          R2, [R10,#0x30C]
LDR             R2, [R3,#4]

loc_114A6
LDR             R1, [R3,#8]
ADDS            R2, #1
CMP.W           R2, #0x200
STR             R2, [R3,#4]
IT EQ
MOVEQ           R2, #0
MOV             R0, R5  ; mutex
ADD.W           R1, R1, #0xFFFFFFFF
IT EQ
STREQ           R2, [R3,#4]
STR             R1, [R3,#8]
BLX             pthread_mutex_unlock
B               loc_11386

loc_114C6
LDR             R0, [SP,#0x1C+var_14]
CMP             R0, #0xC
BNE             loc_114A6
MOVW            R0, #:lower16:aSTheAsicFreqIs ; "%s: the asic freq is 0x%08x\n"
LDR             R2, [R1,#0x10]
MOVT            R0, #:upper16:aSTheAsicFreqIs ; "%s: the asic freq is 0x%08x\n"
LDR             R1, =__FUNCTION__.8023 ; "check_BM1385_asic_reg"
BLX             printf
LDR             R3, [SP,#0x1C+var_18]
LDR             R3, [R3]
LDR             R2, [R3,#4]
B               loc_114A6
; End of function check_BM1385_asic_reg

off_114E4 DCD __FUNCTION__.8023 ; "check_BM1385_asic_reg"
off_114E8 DCD cgpu.subid+0x7FD54



; void __fastcall BM1385_chain_inactive(unsigned __int8 which_chain)
EXPORT BM1385_chain_inactive
BM1385_chain_inactive

buf= -8
var_4= -4

which_chain = R0        ; unsigned __int8
PUSH            {R4,R5,LR}
SUB             SP, SP, #0xC
MOVS            R3, #0x85
ADD             R4, SP, #0xC+var_4
MOVS            R2, #0
MOV             R5, which_chain
STR             R2, [SP,#0xC+buf]
MOVS            R1, #0x1B ; len
STRB.W          R3, [R4,#-4]!
MOV             which_chain, R4 ; ptr
BL              CRC5
MOV             R1, R4  ; buf
STRB.W          R0, [SP,#0xC+buf+3]
MOVS            R2, #4  ; length
MOV             R0, R5  ; which_uart
BL              uart_send
MOVW            R0, #0x1388 ; useconds
BLX             usleep
ADD             SP, SP, #0xC
POP             {R4,R5,PC}
; End of function BM1385_chain_inactive




; void __fastcall BM1385_set_address(unsigned __int8 which_chain, unsigned __int8 address)
EXPORT BM1385_set_address
BM1385_set_address

ptr= -4

which_chain = R0        ; unsigned __int8
address_0 = R1          ; unsigned __int8
PUSH            {R4,LR}
MOVS            R3, #0
SUB             SP, SP, #8
MOV             R4, which_chain
ADD             which_chain, SP, #8+ptr ; ptr
STR             R3, [SP,#8+ptr]
MOVS            R3, #1
STRB.W          address_0, [SP,#8+ptr+1]
MOVS            address_0, #0x1B ; len
STRB.W          R3, [SP,#8+ptr]
BL              CRC5
ADD             R1, SP, #8+ptr ; buf
STRB.W          R0, [SP,#8+ptr+3]
MOVS            R2, #4  ; length
MOV             R0, R4  ; which_uart
BL              uart_send
ADD             SP, SP, #8
POP             {R4,PC}
; End of function BM1385_set_address

ALIGN 0x10



; void __fastcall BM1385_set_baud(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 baud, bool mode)
EXPORT BM1385_set_baud
BM1385_set_baud

ptr= -4

which_chain = R0        ; unsigned __int8
chip_addr_0 = R1        ; unsigned __int8
baud = R2               ; unsigned __int8
mode = R3               ; bool
PUSH            {R4,LR}
CMP             mode, #0
SUB             SP, SP, #8
MOV.W           mode, #0
MOV             R4, which_chain
AND.W           baud, baud, #0x1F
STR             R3, [SP,#8+ptr]
ADD             which_chain, SP, #8+ptr ; ptr
ITE NE
MOVNE           R3, #0x86
MOVEQ           R3, #6
STRB.W          chip_addr_0, [SP,#8+ptr+1]
MOVS            chip_addr_0, #0x1B ; len
STRB.W          R2, [SP,#8+ptr+2]
STRB.W          R3, [SP,#8+ptr]
BL              CRC5
ADD             R1, SP, #8+ptr ; buf
STRB.W          R0, [SP,#8+ptr+3]
MOVS            R2, #4  ; length
MOV             R0, R4  ; which_uart
BL              uart_send
ADD             SP, SP, #8
POP             {R4,PC}
; End of function BM1385_set_baud

ALIGN 0x10



; void __fastcall BM1385_set_gateblk(unsigned __int8 which_chain, unsigned __int8 chip_addr, bool mode)
EXPORT BM1385_set_gateblk
BM1385_set_gateblk

gateblk= -8

which_chain = R0        ; unsigned __int8
chip_addr = R1          ; unsigned __int8
mode = R2               ; bool
MOVW            R3, #:lower16:Conf
PUSH            {R4,R5,LR}
MOVT            R3, #:upper16:Conf
SUB             SP, SP, #0xC
CMP             mode, #0
MOV             R5, which_chain
LDR.W           R3, [R3,#configuration.baud]
ITE NE
MOVNE           mode, #0x86
MOVEQ           R2, #6
MOVS            R4, #0
ADD             which_chain, SP, #0xC+gateblk ; ptr
MOVS            chip_addr, #0x1B ; len
ORN.W           R3, R3, #0x7F
STR             R4, [SP,#0xC+gateblk]
STRB.W          R3, [SP,#0xC+gateblk+2]
STRB.W          R2, [SP,#0xC+gateblk]
BL              CRC5
LDRB.W          R3, [SP,#0xC+gateblk+3]
AND.W           R4, R0, #0x1F
ADD             R1, SP, #0xC+gateblk ; buf
MOVS            R2, #4  ; length
MOV             R0, R5  ; which_uart
ORRS            R3, R4
STRB.W          R3, [SP,#0xC+gateblk+3]
BL              uart_send
MOVW            R0, #0x2710 ; useconds
BLX             usleep
ADD             SP, SP, #0xC
POP             {R4,R5,PC}
; End of function BM1385_set_gateblk

ALIGN 4



; void reset_single_BM1385_global_arg()
EXPORT reset_single_BM1385_global_arg
reset_single_BM1385_global_arg

var_C= -0xC
var_8= -8

PUSH.W          {R4-R11,LR}
MOV             R9, #Conf
SUB             SP, SP, #0xC
MOVS            R5, #0x20 ; ' '
LDR.W           R8, [R9,#configuration.OpenCoreNum1]
OpenCoreNum1 = R8       ; unsigned int
LDR.W           R7, [R9,#configuration.OpenCoreNum2]
OpenCoreNum2 = R7       ; unsigned int
LDR.W           R6, [R9,#configuration.OpenCoreNum3]
OpenCoreNum3 = R6       ; unsigned int
LDR.W           R4, [R9,#configuration.OpenCoreNum4]
OpenCoreNum4 = R4       ; unsigned int
BL              reset_global_arg
MOVW            R0, #:lower16:aS ; "\n--- %s\n"
LDR             R1, =__FUNCTION__.8069 ; "reset_single_BM1385_global_arg"
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
BLX             printf
MOV.W           R12, #0

loc_1161E
get_pattern_loop = R12  ; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum1 = R8       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum2 = R7       ; unsigned int
TST.W           OpenCoreNum3, #1
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
IT NE
ADDNE.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum3 = R6       ; unsigned int
TST.W           OpenCoreNum4, #1
MOV.W           OpenCoreNum4, OpenCoreNum4,LSR#1
IT NE
ADDNE.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum4 = R4       ; unsigned int
SUBS            R5, #1
BNE             loc_1161E
LDR.W           OpenCoreNum2, [R9,#configuration.pattern_number]
ADD.W           R3, get_pattern_loop, #0x20000
LDR             R2, =0x3312CF
MOVW            OpenCoreNum3, #:lower16:cgpu
LDR.W           R11, =(reg_mutex+0x14)
ADDS            R3, #0x2A ; '*'
MOVT            R6, #:upper16:cgpu
MOVW            R10, #:lower16:gRepeated_Nonce_Id
STR             R2, [SP,#0xC+var_C]
ADD.W           R2, R7, R7,LSL#4
MOVW            R9, #:lower16:gValid_Nonce_Num
ADD.W           R6, R6, R3,LSL#2
MOVW            OpenCoreNum1, #:lower16:gSend_Work_Num
LSLS            R3, R2, #2
MOV             R1, R5
MOVT            R10, #:upper16:gRepeated_Nonce_Id
MOVT            R9, #:upper16:gValid_Nonce_Num
MOVT            R8, #:upper16:gSend_Work_Num
STR             R3, [SP,#0xC+var_8]

loc_1169A
LDR             R3, [SP,#0xC+var_C]
STR.W           R1, [R10],#4
STR.W           R1, [R9],#4
STRB.W          R1, [R3,#1]!
STR.W           R1, [R8],#4
STR             R3, [SP,#0xC+var_C]
CMP.W           get_pattern_loop, #0
BEQ             loc_116D8
LDR             R3, [SP,#0xC+var_8]
MOV             R4, R11
LDR             R0, =(cgpu.workdataFilePrefix+0x3C)
ADD.W           LR, R5, R3

loc_116BE
LDR.W           R2, [R0,#4]!
works = R2              ; work *
ADDS            R3, works, R5
ADD             works, LR
CBZ             R7, loc_116D0

loc_116C8
STR             R1, [R3,#0x34]
ADDS            R3, #0x44 ; 'D'
CMP             R3, R2
BNE             loc_116C8

loc_116D0
CMP             R0, R6
STR.W           R1, [R4,#4]!
BNE             loc_116BE

loc_116D8
ADDS            R5, #4
ADD.W           R11, R11, #0x80000
CMP             R5, #0x10
BNE             loc_1169A
ADD             SP, SP, #0xC
POP.W           {R4-R11,PC}
; End of function reset_single_BM1385_global_arg

off_116E8 DCD __FUNCTION__.8069 ; "reset_single_BM1385_global_arg"
dword_116EC DCD 0x3312CF
off_116F0 DCD cgpu.workdataFilePrefix+0x3C
off_116F4 DCD reg_mutex+0x14



; void single_BM1385_calculate_timeout_and_baud()
EXPORT single_BM1385_calculate_timeout_and_baud
single_BM1385_calculate_timeout_and_baud
MOVW            R0, #:lower16:aS ; "\n--- %s\n"
PUSH            {R4-R6,LR}
LDR             R1, =__FUNCTION__.8088 ; "single_BM1385_calculate_timeout_and_bau"...
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
MOVW            R4, #:lower16:Conf
BLX             printf
MOVS            R0, #0x32 ; '2' ; actual_core_number
BL              calculate_core_number
MOVW            R3, #:lower16:pattern_test_time
MOV             R6, R0
temp_corenum = R0       ; unsigned int
MOVT            R3, #:upper16:pattern_test_time
LDRB            R2, [R3]
CMP             R2, #8  ; switch 9 cases
BHI             def_11722 ; jumptable 00011722 default case
TBB.W           [PC,R2] ; switch jump
jpt_11722 DCB 0x41      ; jump table for switch statement
DCB 0x45
DCB 0x49
DCB 0x4D
DCB 0x51
DCB 0x55
DCB 0x59
DCB 0x5D
DCB 5
ALIGN 2

loc_11730               ; jumptable 00011722 case 8
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq9]

loc_11736
temp_corenum = R6       ; unsigned int
temp_freq = R5          ; unsigned int
MOV             R1, temp_corenum
MOV.W           R0, #0x1000000
BL              __aeabi_uidiv
MOVW            R3, #:lower16:gChain_Asic_Interval
MOV             R1, temp_freq
MOVT            R3, #:upper16:gChain_Asic_Interval
LDR             R3, [R3]
MUL             R0, R3, R0
BL              __aeabi_uidiv
MOV             R3, R0
MOVW            R2, #0x851F
ADD.W           R1, R3, R3,LSL#1
MOVT            R2, #0x51EB
MOVW            R0, #:lower16:(gAsic_Core_Nonce_Num+0x166026)
RSB.W           R3, R3, R1,LSL#5
MOVT            R0, #:upper16:(gAsic_Core_Nonce_Num+0x166026)
UMULL           R2, R3, R3, R2
LSRS            R3, R3, #5
MOV             R1, R3
STR.W           R3, [R4,#configuration.timeout]
BL              __aeabi_uidiv
LSLS            R1, R0, #9
MOV             R0, #(cgpu.subid+0x49C98)
BL              __aeabi_uidiv
SUBS            R0, #1
STR             temp_freq, [R4,#configuration.Freq]
CMP             R0, #0x1A
ITET HI
MOVHI           R3, #0x1A
STRLS.W         R0, [R4,#configuration.baud]
STRHI.W         R3, [R4,#configuration.baud]
MOVW            R3, #0x2710
STR.W           R3, [R4,#configuration.timeout]
POP             {R4-temp_corenum,PC}

loc_117A8               ; jumptable 00011722 case 0
temp_corenum = R0       ; unsigned int
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq1]
temp_freq = R5          ; unsigned int
B               loc_11736

loc_117B0               ; jumptable 00011722 case 1
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq2]
temp_freq = R5          ; unsigned int
B               loc_11736

loc_117B8               ; jumptable 00011722 case 2
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq3]
temp_freq = R5          ; unsigned int
B               loc_11736

loc_117C0               ; jumptable 00011722 case 3
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq4]
temp_freq = R5          ; unsigned int
B               loc_11736

loc_117C8               ; jumptable 00011722 case 4
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq5]
temp_freq = R5          ; unsigned int
B               loc_11736

loc_117D0               ; jumptable 00011722 case 5
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq6]
temp_freq = R5          ; unsigned int
B               loc_11736

loc_117D8               ; jumptable 00011722 case 6
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq7]
temp_freq = R5          ; unsigned int
B               loc_11736

loc_117E0               ; jumptable 00011722 case 7
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq8]
temp_freq = R5          ; unsigned int
B               loc_11736

def_11722               ; jumptable 00011722 default case
MOVW            temp_corenum, #:lower16:aSPatternTestTi ; "%s: pattern_test_time = %d, error!!! \n"
temp_corenum = R6       ; unsigned int
LDR             R1, =__FUNCTION__.8088 ; "single_BM1385_calculate_timeout_and_bau"...
MOVT            R0, #:upper16:aSPatternTestTi ; "%s: pattern_test_time = %d, error!!! \n"
MOVT            R4, #:upper16:Conf
MOVS            R5, #0
BLX             printf
B               loc_11736
; End of function single_BM1385_calculate_timeout_and_baud

ALIGN 0x10
off_11800 DCD __FUNCTION__.8088 ; "single_BM1385_calculate_timeout_and_bau"...



; void __fastcall single_BM1385_set_address(unsigned __int8 which_chain)
EXPORT single_BM1385_set_address
single_BM1385_set_address
which_chain = R0        ; unsigned __int8
PUSH            {R3-R7,LR}
MOV             R7, which_chain
MOVW            which_chain, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
LDR             R1, =__FUNCTION__.8105 ; "single_BM1385_set_address"
MOV             R2, R7
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
MOVW            R6, #:lower16:gChain_Asic_Interval
BLX             printf
MOVT            R6, #:upper16:gChain_Asic_Interval
MOV             R0, R7  ; which_chain
BL              BM1385_chain_inactive
LDR             R1, [R6]
MOV.W           R0, #0x100
BL              __aeabi_uidiv
CBZ             R0, locret_1185A
MOVS            R4, #0
MOV             R5, R4

loc_11836               ; address
chip_addr = R5          ; unsigned int
i = R4                  ; unsigned int
UXTB            R1, chip_addr
MOV             R0, R7  ; which_chain
ADDS            i, #1
BL              BM1385_set_address
LDR             R3, [R6]
MOVW            R0, #0x1388 ; useconds
ADD             chip_addr, R3
BLX             usleep
i = R4                  ; unsigned int
LDR             R1, [R6]
MOV.W           R0, #0x100
BL              __aeabi_uidiv
CMP             R0, i
BHI             loc_11836

locret_1185A
POP             {R3-R7,PC}
; End of function single_BM1385_set_address

off_1185C DCD __FUNCTION__.8105 ; "single_BM1385_set_address"



; void __fastcall single_BM1385_set_baud(unsigned __int8 which_chain, unsigned __int8 baud)
EXPORT single_BM1385_set_baud
single_BM1385_set_baud
which_chain = R0        ; unsigned __int8
baud = R1               ; unsigned __int8
PUSH            {R3-R5,LR}
MOV             R5, which_chain
MOVW            which_chain, #:lower16:aSChainDBaudD ; "\n--- %s: Chain : %d, baud = %d\n"
MOV             R4, baud
MOV             R3, baud
MOV             R2, R5
LDR             baud, =__FUNCTION__.8113 ; "single_BM1385_set_baud"
MOVT            R0, #:upper16:aSChainDBaudD ; "\n--- %s: Chain : %d, baud = %d\n"
BLX             printf
MOV             R0, R5  ; which_chain
MOV             R2, R4  ; baud
MOVS            R3, #1  ; mode
MOVS            R1, #0  ; chip_addr
BL              BM1385_set_baud
MOVW            R0, #0xC350 ; useconds
BLX             usleep
MOV             R0, R4  ; asic_baud
POP.W           {R3-R5,LR}
B.W             set_fpga_baud
; End of function single_BM1385_set_baud

ALIGN 4
off_11898 DCD __FUNCTION__.8113 ; "single_BM1385_set_baud"



; void __fastcall single_BM1385_open_core(unsigned __int8 which_chain)
EXPORT single_BM1385_open_core
single_BM1385_open_core

data= -0x44

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x44
MOV             R7, which_chain
MOVS            R2, #0x40 ; '@' ; n
MOVS            R1, #0  ; c
MOV             which_chain, SP ; s
BLX             memset
MOVW            R6, #:lower16:Conf
MOVW            R0, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOVS            R3, #0xFF
MOVS            R4, #0
MOVT            R6, #:upper16:Conf
MOV             R2, R7
LDR             R1, =__FUNCTION__.8121 ; "single_BM1385_open_core"
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
MOVW            R11, #:lower16:gIsOpenCoreEnd
STRB.W          R3, [SP,#0x44+data]
LDR.W           R8, [R6,#configuration.OpenCoreNum1]
OpenCoreNum1 = R8       ; unsigned int
MOVT            R11, #:upper16:gIsOpenCoreEnd
LDR.W           R9, [R6,#configuration.OpenCoreNum2]
OpenCoreNum2 = R9       ; unsigned int
MOVS            R5, #0x32 ; '2'
BLX             printf
MOV             R1, R4  ; c
MOVS            R2, #0x40 ; '@' ; n
MOV             R0, SP  ; s
STRB.W          R4, [R11]
BLX             memset
MOV             R1, R4  ; chip_addr
MOV             R0, R7  ; which_chain
MOVS            R2, #1  ; mode
BL              BM1385_set_gateblk

loc_118F8               ; length
MOVS            R2, #0x40 ; '@'
MOV             R1, SP  ; buf
MOV             R0, R7  ; which_uart
BL              uart_send
LDR.W           R0, [R6,#configuration.OpenCoreGap] ; useconds
BLX             usleep
SUBS            R5, #1
BNE             loc_118F8
MOV             R1, R5  ; c
MOVS            R2, #0x40 ; '@' ; n
MOV             R0, SP  ; s
MOV             R4, R5
BLX             memset
MOVS            R2, #1  ; mode
MOV             R1, R5  ; chip_addr
MOV             R0, R7  ; which_chain
MOV.W           R10, #0xFF
BL              BM1385_set_gateblk
B               loc_11950

loc_1192A
which_core = R4         ; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
BEQ             loc_11938

loc_11934
STRB.W          R10, [SP,#0x44+data+0x34]

loc_11938               ; length
MOVS            R2, #0x40 ; '@'
MOV             R1, SP  ; buf
MOV             R0, R7  ; which_uart
ADDS            which_core, #1
BL              uart_send
LDR.W           R0, [R6,#configuration.OpenCoreGap] ; useconds
BLX             usleep
which_core = R4         ; unsigned int
CMP             which_core, #0x32 ; '2'
BEQ             loc_11960

loc_11950
CMP             which_core, #0x1F
BLS             loc_1192A
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
BEQ             loc_11938
B               loc_11934

loc_11960
MOVS            R3, #1
STRB.W          R3, [R11]
ADD             SP, SP, #0x44 ; 'D'
POP.W           {which_core-R11,PC}
; End of function single_BM1385_open_core

off_1196C DCD __FUNCTION__.8121 ; "single_BM1385_open_core"



; unsigned int __fastcall single_BM1385_get_result(unsigned __int8 which_chain)
EXPORT single_BM1385_get_result
single_BM1385_get_result

var_1C= -0x1C
var_18= -0x18
format= -0x14
var_10= -0x10
var_C= -0xC
works= -8

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x1C
MOV             R4, which_chain
STR             which_chain, [SP,#0x1C+var_C]
MOVW            R8, #:lower16:Conf
MOVW            which_chain, #:lower16:asc_29AF4 ; "\n\n-----------------------------------"...
MOVT            R8, #:upper16:Conf
MOVT            R0, #:upper16:asc_29AF4 ; "\n\n-----------------------------------"...
LDR.W           R7, [R8,#configuration.OpenCoreNum1]
OpenCoreNum1 = R7       ; unsigned int
MOVW            R6, #:lower16:gAsic_Core_Nonce_Num
LDR.W           R10, [R8,#configuration.OpenCoreNum2]
OpenCoreNum2 = R10      ; unsigned int
MOVT            R6, #:upper16:gAsic_Core_Nonce_Num
BLX             puts
MOVW            R0, #:lower16:aEveryCoreRequi ; "every CORE require nonce number: %u\n\n"
LDR.W           R1, [R8,#configuration.pattern_number]
MOVT            R0, #:upper16:aEveryCoreRequi ; "every CORE require nonce number: %u\n\n"
ADD.W           R6, R6, R4,LSL#19
MOVW            R9, #0xCCCD
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum1]
MOV             R0, #aOpenCoreNumber ; "Open core number : Conf.OpenCoreNum1 = "...
MOVW            R5, #:lower16:aCore02d02d ; "core[%02d]=%02d\t"
MOVT            R9, #0xCCCC
MOVT            R5, #:upper16:aCore02d02d ; "core[%02d]=%02d\t"
MOV             R1, R2
MOV.W           R11, #0
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum2]
MOV             R0, #aOpenCoreNumber_0 ; "Open core number : Conf.OpenCoreNum2 = "...
SUBS            R4, R6, #4
MOV             R1, R2
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum3]
MOV             R0, #aOpenCoreNumber_1 ; "Open core number : Conf.OpenCoreNum3 = "...
MOV             R1, R2
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum4]
MOV             R0, #aOpenCoreNumber_2 ; "Open core number : Conf.OpenCoreNum4 = "...
MOV             R1, R2
BLX             printf
B               loc_11A28

loc_11A12
which_core = R11        ; unsigned int
MOV             R1, which_core
LDR.W           R2, [R4,#4]!
MOV             R0, R5  ; format
ADD.W           which_core, which_core, #1
which_core = R1         ; unsigned int
BLX             printf
which_core = R11        ; unsigned int
CMP.W           which_core, #0x32 ; '2'
BEQ             loc_11A40

loc_11A28
UMULL           R2, R3, which_core, R9
LSRS            R3, R3, #3
ADD.W           R3, R3, R3,LSL#2
CMP.W           which_core, R3,LSL#1
BNE             loc_11A12
MOVS            R0, #0xA ; c
BLX             putchar
B               loc_11A12

loc_11A40
LDR             R0, [SP,#0x1C+var_C]
MOVW            R3, #:lower16:cgpu
MOVW            R2, #:lower16:aCore02dDLostTh ; "core[%02d] = %d,      lost these nonce "...
MOVW            R1, #:lower16:aD ; "%d  "
MOV.W           R9, #0
MOVT            R3, #:upper16:cgpu
MOVT            R2, #:upper16:aCore02dDLostTh ; "core[%02d] = %d,      lost these nonce "...
MOVT            R1, #:upper16:aD ; "%d  "
LSLS            R0, R0, #2
MOV             R4, R9
STR             R3, [SP,#0x1C+var_18]
MOVS            R5, #1
STR             R0, [SP,#0x1C+var_10]
MOV             R0, #(aSCreateSingleB_1+0x2C) ; s
STR             R2, [SP,#0x1C+format]
STR             R1, [SP,#0x1C+var_1C]
BLX             puts
B               loc_11A9C

loc_11A7A
which_core = R4         ; unsigned int
test_core_index = R9    ; unsigned int
LSLS            R3, OpenCoreNum1, #0x1F
IT PL
LSRPL           OpenCoreNum1, OpenCoreNum1, #1
BPL             loc_11A92
LDR             R2, [R6]
LDR.W           R3, [R8,#configuration.pattern_number]
CMP             R2, R3
BCC             loc_11ACE

loc_11A8C
LSRS            R7, R7, #1
OpenCoreNum1 = R7       ; unsigned int
ADD.W           test_core_index, test_core_index, #1

loc_11A92
ADDS            which_core, #1
CMP             which_core, #0x32 ; '2'
ADD.W           R6, R6, #4
BEQ             loc_11B2E

loc_11A9C
CMP             which_core, #0x1F
BLS             loc_11A7A
TST.W           OpenCoreNum2, #1
IT EQ
MOVEQ.W         OpenCoreNum2, OpenCoreNum2,LSR#1
BEQ             loc_11A92
LDR             R0, [SP,#0x1C+var_18]
ADD.W           R3, test_core_index, #0x20000
LDR             R2, [R6]
ADDS            R3, #0x2A ; '*'
LDR.W           R1, [R8,#configuration.pattern_number]
ADD.W           R3, R0, R3,LSL#2
CMP             R2, R1
LDR             R3, [R3,#4]
works_0 = R3            ; work *
BCC             loc_11B92

loc_11AC4
MOV.W           R10, R10,LSR#1
OpenCoreNum2 = R10      ; unsigned int
ADD.W           test_core_index, test_core_index, #1
B               loc_11A92

loc_11ACE
LDR             R0, [SP,#0x1C+var_18]
ADD.W           R3, test_core_index, #0x20000
ADDS            R3, #0x2A ; '*'
MOV             R1, which_core
ADD.W           R3, R0, R3,LSL#2
LDR             R0, [SP,#0x1C+format] ; format
LDR             R5, [R3,#4]
BLX             printf
LDR.W           R3, [R8,#configuration.pattern_number]
CBZ             R3, loc_11B24
LDR             R3, [SP,#0x1C+var_10]
ADD.W           R11, R5, R3
MOV             R3, R8
MOVS            R5, #0
MOV             R8, which_core
MOV             which_core, R3
which_core = R8         ; unsigned int
B               loc_11B02

loc_11AFA
which_pattern = R5      ; unsigned int
LDR             R3, [R4,#configuration.pattern_number]
ADDS            which_pattern, #1
CMP             R3, which_pattern
BLS             loc_11B1E

loc_11B02
LDR.W           R3, [R11,#0x34]
ADD.W           R11, R11, #0x44 ; 'D'
CMP             R3, #0
BNE             loc_11AFA
MOV             R1, which_pattern
LDR             R0, [SP,#0x1C+var_1C] ; format
BLX             printf
LDR             R3, [R4,#configuration.pattern_number]
ADDS            which_pattern, #1
CMP             R3, which_pattern
BHI             loc_11B02

loc_11B1E
MOV             R3, R4
MOV             R4, which_core
MOV             which_core, R3

loc_11B24               ; c
which_core = R4         ; unsigned int
MOVS            R0, #0xA
MOVS            R5, #0
BLX             putchar
B               loc_11A8C

loc_11B2E
OpenCoreNum1 = R7       ; unsigned int
MOV             R0, #asc_29CA4 ; "\n-------------------------------------"...
BLX             puts
LDR             R1, [SP,#0x1C+var_C]
MOVW            R3, #:lower16:gValid_Nonce_Num
MOVW            R0, #:lower16:aChainDTotalVal ; "Chain%d total valid nonce number: %d\n"...
MOVT            R3, #:upper16:gValid_Nonce_Num
MOVT            R0, #:upper16:aChainDTotalVal ; "Chain%d total valid nonce number: %d\n"...
LDR.W           R2, [R3,R1,LSL#2]
BLX             printf
CBNZ            R5, loc_11B84
MOV             R0, #aPatternNg ; "Pattern NG\n"
BLX             puts

loc_11B62
LDR             R2, [SP,#0x1C+var_C]
MOV             R3, #gHw_Nonce_Num
MOV             R0, #aHwNumberD ; "HW number = %d\n\n"
LDR.W           R1, [R3,R2,LSL#2]
BLX             printf
MOV             R0, R5
ADD             SP, SP, #0x1C
POP.W           {which_core-R11,PC}

loc_11B84
MOV             R0, #aPatternOk ; "Pattern OK\n"
BLX             puts
B               loc_11B62

loc_11B92
works_0 = R3            ; work *
MOV             R1, which_core
LDR             R0, [SP,#0x1C+format] ; format
STR             works_0, [SP,#0x1C+works]
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R3, [SP,#0x1C+works]
CBZ             R2, loc_11BC8
LDR             R2, [SP,#0x1C+var_10]
MOVS            R5, #0
ADD             R3, R2
MOV             R11, R3

loc_11BAC
which_pattern = R5      ; unsigned int
LDR.W           R3, [R11,#0x34]
ADD.W           R11, R11, #0x44 ; 'D'
CBNZ            R3, loc_11BBE
MOV             R1, which_pattern
LDR             R0, [SP,#0x1C+var_1C] ; format
BLX             printf

loc_11BBE
LDR.W           R3, [R8,#configuration.pattern_number]
ADDS            which_pattern, #1
CMP             R3, which_pattern
BHI             loc_11BAC

loc_11BC8               ; c
MOVS            R0, #0xA
MOVS            R5, #0
BLX             putchar
B               loc_11AC4
; End of function single_BM1385_get_result

ALIGN 4



; void __fastcall single_BM1385_print_lcd(unsigned __int8 which_chain, unsigned int result)
EXPORT single_BM1385_print_lcd
single_BM1385_print_lcd

lcd_display_buf= -0x14

which_chain = R0        ; unsigned __int8
result = R1             ; unsigned int
LDR             R3, =dword_2972C
PUSH            {R4,R5,LR}
MOV             R5, result
SUB             SP, SP, #0x14
MOV             R4, SP
LDR             result, [R3,#(dword_29730 - 0x2972C)]
result = R5             ; unsigned int
LDR             R2, [R3,#(dword_29734 - 0x2972C)]
LDR             which_chain, [R3]
LDR             R3, [R3,#(dword_29738 - 0x2972C)]
STM             R4!, {R0-R3}
BL              display_level_result_on_lcd
LSLS            R3, result, #0x1F
MOV.W           R0, #2  ; line
ITETT MI
MOVWMI          R1, #0x9D64
MOVWPL          R1, #0x9D78
MOVMI           R2, #0x10
MOVTMI          R1, #2
ITT PL
MOVPL           R2, #0x10 ; size
MOVTPL          R1, #2  ; buf
BL              write_lcd_no_memset
MOVW            R2, #:lower16:gChain
MOVW            R3, #:lower16:gHw_Nonce_Num
MOVT            R2, #:upper16:gChain
MOVT            R3, #:upper16:gHw_Nonce_Num
LDRB            R2, [R2]
MOV             R1, #(aT1DT2D+0xC) ; format
ADD.W           R0, SP, #0x14+lcd_display_buf+0xA ; s
LDR.W           R2, [R3,R2,LSL#2]
BLX             sprintf
MOV             R1, SP  ; buf
MOVS            R2, #0x10 ; size
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
ADD             SP, SP, #0x14
POP             {R4,result,PC}
; End of function single_BM1385_print_lcd

ALIGN 4
off_11C44 DCD dword_2972C



; int __fastcall BM1385_is_nonce_or_reg_value(unsigned __int8 data)
EXPORT BM1385_is_nonce_or_reg_value
BM1385_is_nonce_or_reg_value
data = R0               ; unsigned __int8
LSRS            data, data, #7
BX              LR
; End of function BM1385_is_nonce_or_reg_value




; int __fastcall single_BM1385_check_nonce(unsigned __int8 which_chain, unsigned __int8 *nonce_data)
EXPORT single_BM1385_check_nonce
single_BM1385_check_nonce

var_C= -0xC
temp_nonce= -8

which_chain = R0        ; unsigned __int8
nonce_data = R1         ; unsigned __int8 *
PUSH.W          {R4-R11,LR}
MOV             R8, nonce_data
LDRB.W          R3, [R8]
MOV             R6, which_chain
MOVW            nonce_data, #:lower16:gChain_Asic_Interval
nonce_data = R8         ; unsigned __int8 *
SUB             SP, SP, #0xC
LDRB.W          R5, [nonce_data,#1]
MOVT            R1, #:upper16:gChain_Asic_Interval
MOV             which_chain, R3
LDRB.W          R2, [nonce_data,#3]
LSLS            R3, R3, #0x18
LDRB.W          R4, [nonce_data,#2]
LDR             R1, [R1]
ORR.W           R3, R3, R5,LSL#16
AND.W           R5, R2, #0x3F ; '?'
ORRS            R3, R2
ORR.W           R4, R3, R4,LSL#8
temp_nonce_0 = R4       ; unsigned int
BL              __aeabi_uidiv
which_asic = R0         ; unsigned int
which_core = R5         ; unsigned int
LDRB.W          R7, [nonce_data,#4]
MOV             R2, which_asic
CMP             which_asic, #0
BNE.W           loc_11E70
CMP             which_core, #0x31 ; '1'
BHI.W           loc_11E2C
MOVW            R3, #:lower16:Conf
AND.W           R7, R7, #0x7F
which_pattern = R7      ; unsigned int
MOVT            R3, #:upper16:Conf
LDR             R1, [R3,#configuration.pattern_number]
CMP             which_pattern, R1
ITTT CS
MOVWCS          which_asic, #:lower16:aSReceivedWorkI ; "%s: received work_id = %02d nonce. erro"...
which_asic = R2         ; unsigned int
MOVCS           which_asic, which_pattern
MOVTCS          R0, #:upper16:aSReceivedWorkI ; "%s: received work_id = %02d nonce. erro"...
BCS.W           loc_11E36
CMP             which_core, #0x1F
LDR.W           R0, [R3,#configuration.OpenCoreNum2]
OpenCoreNum2 = R0       ; unsigned int
LDR.W           R1, [R3,#configuration.OpenCoreNum1]
OpenCoreNum1 = R1       ; unsigned int
ITT LS
ADDLS           OpenCoreNum2, which_core, #1
MOVLS           R3, R2
BLS             loc_11D82
MOVS            R3, #0x20 ; ' '

loc_11CCC
the_core_should_be_test = R2; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum1 = R1       ; unsigned int
SUBS            R3, #1
BNE             loc_11CCC
OpenCoreNum2 = R0       ; unsigned int
SUB.W           OpenCoreNum1, which_core, #0x1F

loc_11CE0
i = R3                  ; unsigned int
TST.W           OpenCoreNum2, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R3, R1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
i = R3                  ; unsigned int
BCC             loc_11CE0

loc_11CF4
SUBS            R2, #1
MOVW            i, #:lower16:cgpu
ADD.W           R2, R2, #0x20000
MOVT            R3, #:upper16:cgpu
ADDS            R2, #0x2A ; '*'
ADD.W           which_pattern, which_pattern, which_pattern,LSL#4
ADD.W           R2, R3, R2,LSL#2
LDR             R3, [R2,#4]
ADD.W           R7, R3, R7,LSL#2
work = R7               ; work *
LDR             R3, [work,#4]
CMP             temp_nonce_0, R3
BEQ             loc_11D98
MOVW            R3, #:lower16:HW_check_mutex
ADD.W           R10, R6, R6,LSL#1
MOVT            R3, #:upper16:HW_check_mutex
ADD.W           R10, R3, R10,LSL#3
MOV             R9, #gWork_Num_For_Hw_Check
MOV             R0, R10 ; mutex
BLX             pthread_mutex_lock
LDRB.W          work, [R9]
CMP             R7, #0
BEQ.W           loc_11E66
MOVW            R3, #:lower16:gWorks_For_Hw_Check
ADD.W           R7, R6, R6,LSL#4
MOVT            R3, #:upper16:gWorks_For_Hw_Check
ADD.W           R7, R3, R7,LSL#9
MOV.W           nonce_data, #0
B               loc_11D5E

loc_11D56
i = R8                  ; unsigned int
LDRB.W          R3, [R9]
CMP             R3, i
BLS             loc_11DF0

loc_11D5E               ; work
MOV             R0, R7
MOVS            R2, #0  ; print
MOV             R1, temp_nonce_0 ; nonce
ADD.W           i, i, #1
BL              check_hw
i = R8                  ; unsigned int
ADDS            R7, #0x44 ; 'D'
MOV             R11, R0
CMP             R0, #0
BNE             loc_11D56
MOV             R0, R10 ; mutex
BLX             pthread_mutex_unlock
MOV             R0, R11
ADD             SP, SP, #0xC
POP.W           {temp_nonce_0-R11,PC}

loc_11D82
nonce_data = R8         ; unsigned __int8 *
which_pattern = R7      ; unsigned int
i = R3                  ; unsigned int
the_core_should_be_test = R2; unsigned int
OpenCoreNum1 = R1       ; unsigned int
TST.W           OpenCoreNum1, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R3, R0
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
i = R3                  ; unsigned int
BCC             loc_11D82
B               loc_11CF4

loc_11D98
match_nonce = R3        ; unsigned int
work = R7               ; work *
ADD.W           work, work, R6,LSL#2
LDR             R0, [R7,#0x34]
CBZ             R0, loc_11DBE
MOVW            match_nonce, #:lower16:gRepeated_Nonce_Id
ADDS            R0, #1
MOVT            R3, #:upper16:gRepeated_Nonce_Id
STR             R0, [R7,#0x34]
LDR.W           R2, [R3,R6,LSL#2]
MOVS            R0, #0
ADDS            R2, #1
STR.W           R2, [R3,R6,LSL#2]

loc_11DB8
ADD             SP, SP, #0xC
POP.W           {R4-R11,PC}

loc_11DBE
nonce_data = R8         ; unsigned __int8 *
which_core = R5         ; unsigned int
match_nonce = R3        ; unsigned int
temp_nonce_0 = R4       ; unsigned int
ADD.W           which_core, which_core, R6,LSL#17
MOVW            match_nonce, #:lower16:gAsic_Core_Nonce_Num
MOVW            R2, #:lower16:gValid_Nonce_Num
MOVT            R3, #:upper16:gAsic_Core_Nonce_Num
MOVT            R2, #:upper16:gValid_Nonce_Num
MOVS            R1, #1
LDR.W           temp_nonce_0, [R2,R6,LSL#2]
STR             R1, [R7,#0x34]
LDR.W           R1, [R3,R5,LSL#2]
ADDS            R4, #1
STR.W           R4, [R2,R6,LSL#2]
ADDS            R1, #1
STR.W           R1, [R3,R5,LSL#2]
ADD             SP, SP, #0xC
POP.W           {R4-R11,PC}

loc_11DF0               ; mutex
which_core = R5         ; unsigned int
temp_nonce_0 = R4       ; unsigned int
i = R8                  ; unsigned int
ret = R0                ; int
MOV             ret, R10
ret = R11               ; int
BLX             pthread_mutex_unlock
CMP.W           ret, #1
IT NE
MOVNE           R0, #0
BNE             loc_11DB8
MOVW            R7, #:lower16:gHw_Nonce_Num
STR             temp_nonce_0, [SP,#0xC+temp_nonce]
MOVT            R7, #:upper16:gHw_Nonce_Num
MOVW            R0, #:lower16:aSFindAHwChainD ; "%s: Find a HW. Chain%d ASIC%d Core%d : "...
LDR.W           temp_nonce_0, [R7,R6,LSL#2]
MOV             R2, R6
STR             which_core, [SP,#0xC+var_C]
MOVT            R0, #:upper16:aSFindAHwChainD ; "%s: Find a HW. Chain%d ASIC%d Core%d : "...
MOVS            R3, #0
LDR             R1, =__FUNCTION__.8184 ; "single_BM1385_check_nonce"
ADDS            R4, #1
STR.W           R4, [R7,R6,LSL#2]
BLX             printf
MOVS            R0, #0
B               loc_11DB8

loc_11E2C
nonce_data = R8         ; unsigned __int8 *
which_asic = R0         ; unsigned int
temp_nonce_0 = R4       ; unsigned int
MOVW            which_asic, #:lower16:aSReceivedCore0 ; "%s: received core%02d nonce. error!!!\t"
which_asic = R2         ; unsigned int
MOV             which_asic, which_core
MOVT            R0, #:upper16:aSReceivedCore0 ; "%s: received core%02d nonce. error!!!\t"

loc_11E36
LDR             R1, =__FUNCTION__.8184 ; "single_BM1385_check_nonce"
BLX             printf
LDRB.W          which_core, [nonce_data,#4]
MOVW            R0, #:lower16:aReceivedDataIs ; ",received data is : 0x%02x%02x%02x%02x%"...
LDRB.W          temp_nonce_0, [nonce_data,#3]
MOVT            R0, #:upper16:aReceivedDataIs ; ",received data is : 0x%02x%02x%02x%02x%"...
LDRB.W          R3, [nonce_data,#2]
LDRB.W          R2, [nonce_data,#1]
LDRB.W          R1, [nonce_data]
STMEA.W         SP, {R4,R5}
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_11DB8

loc_11E66               ; mutex
which_core = R5         ; unsigned int
temp_nonce_0 = R4       ; unsigned int
MOV             R0, R10
BLX             pthread_mutex_unlock
MOV             R0, R7
B               loc_11DB8

loc_11E70
which_asic = R2         ; unsigned int
MOV             R0, #aSReceivedAsic0 ; "%s: received ASIC%02d nonce. error!!!\t"
B               loc_11E36
; End of function single_BM1385_check_nonce

ALIGN 4
off_11E7C DCD __FUNCTION__.8184 ; "single_BM1385_check_nonce"



; int __fastcall single_BM1385_check_register_value(unsigned __int8 which_chain, unsigned __int8 *register_data)
EXPORT single_BM1385_check_register_value
single_BM1385_check_register_value
which_chain = R0        ; unsigned __int8
register_data = R1      ; unsigned __int8 *
PUSH            {R3-R7,LR}
MOV             R3, #reg_value_buf
LDR             R3, [R3]
LDR             R6, [R3,#8]
CMP.W           R6, #0x1FE
BHI             loc_11ED4
LDRB            R5, [register_data,#1]
ADDS            R6, #1
LDRB.W          LR, [register_data]
LDRB            R4, [register_data,#3]
LDRB            R7, [register_data,#2]
LSLS            R5, R5, #0x10
LDR             R2, [R3]
ORR.W           R5, R5, LR,LSL#24
ORRS            R4, R5
ADD.W           R5, R3, R2,LSL#3
ORR.W           R4, R4, R7,LSL#8
ADDS            R2, #1
CMP.W           R2, #0x200
STR             R4, [R5,#0x10]
LDRB            register_data, [register_data,#4]
STRB            which_chain, [R5,#0x17]
MOV.W           which_chain, #0
AND.W           R1, R1, #0x1F
STRB            R1, [R5,#0x16]
STR             R6, [R3,#8]
STR             R2, [R3]
BCC             locret_11ED2
STR             R0, [R3]
POP             {R3-R7,PC}

locret_11ED2
POP             {R3-R7,PC}

loc_11ED4
which_chain = R0        ; unsigned __int8
register_data = R1      ; unsigned __int8 *
MOVW            which_chain, #:lower16:aSRegValueBufBu ; "%s: reg_value_buf buffer is full!\n"
LDR             register_data, =__FUNCTION__.8201 ; "single_BM1385_check_register_value"
MOVT            R0, #:upper16:aSRegValueBufBu ; "%s: reg_value_buf buffer is full!\n"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
POP             {R3-R7,PC}
; End of function single_BM1385_check_register_value

off_11EE8 DCD __FUNCTION__.8201 ; "single_BM1385_check_register_value"



; void *__fastcall single_BM1385_receive_func(void *arg)
EXPORT single_BM1385_receive_func
single_BM1385_receive_func

var_5FC= -0x5FC
var_5F8= -0x5F8
var_5F4= -0x5F4
var_5F0= -0x5F0
temp_buf= -0x5E8
var_5E3= -0x5E3
var_5E1= -0x5E1
data_buf= -0x5E0
receive_buf= -0x3EC

arg = R0                ; void *
which_chain = R4        ; unsigned __int8
PUSH.W          {which_chain-R11,LR}
MOV             R3, arg
chain_info = R0         ; chain_info *
SUBW            SP, SP, #0x5FC
LDRB            which_chain, [chain_info]
MOV.W           R2, #0x3E8 ; n
MOVS            R1, #0  ; c
LDRB            R5, [R3,#1]
which_i2c = R5          ; unsigned __int8
ADD             chain_info, SP, #0x5FC+receive_buf ; s
chain_info = R3         ; chain_info *
BLX             memset
MOV.W           R2, #0x1F4 ; n
MOVS            R1, #0  ; c
ADD             R0, SP, #0x5FC+data_buf ; s
MOVW            R9, #:lower16:start_receive
BLX             memset
MOVW            R0, #:lower16:aSWhichChainDWh ; "%s: which_chain = %d, which_i2c = %d\n"
MOV             R3, which_i2c
MOV             R2, which_chain
MOVS            which_i2c, #0
which_i2c = R3          ; unsigned __int8
LDR             R1, =__FUNCTION__.8259 ; "single_BM1385_receive_func"
MOVT            R0, #:upper16:aSWhichChainDWh ; "%s: which_chain = %d, which_i2c = %d\n"
STR             R5, [SP,#0x5FC+temp_buf]
MOV             R6, R5
STRB.W          R5, [SP,#0x5FC+temp_buf+4]
MOV             R8, R6
BLX             printf
MOVW            R3, #0xCCCD
MOV             R0, which_chain ; which_chain
MOV             R5, R3
MOVW            R3, #:lower16:gStartTest
MOV             R7, R3
MOVW            R3, #:lower16:gIsOpenCoreEnd
STR             R3, [SP,#0x5FC+var_5F4]
MOVT            R9, #:upper16:start_receive
BL              clear_uart_rx_fifo
MOV             R3, R5
MOVT            R3, #0xCCCC
STR             R3, [SP,#0x5FC+var_5F0]
MOV             R3, R7
MOVT            R3, #:upper16:gStartTest
STR             R3, [SP,#0x5FC+var_5F8]
LDR             R3, [SP,#0x5FC+var_5F4]
MOVT            R3, #:upper16:gIsOpenCoreEnd
STR             R3, [SP,#0x5FC+var_5F4]

loc_11F68
LDRB.W          R0, [R9]
CMP             R0, #0
BEQ             loc_1205C

loc_11F70
CMP.W           R8, #2
MOVW            R5, #0x4B40
MOVW            R0, #0x1388 ; useconds
ITE HI
MOVHI           R7, #0
MOVLS           R7, #1
MOVT            R5, #0x4C ; 'L'
BLX             usleep
B               loc_11F90

loc_11F8C
len = R0                ; unsigned int
SUBS            R5, #1
BEQ             loc_11F68

loc_11F90               ; n
MOV.W           R2, #0x3E8
MOVS            R1, #0  ; c
ADD             R0, SP, #0x5FC+receive_buf ; s
BLX             memset
MOV.W           R2, #0x3E8 ; buf_length
ADD             R1, SP, #0x5FC+receive_buf ; buf
MOV             R0, which_chain ; which_uart
BL              uart_receive
len = R0                ; unsigned int
CMP             len, #0
ITE EQ
MOVEQ           R3, #0
ANDNE.W         R3, R7, #1
CMP             R3, #0
BEQ             loc_11F8C
data_buf_w_p = R6       ; unsigned int
ADD             R3, SP, #0x5FC+data_buf
SUBS            R2, data_buf_w_p, #1
SUBS            R5, len, #1
ADD             R2, R3
ADD             R3, SP, #0x5FC+receive_buf
ADD             R5, R3
ADDW            R3, SP, #0x5FC+data_buf+0x1F3

loc_11FC6
LDRB.W          R1, [R3,#1]!
CMP             R3, R5
STRB.W          R1, [R2,#1]!
BNE             loc_11FC6
ADD             R6, len
CMP             R6, #4
BLS             loc_11F68
error_counter = R8      ; unsigned int
LDR             R3, [SP,#0x5FC+var_5F0]
ADD.W           R11, SP, #0x5FC+data_buf
ADD.W           R7, SP, #0x5FC+var_5E3
MOV.W           R10, #0
UMULL           len, R1, R6, R3
MOV             R3, R11
LSRS            R5, R1, #2
ADD.W           R5, R5, R5,LSL#2
ADD             R3, R5
STR             R3, [SP,#0x5FC+var_5FC]
MOV             R3, R9
MOV             R9, R5
MOV             R5, R11
MOV             R11, R3

loc_11FFE
ADD             R3, SP, #0x5FC+temp_buf
MOV             R1, R5
STR.W           R10, [SP,#0x5FC+temp_buf]
STRB.W          R10, [SP,#0x5FC+temp_buf+4]

loc_1200A
LDRB.W          R2, [R1],#1
STRB.W          R2, [R3],#1
CMP             R3, R7
BNE             loc_1200A
LDRSB.W         R3, [SP,#0x5FC+temp_buf+4]
CMP             R3, #0
BLT             loc_12064
ADD             R1, SP, #0x5FC+temp_buf ; register_data
MOV             R0, which_chain ; which_chain
BL              single_BM1385_check_register_value
ret = R0                ; int
ADDS            ret, #1
BEQ             loc_12080

loc_1202A
LDR             R3, [SP,#0x5FC+var_5FC]
ADDS            R5, #5
CMP             R3, R5
BNE             loc_11FFE
MOV             R5, R9
MOV             R9, R11
SUBS            R6, R6, R5
remaining_len = R6      ; unsigned int
BEQ             loc_11F68
SUBS            R3, R5, #1
ADD             R1, SP, #0x5FC+data_buf
ADDS            R0, remaining_len, R3
ADD.W           R2, SP, #0x5FC+var_5E1
ADD             R3, R1
ADD             R0, R1

loc_12048
LDRB.W          R1, [R3,#1]!
CMP             R3, R0
STRB.W          R1, [R2,#1]!
BNE             loc_12048
LDRB.W          R0, [R9]
CMP             R0, #0
BNE             loc_11F70

loc_1205C
ADDW            SP, SP, #0x5FC
POP.W           {which_chain-R11,PC}

loc_12064
error_counter = R8      ; unsigned int
LDR             R3, [SP,#0x5FC+var_5F8]
LDRB            R3, [R3]
CMP             R3, #0
BEQ             loc_1202A
LDR             R3, [SP,#0x5FC+var_5F4]
LDRB            R3, [R3]
CMP             R3, #0
BEQ             loc_1202A
ADD             R1, SP, #0x5FC+temp_buf ; nonce_data
MOV             R0, which_chain ; which_chain
BL              single_BM1385_check_nonce
ret = R0                ; int
ADDS            ret, #1
BNE             loc_1202A

loc_12080
ADD.W           error_counter, error_counter, #1
B               loc_1202A
; End of function single_BM1385_receive_func

ALIGN 4
off_12088 DCD __FUNCTION__.8259 ; "single_BM1385_receive_func"



; void singleAsicTest_BM1385()
EXPORT singleAsicTest_BM1385
singleAsicTest_BM1385

lcd_display_buf= -0x14

PUSH.W          {R4-R9,LR}
SUB             SP, SP, #0x14
LDR             R5, =dword_29798
MOV             R4, SP
MOV             R6, #lcd_fd
LDR             R2, [R5,#(dword_297A0 - 0x29798)]
LDR             R3, [R5,#(dword_297A4 - 0x29798)]
LDR             R0, [R5]
LDR             R1, [R5,#(dword_2979C - 0x29798)]
STM             R4!, {R0-R3}
MOVW            R0, #:lower16:aBeginSTest ; "\nBegin %s test\n"
ADD.W           R1, R5, #0x10
MOVT            R0, #:upper16:aBeginSTest ; "\nBegin %s test\n"
BLX             printf
MOV             R0, #aDate ; "date"
BLX             system
MOVS            R0, #0xA ; c
BLX             putchar
MOVW            R0, #:lower16:lcd_output
MOVS            R2, #0x40 ; '@' ; n
MOVT            R0, #:upper16:lcd_output ; s
MOVS            R1, #0x20 ; ' ' ; c
BLX             memset
LDR             R0, [R6] ; fd
CMP             R0, #0
BLE             loc_120F8
MOVS            R2, #0  ; whence
MOV             R1, R2  ; offset
BLX             lseek
MOVW            R1, #:lower16:lcd_output
LDR             R0, [R6] ; fd
MOVT            R1, #:upper16:lcd_output ; buf
MOVS            R2, #0x40 ; '@' ; n
BLX             write

loc_120F8
BL              init_fpga
MOVW            R4, #:lower16:gChain
MOVS            R0, #0  ; address
BL              read_axi_fpga
MOVT            R4, #:upper16:gChain
ORR.W           R1, R0, #0x20000000 ; data
MOVS            R0, #0  ; address
BL              write_axi_fpga
BL              reset_single_BM1385_global_arg
BL              check_chain
LDRB            R3, [R4]
CMP             R3, #0xFF
BEQ.W           loc_1223C
LDR             R5, =cgpu.show_id
MOV             R7, #chain_info_0
MOVW            R2, #:lower16:(single_BM1385_show_status_func+1)
ADD.W           R3, R7, R3,LSL#1 ; arg
MOVT            R2, #:upper16:(single_BM1385_show_status_func+1) ; start_routine
MOVS            R1, #0  ; attr
MOV             R0, R5  ; newthread
MOVW            R6, #:lower16:start_receive
BLX             pthread_create
BL              reset_hash_board
LDRB            R3, [R4]
MOV             R2, #(single_BM1385_receive_func+1) ; start_routine
MOVS            R1, #0  ; attr
MOV.W           R9, #1
MOVT            R6, #:upper16:start_receive
SUBS            R0, R5, #4 ; newthread
STRB.W          R9, [R6]
ADD.W           R3, R7, R3,LSL#1 ; arg
SUB.W           R6, R5, #0x80008
MOVW            R8, #:lower16:Conf
BLX             pthread_create
MOVW            R0, #:lower16:aCheckAsicNumbe ; "\n--- check asic number"
MOVT            R8, #:upper16:Conf
MOVT            R0, #:upper16:aCheckAsicNumbe ; "\n--- check asic number"
BLX             puts
MOVS            R2, #0  ; reg
MOV             R3, R9  ; mode
MOV             R1, R2  ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              check_BM1385_asic_reg
LDRB            R3, [R4]
MOV             R0, #aCheckChainAsic ; "\n--- check chain: asicNum = %d\n"
ADD             R3, R6  ; cgpu
ADD.W           R3, R3, #0x100000
LDRB.W          R1, [R3,#(Conf.OpenCoreNum1+3 - 0x3310C3)]
BLX             printf
LDRB            R3, [R4]
LDR.W           R2, [R8,#configuration.AsicNum]
ADD             R3, R6  ; cgpu
ADD.W           R3, R3, #0x100000
LDRB.W          R3, [R3,#(Conf.OpenCoreNum1+3 - 0x3310C3)]
CMP             R3, R2
BEQ             loc_1226C
LDR.W           R0, [R5,#(cgpu.receive_id - 0x2B0FCC)] ; th
BLX             pthread_cancel
LDR             R0, [R5] ; th
BLX             pthread_cancel
LDRB            R3, [R4]
MOV             R1, #(aT1DT2D+0xC) ; format
ADD.W           R0, SP, #0x14+lcd_display_buf+7 ; s
ADD             R3, R6  ; cgpu
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#(Conf.OpenCoreNum1+3 - 0x3310C3)]
BLX             sprintf
MOVW            R1, #:lower16:aOnlyHave ; "   Only have    "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aOnlyHave ; "   Only have    "
MOVS            R0, #0  ; line
BL              write_lcd
MOV             R1, SP  ; buf
MOV             R0, R9  ; line
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aAsic ; "      ASIC      "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aAsic ; "      ASIC      "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
LDRB            R3, [R4]
MOVW            R0, #:lower16:aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
LDR             R1, =__FUNCTION__.8283 ; "singleAsicTest_BM1385"
MOVT            R0, #:upper16:aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
ADD             R6, R3  ; cgpu
ADD.W           R6, R6, #0x100000
LDRB.W          R2, [R6,#(Conf.OpenCoreNum1+3 - 0x3310C3)]
BLX             printf
MOV             R0, #asc_29F80 ; "----------------------------\n\n"
BLX             puts
ADD             SP, SP, #0x14
POP.W           {R4-R9,PC}

loc_1223C
LDR             R4, =cgpu.send_id
MOV             R1, #aNoHashBoard ; "  no hash board "
MOVS            R2, #0x10 ; size
MOVS            R0, #1  ; line
BL              write_lcd
LDR             R0, [R4,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R4,#(cgpu.show_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #aNoHashBoardPle ; "\nNo hash board, please plug in it"
BLX             puts
ADD             SP, SP, #0x14
POP.W           {R4-R9,PC}

loc_1226C
BL              single_BM1385_calculate_timeout_and_baud
MOV             R3, R9  ; mode
LDR.W           R2, [R8,#configuration.Freq] ; freq
MOVS            R1, #0  ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              set_BM1385_freq
LDRB            R0, [R4] ; which_chain
ADD.W           R6, R6, #0x80000
BL              single_BM1385_set_address
MOVS            R2, #0  ; reg
MOV             R3, R9  ; mode
MOV             R1, R2  ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              check_BM1385_asic_reg
LDRB.W          R1, [R8,#configuration.baud] ; baud
LDRB            R0, [R4] ; which_chain
BL              single_BM1385_set_baud
LDRB            R0, [R4] ; which_chain
BL              single_BM1385_open_core
MOV             R0, #aBeginSendTestP ; "\nBegin send test pattern"
BLX             puts
MOV             R0, #aDate ; "date"
BLX             system
MOVS            R0, #0xA ; c
BLX             putchar
LDRB            R3, [R4]
MOVW            LR, #:lower16:gStartTest
MOVW            R2, #:lower16:(single_BM1385_send_func+1)
MOVT            LR, #:upper16:gStartTest
MOVT            R2, #:upper16:(single_BM1385_send_func+1) ; start_routine
MOV             R0, R6  ; newthread
MOVS            R1, #0  ; attr
STRB.W          R9, [LR]
ADD.W           R3, R7, R3,LSL#1 ; arg
BLX             pthread_create
LDR             R0, [R6] ; th
MOVS            R1, #0  ; thread_return
BLX             pthread_join
MOVS            R1, #0  ; thread_return
LDR             R0, [R6,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_join
LDR             R0, [R5] ; th
BLX             pthread_cancel
LDRB            R0, [R4] ; which_chain
BL              single_BM1385_get_result
result = R0             ; unsigned int
MOV             R1, result ; result
LDRB            result, [R4] ; which_chain
result = R1             ; unsigned int
BL              single_BM1385_print_lcd
MOVS            R0, #0  ; speed
BL              set_fan_speed
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
ADD             SP, SP, #0x14
POP.W           {R4-R9,PC}
; End of function singleAsicTest_BM1385

off_12320 DCD dword_29798
off_12324 DCD cgpu.show_id
off_12328 DCD __FUNCTION__.8283 ; "singleAsicTest_BM1385"
off_1232C DCD cgpu.send_id



; unsigned __int8 __fastcall CRC5(unsigned __int8 *ptr, unsigned __int8 len)
EXPORT CRC5
CRC5
ptr = R0                ; unsigned __int8 *
len = R1                ; unsigned __int8
PUSH.W          {R4-R11,LR}
CMP             len, #0
BEQ             loc_123AC
MOVS            R7, #1
MOVS            R6, #0
MOV             R2, R6
MOV             LR, R7
MOV             R12, R7
MOV             R8, R7
MOV             R9, R7
MOVS            R5, #0x80
B               loc_12350

loc_1234A
j = R5                  ; unsigned __int8
k = R2                  ; unsigned __int8
crcout_0 = R3           ; unsigned __int8
crcout_1 = R7           ; unsigned __int8
crcout_2 = R4           ; unsigned __int8
crcout_3 = R12          ; unsigned __int8
crcout_4 = R8           ; unsigned __int8
MOV             crcout_1, crcout_0
crcout_0 = R3           ; unsigned __int8
crcout_2 = R4           ; unsigned __int8
crcout_3 = R12          ; unsigned __int8
crcout_4 = R8           ; unsigned __int8
MOV             crcout_3, crcout_2
crcout_0 = R3           ; unsigned __int8
crcout_2 = R4           ; unsigned __int8
crcout_4 = R8           ; unsigned __int8
MOV             crcout_4, R11

loc_12350
i = R6                  ; unsigned __int8
crcin_1 = R14           ; unsigned __int8
crcin_2 = R12           ; unsigned __int8
crcin_3 = R8            ; unsigned __int8
crcin_4 = R9            ; unsigned __int8
crcin_0 = R7            ; unsigned __int8
LDRB            R3, [ptr]
ADDS            k, #1
UXTB            R2, R2
ADDS            i, #1
UXTB.W          R10, R6
MOV             R11, crcin_2
ANDS            R3, j
LSRS            j, j, #1
CMP             R3, #0
ITE EQ
MOVEQ           R3, crcin_4
EORNE.W         R3, crcin_4, #1
UXTB            R3, R3
crcout_0 = R3           ; unsigned __int8
crcout_1 = R7           ; unsigned __int8
CMP             R2, #8
ITTT EQ
ADDEQ           ptr, #1
MOVEQ           R2, #0
MOVEQ           R5, #0x80
CMP             len, R10
EOR.W           R4, crcout_0, LR
UXTB            R4, R4
ptr = R0                ; unsigned __int8 *
j = R5                  ; unsigned __int8
k = R2                  ; unsigned __int8
crcout_0 = R3           ; unsigned __int8
crcout_1 = R7           ; unsigned __int8
crcout_2 = R4           ; unsigned __int8
crcout_3 = R12          ; unsigned __int8
crcout_4 = R8           ; unsigned __int8
MOV             R9, crcout_4
MOV             LR, crcout_1
BHI             loc_1234A
CMP.W           crcout_4, #0
ITE NE
MOVNE           ptr, #0x10
MOVEQ           R0, #0
crc = R0                ; unsigned __int8
CMP.W           crcout_3, #0
BNE             loc_123B4

loc_12396
CBZ             R4, loc_1239C
ORR.W           crc, crc, #4

loc_1239C
CBZ             R7, loc_123A2
ORR.W           crc, crc, #2

loc_123A2
CBZ             R3, locret_123A8
ORR.W           crc, crc, #1

locret_123A8
POP.W           {R4-R11,PC}

loc_123AC
ptr = R0                ; unsigned __int8 *
MOVS            R3, #1
MOVS            ptr, #0x10
MOV             R4, R3
MOV             R7, R3

loc_123B4
crc = R0                ; unsigned __int8
ORR.W           crc, crc, #8
B               loc_12396
; End of function CRC5

ALIGN 4



; uint16_t __fastcall CRC16(const uint8_t *p_data, uint16_t w_len)
EXPORT CRC16
CRC16
p_data = R0             ; const uint8_t *
CBZ             R1, loc_123F2
PUSH            {R4,R5}
SUBS            R5, R1, #1
UXTH            R5, R5
MOVS            R3, #0xFF
MOVW            R1, #:lower16:chCRCHTalbe
ADD             R5, p_data
SUBS            R2, p_data, #1
MOV             R4, R3
MOVT            R1, #:upper16:chCRCHTalbe

loc_123D4
chCRCHi = R4            ; uint8_t
chCRCLo = R3            ; uint8_t
LDRB.W          R0, [R2,#1]!
EORS            R0, chCRCLo
CMP             R2, R5
LDRB            chCRCLo, [R1,R0]
ADD             R0, R1
EOR.W           R3, R3, chCRCHi
chCRCLo = R3            ; uint8_t
LDRB.W          chCRCHi, [R0,#0x100]
BNE             loc_123D4
ORR.W           R0, chCRCLo, chCRCHi,LSL#8
POP             {chCRCHi,R5}
BX              LR

loc_123F2
p_data = R0             ; const uint8_t *
MOVW            p_data, #0xFFFF
BX              LR
; End of function CRC16




; void reset_hash_board()
EXPORT reset_hash_board
reset_hash_board
PUSH            {R4,LR}
MOVW            R4, #:lower16:(gAsic_Core_Nonce_Num+0x1859C)
MOVW            R1, #0xFFFF ; data
MOVT            R4, #:upper16:(gAsic_Core_Nonce_Num+0x1859C)
MOVS            R0, #0xD ; address
BL              write_axi_fpga
MOV             R0, R4  ; useconds
BLX             usleep
MOVS            R0, #0xD ; address
MOVS            R1, #0  ; data
BL              write_axi_fpga
MOV             R0, R4  ; useconds
POP.W           {R4,LR}
B.W             j_usleep
; End of function reset_hash_board

ALIGN 8



; void *__fastcall single_BM1391_send_func(void *arg)
EXPORT single_BM1391_send_func
single_BM1391_send_func

var_A4= -0xA4
OpenCoreNum3= -0x98
OpenCoreNum4= -0x94
OpenCoreNum8= -0x90
var_8C= -0x8C
var_88= -0x88
var_84= -0x84
var_80= -0x80
useconds= -0x7C
test_core_number= -0x78
test_core_index= -0x74
var_70= -0x70
work_vil_1391= -0x6C
buf_vil= -0x38
var_4= -4

chain_info = R0         ; chain_info *
work = R6               ; work *
PUSH.W          {R4-R11,LR}
MOVW            R8, #:lower16:Conf
SUB             SP, SP, #0xA4
MOVT            R8, #:upper16:Conf
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
LDRB            R7, [chain_info]
which_chain = R7        ; unsigned __int8
ADD             chain_info, SP, #0xA4+buf_vil ; s
BLX             memset
MOVW            R4, #:lower16:gBegin_Get_Nonce
LDR.W           R3, [R8,#configuration.OpenCoreNum3]
MOVT            R4, #:upper16:gBegin_Get_Nonce
ADD.W           R9, R8, #0xDC
LDRB            R2, [R4]
STR             R3, [SP,#0xA4+OpenCoreNum3]
LDR.W           R3, [R8,#configuration.OpenCoreNum4]
LDR.W           R5, [R8,#configuration.OpenCoreNum1]
OpenCoreNum1 = R5       ; unsigned int
LDR.W           work, [R8,#configuration.OpenCoreNum2]
OpenCoreNum2 = R6       ; unsigned int
STR             R3, [SP,#0xA4+OpenCoreNum4]
OpenCoreNum4_0 = R3     ; unsigned int
LDM.W           R9, {R9-R11}
OpenCoreNum7 = R11      ; unsigned int
LDR.W           OpenCoreNum4_0, [R8,#configuration.OpenCoreNum8]
OpenCoreNum8_0 = R3     ; unsigned int
CBNZ            R2, loc_12486
MOVS            R0, #7  ; address
STR             OpenCoreNum8_0, [SP,#0xA4+OpenCoreNum8]
BL              read_axi_fpga
ORR.W           R1, R0, #0x10000 ; data
MOVS            R0, #7  ; address
BL              write_axi_fpga
LDR             R3, [SP,#0xA4+OpenCoreNum8]
MOVS            R2, #1
STRB            R2, [R4]

loc_12486
OpenCoreNum5 = R9       ; unsigned int
OpenCoreNum6 = R10      ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
LDR             R1, [SP,#0xA4+OpenCoreNum3]
MOVS            R4, #0x20 ; ' '
LDR             R0, [SP,#0xA4+OpenCoreNum4]
MOVS            R2, #0

loc_1248E
test_core_number_0 = R2 ; unsigned int
OpenCoreNum3_0 = R1     ; unsigned int
OpenCoreNum4_0 = R0     ; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum1 = R5       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
work = R6               ; work *
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum2 = R6       ; unsigned int
TST.W           OpenCoreNum3_0, #1
MOV.W           OpenCoreNum3_0, OpenCoreNum3_0,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum3_0 = R1     ; unsigned int
TST.W           OpenCoreNum4_0, #1
MOV.W           OpenCoreNum4_0, OpenCoreNum4_0,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum4_0 = R0     ; unsigned int
TST.W           OpenCoreNum5, #1
MOV.W           OpenCoreNum5, OpenCoreNum5,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum5 = R9       ; unsigned int
TST.W           OpenCoreNum6, #1
MOV.W           OpenCoreNum6, OpenCoreNum6,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum6 = R10      ; unsigned int
TST.W           OpenCoreNum7, #1
MOV.W           OpenCoreNum7, OpenCoreNum7,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum7 = R11      ; unsigned int
TST.W           OpenCoreNum8_0, #1
MOV.W           OpenCoreNum8_0, OpenCoreNum8_0,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum8_0 = R3     ; unsigned int
SUBS            R4, #1
BNE             loc_1248E
MOV             OpenCoreNum1, test_core_number_0
MOVW            OpenCoreNum3_0, #:lower16:__FUNCTION__.8697 ; "single_BM1391_send_func"
MOVW            OpenCoreNum4_0, #:lower16:aSThereAreDCore_0 ; "%s: There are %d cores should be test\n"
MOVT            R1, #:upper16:__FUNCTION__.8697 ; "single_BM1391_send_func"
MOVT            R0, #:upper16:aSThereAreDCore_0 ; "%s: There are %d cores should be test\n"
STR             test_core_number_0, [SP,#0xA4+test_core_number]
BLX             printf
CMP             test_core_number_0, #0
BEQ.W           loc_12736
ORR.W           R2, which_chain, #0x80
ADD.W           R3, which_chain, which_chain,LSL#4
MOV             R0, R2
STR             R2, [SP,#0xA4+var_8C]
ADD.W           LR, which_chain, which_chain,LSL#1
MOV             R2, #HW_check_mutex
LSLS            R3, R3, #9
LDR             R1, =(cgpu.workdataFilePrefix+0x3C)
ADD.W           R2, R2, LR,LSL#3
LSLS            R0, R0, #0x10
MOV             test_core_number_0, R3
STR             R3, [SP,#0xA4+var_84]
MOVW            OpenCoreNum2, #:lower16:gWorks_For_Hw_Check
work = R6               ; work *
STR             R2, [SP,#0xA4+OpenCoreNum4]
MOVW            R2, #:lower16:gReadingTemp
LDR.W           R3, [R8,#configuration.pattern_number]
MOVT            work, #:upper16:gWorks_For_Hw_Check
STR             R1, [SP,#0xA4+var_70]
MOVW            OpenCoreNum7, #:lower16:gSend_Work_Num
MOV             R1, R2
ORR.W           R2, R0, #0x1000000
STR             R4, [SP,#0xA4+test_core_index]
MOVT            R11, #:upper16:gSend_Work_Num
STR             R2, [SP,#0xA4+var_88]
ADDS            R4, work, R5
MOV             R2, R1
STR             work, [SP,#0xA4+var_80]
MOVT            R2, #:upper16:gReadingTemp
STR             R2, [SP,#0xA4+OpenCoreNum3]

loc_12568
LDR             R1, [SP,#0xA4+var_70]
MOVS            R5, #0
MOVW            R2, #:lower16:(gAsic_Core_Nonce_Num+0x492DC)
CMP             R5, R3
MOVT            R2, #:upper16:(gAsic_Core_Nonce_Num+0x492DC)
MOV             R0, R1
STR             R2, [SP,#0xA4+useconds]
LDR.W           R1, [R0,#4]!
STR             R1, [SP,#0xA4+OpenCoreNum8]
STR             R0, [SP,#0xA4+var_70]
which_pattern = R5      ; unsigned int
works_0 = R1            ; work *
BCS.W           loc_126D6

loc_12586
LDR             R3, [SP,#0xA4+OpenCoreNum3]
LDRB            R3, [R3]
CMP             R3, #0
BNE.W           loc_1272E

loc_12590               ; address
MOVS            R0, #3
MOV.W           R9, #1
BL              read_axi_fpga
work_fifo_ready = R0    ; unsigned int
MOV             R3, #gChain
LDRB            R3, [R3]
LSL.W           R3, R9, R3
TST             R3, work_fifo_ready
BEQ.W           loc_12724
LDR             R3, [SP,#0xA4+OpenCoreNum8]
ADD.W           work, which_pattern, which_pattern,LSL#4
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             work_fifo_ready, SP, #0xA4+buf_vil ; s
ADD.W           work, R3, work,LSL#2
BLX             memset
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             R0, SP, #0xA4+work_vil_1391 ; s
BLX             memset
LDRB.W          R0, [SP,#0xA4+var_8C]
ADDS            R3, work, #7
ADD.W           R2, work, #0x13
ADD.W           R1, SP, #0xA4+work_vil_1391.work_count+3
STRB.W          R9, [SP,#0xA4+work_vil_1391]
STRB.W          R0, [SP,#0xA4+work_vil_1391.chain_id]
STR             which_pattern, [SP,#0xA4+work_vil_1391.work_count]

loc_125E4
LDRB.W          R0, [R3,#1]!
CMP             R2, R3
STRB.W          R0, [R1,#1]!
BNE             loc_125E4
ADD.W           R3, SP, #0xA4+work_vil_1391.data+0xB
ADD.W           R0, SP, #0xA4+work_vil_1391.midstate+0x1F

loc_125F8
LDRB.W          R1, [R2,#1]!
STRB.W          R1, [R3,#1]!
CMP             R3, R0
BNE             loc_125F8
ADD             R3, SP, #0xA4+work_vil_1391
LDR             R2, [SP,#0xA4+var_88]
ADD.W           R10, SP, #0xA4+work_vil_1391.data+4
MOV             R12, R3
ADD.W           R9, SP, #0xA4+var_4
STR             R2, [SP,#0xA4+buf_vil]
STR.W           which_pattern, [R9,#-0x30]!

loc_12618
LDRB.W          R1, [R12,#9]
ADD.W           R12, R12, #4
LDRB.W          LR, [R12,#4]
LDRB.W          R2, [R12,#7]
LDRB.W          R0, [R12,#6]
CMP             R12, R10
MOV.W           R1, R1,LSL#16
ORR.W           R1, R1, LR,LSL#24
ORR.W           R2, R2, R1
ORR.W           R2, R2, R0,LSL#8
STR.W           R2, [R9,#4]!
BNE             loc_12618
ADD.W           R12, SP, #0xA4+buf_vil+0x10
ADD.W           R9, SP, #0xA4+work_vil_1391.midstate+0xC

loc_1264C
LDRB            R1, [R3,#0x15]
ADDS            R3, #4
LDRB.W          LR, [R3,#0x10]
LDRB            R2, [R3,#0x13]
LDRB            R0, [R3,#0x12]
CMP             R3, R9
MOV.W           R1, R1,LSL#16
ORR.W           R1, R1, LR,LSL#24
ORR.W           R2, R2, R1
ORR.W           R2, R2, R0,LSL#8
STR.W           R2, [R12,#4]!
BNE             loc_1264C
ADD             R0, SP, #0xA4+buf_vil ; value
BL              set_TW_write_command
LDR             R0, [SP,#0xA4+OpenCoreNum4] ; mutex
BLX             pthread_mutex_lock
LDR             R3, [SP,#0xA4+var_84]
ADD.W           R0, R3, #0x2180
LDR             R3, [SP,#0xA4+var_80]
ADDS            R0, #0x3C ; '<'
ADD             R0, R3  ; dest

loc_12688
SUB.W           R9, R0, #0x44 ; 'D'
MOVS            R2, #0x44 ; 'D' ; n
MOV             R1, R9  ; src
BLX             memcpy
CMP             R4, R9
MOV             R0, R9
BNE             loc_12688
MOVW            R2, #:lower16:gWork_Num_For_Hw_Check
MOV             R1, work ; src
MOVT            R2, #:upper16:gWork_Num_For_Hw_Check
MOV             R0, R4  ; dest
LDRB            R3, [R2]
ADDS            which_pattern, #1
ADDS            R3, #1
UXTB            R3, R3
CMP             R3, #0x7E ; '~'
IT HI
MOVHI           R3, #0x7F
STRB            R3, [R2]
MOVS            R2, #0x44 ; 'D' ; n
BLX             memcpy
LDR             R0, [SP,#0xA4+OpenCoreNum4] ; mutex
BLX             pthread_mutex_unlock
which_pattern = R5      ; unsigned int
LDR.W           R3, [R11,which_chain,LSL#2]
ADDS            R3, #1
STR.W           R3, [R11,which_chain,LSL#2]

loc_126CC
LDR.W           R3, [R8,#configuration.pattern_number]
CMP             which_pattern, R3
BCC.W           loc_12586

loc_126D6
LDR             R2, [SP,#0xA4+test_core_index]
LDR             R1, [SP,#0xA4+test_core_number]
ADDS            R2, #1
CMP             R1, R2
STR             R2, [SP,#0xA4+test_core_index]
test_core_index_0 = R2  ; unsigned int
BNE.W           loc_12568
MOV             test_core_index_0, R1
MUL             R2, R3, R2
LDR.W           R3, [R11,which_chain,LSL#2]
CMP             R3, R2
ITTTT CC
MOVWCC          which_pattern, #:lower16:__FUNCTION__.8697 ; "single_BM1391_send_func"
MOVWCC          R4, #:lower16:aSChainDSendWor ; "\n\n---%s: Chain%d send work num : %d, "...
MOVTCC          R5, #:upper16:__FUNCTION__.8697 ; "single_BM1391_send_func"
MOVTCC          R4, #:upper16:aSChainDSendWor ; "\n\n---%s: Chain%d send work num : %d, "...
BCS             loc_1274C

loc_12704
STR             R2, [SP,#0xA4+var_A4]
MOV             R1, R5
MOV             R2, which_chain
MOV             R0, R4  ; format
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R1, [SP,#0xA4+test_core_number]
LDR.W           R3, [R11,which_chain,LSL#2]
MUL             R2, R2, R1
CMP             R3, R2
BCC             loc_12704
B               loc_1274C

loc_12724               ; useconds
which_pattern = R5      ; unsigned int
work_fifo_ready = R0    ; unsigned int
MOVW            work_fifo_ready, #0x1388
BLX             usleep
B               loc_126CC

loc_1272E               ; useconds
LDR             R0, [SP,#0xA4+useconds]
BLX             usleep
B               loc_12590

loc_12736
test_core_number_0 = R5 ; unsigned int
OpenCoreNum2 = R6       ; unsigned int
OpenCoreNum5 = R9       ; unsigned int
OpenCoreNum6 = R10      ; unsigned int
OpenCoreNum7 = R11      ; unsigned int
MOVW            R3, #:lower16:gSend_Work_Num
MOVW            R2, #:lower16:gReadingTemp
MOVT            R3, #:upper16:gSend_Work_Num
MOVT            R2, #:upper16:gReadingTemp
LDR.W           R3, [R3,which_chain,LSL#2]
STR             R2, [SP,#0xA4+OpenCoreNum3]

loc_1274C
work = R6               ; work *
MOVW            R1, #:lower16:__FUNCTION__.8697 ; "single_BM1391_send_func"
MOVW            R0, #:lower16:aSChainDSendWor_0 ; "\n\n---%s: Chain%d send work num : %d\n"
MOVT            R1, #:upper16:__FUNCTION__.8697 ; "single_BM1391_send_func"
MOV             R2, which_chain
MOVT            R0, #:upper16:aSChainDSendWor_0 ; "\n\n---%s: Chain%d send work num : %d\n"
MOVW            R4, #:lower16:gValid_Nonce_Num
BLX             printf
MOVW            R0, #:lower16:aSendTestPatter ; "\nsend test pattern done"
MOVT            R4, #:upper16:gValid_Nonce_Num
MOVT            R0, #:upper16:aSendTestPatter ; "\nsend test pattern done"
MOVW            R9, #:lower16:(gAsic_Core_Nonce_Num+0xC33FC)
BLX             puts
MOVW            R0, #:lower16:aDate ; "date"
MOVT            R9, #:upper16:(gAsic_Core_Nonce_Num+0xC33FC)
MOVT            R0, #:upper16:aDate ; "date"
MOVS            R5, #0
BLX             system
MOVS            R0, #0xA ; c
ADDS            R5, #1
BLX             putchar
LDR.W           R8, [R4,which_chain,LSL#2]
received_data = R8      ; unsigned int
MOV             R0, R9  ; useconds
MOV             work, received_data
count = R5              ; unsigned int
CMP             R8, work
BNE             loc_127B4

loc_127A0
CMP             count, #2
BHI             loc_127C6
BLX             usleep

loc_127A8
LDR.W           work, [R4,which_chain,LSL#2]
ADDS            R5, #1
count = R5              ; unsigned int
MOV             R0, R9  ; useconds
CMP             R8, work
BEQ             loc_127A0

loc_127B4
BLX             usleep
MOV             R8, work
MOVS            count, #0
B               loc_127A8

loc_127BE               ; useconds
count = R5              ; unsigned int
MOVW            R0, #0x2710
BLX             usleep

loc_127C6
LDR             R3, [SP,#0xA4+OpenCoreNum3]
LDRB            R3, [R3]
CMP             R3, #0
BNE             loc_127BE
MOVW            R3, #:lower16:start_receive
MOVW            R0, #:lower16:aToStopReceive ; "to stop receive"
MOVT            R3, #:upper16:start_receive
MOVS            R4, #0
MOVT            R0, #:upper16:aToStopReceive ; "to stop receive"
STRB            R4, [R3]
BLX             puts
MOV             R0, R4
ADD             SP, SP, #0xA4
POP.W           {R4-R11,PC}
; End of function single_BM1391_send_func

ALIGN 0x10
off_127F0 DCD cgpu.workdataFilePrefix+0x3C



; void __fastcall BM1391_set_config(unsigned __int8 which_chain, unsigned __int8 asic_addr, unsigned __int8 reg_addr, unsigned int reg_data, bool mode)
EXPORT BM1391_set_config
BM1391_set_config

var_1C= -0x1C
var_18= -0x18
var_14= -0x14
cmd_buf= -0x10
mode=  0x14

which_chain = R0        ; unsigned __int8
asic_addr_0 = R1        ; unsigned __int8
reg_addr_0 = R2         ; unsigned __int8
reg_data = R3           ; unsigned int
PUSH            {R4-R7,LR}
SUB             SP, SP, #0x1C
LDRB.W          R6, [SP,#0x1C+mode]
MOVS            R4, #0
MOV             R5, which_chain
STRB.W          R4, [SP,#0x1C+var_14]
STR             R4, [SP,#0x1C+cmd_buf]
STR             R4, [SP,#0x1C+cmd_buf+4]
STR             R4, [SP,#0x1C+cmd_buf+8]
CMP             R6, #0
BEQ             loc_12880
MOVS            which_chain, #0x51 ; 'Q'
STRB.W          R0, [SP,#0x1C+var_1C]

loc_12814
LSRS            R7, reg_data, #0x18
LSRS            R6, reg_data, #0x10
LSRS            R4, reg_data, #8
STRB.W          asic_addr_0, [SP,#0x1C+var_1C+2]
STRB.W          reg_addr_0, [SP,#0x1C+var_1C+3]
MOV             R0, SP  ; ptr
MOVS            reg_addr_0, #9
MOVS            asic_addr_0, #0x40 ; '@' ; len
STRB.W          reg_data, [SP,#0x1C+var_18+3]
STRB.W          R4, [SP,#0x1C+var_18+2]
STRB.W          R2, [SP,#0x1C+var_1C+1]
STRB.W          R7, [SP,#0x1C+var_18]
STRB.W          R6, [SP,#0x1C+var_18+1]
BL              CRC5
LDR             R2, [SP,#0x1C+var_1C]
MOV             R1, R0
LDR             R3, [SP,#0x1C+var_18]
LSLS            R4, R1, #0x18
ADD             R0, SP, #0x1C+cmd_buf ; value
STRB.W          R1, [SP,#0x1C+var_14]
REV             R2, R2
STR             R4, [SP,#0x1C+cmd_buf+8]
REV             R3, R3
STR             R2, [SP,#0x1C+cmd_buf]
STR             R3, [SP,#0x1C+cmd_buf+4]
BL              set_BC_command_buffer
BL              get_BC_write_command
ret = R0                ; unsigned int
MOVS            R3, #0
BIC.W           ret, ret, #0xF0000
MOVT            R3, #0x8080
ORR.W           R3, R3, R5,LSL#16
ORRS            R0, R3  ; value
BL              set_BC_write_command
MOVW            R0, #0x2710 ; useconds
BLX             usleep
ADD             SP, SP, #0x1C
POP             {R4-R7,PC}

loc_12880
which_chain = R0        ; unsigned __int8
asic_addr_0 = R1        ; unsigned __int8
reg_addr_0 = R2         ; unsigned __int8
reg_data = R3           ; unsigned int
MOVS            which_chain, #0x41 ; 'A'
STRB.W          R0, [SP,#0x1C+var_1C]
B               loc_12814
; End of function BM1391_set_config




; void __fastcall BM1391_get_status(unsigned __int8 which_chain, unsigned __int8 asic_addr, unsigned __int8 reg_addr, unsigned __int8 mode)
EXPORT BM1391_get_status
BM1391_get_status

buf= -0x14
cmd_buf= -0xC

which_chain = R0        ; unsigned __int8
asic_addr = R1          ; unsigned __int8
reg_addr = R2           ; unsigned __int8
mode = R3               ; unsigned __int8
PUSH            {R4-R6,LR}
MOVS            R4, #0
SUB             SP, SP, #0x18
MOV             R5, which_chain
MOV             R6, asic_addr
STRB.W          R4, [SP,#0x18+buf+4]
STR             R4, [SP,#0x18+cmd_buf]
STR             R4, [SP,#0x18+cmd_buf+4]
STR             R4, [SP,#0x18+cmd_buf+8]
CBZ             mode, loc_128EC
MOVS            mode, #0x52 ; 'R'
STRB.W          R3, [SP,#0x18+buf]

loc_128A4
MOVS            R3, #5
ADD             which_chain, SP, #0x18+buf ; ptr
MOVS            asic_addr, #0x20 ; ' ' ; len
STRB.W          reg_addr, [SP,#0x18+buf+3]
STRB.W          R3, [SP,#0x18+buf+1]
STRB.W          R6, [SP,#0x18+buf+2]
BL              CRC5
LDR             R3, [SP,#0x18+buf]
MOV             R2, R0
LSLS            R1, R2, #0x18
ADD             R0, SP, #0x18+cmd_buf ; value
STRB.W          R2, [SP,#0x18+buf+4]
REV             R3, R3
STR             R1, [SP,#0x18+cmd_buf+4]
STR             R3, [SP,#0x18+cmd_buf]
BL              set_BC_command_buffer
BL              get_BC_write_command
ret = R0                ; unsigned int
MOVS            R3, #0
BIC.W           ret, ret, #0xF0000
MOVT            R3, #0x8080
ORR.W           R3, R3, R5,LSL#16
ORRS            R0, R3  ; value
BL              set_BC_write_command
ADD             SP, SP, #0x18
POP             {R4-R6,PC}

loc_128EC
which_chain = R0        ; unsigned __int8
asic_addr = R1          ; unsigned __int8
reg_addr = R2           ; unsigned __int8
mode = R3               ; unsigned __int8
MOVS            mode, #0x42 ; 'B'
STRB.W          R3, [SP,#0x18+buf]
B               loc_128A4
; End of function BM1391_get_status




; void __fastcall set_BM1391_freq(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int freq, bool mode)
EXPORT set_BM1391_freq
set_BM1391_freq

var_34= -0x34
var_28= -0x28
var_24= -0x24
var_20= -0x20
reg_data= -0x18
freq= -0x14
var_10= -0x10
var_C= -0xC
var_8= -8

which_chain = R0        ; unsigned __int8
chip_addr = R1          ; unsigned __int8
freq_0 = R2             ; unsigned int
mode = R3               ; bool
PUSH.W          {R4-R11,LR}
MOV             R9, chip_addr
VPUSH           {D8-D14}
SUB             SP, SP, #0x34
STR             freq_0, [SP,#0x34+freq]
MOVS            freq_0, #0
VLDR            S15, [SP,#0x34+freq]
MOV             R10, R2
VLDR            S11, =0.0
MOV             R8, R2
VLDR            S20, =3200.0
MOV             R7, R2
VLDR            S29, =3125.0
VCVT.F32.U32    S26, S15
VLDR            D9, =0.0001
VLDR            S25, =2000.0
VLDR            D11, =0.000001
VMOV.F32        S24, #25.0
VMOV.F32        S28, #2.0
VMOV.F32        S27, #1.0
STR             which_chain, [SP,#0x34+var_C]
STR             mode, [SP,#0x34+var_8]

loc_1293A
VCMPE.F32       S20, S29
VMOV.F32        S13, #12.5
VMRS            APSR_nzcv, FPSCR
VMOV.F32        S15, #25.0
ITE MI
MOVMI           R3, #2
MOVPL           R3, #1
ITE PL
VMOVPL.F32      S12, S27
VMOVMI.F32      S12, S28
IT PL
VMOVPL.F32      S13, S15
CBZ             R2, loc_1296A
VSUB.F32        S20, S11, S13
VMOV.F32        S24, S15

loc_1296A
VDIV.F32        S15, S20, S26
VCVT.U32.F32    S14, S15
VSTR            S14, [SP,#0x34+reg_data]
VCVT.F32.U32    S14, S14
VSUB.F32        S15, S15, S14
VCMPE.F32       S15, S24
VMRS            APSR_nzcv, FPSCR
BPL             loc_129BC
VMUL.F32        S12, S20, S12
MOV             R8, R3
VMOV.F32        S9, #25.0
VCVT.F64.F32    D5, S15
LDRB.W          R10, [SP,#0x34+reg_data]
VDIV.F32        S14, S12, S9
VMOV.F32        S24, S15
VCMPE.F64       D5, D11
VMRS            APSR_nzcv, FPSCR
VCVT.U32.F32    S14, S14
VSTR            S14, [SP,#0x34+reg_data]
LDRB.W          R7, [SP,#0x34+reg_data]
BMI             loc_129D0
VMOV.F32        S11, S20

loc_129BC
VSUB.F32        S20, S20, S13
VCMPE.F32       S20, S25
VMRS            APSR_nzcv, FPSCR
BGE.W           loc_12B80
VMOV.F32        S20, S11

loc_129D0
CMP.W           R10, #0x10
BLS.W           loc_12BF2
VMOV            S15, R10
MOVW            R6, #:lower16:aSPllDivDecimal ; "\n--- %s: pll_div decimals %f postdiv_f"...
VCVT.F32.U32    S21, S15
MOVT            R6, #:upper16:aSPllDivDecimal ; "\n--- %s: pll_div decimals %f postdiv_f"...
LDR.W           R11, =__FUNCTION__.8160 ; "BM1391_get_pllparam_divider"
MOVS            R4, #0xF

loc_129EE
VMOV            S15, R4
MOV             R1, R11
VCVT.F32.S32    S14, S15
MOV             R0, R6  ; format
UXTB            R5, R4
SUBS            R4, #1
VDIV.F32        S15, S21, S14
VCVT.U32.F32    S16, S15
VCVT.F64.F32    D6, S15
VCVT.F32.U32    S16, S16
VSTR            D6, [SP,#0x34+var_34]
VSUB.F32        S16, S15, S16
VCVT.F64.F32    D8, S16
VMOV            R2, R3, D8
BLX             printf
VCMPE.F64       D8, D9
SUBS            R3, R5, #1
VMRS            APSR_nzcv, FPSCR
BMI.W           loc_12B84
CMP             R4, #1
UXTB            R5, R3
BNE             loc_129EE
CMP             R5, #2
BEQ.W           loc_12B96

loc_12A3C
CMP.W           R10, #7
BLS.W           loc_12BFE
VMOV            S15, R10
MOVS            R4, #6
VCVT.F32.U32    S13, S15

loc_12A4E
VMOV            S15, R4
SUBS            R3, R4, #1
VCVT.F32.S32    S14, S15
MOV             R11, R4
VDIV.F32        S15, S13, S14
VCVT.U32.F32    S14, S15
VSTR            S14, [SP,#0x34+reg_data]
VCVT.F32.U32    S14, S14
VSUB.F32        S14, S15, S14
VCVT.F64.F32    D7, S14
VCMPE.F64       D7, D9
VMRS            APSR_nzcv, FPSCR
BMI.W           loc_12BBE
UXTB            R4, R3
CMP             R4, #0xFF
BNE             loc_12A4E
MOV             R3, R4
MOVS            R6, #1
MOV             R11, R4

loc_12A8A
CMP             R10, R3
MOV             R2, R10
BNE.W           loc_12C0A
LSLS            R4, R4, #4

loc_12A94
VMOV            S15, R8
MUL             R3, R2, R5
VCVT.F32.S32    S12, S15
ORRS            R4, R6
VMOV.F32        S11, #25.0
ORR.W           R4, R4, R7,LSL#16
VMOV            S14, R7
MOV             R10, R5
VMOV            S15, R3
ORR.W           R4, R4, R8,LSL#8
pll_param = R4          ; unsigned int
VDIV.F32        S13, S11, S12
MOVW            R0, #:lower16:aSWantFreqFReal ; "\n--- %s: Want freq %f  real freq %f\n"
VCVT.F32.S32    S14, S14
ORR.W           R5, pll_param, #0xC0000000
VCVT.F32.S32    S15, S15
MOVT            R0, #:upper16:aSWantFreqFReal ; "\n--- %s: Want freq %f  real freq %f\n"
VCVT.F64.F32    D4, S26
LDR             R1, =__FUNCTION__.8160 ; "BM1391_get_pllparam_divider"
STR             R5, [SP,#0x34+reg_data]
ADD.W           R5, R10, #0xFFFFFFFF
STR             R5, [SP,#0x34+var_10]
VMOV            R2, R3, D4
VMUL.F32        S13, S13, S14
VDIV.F32        S14, S13, S15
VCVT.F64.F32    D7, S14
VSTR            D7, [SP,#0x34+var_34]
BLX             printf
VCVT.F64.F32    D7, S20
MOVW            R0, #:lower16:aSPllVcoFFbdivX ; "\n--- %s: pll_vco %f, fbdiv %#x refdiv "...
STR             pll_param, [SP,#0x34+var_20]
MOVT            R0, #:upper16:aSPllVcoFFbdivX ; "\n--- %s: pll_vco %f, fbdiv %#x refdiv "...
STR.W           R10, [SP,#0x34+var_24]
STR             R6, [SP,#0x34+var_28]
STMEA.W         SP, {R7,R8,R11}
VMOV            R2, R3, D7
LDR             R1, =__FUNCTION__.8160 ; "BM1391_get_pllparam_divider"
BLX             printf

loc_12B18
MOVW            R0, #:lower16:aSFreqDPllParam ; "\n--- %s: freq = %d, pll_param = 0x%08x"...
MOV             R3, pll_param
LDR             R2, [SP,#0x34+freq]
MOVT            R0, #:upper16:aSFreqDPllParam ; "\n--- %s: freq = %d, pll_param = 0x%08x"...
STR.W           R10, [SP,#0x34+var_34]
LDR             R1, =__FUNCTION__.8200 ; "set_BM1391_freq"
BLX             printf
LDR             pll_param, [SP,#0x34+var_8]
MOV             R1, R9  ; asic_addr
LDR             R5, [SP,#0x34+var_C]
MOVS            R2, #8  ; reg_addr
LDR             R6, [SP,#0x34+reg_data]
STR             R4, [SP,#0x34+var_34] ; mode
MOV             R0, R5  ; which_chain
MOV             R3, R6  ; reg_data
BL              BM1391_set_config
MOVW            R0, #0x2710 ; useconds
BLX             usleep
LDR             R3, [SP,#0x34+var_10] ; reg_data
MOV             R1, R9  ; asic_addr
MOVS            R2, #0x70 ; 'p' ; reg_addr
MOV             R0, R5  ; which_chain
STR             R4, [SP,#0x34+var_34] ; mode
BL              BM1391_set_config
MOVW            R0, #0x2710 ; useconds
BLX             usleep
MOV             R0, R5  ; which_chain
STR             R4, [SP,#0x34+var_34] ; mode
MOV             R3, R6  ; reg_data
MOV             R1, R9  ; asic_addr
MOVS            R2, #8  ; reg_addr
BL              BM1391_set_config
MOVW            R0, #0x2710 ; useconds
ADD             SP, SP, #0x34 ; '4'
VPOP            {D8-D14}
POP.W           {R4-R11,LR}
B.W             j_usleep

loc_12B80
MOVS            R2, #0
B               loc_1293A

loc_12B84
MOV             R0, R10
MOV             R1, R5
BL              __aeabi_uidiv
CMP             R5, #2
UXTB.W          R10, R0
BNE.W           loc_12A3C

loc_12B96
TST.W           R10, #1
BEQ.W           loc_12A3C
MOVW            R0, #:lower16:aSNeedRecal1 ; "\n--- %s: need recal 1\n"
LDR             R1, =__FUNCTION__.8160 ; "BM1391_get_pllparam_divider"
MOVT            R0, #:upper16:aSNeedRecal1 ; "\n--- %s: need recal 1\n"
BLX             printf
VCMPE.F32       S20, S25
VMRS            APSR_nzcv, FPSCR
BLE             loc_12C48

loc_12BB6
VMOV.F32        S11, S20
MOVS            R2, #1
B               loc_1293A

loc_12BBE
LDRB.W          R6, [SP,#0x34+reg_data]
CMP             R6, #7
ITE LS
MOVLS           R3, #0
MOVHI           R3, #1
CMP             R4, R6
IT CC
ORRCC.W         R3, R3, #1
CBZ             R3, loc_12BEC
MOVW            R0, #:lower16:aSNeedRecal2 ; "\n--- %s: need recal 2\n"
LDR             R1, =__FUNCTION__.8160 ; "BM1391_get_pllparam_divider"
MOVT            R0, #:upper16:aSNeedRecal2 ; "\n--- %s: need recal 2\n"
BLX             printf
VCMPE.F32       S20, S25
VMRS            APSR_nzcv, FPSCR
BGT             loc_12BB6

loc_12BEC
MUL             R3, R6, R4
B               loc_12A8A

loc_12BF2
MOVS            R2, #1
MOV             R5, R10
MOV             R6, R2
MOV             R11, R2
MOVS            R4, #0x10
B               loc_12A94

loc_12BFE
MOV             R11, R10
MOVS            R6, #1
MOV.W           R4, R10,LSL#4
MOV             R2, R10
B               loc_12A94

loc_12C0A
MOVW            R0, #:lower16:aSDonTFindPostd ; "\n--- %s: Don't find postdiv1 %d * post"...
MOV             R2, R4
STR.W           R10, [SP,#0x34+var_34]
MOV             R3, R6
LDR             R1, =__FUNCTION__.8160 ; "BM1391_get_pllparam_divider"
MOVT            R0, #:upper16:aSDonTFindPostd ; "\n--- %s: Don't find postdiv1 %d * post"...
BLX             printf
MOVW            R3, #0x111
MOVW            R0, #:lower16:aSSetFreqDonTOk ; "\n--- %s: !!!!!!!!!!!!!!!Set freq don't"...
MOV             R4, R3
LDR             R1, =__FUNCTION__.8160 ; "BM1391_get_pllparam_divider"
MOVT            R3, #0xC078
MOVT            R0, #:upper16:aSSetFreqDonTOk ; "\n--- %s: !!!!!!!!!!!!!!!Set freq don't"...
STR             R3, [SP,#0x34+reg_data]
MOVT            R4, #0x78 ; 'x'
BLX             printf
MOVS            R3, #0xE
MOV.W           R10, #0xF
STR             R3, [SP,#0x34+var_10]
B               loc_12B18

loc_12C48
MOVW            R3, #0x111
MOVW            R0, #:lower16:aSSetFreqDonTOk ; "\n--- %s: !!!!!!!!!!!!!!!Set freq don't"...
MOV             R4, R3
MOVT            R3, #0xC078
STR             R3, [SP,#0x34+reg_data]
MOVT            R0, #:upper16:aSSetFreqDonTOk ; "\n--- %s: !!!!!!!!!!!!!!!Set freq don't"...
MOVS            R3, #0xE
LDR             R1, =__FUNCTION__.8160 ; "BM1391_get_pllparam_divider"
STR             R3, [SP,#0x34+var_10]
MOVT            R4, #0x78 ; 'x'
BLX             printf
MOV.W           R10, #0xF
B               loc_12B18
; End of function set_BM1391_freq

dbl_12C70 DCFD 0.0001
dbl_12C78 DCFD 0.000001
flt_12C80 DCFS 0.0
flt_12C84 DCFS 3200.0
flt_12C88 DCFS 3125.0
flt_12C8C DCFS 2000.0
off_12C90 DCD __FUNCTION__.8160 ; "BM1391_get_pllparam_divider"
off_12C94 DCD __FUNCTION__.8200 ; "set_BM1391_freq"



; unsigned int __fastcall check_BM1391_asic_reg(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 reg, bool mode)
EXPORT check_BM1391_asic_reg
check_BM1391_asic_reg

var_14= -0x14
var_10= -0x10
reg_buf= -0xC

which_chain = R0        ; unsigned __int8
chip_addr = R1          ; unsigned __int8
reg = R2                ; unsigned __int8
mode = R3               ; bool
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x14
MOV             R7, reg
MOV             R6, which_chain
MOV             R4, chip_addr
MOV             R5, mode
STR             reg, [SP,#0x14+var_10]
MOVS            reg, #0
STR             R2, [SP,#0x14+reg_buf]
STR.W           R2, [SP,#0x14+reg_buf+3]
BL              clear_register_value_buf
MOV             R3, R5  ; mode
MOV             R2, R7  ; reg_addr
MOV             R1, R4  ; asic_addr
MOV             R0, R6  ; which_chain
BL              BM1391_get_status
CBNZ            R7, loc_12CCA
LDR             R3, =(cgpu.subid+0x7FD54)
ADD             R3, R6
STRB.W          R7, [R3,#0x30C]

loc_12CCA
MOVW            R3, #:lower16:cgpu
MOVS            R2, #0
MOVT            R3, #:upper16:cgpu
MOVW            R7, #:lower16:reg_value_buf
MOVW            R5, #:lower16:reg_mutex
ADD.W           R10, R3, R6
MOV             R4, R2
MOVT            R7, #:upper16:reg_value_buf
MOVT            R5, #:upper16:reg_mutex
STR             R2, [SP,#0x14+var_14]

loc_12CEC               ; useconds
not_reg_data_time = R4  ; unsigned int
MOVW            R0, #0x7530
BLX             usleep
MOV             R0, R5  ; mutex
BLX             pthread_mutex_lock
LDR             R3, [R7]
MOV             R0, R5  ; mutex
LDR.W           R8, [R3,#8]
reg_value_num = R8      ; unsigned int
BLX             pthread_mutex_unlock
CMP.W           reg_value_num, #0
BEQ.W           loc_12E3E
MOVS            not_reg_data_time, #0
ADD.W           R11, R10, #0x100000
B               loc_12D52

loc_12D16
i = R4                  ; unsigned int
LDR             R1, [R2,#8]
ADDS            R3, #1
CMP.W           R3, #0x200
STR             R3, [R2,#4]
MOVW            R0, #:lower16:aSTheReturnData ; "%s: the return data is from chain%d, bu"...
ADD.W           i, i, #1
ADD.W           R1, R1, #0xFFFFFFFF
MOVT            R0, #:upper16:aSTheReturnData ; "%s: the return data is from chain%d, bu"...
STR             R1, [R2,#8]
ITTT EQ
MOVEQ           R1, #0
MOVEQ           R3, R1
STREQ           R1, [R2,#4]
ADD.W           R3, R2, R3,LSL#3
LDR             R1, =__FUNCTION__.8213 ; "check_BM1391_asic_reg"
LDRB            R2, [R3,#0x17]
MOV             R3, R6
BLX             printf
MOV             R0, R5  ; mutex
BLX             pthread_mutex_unlock
i = R4                  ; unsigned int
CMP             reg_value_num, i
BEQ             loc_12DEE

loc_12D52               ; mutex
MOV             R0, R5
BLX             pthread_mutex_lock
LDR             R2, [R7]
LDR             R3, [R2,#4]
ADD.W           R1, R2, R3,LSL#3
LDRB            R1, [R1,#0x17]
CMP             R1, R6
BNE             loc_12D16
MOV.W           R9, #0
MOVS            R1, #0x33 ; '3' ; len
STR.W           R9, [SP,#0x14+reg_buf]
ADD             R0, SP, #0x14+reg_buf ; ptr
STR.W           R9, [SP,#0x14+reg_buf+3]
LDR             R3, [R2,#4]
ADD.W           R3, R2, R3,LSL#3
LDR             R2, [R3,#0x10]
LDRB.W          LR, [R3,#0x14]
LDRB            R3, [R3,#0x15]
STRB.W          R2, [SP,#0x14+reg_buf+3]
MOV.W           R12, R2,LSR#8
STRB.W          LR, [SP,#0x14+reg_buf+4]
MOV.W           LR, R2,LSR#16
LSRS            R2, R2, #0x18
STRB.W          R3, [SP,#0x14+reg_buf+5]
STRB.W          LR, [SP,#0x14+reg_buf+1]
STRB.W          R2, [SP,#0x14+reg_buf]
STRB.W          R12, [SP,#0x14+reg_buf+2]
BL              CRC5
LDR             R1, [R7]
MOV             R2, R0
crc_value = R2          ; unsigned __int8
LDR             R0, [R1,#4]
ADD.W           LR, R1, R0,LSL#3
LDRB.W          R3, [LR,#0x16]
CMP             crc_value, R3
BEQ             loc_12DF2
MOVW            R0, #:lower16:aSCrcIs0xXButIt ; "%s: crc is 0x%x, but it should be 0x%x"...
LDR             R1, =__FUNCTION__.8213 ; "check_BM1391_asic_reg"
MOVT            R0, #:upper16:aSCrcIs0xXButIt ; "%s: crc is 0x%x, but it should be 0x%x"...
BLX             printf
LDR             R3, [R7]
LDR             R2, [R3,#4]
LDR             R1, [R3,#8]
ADDS            R2, #1
SUBS            R1, #1
CMP.W           R2, #0x200
STR             R2, [R3,#4]
STR             R1, [R3,#8]
IT EQ
STREQ.W         R9, [R3,#4]

loc_12DE2               ; mutex
MOV             R0, R5
ADDS            i, #1
BLX             pthread_mutex_unlock
i = R4                  ; unsigned int
CMP             reg_value_num, i
BNE             loc_12D52

loc_12DEE
MOVS            i, #0
B               loc_12CEC

loc_12DF2
crc_value = R2          ; unsigned __int8
i = R4                  ; unsigned int
LDR             R3, [SP,#0x14+var_10]
CBNZ            R3, loc_12E1C
LDRB.W          R3, [SP,#0x14+reg_buf]
CMP             R3, #0x13
BNE             loc_12E06
LDRB.W          R3, [SP,#0x14+reg_buf+1]
CMP             R3, #0x91
BEQ             loc_12E80

loc_12E06
MOVW            R0, #:lower16:aSErrorAsicAddr ; "%s: error asic address : 0x%08x\n"
LDR             R1, =__FUNCTION__.8213 ; "check_BM1391_asic_reg"
LDR.W           crc_value, [LR,#0x10]
MOVT            R0, #:upper16:aSErrorAsicAddr ; "%s: error asic address : 0x%08x\n"
BLX             printf
LDR             R1, [R7]
LDR             R0, [R1,#4]

loc_12E1C
LDR             R3, [R1,#8]
ADDS            R2, R0, #2
LDR.W           R2, [R1,R2,LSL#3]
ADDS            R0, #1
CMP.W           R0, #0x200
STR             R0, [R1,#4]
ADD.W           R3, R3, #0xFFFFFFFF
STR             R3, [R1,#8]
IT EQ
MOVEQ           R3, #0
STR             R2, [SP,#0x14+var_14]
ret = R2                ; unsigned int
IT EQ
STREQ           R3, [R1,#4]
B               loc_12DE2

loc_12E3E
not_reg_data_time = R4  ; unsigned int
ADDS            not_reg_data_time, #1
MOVW            R0, #0x7530 ; useconds
BLX             usleep
not_reg_data_time = R4  ; unsigned int
CMP             not_reg_data_time, #3
BNE.W           loc_12CEC
LDR             R3, [SP,#0x14+var_10]
CBNZ            R3, loc_12E74
MOV             R2, #cgpu
ADDS            R3, R2, R6
ADD.W           R2, R2, #0x100000
ADD.W           R3, R3, #0x100000
LDR.W           R1, [R2,#(cgpu.max_asic_num_in_one_chain - 0x330FC4)]
LDRB.W          R3, [R3,#0x30C]
CMP             R3, R1
IT HI
STRHI.W         R3, [R2,#(cgpu.max_asic_num_in_one_chain - 0x330FC4)]

loc_12E74
BL              clear_register_value_buf
LDR             R0, [SP,#0x14+var_14]
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}

loc_12E80
crc_value = R2          ; unsigned __int8
i = R4                  ; unsigned int
LDRB.W          R3, [R11,#0x30C]
ADDS            R3, #1
STRB.W          R3, [R11,#0x30C]
LDR             R0, [R1,#4]
B               loc_12E1C
; End of function check_BM1391_asic_reg

ALIGN 0x10
off_12E90 DCD cgpu.subid+0x7FD54
off_12E94 DCD __FUNCTION__.8213 ; "check_BM1391_asic_reg"



; void __fastcall BM1391_chain_inactive(unsigned __int8 which_chain)
EXPORT BM1391_chain_inactive
BM1391_chain_inactive

buf= -0x18
cmd_buf= -0x10

which_chain = R0        ; unsigned __int8
PUSH            {R4,R5,LR}
MOV             R5, which_chain
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
SUB             SP, SP, #0x1C
MOVS            R4, #0
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             R1, =__FUNCTION__.8228 ; "BM1391_chain_inactive"
STRB.W          R4, [SP,#0x1C+buf+4]
STR             R4, [SP,#0x1C+buf]
STR             R4, [SP,#0x1C+cmd_buf]
STR             R4, [SP,#0x1C+cmd_buf+4]
STR             R4, [SP,#0x1C+cmd_buf+8]
BLX             printf
MOVS            R2, #0x53 ; 'S'
MOVS            R3, #5
ADD             R0, SP, #0x1C+buf ; ptr
MOVS            R1, #0x20 ; ' ' ; len
STRB.W          R2, [SP,#0x1C+buf]
STRB.W          R3, [SP,#0x1C+buf+1]
STRB.W          R4, [SP,#0x1C+buf+2]
STRB.W          R4, [SP,#0x1C+buf+3]
BL              CRC5
LDR             R2, [SP,#0x1C+buf]
MOV             R1, R0
LSLS            R3, R1, #0x18
ADD             R0, SP, #0x1C+cmd_buf ; value
STRB.W          R1, [SP,#0x1C+buf+4]
REV             R2, R2
STR             R3, [SP,#0x1C+cmd_buf+4]
STR             R2, [SP,#0x1C+cmd_buf]
BL              set_BC_command_buffer
BL              get_BC_write_command
ret = R0                ; unsigned int
MOV             R3, R4
BIC.W           ret, ret, #0xF0000
MOVT            R3, #0x8080
ORR.W           R3, R3, R5,LSL#16
ORRS            R0, R3  ; value
BL              set_BC_write_command
MOVW            R0, #0x1388 ; useconds
BLX             usleep
ADD             SP, SP, #0x1C
POP             {R4,R5,PC}
; End of function BM1391_chain_inactive

off_12F10 DCD __FUNCTION__.8228 ; "BM1391_chain_inactive"



; void __fastcall BM1391_set_address(unsigned __int8 which_chain, unsigned __int8 address)
EXPORT BM1391_set_address
BM1391_set_address

ptr= -0x18
var_14= -0x14
cmd_buf= -0x10

which_chain = R0        ; unsigned __int8
address_0 = R1          ; unsigned __int8
PUSH            {R4,R5,LR}
MOVS            R3, #0
SUB             SP, SP, #0x1C
MOV             R4, which_chain
MOVS            R2, #5
ADD             which_chain, SP, #0x1C+ptr ; ptr
STR             R3, [SP,#0x1C+ptr]
MOVS            R5, #0x40 ; '@'
STRB.W          address_0, [SP,#0x1C+ptr+2]
MOVS            address_0, #0x20 ; ' ' ; len
STR             R3, [SP,#0x1C+cmd_buf]
STR             R3, [SP,#0x1C+cmd_buf+4]
STR             R3, [SP,#0x1C+cmd_buf+8]
STRB.W          R3, [SP,#0x1C+var_14]
STRB.W          R2, [SP,#0x1C+ptr+1]
STRB.W          R5, [SP,#0x1C+ptr]
BL              CRC5
LDR             R2, [SP,#0x1C+ptr]
MOV             R1, R0
LSLS            R3, R1, #0x18
ADD             R0, SP, #0x1C+cmd_buf ; value
STRB.W          R1, [SP,#0x1C+var_14]
REV             R2, R2
STR             R3, [SP,#0x1C+cmd_buf+4]
STR             R2, [SP,#0x1C+cmd_buf]
BL              set_BC_command_buffer
BL              get_BC_write_command
ret = R0                ; unsigned int
MOVS            R3, #0
BIC.W           ret, ret, #0xF0000
MOVT            R3, #0x8080
ORR.W           R3, R3, R4,LSL#16
ORRS            R0, R3  ; value
BL              set_BC_write_command
ADD             SP, SP, #0x1C
POP             {R4,R5,PC}
; End of function BM1391_set_address

ALIGN 4



; void __fastcall single_BM1391_set_baud(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 asic_baud, bool mode)
EXPORT single_BM1391_set_baud
single_BM1391_set_baud

var_C= -0xC

which_chain = R0        ; unsigned __int8
chip_addr = R1          ; unsigned __int8
asic_baud = R2          ; unsigned __int8
mode = R3               ; bool
PUSH            {R4,R5,LR}
MOV             R5, #gBM1391_MISC_CONTROL_reg
SUB             SP, SP, #0xC
LDR             R4, [R5]
STR             mode, [SP,#0xC+var_C] ; mode
BIC.W           R4, R4, #0x1F00
ORR.W           R4, R4, asic_baud,LSL#8
MOVS            asic_baud, #0x18 ; reg_addr
MOV             mode, R4 ; reg_data
STR             R4, [R5]
BL              BM1391_set_config
ADD             SP, SP, #0xC
POP             {R4,R5,PC}
; End of function single_BM1391_set_baud

ALIGN 4



; void __fastcall single_BM1391_set_IO_strength(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int data, bool mode)
EXPORT single_BM1391_set_IO_strength
single_BM1391_set_IO_strength

var_C= -0xC

which_chain = R0        ; unsigned __int8
chip_addr = R1          ; unsigned __int8
data = R2               ; unsigned int
mode = R3               ; bool
PUSH            {R4-R7,LR}
MOV             R4, which_chain
MOVW            which_chain, #:lower16:aSIoStrengthIs0 ; "\n--- %s: IO strength is 0x%08x\n"
SUB             SP, SP, #0xC
MOV             R7, mode
MOV             R6, data
MOV             R5, chip_addr
MOVT            R0, #:upper16:aSIoStrengthIs0 ; "\n--- %s: IO strength is 0x%08x\n"
LDR             chip_addr, =__FUNCTION__.8249 ; "single_BM1391_set_IO_strength"
BLX             printf
STR             R7, [SP,#0xC+var_C] ; mode
MOV             R3, data ; reg_data
MOV             R1, R5  ; asic_addr
MOV             R0, R4  ; which_chain
MOVS            R2, #0x58 ; 'X' ; reg_addr
BL              BM1391_set_config
ADD             SP, SP, #0xC
POP             {R4-R7,PC}
; End of function single_BM1391_set_IO_strength

off_12FC8 DCD __FUNCTION__.8249 ; "single_BM1391_set_IO_strength"



; void reset_single_BM1391_global_arg()
EXPORT reset_single_BM1391_global_arg
reset_single_BM1391_global_arg

var_C= -0xC
var_8= -8

MOVW            R3, #:lower16:Conf
MOVW            R2, #:lower16:gBM1391_MISC_CONTROL_reg
PUSH.W          {R4-R11,LR}
MOVT            R3, #:upper16:Conf
SUB             SP, SP, #0xC
MOVT            R2, #:upper16:gBM1391_MISC_CONTROL_reg
MOVW            R1, #0x3A01
STR             R1, [R2]
LDR.W           R11, [R3,#configuration.OpenCoreNum1]
OpenCoreNum1 = R11      ; unsigned int
LDR.W           R10, [R3,#configuration.OpenCoreNum2]
OpenCoreNum2 = R10      ; unsigned int
LDR.W           R9, [R3,#configuration.OpenCoreNum3]
OpenCoreNum3 = R9       ; unsigned int
LDR.W           R8, [R3,#configuration.OpenCoreNum4]
OpenCoreNum4 = R8       ; unsigned int
LDR.W           R5, [R3,#configuration.OpenCoreNum5]
OpenCoreNum5 = R5       ; unsigned int
LDR.W           R7, [R3,#configuration.OpenCoreNum6]
OpenCoreNum6 = R7       ; unsigned int
LDR.W           R6, [R3,#configuration.OpenCoreNum7]
OpenCoreNum7 = R6       ; unsigned int
LDR.W           R4, [R3,#configuration.OpenCoreNum8]
STR             R3, [SP,#0xC+var_C]
OpenCoreNum8 = R4       ; unsigned int
BL              reset_global_arg
MOVW            R0, #:lower16:aS ; "\n--- %s\n"
LDR             R1, =__FUNCTION__.8269 ; "reset_single_BM1391_global_arg"
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
BLX             printf
LDR             R3, [SP,#0xC+var_C]
MOVS            R2, #0x20 ; ' '
MOV.W           R12, #0

loc_13024
get_pattern_loop = R12  ; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum1 = R11      ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum2 = R10      ; unsigned int
TST.W           OpenCoreNum3, #1
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
IT NE
ADDNE.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum3 = R9       ; unsigned int
TST.W           OpenCoreNum4, #1
MOV.W           OpenCoreNum4, OpenCoreNum4,LSR#1
IT NE
ADDNE.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum4 = R8       ; unsigned int
LSLS            R0, OpenCoreNum5, #0x1F
MOV.W           OpenCoreNum5, OpenCoreNum5,LSR#1
IT MI
ADDMI.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum5 = R5       ; unsigned int
LSLS            R1, OpenCoreNum6, #0x1F
MOV.W           OpenCoreNum6, OpenCoreNum6,LSR#1
IT MI
ADDMI.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum6 = R7       ; unsigned int
LSLS            R0, OpenCoreNum7, #0x1F
MOV.W           OpenCoreNum7, OpenCoreNum7,LSR#1
IT MI
ADDMI.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum7 = R6       ; unsigned int
LSLS            R1, OpenCoreNum8, #0x1F
MOV.W           OpenCoreNum8, OpenCoreNum8,LSR#1
IT MI
ADDMI.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum8 = R4       ; unsigned int
SUBS            R2, #1
BNE             loc_13024
LDR             OpenCoreNum6, [R3,#configuration.pattern_number]
MOV             OpenCoreNum5, R2
LDR             R1, =0x3312CF
ADD.W           R3, get_pattern_loop, #0x20000
MOVW            OpenCoreNum7, #:lower16:cgpu
LDR.W           OpenCoreNum1, =(reg_mutex+0x14)
ADDS            R3, #0x2A ; '*'
MOVT            R6, #:upper16:cgpu
ADD.W           R2, R7, R7,LSL#4
MOVW            OpenCoreNum2, #:lower16:gRepeated_Nonce_Id
MOVW            OpenCoreNum3, #:lower16:gValid_Nonce_Num
STR             R1, [SP,#0xC+var_C]
MOVW            OpenCoreNum4, #:lower16:gSend_Work_Num
ADD.W           R6, R6, R3,LSL#2
MOV             R1, R5
LSLS            R3, R2, #2
MOVT            R10, #:upper16:gRepeated_Nonce_Id
MOVT            R9, #:upper16:gValid_Nonce_Num
MOVT            R8, #:upper16:gSend_Work_Num
STR             R3, [SP,#0xC+var_8]

loc_130D0
LDR             R3, [SP,#0xC+var_C]
STR.W           R1, [R10],#4
STR.W           R1, [R9],#4
STRB.W          R1, [R3,#1]!
STR.W           R1, [R8],#4
STR             R3, [SP,#0xC+var_C]
CMP.W           get_pattern_loop, #0
BEQ             loc_1310E
LDR             R3, [SP,#0xC+var_8]
MOV             R4, R11
LDR             R0, =(cgpu.workdataFilePrefix+0x3C)
ADD.W           LR, R5, R3

loc_130F4
LDR.W           R2, [R0,#4]!
works = R2              ; work *
ADDS            R3, works, R5
ADD             works, LR
CBZ             R7, loc_13106

loc_130FE
STR             R1, [R3,#0x34]
ADDS            R3, #0x44 ; 'D'
CMP             R3, R2
BNE             loc_130FE

loc_13106
CMP             R0, R6
STR.W           R1, [R4,#4]!
BNE             loc_130F4

loc_1310E
ADDS            R5, #4
ADD.W           R11, R11, #0x80000
CMP             R5, #0x10
BNE             loc_130D0
ADD             SP, SP, #0xC
POP.W           {R4-R11,PC}
; End of function reset_single_BM1391_global_arg

ALIGN 0x10
off_13120 DCD __FUNCTION__.8269 ; "reset_single_BM1391_global_arg"
dword_13124 DCD 0x3312CF
off_13128 DCD cgpu.workdataFilePrefix+0x3C
off_1312C DCD reg_mutex+0x14



; void single_BM1391_calculate_timeout_and_baud()
EXPORT single_BM1391_calculate_timeout_and_baud
single_BM1391_calculate_timeout_and_baud
MOVW            R0, #:lower16:aS ; "\n--- %s\n"
PUSH.W          {R4-R8,LR}
LDR             R1, =__FUNCTION__.8287 ; "single_BM1391_calculate_timeout_and_bau"...
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
MOVW            R6, #:lower16:Conf
BLX             printf
MOV.W           R0, #0x100 ; actual_core_number
BL              calculate_core_number
MOVW            R3, #:lower16:pattern_test_time
MOV             R4, R0
temp_corenum = R0       ; unsigned int
MOVT            R3, #:upper16:pattern_test_time
LDRB            R2, [R3]
CMP             R2, #8  ; switch 9 cases
BHI             def_1315E ; jumptable 0001315E default case
TBB.W           [PC,R2] ; switch jump
jpt_1315E DCB 0x34      ; jump table for switch statement
DCB 0x38
DCB 0x3C
DCB 0x40
DCB 0x44
DCB 0x48
DCB 0x4C
DCB 0x50
DCB 5
ALIGN 2

loc_1316C               ; jumptable 0001315E case 8
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq9]

loc_13172
temp_corenum = R4       ; unsigned int
temp_freq = R5          ; unsigned int
MOV             R1, temp_corenum
MOV.W           R0, #0x1000000
BL              __aeabi_uidiv
MOVW            R3, #:lower16:gChain_Asic_Interval
MOV             R1, temp_freq
MOVT            R3, #:upper16:gChain_Asic_Interval
MOVW            temp_corenum, #0x851F
LDR             R3, [R3]
MOVT            R4, #0x51EB
MOVS            R7, #0
MUL             R0, R3, R0
BL              __aeabi_uidiv
MOV             R3, R0
STR             temp_freq, [R6,#configuration.Freq]
ADD.W           R2, R3, R3,LSL#1
MOVW            R0, #:lower16:aSBaudrateDTime ; "\n---%s: Baudrate = %d, timeout = %d us"...
STR.W           R7, [R6,#configuration.baud]
MOVT            R0, #:upper16:aSBaudrateDTime ; "\n---%s: Baudrate = %d, timeout = %d us"...
RSB.W           R3, R3, R2,LSL#5
LDR             R1, =__FUNCTION__.8287 ; "single_BM1391_calculate_timeout_and_bau"...
MOV             R2, R7
UMULL           R4, temp_freq, R3, R4
LSRS            R4, temp_freq, #5
MOV             R3, R4
STR.W           R4, [R6,#configuration.timeout]
POP.W           {R4-R8,LR}
B.W             j_printf

loc_131CA               ; jumptable 0001315E case 0
temp_corenum = R0       ; unsigned int
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq1]
temp_freq = R5          ; unsigned int
B               loc_13172

loc_131D2               ; jumptable 0001315E case 1
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq2]
temp_freq = R5          ; unsigned int
B               loc_13172

loc_131DA               ; jumptable 0001315E case 2
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq3]
temp_freq = R5          ; unsigned int
B               loc_13172

loc_131E2               ; jumptable 0001315E case 3
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq4]
temp_freq = R5          ; unsigned int
B               loc_13172

loc_131EA               ; jumptable 0001315E case 4
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq5]
temp_freq = R5          ; unsigned int
B               loc_13172

loc_131F2               ; jumptable 0001315E case 5
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq6]
temp_freq = R5          ; unsigned int
B               loc_13172

loc_131FA               ; jumptable 0001315E case 6
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq7]
temp_freq = R5          ; unsigned int
B               loc_13172

loc_13202               ; jumptable 0001315E case 7
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq8]
temp_freq = R5          ; unsigned int
B               loc_13172

def_1315E               ; jumptable 0001315E default case
MOVW            temp_corenum, #:lower16:aSPatternTestTi ; "%s: pattern_test_time = %d, error!!! \n"
temp_corenum = R4       ; unsigned int
LDR             R1, =__FUNCTION__.8287 ; "single_BM1391_calculate_timeout_and_bau"...
MOVT            R0, #:upper16:aSPatternTestTi ; "%s: pattern_test_time = %d, error!!! \n"
MOVT            R6, #:upper16:Conf
MOVS            R5, #0
BLX             printf
B               loc_13172
; End of function single_BM1391_calculate_timeout_and_baud

off_13220 DCD __FUNCTION__.8287 ; "single_BM1391_calculate_timeout_and_bau"...



; void __fastcall BM1391_software_set_address(unsigned __int8 which_chain)
EXPORT BM1391_software_set_address
BM1391_software_set_address
which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R7, which_chain
MOVW            which_chain, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R2, R7
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
MOVW            R6, #:lower16:BHB91601_ASIC_NUMBER
LDR             R1, =__FUNCTION__.8304 ; "BM1391_software_set_address"
MOVT            R6, #:upper16:BHB91601_ASIC_NUMBER
BLX             printf
MOV             R0, R7  ; which_chain
BL              BM1391_chain_inactive
LDR             R3, [R6]
CBZ             R3, locret_13276
MOVS            R4, #0
MOVW            R8, #:lower16:gChain_Asic_Interval
MOV             R5, R4
MOVT            R8, #:upper16:gChain_Asic_Interval

loc_13258               ; address
chip_addr = R5          ; unsigned int
i = R4                  ; unsigned int
UXTB            R1, chip_addr
MOV             R0, R7  ; which_chain
ADDS            i, #1
BL              BM1391_set_address
MOV.W           R0, #0x7D0 ; useconds
BLX             usleep
LDR             R3, [R6]
LDR.W           R2, [R8]
CMP             R3, R4
ADD             chip_addr, R2
i = R4                  ; unsigned int
BHI             loc_13258

locret_13276
POP.W           {R4-R8,PC}
; End of function BM1391_software_set_address

ALIGN 4
off_1327C DCD __FUNCTION__.8304 ; "BM1391_software_set_address"



; void __fastcall BM1391_set_baud(unsigned __int8 which_chain, unsigned __int8 baud)
EXPORT BM1391_set_baud
BM1391_set_baud

mode= -8

which_chain = R0        ; unsigned __int8
baud = R1               ; unsigned __int8
PUSH            {R4-R6,LR}
MOV             R4, which_chain
MOVW            R5, #:lower16:gBM1391_MISC_CONTROL_reg
MOVW            which_chain, #:lower16:aSChainDBaudD ; "\n--- %s: Chain : %d, baud = %d\n"
SUB             SP, SP, #8
MOV             R6, baud
MOV             R3, baud
MOV             R2, R4
MOVT            R5, #:upper16:gBM1391_MISC_CONTROL_reg
LDR             baud, =__FUNCTION__.8312 ; "BM1391_set_baud"
MOVT            R0, #:upper16:aSChainDBaudD ; "\n--- %s: Chain : %d, baud = %d\n"
BLX             printf
MOV             R0, R4  ; which_chain
LDR             R4, [R5]
MOVS            R3, #1
MOVS            R2, #0x18 ; reg_addr
MOVS            R1, #0  ; asic_addr
STR             R3, [SP,#8+mode] ; mode
BIC.W           R4, R4, #0x1F00
ORR.W           R4, R4, R6,LSL#8
MOV             R3, R4  ; reg_data
STR             R4, [R5]
BL              BM1391_set_config
MOVW            R0, #0xC350 ; useconds
BLX             usleep
MOV             R0, R6  ; asic_baud
BL              set_fpga_baud
MOVW            R0, #0xC350 ; useconds
ADD             SP, SP, #8
POP.W           {R4-R6,LR}
B.W             j_usleep
; End of function BM1391_set_baud

ALIGN 4
off_132DC DCD __FUNCTION__.8312 ; "BM1391_set_baud"



; void __fastcall BM1391_set_TM(unsigned __int8 which_chain, unsigned __int8 asic_addr, unsigned int tm, bool mode)
EXPORT BM1391_set_TM
BM1391_set_TM

var_1C= -0x1C
var_18= -0x18
var_14= -0x14
cmd_buf= -0x10

which_chain = R0        ; unsigned __int8
asic_addr_0 = R1        ; unsigned __int8
tm = R2                 ; unsigned int
mode = R3               ; bool
PUSH            {R4-R7,LR}
MOVS            R4, #0
SUB             SP, SP, #0x1C
MOV             R5, which_chain
REV             tm, tm
STRB.W          R4, [SP,#0x1C+var_14]
STR             R4, [SP,#0x1C+cmd_buf]
STR             R4, [SP,#0x1C+cmd_buf+4]
STR             R4, [SP,#0x1C+cmd_buf+8]
CMP             mode, #0
BEQ             loc_13384
MOVS            mode, #0x51 ; 'Q'
STRB.W          R3, [SP,#0x1C+var_1C]

loc_132FE
LSRS            R6, R2, #0x18
UXTB            R4, R2
STRB.W          asic_addr_0, [SP,#0x1C+var_1C+2]
MOVW            R3, #:lower16:bit_swap_table
UBFX.W          which_chain, R2, #0x10, #8
MOVT            R3, #:upper16:bit_swap_table
UBFX.W          R2, R2, #8, #8
LDRB.W          LR, [R3,R6]
MOVS            asic_addr_0, #0x40 ; '@' ; len
LDRB            R7, [R3,R0]
MOV             R0, SP  ; ptr
LDRB            R6, [R3,R2]
MOVS            R2, #9
LDRB            R4, [R3,R4]
MOVS            R3, #0x14
STRB.W          LR, [SP,#0x1C+var_18]
STRB.W          R2, [SP,#0x1C+var_1C+1]
STRB.W          R4, [SP,#0x1C+var_18+3]
STRB.W          R3, [SP,#0x1C+var_1C+3]
STRB.W          R7, [SP,#0x1C+var_18+1]
STRB.W          R6, [SP,#0x1C+var_18+2]
BL              CRC5
LDR             R2, [SP,#0x1C+var_1C]
MOV             R1, R0
LDR             R3, [SP,#0x1C+var_18]
LSLS            R4, R1, #0x18
ADD             R0, SP, #0x1C+cmd_buf ; value
STRB.W          R1, [SP,#0x1C+var_14]
REV             R2, R2
STR             R4, [SP,#0x1C+cmd_buf+8]
REV             R3, R3
STR             R2, [SP,#0x1C+cmd_buf]
STR             R3, [SP,#0x1C+cmd_buf+4]
BL              set_BC_command_buffer
BL              get_BC_write_command
ret = R0                ; unsigned int
MOVS            R3, #0
BIC.W           ret, ret, #0xF0000
MOVT            R3, #0x8080
ORR.W           R3, R3, R5,LSL#16
ORRS            R0, R3  ; value
BL              set_BC_write_command
MOVW            R0, #0x2710 ; useconds
BLX             usleep
ADD             SP, SP, #0x1C
POP             {R4-R7,PC}

loc_13384
which_chain = R0        ; unsigned __int8
asic_addr_0 = R1        ; unsigned __int8
mode = R3               ; bool
MOVS            mode, #0x41 ; 'A'
STRB.W          R3, [SP,#0x1C+var_1C]
B               loc_132FE
; End of function BM1391_set_TM




; void __fastcall BM1391_enable_read_temperature_from_asic(unsigned __int8 which_chain, unsigned __int8 asic_addr)
EXPORT BM1391_enable_read_temperature_from_asic
BM1391_enable_read_temperature_from_asic

mode= -0xC

which_chain = R0        ; unsigned __int8
asic_addr = R1          ; unsigned __int8
MOVW            R3, #:lower16:gBM1391_MISC_CONTROL_reg
PUSH            {LR}
MOVS            R2, #0
SUB             SP, SP, #0xC
MOVT            R3, #:upper16:gBM1391_MISC_CONTROL_reg
STR             R2, [SP,#0xC+mode] ; mode
MOVS            R2, #0x18 ; reg_addr
LDR             R3, [R3]
ORR.W           R3, R3, #0x4000
ORR.W           R3, R3, #0x30 ; '0' ; reg_data
BL              BM1391_set_config
ADD             SP, SP, #0xC
POP.W           {PC}
; End of function BM1391_enable_read_temperature_from_asic

ALIGN 4



; void __fastcall BM1391_enable_core_clock(unsigned __int8 which_chain, unsigned __int8 which_asic, unsigned __int8 core_id, unsigned __int8 mode)
EXPORT BM1391_enable_core_clock
BM1391_enable_core_clock

var_8= -8

which_chain = R0        ; unsigned __int8
which_asic = R1         ; unsigned __int8
core_id = R2            ; unsigned __int8
mode = R3               ; unsigned __int8
PUSH            {R4,LR}
MOVS            R4, mode
SUB             SP, SP, #8
IT NE
MOVNE           R4, #1
MOVW            mode, #0xBCAA
ORR.W           R3, R3, core_id,LSL#16 ; reg_data
STR             R4, [SP,#8+var_8] ; mode
MOVS            core_id, #0x3C ; '<' ; reg_addr
BL              BM1391_set_config
MOVW            R0, #0x1388 ; useconds
ADD             SP, SP, #8
POP.W           {R4,LR}
B.W             j_usleep
; End of function BM1391_enable_core_clock




; void __fastcall single_BM1391P_open_core(unsigned __int8 which_chain)
EXPORT single_BM1391P_open_core
single_BM1391P_open_core

OpenCoreNum2= -0x54
OpenCoreNum3= -0x50
OpenCoreNum4= -0x4C
OpenCoreNum5= -0x48
OpenCoreNum6= -0x44
OpenCoreNum7= -0x40
buf_vil_tw= -0x38

which_chain = R0        ; unsigned __int8
OpenCoreNum1 = R7       ; unsigned int
OpenCoreNum8 = R5       ; unsigned int
PUSH.W          {R4-R11,LR}
MOVW            R8, #:lower16:Conf
SUB             SP, SP, #0x54
MOVT            R8, #:upper16:Conf
MOV             R9, which_chain
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             which_chain, SP, #0x54+buf_vil_tw ; s
BLX             memset
LDR.W           R3, [R8,#configuration.OpenCoreNum2]
MOVW            R0, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R2, R9
LDR             R1, =__FUNCTION__.8350 ; "single_BM1391P_open_core"
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
MOVW            R11, #:lower16:gIsOpenCoreEnd
STR             R3, [SP,#0x54+OpenCoreNum2]
MOVS            R6, #0
LDR.W           R3, [R8,#configuration.OpenCoreNum3]
MOVT            R11, #:upper16:gIsOpenCoreEnd
LDR.W           OpenCoreNum1, [R8,#configuration.OpenCoreNum1]
MOV.W           R10, #0x80
LDR.W           OpenCoreNum8, [R8,#configuration.OpenCoreNum8]
MOV             R4, R6
STR             R3, [SP,#0x54+OpenCoreNum3]
OpenCoreNum3_0 = R3     ; unsigned int
MOVT            R10, #0x100
LDR.W           OpenCoreNum3_0, [R8,#configuration.OpenCoreNum4]
ORR.W           R10, R10, R9,LSL#16
STR             R3, [SP,#0x54+OpenCoreNum4]
OpenCoreNum4_0 = R3     ; unsigned int
LDR.W           OpenCoreNum4_0, [R8,#configuration.OpenCoreNum5]
STR             R3, [SP,#0x54+OpenCoreNum5]
OpenCoreNum5_0 = R3     ; unsigned int
LDR.W           OpenCoreNum5_0, [R8,#configuration.OpenCoreNum6]
STR             R3, [SP,#0x54+OpenCoreNum6]
OpenCoreNum6_0 = R3     ; unsigned int
LDR.W           OpenCoreNum6_0, [R8,#configuration.OpenCoreNum7]
STR             R3, [SP,#0x54+OpenCoreNum7]
OpenCoreNum7_0 = R3     ; unsigned int
BLX             printf
MOVS            R0, #0x40 ; '@' ; address
STRB.W          R6, [R11]
BL              read_axi_fpga
BIC.W           R1, R0, #0x20 ; ' ' ; data
MOVS            R0, #0x40 ; '@' ; address
BL              write_axi_fpga
MOV             R1, R6  ; data
MOVS            R0, #0x24 ; '$' ; address
BL              write_axi_fpga
MOV             R1, R6  ; c
MOVS            R6, #1
LSL.W           R6, R6, R9
ADD             R0, SP, #0x54+buf_vil_tw ; s
MOVS            R2, #0x34 ; '4' ; n
BLX             memset

loc_13476
which_core = R4         ; unsigned int
CMP             which_core, #0x1F
BLS             loc_134EC
SUB.W           R3, which_core, #0x20 ; ' '
CMP             R3, #0x1F
BLS             loc_13532
SUB.W           R3, which_core, #0x40 ; '@'
CMP             R3, #0x1F
BLS.W           loc_13686
SUB.W           R3, which_core, #0x60 ; '`'
CMP             R3, #0x1F
BLS.W           loc_13678
SUB.W           R3, which_core, #0x80
CMP             R3, #0x1F
BLS.W           loc_135FE
SUB.W           R3, which_core, #0xA0
CMP             R3, #0x1F
BLS.W           loc_135F0
SUB.W           R3, which_core, #0xC0
CMP             R3, #0x1F
BLS             loc_13576
LSLS            R3, OpenCoreNum8, #0x1F
BMI             loc_13540

loc_134B6
LSRS            OpenCoreNum8, OpenCoreNum8, #1

loc_134B8
ADDS            which_core, #1
CMP.W           which_core, #0x100
BNE             loc_13476

loc_134C0               ; address
MOVS            R0, #0x30 ; '0'
BL              read_axi_fpga
ORR.W           R1, R0, #0x400000 ; data
MOVS            R0, #0x30 ; '0' ; address
BL              write_axi_fpga
MOVW            R0, #:lower16:aSEndChainD ; "\n--- %s end: Chain : %d\n"
MOVS            R3, #1
MOV             R2, R9
LDR             R1, =__FUNCTION__.8350 ; "single_BM1391P_open_core"
MOVT            R0, #:upper16:aSEndChainD ; "\n--- %s end: Chain : %d\n"
STRB.W          R3, [R11]
BLX             printf
ADD             SP, SP, #0x54 ; 'T'
POP.W           {which_core-R11,PC}

loc_134EC
LSLS            R0, OpenCoreNum1, #0x1F
BMI             loc_134FC

loc_134F0
ADDS            which_core, #1
LSRS            OpenCoreNum1, OpenCoreNum1, #1
which_core = R4         ; unsigned int
CMP.W           which_core, #0x100
BNE             loc_13476
B               loc_134C0

loc_134FC               ; which_chain
MOV             R0, R9
MOVS            R3, #1  ; mode
UXTB            R2, which_core ; core_id
MOVS            R1, #0  ; which_asic
BL              BM1391_enable_core_clock
MOVW            R0, #0x1388 ; useconds

loc_1350C
BLX             usleep
MOVS            R0, #3  ; address
BL              read_axi_fpga
work_fifo_ready = R0    ; unsigned int
TST             work_fifo_ready, R6
MOVW            work_fifo_ready, #0xBB8
BEQ             loc_1350C
ADD             R0, SP, #0x54+buf_vil_tw ; value
STR.W           R10, [SP,#0x54+buf_vil_tw]
BL              set_TW_write_command
LDR.W           R0, [R8,#configuration.OpenCoreGap] ; useconds
BLX             usleep
B               loc_134F0

loc_13532
LDR             R3, [SP,#0x54+OpenCoreNum2]
LSLS            R1, R3, #0x1F
BMI             loc_13584

loc_13538
LDR             R3, [SP,#0x54+OpenCoreNum2]
LSRS            R3, R3, #1
STR             R3, [SP,#0x54+OpenCoreNum2]
OpenCoreNum2_0 = R3     ; unsigned int
B               loc_134B8

loc_13540               ; which_chain
MOV             R0, R9
MOVS            R3, #1  ; mode
UXTB            R2, which_core ; core_id
MOVS            R1, #0  ; which_asic
BL              BM1391_enable_core_clock
MOVW            R0, #0x1388 ; useconds

loc_13550
BLX             usleep
MOVS            R0, #3  ; address
BL              read_axi_fpga
work_fifo_ready = R0    ; unsigned int
TST             work_fifo_ready, R6
MOVW            work_fifo_ready, #0xBB8
BEQ             loc_13550
ADD             R0, SP, #0x54+buf_vil_tw ; value
STR.W           R10, [SP,#0x54+buf_vil_tw]
BL              set_TW_write_command
LDR.W           R0, [R8,#configuration.OpenCoreGap] ; useconds
BLX             usleep
B               loc_134B6

loc_13576
LDR             R3, [SP,#0x54+OpenCoreNum7]
LSLS            R2, R3, #0x1F
BMI             loc_135BA

loc_1357C
LDR             R3, [SP,#0x54+OpenCoreNum7]
LSRS            R3, R3, #1
STR             R3, [SP,#0x54+OpenCoreNum7]
OpenCoreNum7_0 = R3     ; unsigned int
B               loc_134B8

loc_13584               ; which_chain
MOV             R0, R9
MOVS            R3, #1  ; mode
UXTB            R2, which_core ; core_id
MOVS            R1, #0  ; which_asic
BL              BM1391_enable_core_clock
MOVW            R0, #0x1388 ; useconds

loc_13594
BLX             usleep
MOVS            R0, #3  ; address
BL              read_axi_fpga
work_fifo_ready = R0    ; unsigned int
TST             work_fifo_ready, R6
MOVW            work_fifo_ready, #0xBB8
BEQ             loc_13594
ADD             R0, SP, #0x54+buf_vil_tw ; value
STR.W           R10, [SP,#0x54+buf_vil_tw]
BL              set_TW_write_command
LDR.W           R0, [R8,#configuration.OpenCoreGap] ; useconds
BLX             usleep
B               loc_13538

loc_135BA               ; which_chain
MOV             R0, R9
MOVS            R3, #1  ; mode
UXTB            R2, which_core ; core_id
MOVS            R1, #0  ; which_asic
BL              BM1391_enable_core_clock
MOVW            R0, #0x1388 ; useconds

loc_135CA
BLX             usleep
MOVS            R0, #3  ; address
BL              read_axi_fpga
work_fifo_ready = R0    ; unsigned int
TST             work_fifo_ready, R6
MOVW            work_fifo_ready, #0xBB8
BEQ             loc_135CA
ADD             R0, SP, #0x54+buf_vil_tw ; value
STR.W           R10, [SP,#0x54+buf_vil_tw]
BL              set_TW_write_command
LDR.W           R0, [R8,#configuration.OpenCoreGap] ; useconds
BLX             usleep
B               loc_1357C

loc_135F0
LDR             R3, [SP,#0x54+OpenCoreNum6]
LSLS            R1, R3, #0x1F
BMI             loc_1360C

loc_135F6
LDR             R3, [SP,#0x54+OpenCoreNum6]
LSRS            R3, R3, #1
STR             R3, [SP,#0x54+OpenCoreNum6]
OpenCoreNum6_0 = R3     ; unsigned int
B               loc_134B8

loc_135FE
LDR             R3, [SP,#0x54+OpenCoreNum5]
LSLS            R0, R3, #0x1F
BMI             loc_13642

loc_13604
LDR             R3, [SP,#0x54+OpenCoreNum5]
LSRS            R3, R3, #1
STR             R3, [SP,#0x54+OpenCoreNum5]
OpenCoreNum5_0 = R3     ; unsigned int
B               loc_134B8

loc_1360C               ; which_chain
MOV             R0, R9
MOVS            R3, #1  ; mode
UXTB            R2, which_core ; core_id
MOVS            R1, #0  ; which_asic
BL              BM1391_enable_core_clock
MOVW            R0, #0x1388 ; useconds

loc_1361C
BLX             usleep
MOVS            R0, #3  ; address
BL              read_axi_fpga
work_fifo_ready = R0    ; unsigned int
TST             work_fifo_ready, R6
MOVW            work_fifo_ready, #0xBB8
BEQ             loc_1361C
ADD             R0, SP, #0x54+buf_vil_tw ; value
STR.W           R10, [SP,#0x54+buf_vil_tw]
BL              set_TW_write_command
LDR.W           R0, [R8,#configuration.OpenCoreGap] ; useconds
BLX             usleep
B               loc_135F6

loc_13642               ; which_chain
MOV             R0, R9
MOVS            R3, #1  ; mode
UXTB            R2, which_core ; core_id
MOVS            R1, #0  ; which_asic
BL              BM1391_enable_core_clock
MOVW            R0, #0x1388 ; useconds

loc_13652
BLX             usleep
MOVS            R0, #3  ; address
BL              read_axi_fpga
work_fifo_ready = R0    ; unsigned int
TST             work_fifo_ready, R6
MOVW            work_fifo_ready, #0xBB8
BEQ             loc_13652
ADD             R0, SP, #0x54+buf_vil_tw ; value
STR.W           R10, [SP,#0x54+buf_vil_tw]
BL              set_TW_write_command
LDR.W           R0, [R8,#configuration.OpenCoreGap] ; useconds
BLX             usleep
B               loc_13604

loc_13678
LDR             R3, [SP,#0x54+OpenCoreNum4]
LSLS            R3, R3, #0x1F
BMI             loc_13694

loc_1367E
LDR             R3, [SP,#0x54+OpenCoreNum4]
LSRS            R3, R3, #1
STR             R3, [SP,#0x54+OpenCoreNum4]
OpenCoreNum4_0 = R3     ; unsigned int
B               loc_134B8

loc_13686
LDR             R3, [SP,#0x54+OpenCoreNum3]
LSLS            R2, R3, #0x1F
BMI             loc_136CA

loc_1368C
LDR             R3, [SP,#0x54+OpenCoreNum3]
LSRS            R3, R3, #1
STR             R3, [SP,#0x54+OpenCoreNum3]
OpenCoreNum3_0 = R3     ; unsigned int
B               loc_134B8

loc_13694               ; which_chain
MOV             R0, R9
MOVS            R3, #1  ; mode
UXTB            R2, which_core ; core_id
MOVS            R1, #0  ; which_asic
BL              BM1391_enable_core_clock
MOVW            R0, #0x1388 ; useconds

loc_136A4
BLX             usleep
MOVS            R0, #3  ; address
BL              read_axi_fpga
work_fifo_ready = R0    ; unsigned int
TST             work_fifo_ready, R6
MOVW            work_fifo_ready, #0xBB8
BEQ             loc_136A4
ADD             R0, SP, #0x54+buf_vil_tw ; value
STR.W           R10, [SP,#0x54+buf_vil_tw]
BL              set_TW_write_command
LDR.W           R0, [R8,#configuration.OpenCoreGap] ; useconds
BLX             usleep
B               loc_1367E

loc_136CA               ; which_chain
MOV             R0, R9
MOVS            R3, #1  ; mode
UXTB            R2, which_core ; core_id
MOVS            R1, #0  ; which_asic
BL              BM1391_enable_core_clock
MOVW            R0, #0x1388 ; useconds

loc_136DA
BLX             usleep
MOVS            R0, #3  ; address
BL              read_axi_fpga
work_fifo_ready = R0    ; unsigned int
TST             work_fifo_ready, R6
MOVW            work_fifo_ready, #0xBB8
BEQ             loc_136DA
ADD             R0, SP, #0x54+buf_vil_tw ; value
STR.W           R10, [SP,#0x54+buf_vil_tw]
BL              set_TW_write_command
LDR.W           R0, [R8,#configuration.OpenCoreGap] ; useconds
BLX             usleep
B               loc_1368C
; End of function single_BM1391P_open_core

off_13700 DCD __FUNCTION__.8350 ; "single_BM1391P_open_core"



; void __fastcall single_BM1391S_open_core(unsigned __int8 which_chain)
EXPORT single_BM1391S_open_core
single_BM1391S_open_core

buf_vil_tw= -0x34

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R10,LR}
SUB             SP, SP, #0x38
MOV             R7, which_chain
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             which_chain, SP, #0x38+buf_vil_tw ; s
BLX             memset
MOVW            R0, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R2, R7
LDR             R1, =__FUNCTION__.8379 ; "single_BM1391S_open_core"
MOVW            R10, #:lower16:gIsOpenCoreEnd
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV.W           R8, #0x80
BLX             printf
MOVS            R4, #0
MOVT            R10, #:upper16:gIsOpenCoreEnd
MOVS            R0, #0x40 ; '@' ; address
MOVS            R5, #1
MOVT            R8, #0x100
STRB.W          R4, [R10]
MOVW            R9, #:lower16:Conf
LSLS            R5, R7
ORR.W           R8, R8, R7,LSL#16
MOV             R6, R4
MOVT            R9, #:upper16:Conf
BL              read_axi_fpga
BIC.W           R1, R0, #0x20 ; ' ' ; data
MOVS            R0, #0x40 ; '@' ; address
BL              write_axi_fpga
MOV             R1, R4  ; data
MOVS            R0, #0x24 ; '$' ; address
BL              write_axi_fpga
MOV             R1, R4  ; c
ADD             R0, SP, #0x38+buf_vil_tw ; s
MOVS            R2, #0x34 ; '4' ; n
BLX             memset

loc_13770
core_id = R6            ; unsigned int
MOVS            R4, #0

loc_13772               ; useconds
slot = R4               ; unsigned int
MOV.W           R0, #0x3E8
BLX             usleep
ADD.W           R2, core_id, slot,LSL#6
core_index = R2         ; unsigned int
MOVS            R3, #1  ; mode
ADD             slot, R3
UXTB            core_index, core_index ; core_id
MOVS            R1, #0  ; which_asic
MOV             R0, R7  ; which_chain
BL              BM1391_enable_core_clock
slot = R4               ; unsigned int
CMP             slot, #4
BNE             loc_13772
MOVW            R0, #0x1388 ; useconds

loc_13794
BLX             usleep
MOVS            R0, #3  ; address
BL              read_axi_fpga
work_fifo_ready = R0    ; unsigned int
TST             work_fifo_ready, R5
MOVW            work_fifo_ready, #0xBB8
BEQ             loc_13794
ADD             R0, SP, #0x38+buf_vil_tw ; value
STR.W           R8, [SP,#0x38+buf_vil_tw]
ADDS            core_id, #1
BL              set_TW_write_command
LDR.W           R0, [R9,#configuration.OpenCoreGap] ; useconds
BLX             usleep
core_id = R6            ; unsigned int
CMP             core_id, #0x40 ; '@'
BNE             loc_13770
MOVS            R0, #0x30 ; '0' ; address
BL              read_axi_fpga
ORR.W           R1, R0, #0x400000 ; data
MOVS            R0, #0x30 ; '0' ; address
BL              write_axi_fpga
MOVW            R0, #:lower16:aSEndChainD ; "\n--- %s end: Chain : %d\n"
MOVS            R3, #1
MOV             R2, R7
LDR             R1, =__FUNCTION__.8379 ; "single_BM1391S_open_core"
MOVT            R0, #:upper16:aSEndChainD ; "\n--- %s end: Chain : %d\n"
STRB.W          R3, [R10]
BLX             printf
ADD             SP, SP, #0x38 ; '8'
POP.W           {slot-R10,PC}
; End of function single_BM1391S_open_core

ALIGN 4
off_137EC DCD __FUNCTION__.8379 ; "single_BM1391S_open_core"



; unsigned int __fastcall single_BM1391_get_result(unsigned __int8 which_chain)
EXPORT single_BM1391_get_result
single_BM1391_get_result

var_34= -0x34
var_30= -0x30
var_2C= -0x2C
format= -0x28
var_24= -0x24
OpenCoreNum2= -0x20
OpenCoreNum3= -0x1C
OpenCoreNum4= -0x18
OpenCoreNum5= -0x14
OpenCoreNum6= -0x10
OpenCoreNum7= -0xC
works= -8

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
MOV             R8, #Conf
SUB             SP, SP, #0x34
MOV             R4, which_chain
MOVW            R5, #:lower16:gAsic_Core_Nonce_Num
LDR.W           R3, [R8,#configuration.OpenCoreNum2]
MOVT            R5, #:upper16:gAsic_Core_Nonce_Num
STR             which_chain, [SP,#0x34+var_30]
MOV             R0, #asc_29AF4 ; "\n\n-----------------------------------"...
LDR.W           R9, [R8,#configuration.OpenCoreNum1]
OpenCoreNum1 = R9       ; unsigned int
STR             R3, [SP,#0x34+OpenCoreNum2]
OpenCoreNum2_0 = R3     ; unsigned int
ADD.W           R5, R5, R4,LSL#19
LDR.W           OpenCoreNum2_0, [R8,#configuration.OpenCoreNum3]
MOVW            R7, #:lower16:aCore03d02d ; "core[%03d]=%02d\t"
LDR.W           R6, [R8,#configuration.OpenCoreNum8]
MOVT            R7, #:upper16:aCore03d02d ; "core[%03d]=%02d\t"
MOV.W           R10, #0
SUBS            R4, R5, #4
STR             R3, [SP,#0x34+OpenCoreNum3]
OpenCoreNum3_0 = R3     ; unsigned int
LDR.W           OpenCoreNum3_0, [R8,#configuration.OpenCoreNum4]
STR             R3, [SP,#0x34+OpenCoreNum4]
OpenCoreNum4_0 = R3     ; unsigned int
LDR.W           OpenCoreNum4_0, [R8,#configuration.OpenCoreNum5]
STR             R3, [SP,#0x34+OpenCoreNum5]
OpenCoreNum5_0 = R3     ; unsigned int
LDR.W           OpenCoreNum5_0, [R8,#configuration.OpenCoreNum6]
STR             R3, [SP,#0x34+OpenCoreNum6]
OpenCoreNum6_0 = R3     ; unsigned int
LDR.W           OpenCoreNum6_0, [R8,#configuration.OpenCoreNum7]
STR             R3, [SP,#0x34+OpenCoreNum7]
OpenCoreNum7_0 = R3     ; unsigned int
OpenCoreNum8 = R6       ; unsigned int
BLX             puts
MOVW            R0, #:lower16:aEveryCoreRequi ; "every CORE require nonce number: %u\n\n"
LDR.W           R1, [R8,#configuration.pattern_number]
MOVT            R0, #:upper16:aEveryCoreRequi ; "every CORE require nonce number: %u\n\n"
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum1]
MOV             R0, #aOpenCoreNumber ; "Open core number : Conf.OpenCoreNum1 = "...
MOV             R1, R2
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum2]
MOV             R0, #aOpenCoreNumber_0 ; "Open core number : Conf.OpenCoreNum2 = "...
MOV             R1, R2
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum3]
MOV             R0, #aOpenCoreNumber_1 ; "Open core number : Conf.OpenCoreNum3 = "...
MOV             R1, R2
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum4]
MOV             R0, #aOpenCoreNumber_3 ; "Open core number : Conf.OpenCoreNum4 = "...
MOV             R1, R2
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum5]
MOV             R0, #aOpenCoreNumber_4 ; "Open core number : Conf.OpenCoreNum5 = "...
MOV             R1, R2
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum6]
MOV             R0, #aOpenCoreNumber_5 ; "Open core number : Conf.OpenCoreNum6 = "...
MOV             R1, R2
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum7]
MOV             R0, #aOpenCoreNumber_6 ; "Open core number : Conf.OpenCoreNum7 = "...
MOV             R1, R2
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum8]
MOV             R0, #aOpenCoreNumber_7 ; "Open core number : Conf.OpenCoreNum8 = "...
MOV             R1, R2
BLX             printf
B               loc_1390C

loc_138F6
which_core = R10        ; unsigned int
MOV             R1, which_core
LDR.W           R2, [R4,#4]!
MOV             R0, R7  ; format
ADD.W           which_core, which_core, #1
which_core = R1         ; unsigned int
BLX             printf
which_core = R10        ; unsigned int
CMP.W           which_core, #0x100
BEQ             loc_1391A

loc_1390C
TST.W           which_core, #7
BNE             loc_138F6
MOVS            R0, #0xA ; c
BLX             putchar
B               loc_138F6

loc_1391A
LDR             R0, [SP,#0x34+var_30]
MOVW            R3, #:lower16:cgpu
MOVW            R2, #:lower16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
MOVW            R1, #:lower16:aD ; "%d  "
MOV.W           which_core, #0
MOVT            R3, #:upper16:cgpu
MOVT            R2, #:upper16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
MOVT            R1, #:upper16:aD ; "%d  "
LSLS            R0, R0, #2
MOV             R4, R10
STR             R3, [SP,#0x34+var_2C]
MOVS            R7, #3
STR             R0, [SP,#0x34+var_24]
MOV             R0, #(aSCreateSingleB_1+0x2C) ; s
STR             R2, [SP,#0x34+format]
STR             R1, [SP,#0x34+var_34]
BLX             puts

loc_13952
which_core = R4         ; unsigned int
test_core_index = R10   ; unsigned int
CMP             which_core, #0x1F
BLS.W           loc_13B06
SUB.W           R3, which_core, #0x20 ; ' '
CMP             R3, #0x1F
BLS.W           loc_13BCC
SUB.W           R3, which_core, #0x40 ; '@'
CMP             R3, #0x1F
BLS.W           loc_13DB2
SUB.W           R3, which_core, #0x60 ; '`'
CMP             R3, #0x1F
BLS.W           loc_13D88
SUB.W           R3, which_core, #0x80
CMP             R3, #0x1F
BLS.W           loc_13CD2
SUB.W           R3, which_core, #0xA0
CMP             R3, #0x1F
BLS.W           loc_13CA8
SUB.W           R3, which_core, #0xC0
CMP             R3, #0x1F
BLS.W           loc_13C7A
LSLS            R1, OpenCoreNum8, #0x1F
IT PL
LSRPL           OpenCoreNum8, OpenCoreNum8, #1
BPL             loc_139BC
LDR             R0, [SP,#0x34+var_2C]
ADD.W           R3, test_core_index, #0x20000
LDR             R2, [R5]
ADDS            R3, #0x2A ; '*'
LDR.W           R1, [R8,#configuration.pattern_number]
ADD.W           R3, R0, R3,LSL#2
CMP             R2, R1
LDR             R3, [R3,#4]
works_0 = R3            ; work *
BCC.W           loc_13C3C

loc_139B6
LSRS            R6, R6, #1
OpenCoreNum8 = R6       ; unsigned int
ADD.W           test_core_index, test_core_index, #1

loc_139BC
ADDS            which_core, #1
CMP.W           which_core, #0x100
ADD.W           R5, R5, #4
BNE             loc_13952

loc_139C8
LDR.W           R3, [R8,#configuration.TempSensor1]
CBZ             R3, loc_13A0A
MOV             R3, #Sensor1_temp
LDR             R1, [R3]
CMP             R1, #0
BEQ.W           loc_13B96
MOV             R3, #Sensor1_OK
LDRB            R3, [R3]
CMP             R3, #0
BEQ.W           loc_13B96
MOV             R3, #gNotReadOutTemp
LDRB            R3, [R3]
CMP             R3, #0
BNE.W           loc_13B96
MOV             R0, #aTemperature1D ; "temperature1 = %d\n"
BLX             printf

loc_13A0A
ret = R7                ; unsigned int
LDR.W           R3, [R8,#configuration.TempSensor2]
CBZ             R3, loc_13A4C
MOV             R3, #Sensor2_temp
LDR             R1, [R3]
CMP             R1, #0
BEQ.W           loc_13BA8
MOV             R3, #Sensor2_OK
LDRB            R3, [R3]
CMP             R3, #0
BEQ.W           loc_13BA8
MOV             R3, #gNotReadOutTemp
LDRB            R3, [R3]
CMP             R3, #0
BNE.W           loc_13BA8
MOV             R0, #aTemperature2D ; "temperature2 = %d\n"
BLX             printf

loc_13A4C
LDR.W           R3, [R8,#configuration.TempSensor3]
CBZ             R3, loc_13A8E
MOV             R3, #Sensor3_temp
LDR             R1, [R3]
CMP             R1, #0
BEQ.W           loc_13BBA
MOV             R3, #Sensor3_OK
LDRB            R3, [R3]
CMP             R3, #0
BEQ.W           loc_13BBA
MOV             R3, #gNotReadOutTemp
LDRB            R3, [R3]
CMP             R3, #0
BNE.W           loc_13BBA
MOV             R0, #aTemperature3D ; "temperature3 = %d\n"
BLX             printf

loc_13A8E
MOV             R0, #asc_29CA4 ; "\n-------------------------------------"...
BLX             puts
LDR             R1, [SP,#0x34+var_30]
MOV             R3, #gValid_Nonce_Num
MOV             R0, #aChainDTotalVal ; "Chain%d total valid nonce number: %d\n"...
LDR.W           R2, [R3,R1,LSL#2]
BLX             printf
LSLS            R2, ret, #0x1F
ITETE MI
MOVWMI          R0, #0x9D38
MOVWPL          R0, #0x9D44
MOVTMI          R0, #2
MOVTPL          R0, #2  ; s
BLX             puts
LSLS            R3, ret, #0x1E
ITETE MI
MOVWMI          R0, #0xAB0C
MOVWPL          R0, #0xAB18
MOVTMI          R0, #2
MOVTPL          R0, #2  ; s
BLX             puts
LDR             R2, [SP,#0x34+var_30]
MOV             R3, #gHw_Nonce_Num
MOV             R0, #aHwNumberD ; "HW number = %d\n\n"
LDR.W           R1, [R3,R2,LSL#2]
BLX             printf
MOV             R0, ret
ADD             SP, SP, #0x34 ; '4'
POP.W           {which_core-R11,PC}

loc_13B06
TST.W           OpenCoreNum1, #1
IT EQ
MOVEQ.W         OpenCoreNum1, OpenCoreNum1,LSR#1
BEQ.W           loc_139BC
LDR             R2, [R5]
LDR.W           R3, [R8,#configuration.pattern_number]
CMP             R2, R3
BCC             loc_13B36

loc_13B1E
ADDS            which_core, #1
MOV.W           R9, R9,LSR#1
OpenCoreNum1 = R9       ; unsigned int
CMP.W           R4, #0x100
ADD.W           test_core_index, test_core_index, #1
which_core = R4         ; unsigned int
ADD.W           R5, R5, #4
BNE.W           loc_13952
B               loc_139C8

loc_13B36
LDR             R0, [SP,#0x34+var_2C]
ADD.W           R3, test_core_index, #0x20000
ADDS            R3, #0x2A ; '*'
MOV             R1, which_core
ADD.W           R3, R0, R3,LSL#2
LDR             R0, [SP,#0x34+format] ; format
LDR             R7, [R3,#4]
BLX             printf
LDR.W           R3, [R8,#configuration.pattern_number]
CBZ             R3, loc_13B8C
LDR             R3, [SP,#0x34+var_24]
ADD.W           R11, R7, R3
MOV             R3, R8
MOVS            R7, #0
MOV             R8, which_core
MOV             which_core, R3
which_core = R8         ; unsigned int
B               loc_13B6A

loc_13B62
which_pattern = R7      ; unsigned int
LDR             R3, [R4,#configuration.pattern_number]
ADDS            which_pattern, #1
CMP             R3, which_pattern
BLS             loc_13B86

loc_13B6A
LDR.W           R3, [R11,#0x34]
ADD.W           R11, R11, #0x44 ; 'D'
CMP             R3, #0
BNE             loc_13B62
MOV             R1, which_pattern
LDR             R0, [SP,#0x34+var_34] ; format
BLX             printf
LDR             R3, [R4,#configuration.pattern_number]
ADDS            which_pattern, #1
CMP             R3, which_pattern
BHI             loc_13B6A

loc_13B86
MOV             R3, R4
MOV             R4, which_core
MOV             which_core, R3

loc_13B8C               ; c
which_core = R4         ; unsigned int
MOVS            R0, #0xA
MOVS            R7, #2
BLX             putchar
B               loc_13B1E

loc_13B96
OpenCoreNum1 = R9       ; unsigned int
MOVW            R0, #:lower16:aTemperature1Ch ; "temperature1 check error"
BIC.W           R7, R7, #2
MOVT            R0, #:upper16:aTemperature1Ch ; "temperature1 check error"
BLX             puts
ret = R7                ; unsigned int
B               loc_13A0A

loc_13BA8
MOVW            R0, #:lower16:aTemperature2Ch ; "temperature2 check error"
BIC.W           ret, ret, #2
MOVT            R0, #:upper16:aTemperature2Ch ; "temperature2 check error"
BLX             puts
ret = R7                ; unsigned int
B               loc_13A4C

loc_13BBA
MOVW            R0, #:lower16:aTemperature3Ch ; "temperature3 check error"
BIC.W           ret, ret, #2
MOVT            R0, #:upper16:aTemperature3Ch ; "temperature3 check error"
BLX             puts
ret = R7                ; unsigned int
B               loc_13A8E

loc_13BCC
LDR             R3, [SP,#0x34+OpenCoreNum2]
LSLS            R3, R3, #0x1F
BPL             loc_13C34
LDR             R0, [SP,#0x34+var_2C]
ADD.W           R3, test_core_index, #0x20000
LDR             R2, [R5]
ADDS            R3, #0x2A ; '*'
LDR.W           R1, [R8,#configuration.pattern_number]
ADD.W           R3, R0, R3,LSL#2
CMP             R2, R1
LDR             R3, [R3,#4]
works_0 = R3            ; work *
BCC             loc_13BF6

loc_13BEA
LDR             R3, [SP,#0x34+OpenCoreNum2]
ADD.W           test_core_index, test_core_index, #1
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum2]
test_core_index = R10   ; unsigned int
OpenCoreNum2_0 = R3     ; unsigned int
B               loc_139BC

loc_13BF6
works_0 = R3            ; work *
MOV             R1, which_core
LDR             R0, [SP,#0x34+format] ; format
STR             works_0, [SP,#0x34+works]
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R3, [SP,#0x34+works]
CBZ             R2, loc_13C2A
LDR             R2, [SP,#0x34+var_24]
ADDS            R7, R3, R2
MOVS            R3, #0
MOV             R11, R3

loc_13C10
which_pattern = R11     ; unsigned int
LDR             R3, [R7,#0x34]
ADDS            R7, #0x44 ; 'D'
CBNZ            R3, loc_13C1E
MOV             R1, which_pattern
LDR             R0, [SP,#0x34+var_34] ; format
BLX             printf

loc_13C1E
LDR.W           R3, [R8,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R3, which_pattern
BHI             loc_13C10

loc_13C2A               ; c
MOVS            R0, #0xA
MOVS            R7, #2
BLX             putchar
B               loc_13BEA

loc_13C34
LDR             R3, [SP,#0x34+OpenCoreNum2]
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum2]
OpenCoreNum2_0 = R3     ; unsigned int
B               loc_139BC

loc_13C3C
works_0 = R3            ; work *
MOV             R1, which_core
LDR             R0, [SP,#0x34+format] ; format
STR             works_0, [SP,#0x34+works]
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R3, [SP,#0x34+works]
CBZ             R2, loc_13C70
LDR             R2, [SP,#0x34+var_24]
ADDS            R7, R3, R2
MOVS            R3, #0
MOV             R11, R3

loc_13C56
which_pattern = R11     ; unsigned int
LDR             R3, [R7,#0x34]
ADDS            R7, #0x44 ; 'D'
CBNZ            R3, loc_13C64
MOV             R1, which_pattern
LDR             R0, [SP,#0x34+var_34] ; format
BLX             printf

loc_13C64
LDR.W           R3, [R8,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R3, which_pattern
BHI             loc_13C56

loc_13C70               ; c
MOVS            R0, #0xA
MOVS            R7, #2
BLX             putchar
B               loc_139B6

loc_13C7A
OpenCoreNum8 = R6       ; unsigned int
LDR             R3, [SP,#0x34+OpenCoreNum7]
LSLS            R0, R3, #0x1F
BPL.W           loc_13E60
LDR             R0, [SP,#0x34+var_2C]
ADD.W           R3, test_core_index, #0x20000
LDR             R2, [R5]
ADDS            R3, #0x2A ; '*'
LDR.W           R1, [R8,#configuration.pattern_number]
ADD.W           R3, R0, R3,LSL#2
CMP             R2, R1
LDR             R3, [R3,#4]
works_0 = R3            ; work *
BCC.W           loc_13E22

loc_13C9C
LDR             R3, [SP,#0x34+OpenCoreNum7]
ADD.W           test_core_index, test_core_index, #1
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum7]
test_core_index = R10   ; unsigned int
OpenCoreNum7_0 = R3     ; unsigned int
B               loc_139BC

loc_13CA8
LDR             R3, [SP,#0x34+OpenCoreNum6]
LSLS            R3, R3, #0x1F
BPL             loc_13D3A
LDR             R0, [SP,#0x34+var_2C]
ADD.W           R3, test_core_index, #0x20000
LDR             R2, [R5]
ADDS            R3, #0x2A ; '*'
LDR.W           R1, [R8,#configuration.pattern_number]
ADD.W           R3, R0, R3,LSL#2
CMP             R2, R1
LDR             R3, [R3,#4]
works_0 = R3            ; work *
BCC             loc_13CFC

loc_13CC6
LDR             R3, [SP,#0x34+OpenCoreNum6]
ADD.W           test_core_index, test_core_index, #1
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum6]
test_core_index = R10   ; unsigned int
OpenCoreNum6_0 = R3     ; unsigned int
B               loc_139BC

loc_13CD2
LDR             R3, [SP,#0x34+OpenCoreNum5]
LSLS            R2, R3, #0x1F
BPL             loc_13D80
LDR             R0, [SP,#0x34+var_2C]
ADD.W           R3, test_core_index, #0x20000
LDR             R2, [R5]
ADDS            R3, #0x2A ; '*'
LDR.W           R1, [R8,#configuration.pattern_number]
ADD.W           R3, R0, R3,LSL#2
CMP             R2, R1
LDR             R3, [R3,#4]
works_0 = R3            ; work *
BCC             loc_13D42

loc_13CF0
LDR             R3, [SP,#0x34+OpenCoreNum5]
ADD.W           test_core_index, test_core_index, #1
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum5]
test_core_index = R10   ; unsigned int
OpenCoreNum5_0 = R3     ; unsigned int
B               loc_139BC

loc_13CFC
works_0 = R3            ; work *
MOV             R1, which_core
LDR             R0, [SP,#0x34+format] ; format
STR             works_0, [SP,#0x34+works]
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R3, [SP,#0x34+works]
CBZ             R2, loc_13D30
LDR             R2, [SP,#0x34+var_24]
ADDS            R7, R3, R2
MOVS            R3, #0
MOV             R11, R3

loc_13D16
which_pattern = R11     ; unsigned int
LDR             R3, [R7,#0x34]
ADDS            R7, #0x44 ; 'D'
CBNZ            R3, loc_13D24
MOV             R1, which_pattern
LDR             R0, [SP,#0x34+var_34] ; format
BLX             printf

loc_13D24
LDR.W           R3, [R8,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R3, which_pattern
BHI             loc_13D16

loc_13D30               ; c
MOVS            R0, #0xA
MOVS            R7, #2
BLX             putchar
B               loc_13CC6

loc_13D3A
LDR             R3, [SP,#0x34+OpenCoreNum6]
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum6]
OpenCoreNum6_0 = R3     ; unsigned int
B               loc_139BC

loc_13D42
works_0 = R3            ; work *
MOV             R1, which_core
LDR             R0, [SP,#0x34+format] ; format
STR             works_0, [SP,#0x34+works]
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R3, [SP,#0x34+works]
CBZ             R2, loc_13D76
LDR             R2, [SP,#0x34+var_24]
ADDS            R7, R3, R2
MOVS            R3, #0
MOV             R11, R3

loc_13D5C
which_pattern = R11     ; unsigned int
LDR             R3, [R7,#0x34]
ADDS            R7, #0x44 ; 'D'
CBNZ            R3, loc_13D6A
MOV             R1, which_pattern
LDR             R0, [SP,#0x34+var_34] ; format
BLX             printf

loc_13D6A
LDR.W           R3, [R8,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R3, which_pattern
BHI             loc_13D5C

loc_13D76               ; c
MOVS            R0, #0xA
MOVS            R7, #2
BLX             putchar
B               loc_13CF0

loc_13D80
LDR             R3, [SP,#0x34+OpenCoreNum5]
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum5]
OpenCoreNum5_0 = R3     ; unsigned int
B               loc_139BC

loc_13D88
LDR             R3, [SP,#0x34+OpenCoreNum4]
LSLS            R1, R3, #0x1F
BPL             loc_13E1A
LDR             R0, [SP,#0x34+var_2C]
ADD.W           R3, test_core_index, #0x20000
LDR             R2, [R5]
ADDS            R3, #0x2A ; '*'
LDR.W           R1, [R8,#configuration.pattern_number]
ADD.W           R3, R0, R3,LSL#2
CMP             R2, R1
LDR             R3, [R3,#4]
works_0 = R3            ; work *
BCC             loc_13DDC

loc_13DA6
LDR             R3, [SP,#0x34+OpenCoreNum4]
ADD.W           test_core_index, test_core_index, #1
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum4]
test_core_index = R10   ; unsigned int
OpenCoreNum4_0 = R3     ; unsigned int
B               loc_139BC

loc_13DB2
LDR             R3, [SP,#0x34+OpenCoreNum3]
LSLS            R0, R3, #0x1F
BPL             loc_13EA6
LDR             R0, [SP,#0x34+var_2C]
ADD.W           R3, test_core_index, #0x20000
LDR             R2, [R5]
ADDS            R3, #0x2A ; '*'
LDR.W           R1, [R8,#configuration.pattern_number]
ADD.W           R3, R0, R3,LSL#2
CMP             R2, R1
LDR             R3, [R3,#4]
works_0 = R3            ; work *
BCC             loc_13E68

loc_13DD0
LDR             R3, [SP,#0x34+OpenCoreNum3]
ADD.W           test_core_index, test_core_index, #1
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum3]
test_core_index = R10   ; unsigned int
OpenCoreNum3_0 = R3     ; unsigned int
B               loc_139BC

loc_13DDC
works_0 = R3            ; work *
MOV             R1, which_core
LDR             R0, [SP,#0x34+format] ; format
STR             works_0, [SP,#0x34+works]
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R3, [SP,#0x34+works]
CBZ             R2, loc_13E10
LDR             R2, [SP,#0x34+var_24]
ADDS            R7, R3, R2
MOVS            R3, #0
MOV             R11, R3

loc_13DF6
which_pattern = R11     ; unsigned int
LDR             R3, [R7,#0x34]
ADDS            R7, #0x44 ; 'D'
CBNZ            R3, loc_13E04
MOV             R1, which_pattern
LDR             R0, [SP,#0x34+var_34] ; format
BLX             printf

loc_13E04
LDR.W           R3, [R8,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R3, which_pattern
BHI             loc_13DF6

loc_13E10               ; c
MOVS            R0, #0xA
MOVS            R7, #2
BLX             putchar
B               loc_13DA6

loc_13E1A
LDR             R3, [SP,#0x34+OpenCoreNum4]
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum4]
OpenCoreNum4_0 = R3     ; unsigned int
B               loc_139BC

loc_13E22
works_0 = R3            ; work *
MOV             R1, which_core
LDR             R0, [SP,#0x34+format] ; format
STR             works_0, [SP,#0x34+works]
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R3, [SP,#0x34+works]
CBZ             R2, loc_13E56
LDR             R2, [SP,#0x34+var_24]
ADDS            R7, R3, R2
MOVS            R3, #0
MOV             R11, R3

loc_13E3C
which_pattern = R11     ; unsigned int
LDR             R3, [R7,#0x34]
ADDS            R7, #0x44 ; 'D'
CBNZ            R3, loc_13E4A
MOV             R1, which_pattern
LDR             R0, [SP,#0x34+var_34] ; format
BLX             printf

loc_13E4A
LDR.W           R3, [R8,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R3, which_pattern
BHI             loc_13E3C

loc_13E56               ; c
MOVS            R0, #0xA
MOVS            R7, #2
BLX             putchar
B               loc_13C9C

loc_13E60
LDR             R3, [SP,#0x34+OpenCoreNum7]
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum7]
OpenCoreNum7_0 = R3     ; unsigned int
B               loc_139BC

loc_13E68
works_0 = R3            ; work *
MOV             R1, which_core
LDR             R0, [SP,#0x34+format] ; format
STR             works_0, [SP,#0x34+works]
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R3, [SP,#0x34+works]
CBZ             R2, loc_13E9C
LDR             R2, [SP,#0x34+var_24]
ADDS            R7, R3, R2
MOVS            R3, #0
MOV             R11, R3

loc_13E82
which_pattern = R11     ; unsigned int
LDR             R3, [R7,#0x34]
ADDS            R7, #0x44 ; 'D'
CBNZ            R3, loc_13E90
MOV             R1, which_pattern
LDR             R0, [SP,#0x34+var_34] ; format
BLX             printf

loc_13E90
LDR.W           R3, [R8,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R3, which_pattern
BHI             loc_13E82

loc_13E9C               ; c
MOVS            R0, #0xA
MOVS            R7, #2
BLX             putchar
B               loc_13DD0

loc_13EA6
LDR             R3, [SP,#0x34+OpenCoreNum3]
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum3]
OpenCoreNum3_0 = R3     ; unsigned int
B               loc_139BC
; End of function single_BM1391_get_result

ALIGN 0x10



; void __fastcall single_BM1391_print_lcd(unsigned __int8 which_chain, unsigned int result)
EXPORT single_BM1391_print_lcd
single_BM1391_print_lcd

lcd_display_buf= -0x14

which_chain = R0        ; unsigned __int8
result = R1             ; unsigned int
LDR             R3, =dword_2A534
PUSH            {R4,R5,LR}
MOV             R5, result
SUB             SP, SP, #0x14
MOV             R4, SP
LDR             which_chain, [R3]
LDR             result, [R3,#(dword_2A538 - 0x2A534)]
result = R5             ; unsigned int
LDR             R2, [R3,#(dword_2A53C - 0x2A534)]
LDR             R3, [R3,#(dword_2A540 - 0x2A534)]
STM             R4!, {R0-R3}
BL              display_level_result_on_lcd
MOVW            R2, #:lower16:gChain
MOVW            R3, #:lower16:gHw_Nonce_Num
MOVT            R2, #:upper16:gChain
MOVT            R3, #:upper16:gHw_Nonce_Num
LDRB            R2, [R2]
MOV             R1, #(aT1DT2D+0xC) ; format
ADD.W           R0, SP, #0x14+lcd_display_buf+0xA ; s
LDR.W           R2, [R3,R2,LSL#2]
BLX             sprintf
MOV             R1, SP  ; buf
MOVS            R2, #0x10 ; size
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
LSLS            R2, result, #0x1F
MOV.W           R0, #2  ; line
ITETE MI
MOVWMI          R1, #0x9D64
MOVWPL          R1, #0x9D78
MOVTMI          R1, #2
MOVTPL          R1, #2  ; buf
ITE MI
MOVMI           R2, #0x10
MOVPL           R2, #0x10 ; size
BL              write_lcd_no_memset
LSLS            R3, result, #0x1E
MOV.W           R0, #3  ; line
ITETT MI
MOVWMI          R1, #0xAB24
MOVWPL          R1, #0xAB38
MOVMI           R2, #0x10
MOVTMI          R1, #2
ITT PL
MOVPL           R2, #0x10 ; size
MOVTPL          R1, #2  ; buf
BL              write_lcd_no_memset
ADD             SP, SP, #0x14
POP             {R4,result,PC}
; End of function single_BM1391_print_lcd

off_13F40 DCD dword_2A534



; void __fastcall BM1391_soft_reset_sensor(unsigned __int8 which_chain)
EXPORT BM1391_soft_reset_sensor
BM1391_soft_reset_sensor

mode= -0x14
var_8= -8

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
MOVW            R10, #:lower16:Conf
MOVW            R9, #:lower16:read_loop
MOVW            R11, #:lower16:gBM1391_MISC_CONTROL_reg
MOV             R8, which_chain
MOVT            R10, #:upper16:Conf
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
MOVT            R9, #:upper16:read_loop
MOVS            R7, #0
SUB             SP, SP, #0x14
MOVT            R11, #:upper16:gBM1391_MISC_CONTROL_reg
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             R1, =__FUNCTION__.8451 ; "BM1391_soft_reset_sensor"
BLX             printf
STR.W           R11, [SP,#0x14+var_8]

loc_13F78
i = R7                  ; unsigned int
CMP             i, #0
BEQ             loc_14072
CMP             i, #1
IT EQ
LDREQ.W         R5, [R10,#configuration.TempSensor2]
BEQ             loc_13F92
CMP             i, #2
ITE EQ
LDREQ.W         R5, [R10,#configuration.TempSensor3]
LDRNE.W         R5, [R10,#configuration.TempSensor4]

loc_13F92
CBNZ            R5, loc_13FAC

loc_13F94
ADDS            R7, #1
i = R7                  ; unsigned int
CMP             i, #4
BNE             loc_13F78
MOV             R0, #(gAsic_Core_Nonce_Num+0x1859C) ; useconds
ADD             SP, SP, #0x14
POP.W           {R4-R11,LR}
B.W             j_usleep

loc_13FAC
MOVW            R6, #:lower16:gChain_Asic_Interval
LDR             R3, [SP,#0x14+var_8]
MOVT            R6, #:upper16:gChain_Asic_Interval
SUBS            R5, #1
LDR             R1, [R6]
UXTB            R5, R5
LDR             R3, [R3]
MOV.W           R11, #0
MOV             R0, R8  ; which_chain
MOVS            R2, #0x18 ; reg_addr
STR.W           R11, [SP,#0x14+mode] ; mode
MOV             R4, R11
SMULBB          R1, R1, R5
ORR.W           R3, R3, #0x4000
ORR.W           R3, R3, #0x30 ; '0' ; reg_data
UXTB            R1, R1  ; asic_addr
BL              BM1391_set_config
LDR             R1, [R6]
MOV             R3, R11 ; mode
MOVS            R2, #0x18 ; reg
MOV             R0, R8  ; which_chain
SMULBB          R1, R1, R5
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
B               loc_13FFA

loc_13FF2
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
LDR.W           R3, [R9]
CMP             read_temperature_time, R3
BCS             loc_14054

loc_13FFA
LDR             R1, [R6]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R8  ; which_chain
ADDS            read_temperature_time, #1
SMULBB          R1, R1, R5
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
ANDS.W          R1, ret, #0xC0000000
BNE             loc_13FF2
STR             R1, [SP,#0x14+mode] ; mode
MOV             R4, R1
LDRH            R1, [R6]
MOVS            R3, #0x10006 ; reg_data
MOVS            R2, #0x1C ; reg_addr
MOV             ret, R8 ; which_chain
SMULBB          R1, R1, R5
UXTB            R1, R1  ; asic_addr
BL              BM1391_set_config
B               loc_14038

loc_14030
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
LDR.W           R3, [R9]
CMP             read_temperature_time, R3
BCS             loc_13F94

loc_14038
LDR             R1, [R6]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R8  ; which_chain
ADDS            read_temperature_time, #1
SMULBB          R1, R1, R5
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_14030
B               loc_13F94

loc_14054
MOVW            R3, #:lower16:gNotReadOutTemp
MOV             R2, ret
MOVT            R3, #:upper16:gNotReadOutTemp
MOVS            R1, #1
MOVW            ret, #:lower16:aSCanTReadOutGe ; "%s: Can't read out GENERAL_I2C_COMMAND."...
ret = R2                ; unsigned int
STRB            R1, [R3]
MOVT            R0, #:upper16:aSCanTReadOutGe ; "%s: Can't read out GENERAL_I2C_COMMAND."...
LDR             R1, =__FUNCTION__.8451 ; "BM1391_soft_reset_sensor"
BLX             printf
B               loc_13F94

loc_14072
LDR.W           R5, [R10,#configuration.TempSensor1]
which_sensor = R5       ; unsigned int
B               loc_13F92
; End of function BM1391_soft_reset_sensor

off_14078 DCD __FUNCTION__.8451 ; "BM1391_soft_reset_sensor"



; void __fastcall BM1391_enable_extended_mode_of_temperature_sensor(unsigned __int8 which_chain)
EXPORT BM1391_enable_extended_mode_of_temperature_sensor
BM1391_enable_extended_mode_of_temperature_sensor

mode= -0x1C
var_14= -0x14
var_10= -0x10
var_C= -0xC
var_8= -8

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
MOVW            R1, #0xFCFF
MOVW            R10, #:lower16:Conf
MOVW            R6, #:lower16:gChain_Asic_Interval
MOVW            R8, #:lower16:read_loop
SUB             SP, SP, #0x1C
MOVT            R1, #0xFEFE
MOVW            R3, #:lower16:gBM1391_MISC_CONTROL_reg
MOVW            R2, #0x904
MOV             R7, which_chain
MOVT            R10, #:upper16:Conf
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
MOVT            R6, #:upper16:gChain_Asic_Interval
MOVT            R8, #:upper16:read_loop
MOV.W           R9, #0
MOVT            R3, #:upper16:gBM1391_MISC_CONTROL_reg
MOVT            R2, #0x101
STR             R1, [SP,#0x1C+var_C]
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             R1, =__FUNCTION__.8467 ; "BM1391_enable_extended_mode_of_temperat"...
STR             R3, [SP,#0x1C+var_14]
STR             R2, [SP,#0x1C+var_10]
BLX             printf

loc_140CC
i = R9                  ; unsigned int
CMP.W           i, #0
BEQ.W           loc_1424C
CMP.W           i, #1
IT EQ
LDREQ.W         R4, [R10,#configuration.TempSensor2]
BEQ             loc_140EE
CMP.W           i, #2
ITE EQ
LDREQ.W         R4, [R10,#configuration.TempSensor3]
LDRNE.W         R4, [R10,#configuration.TempSensor4]

loc_140EE
CBNZ            R4, loc_14100

loc_140F0
ADD.W           R9, R9, #1
i = R9                  ; unsigned int
CMP.W           i, #4
BNE             loc_140CC
ADD             SP, SP, #0x1C
POP.W           {R4-R11,PC}

loc_14100
LDR             R1, [R6]
SUBS            R4, #1
LDR             R3, [SP,#0x1C+var_14]
UXTB            R4, R4
MOV.W           R11, #0
MOV             R0, R7  ; which_chain
MOVS            R2, #0x18 ; reg_addr
LDR             R3, [R3]
SMULBB          R1, R1, R4
STR.W           R11, [SP,#0x1C+mode] ; mode
MOV             R5, R11
ORR.W           R3, R3, #0x4000
UXTB            R1, R1  ; asic_addr
ORR.W           R3, R3, #0x30 ; '0' ; reg_data
BL              BM1391_set_config
LDR             R1, [R6]
MOV             R3, R11 ; mode
MOVS            R2, #0x18 ; reg
MOV             R0, R7  ; which_chain
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
B               loc_14146

loc_1413E
ret = R0                ; unsigned int
read_temperature_time = R5; unsigned int
LDR.W           R3, [R8]
CMP             read_temperature_time, R3
BCS             loc_1422E

loc_14146
LDR             R1, [R6]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R7  ; which_chain
ADDS            read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R5; unsigned int
ANDS.W          R1, ret, #0xC0000000
BNE             loc_1413E
STR             R1, [SP,#0x1C+mode] ; mode
MOV             R5, R1
LDRH            R1, [R6]
MOV             R11, #gSensor_i2c_addr_high_4_bit
MOVS            R2, #0x1C ; reg_addr
LDR.W           R3, [R11]
MOV             ret, R7 ; which_chain
SMULBB          LR, R1, R4
LDR             R1, [SP,#0x1C+var_10]
ORRS            R3, R1  ; reg_data
UXTB.W          R1, LR  ; asic_addr
BL              BM1391_set_config
B               loc_14190

loc_14188
ret = R0                ; unsigned int
read_temperature_time = R5; unsigned int
LDR.W           R3, [R8]
CMP             read_temperature_time, R3
BCS             loc_141AA

loc_14190
LDR             R1, [R6]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R7  ; which_chain
ADDS            read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R5; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_14188

loc_141AA
MOVS            R3, #0
MOVW            ret, #0x2710 ; useconds
STR             R3, [SP,#0x1C+var_8]
BLX             usleep
LDR             R3, [SP,#0x1C+var_8]
MOVS            R2, #0x1C ; reg_addr
LDR             R1, [R6]
MOV             R0, R7  ; which_chain
LDR.W           LR, [R11]
MOV             R5, R3
STR             R3, [SP,#0x1C+mode] ; mode
LDR             R3, [SP,#0x1C+var_C]
SMULBB          R1, R1, R4
AND.W           R3, LR, R3
ORR.W           R3, R3, #0x1000000
UXTB            R1, R1  ; asic_addr
ORR.W           R3, R3, #0x300 ; reg_data
BL              BM1391_set_config
B               loc_141E8

loc_141E0
ret = R0                ; unsigned int
read_temperature_time = R5; unsigned int
LDR.W           R3, [R8]
CMP             read_temperature_time, R3
BCS             loc_14202

loc_141E8
LDR             R1, [R6]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R7  ; which_chain
ADDS            read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R5; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_141E0

loc_14202
MOVS            R3, #4
MOV             R2, ret
MOVT            R3, #0xC000
ANDS            R3, ret
CMP             R3, #4
BEQ.W           loc_140F0
MOVW            R3, #:lower16:gNotReadOutTemp
MOVS            R1, #1
MOVT            R3, #:upper16:gNotReadOutTemp
MOVW            ret, #:lower16:aSCanTSetExtend ; "\n!!! %s: Can't set extended mode. ret "...
ret = R2                ; unsigned int
STRB            R1, [R3]
MOVT            R0, #:upper16:aSCanTSetExtend ; "\n!!! %s: Can't set extended mode. ret "...
LDR             R1, =__FUNCTION__.8467 ; "BM1391_enable_extended_mode_of_temperat"...
BLX             printf
B               loc_140F0

loc_1422E
ret = R0                ; unsigned int
read_temperature_time = R5; unsigned int
MOVW            R3, #:lower16:gNotReadOutTemp
MOV             R2, ret
MOVT            R3, #:upper16:gNotReadOutTemp
MOVS            R1, #1
MOVW            ret, #:lower16:aSCanTReadOutGe_0 ; "\n!!! %s: Can't read out GENERAL_I2C_CO"...
ret = R2                ; unsigned int
STRB            R1, [R3]
MOVT            R0, #:upper16:aSCanTReadOutGe_0 ; "\n!!! %s: Can't read out GENERAL_I2C_CO"...
LDR             R1, =__FUNCTION__.8467 ; "BM1391_enable_extended_mode_of_temperat"...
BLX             printf
B               loc_140F0

loc_1424C
LDR.W           R4, [R10,#configuration.TempSensor1]
which_sensor = R4       ; unsigned int
B               loc_140EE
; End of function BM1391_enable_extended_mode_of_temperature_sensor

ALIGN 4
off_14254 DCD __FUNCTION__.8467 ; "BM1391_enable_extended_mode_of_temperat"...



; void __fastcall BM1391_get_temperature_offset_value_from_asic(unsigned __int8 which_chain)
EXPORT BM1391_get_temperature_offset_value_from_asic
BM1391_get_temperature_offset_value_from_asic

mode= -0x24
var_1C= -0x1C
local_temp= -0x18
remote_temp= -0x14
var_10= -0x10
offset_value= -0xC

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
MOVW            R1, #:lower16:gBM1391_MISC_CONTROL_reg
MOVW            R7, #:lower16:read_loop
SUB             SP, SP, #0x24
MOVT            R1, #:upper16:gBM1391_MISC_CONTROL_reg
MOVW            R11, #:lower16:Conf
MOV             R6, which_chain
MOVT            R7, #:upper16:read_loop
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
MOVS            R3, #0
STR             R1, [SP,#0x24+var_10]
MOVT            R11, #:upper16:Conf
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             R1, =__FUNCTION__.8489 ; "BM1391_get_temperature_offset_value_fro"...
STR             R3, [SP,#0x24+remote_temp]
MOV             R9, R3
STR             R3, [SP,#0x24+local_temp]
STR             R3, [SP,#0x24+offset_value]
STR             R3, [SP,#0x24+offset_value+4]
BLX             printf
STR.W           R11, [SP,#0x24+var_1C]

loc_14298
i = R9                  ; unsigned int
LDR             R3, [SP,#0x24+var_1C]
CMP.W           i, #0
BEQ.W           loc_14530
CMP.W           i, #1
ITE EQ
LDREQ.W         R11, [R3,#configuration.TempSensor2]
LDRNE.W         R11, [R3,#configuration.TempSensor3]

loc_142B0
CMP.W           R11, #0
BNE             loc_1434C

loc_142B6
ADD.W           R9, R9, #1
i = R9                  ; unsigned int
CMP.W           i, #3
BNE             loc_14298
LDR.W           R11, [SP,#0x24+var_1C]
MOVS            R2, #0
MOVW            R6, #:lower16:(aSOffsetValueDD+4) ; "offset_value[%d] = %d\n"
MOVS            R0, #0xA ; c
MOV             R4, R2
MOVT            R6, #:upper16:(aSOffsetValueDD+4) ; "offset_value[%d] = %d\n"
LDR.W           R3, [R11,#configuration.sensor_model]
ADD.W           R5, SP, #0x24+var_10+3
STRB.W          R2, [SP,#0x24+offset_value+7]
ORR.W           R3, R3, #0x20 ; ' '
STRB.W          R3, [SP,#0x24+offset_value+6]
BLX             putchar

loc_142EA
i = R4                  ; unsigned int
MOV             R1, i
LDRB.W          R2, [R5,#1]!
MOV             R0, R6  ; format
ADDS            i, #1
i = R1                  ; unsigned int
BLX             printf
i = R4                  ; unsigned int
CMP             i, #8
BNE             loc_142EA
MOV             R3, #pattern_test_time
LDRB            R3, [R3]
CBNZ            R3, loc_14346
LDR.W           R3, [R11,#configuration.AsicNum]
CMP             R3, #1
BEQ             loc_14346
MOV             R3, #gHashBoard_BHB91601P
LDRB            R3, [R3]
CBNZ            R3, loc_1432C
MOV             R3, #gHashBoard_BHB91601S
LDRB            R3, [R3]
CMP             R3, #0
BEQ.W           loc_14510

loc_1432C
MOVW            R1, #:lower16:gChain
MOVW            R3, #:lower16:gI2c
MOVT            R1, #:upper16:gChain
MOVT            R3, #:upper16:gI2c
ADD             R2, SP, #0x24+offset_value ; offset_value
LDRB            R1, [R1] ; which_chain
LDRB            R0, [R3] ; which_iic
BL              AT24C02_save_offset_value

loc_14346
ADD             SP, SP, #0x24 ; '$'
POP.W           {i-R11,PC}

loc_1434C
MOVW            R5, #:lower16:gChain_Asic_Interval
LDR             R3, [SP,#0x24+var_10]
MOVT            R5, #:upper16:gChain_Asic_Interval
ADD.W           R4, R11, #0xFFFFFFFF
LDR             R1, [R5]
UXTB            R4, R4
LDR             R3, [R3]
MOV.W           R10, #0
MOV             R0, R6  ; which_chain
MOVS            R2, #0x18 ; reg_addr
STR.W           R10, [SP,#0x24+mode] ; mode
MOV             R8, R10
SMULBB          R1, R1, R4
ORR.W           R3, R3, #0x4000
ORR.W           R3, R3, #0x30 ; '0' ; reg_data
UXTB            R1, R1  ; asic_addr
BL              BM1391_set_config
LDR             R1, [R5]
MOV             R3, R10 ; mode
MOVS            R2, #0x18 ; reg
MOV             R0, R6  ; which_chain
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
B               loc_1439A

loc_14394
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS             loc_143B6

loc_1439A
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_14394

loc_143B6
LDR             R1, [R5]
MOV             R8, #gSensor_i2c_addr_high_4_bit
MOVS            R2, #0
LDR.W           R3, [R8]
MOV             R10, R2
STR             R2, [SP,#0x24+mode] ; mode
MOV             ret, R6 ; which_chain
SMULBB          R1, R1, R4
MOVS            R2, #0x1C ; reg_addr
BIC.W           R3, R3, #0x1000100
BIC.W           R3, R3, #0x10000
ORR.W           R3, R3, #0x1000100 ; reg_data
UXTB            R1, R1  ; asic_addr
BL              BM1391_set_config
B               loc_143EE

loc_143E6
ret = R0                ; unsigned int
read_temperature_time = R10; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS.W           loc_144F0

loc_143EE
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R10; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_143E6
UXTB            R2, ret
MOVW            ret, #:lower16:aAsicTemperatur ; "\nASIC temperature is %d\n"
MOVW            R10, #:lower16:gNotReadOutTemp
SUB.W           R3, R2, #0x40 ; '@'
MOVT            R0, #:upper16:aAsicTemperatur ; "\nASIC temperature is %d\n"
MOV             R1, R3
STR             R3, [SP,#0x24+remote_temp]
remote_temp_0 = R1      ; int
MOVT            R10, #:upper16:gNotReadOutTemp
BLX             printf

loc_14428
LDR             R1, [R5]
MOVS            R2, #0
LDR.W           R3, [R8]
MOV             R0, R6  ; which_chain
MOV             R8, R2
STR             R2, [SP,#0x24+mode] ; mode
MOVS            R2, #0x1C ; reg_addr
SMULBB          R1, R1, R4
BIC.W           R3, R3, #0x1000000
BIC.W           R3, R3, #0x10000
ORR.W           R3, R3, #0x1000000 ; reg_data
UXTB            R1, R1  ; asic_addr
BL              BM1391_set_config
B               loc_14456

loc_14450
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS             loc_144D8

loc_14456
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_14450
UXTB            R2, ret
MOV             R0, #aPcbTemperature ; "\nPCB temperature is %d\n"
SUB.W           R3, R2, #0x40 ; '@'
MOV             R1, R3
STR             R3, [SP,#0x24+local_temp]
local_temp_0 = R1       ; int
BLX             printf

loc_14488
LDRB.W          R3, [R10]
CBNZ            R3, loc_144D0
LDR             R2, [SP,#0x24+remote_temp]
LDR             R3, [SP,#0x24+local_temp]
SUBS            R3, R3, R2
UXTB            R3, R3
temp_offset_value = R3  ; char
SXTB            R2, temp_offset_value
MOV             R1, R2

loc_1449A
CMP.W           R9, #0
BEQ             loc_14536
CMP.W           R9, #1
BEQ             loc_14554
LDR             R0, =cgpu.T3_offset_value
MOV             R4, #gT3_offset_value
STRB.W          R11, [SP,#0x24+offset_value+4]
STRB            R2, [R4]
LDRB            R2, [R0]
ADD             temp_offset_value, R2
UXTB            R3, R3
STRB            R3, [R0]
STRB.W          R3, [SP,#0x24+offset_value+5]

loc_144C2
MOV             R0, #aTempOffsetValu ; "\ntemp_offset_value = %d\n"
BLX             printf
B               loc_142B6

loc_144D0
MOVS            R1, #0
MOV             R2, R1
MOV             R3, R1
B               loc_1449A

loc_144D8
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
MOV             R2, ret
MOVW            ret, #:lower16:aSCanTReadOutHa ; "%s: Can't read out HASH BOARD TEMP. ret"...
ret = R2                ; unsigned int
MOVS            R3, #1
LDR             R1, =__FUNCTION__.8489 ; "BM1391_get_temperature_offset_value_fro"...
MOVT            R0, #:upper16:aSCanTReadOutHa ; "%s: Can't read out HASH BOARD TEMP. ret"...
STRB.W          R3, [R10]
BLX             printf
B               loc_14488

loc_144F0
ret = R0                ; unsigned int
read_temperature_time = R10; unsigned int
MOV             R2, ret
MOVW            R10, #:lower16:gNotReadOutTemp
MOVW            ret, #:lower16:aSCanTReadOutAs ; "%s: Can't read out ASIC TEMP. ret = 0x%"...
ret = R2                ; unsigned int
MOVT            R10, #:upper16:gNotReadOutTemp
MOVS            R3, #1
LDR             R1, =__FUNCTION__.8489 ; "BM1391_get_temperature_offset_value_fro"...
MOVT            R0, #:upper16:aSCanTReadOutAs ; "%s: Can't read out ASIC TEMP. ret = 0x%"...
STRB.W          R3, [R10]
BLX             printf
B               loc_14428

loc_14510
i = R4                  ; unsigned int
MOVW            R1, #:lower16:gChain
MOV             R3, #gI2c
MOVT            R1, #:upper16:gChain
ADD             R2, SP, #0x24+offset_value ; value
LDRB            R1, [R1] ; which_chain
LDRB            R0, [R3] ; which_i2c
BL              set_temperature_offset_value
ADD             SP, SP, #0x24 ; '$'
POP.W           {i-R11,PC}

loc_14530
LDR.W           R11, [R3,#configuration.TempSensor1]
which_sensor = R11      ; unsigned int
B               loc_142B0

loc_14536
temp_offset_value = R3  ; char
LDR             R0, =cgpu.T1_offset_value
MOV             R4, #gT1_offset_value
STRB.W          R11, [SP,#0x24+offset_value]
STRB            R2, [R4]
LDRB            R2, [R0]
ADD             temp_offset_value, R2
UXTB            R3, R3
STRB            R3, [R0]
STRB.W          R3, [SP,#0x24+offset_value+1]
B               loc_144C2

loc_14554
temp_offset_value = R3  ; char
LDR             R0, =cgpu.T2_offset_value
MOV             R4, #gT2_offset_value
STRB.W          R11, [SP,#0x24+offset_value+2]
STRB            R2, [R4]
LDRB            R2, [R0]
ADD             temp_offset_value, R2
UXTB            R3, R3
STRB            R3, [R0]
STRB.W          R3, [SP,#0x24+offset_value+3]
B               loc_144C2
; End of function BM1391_get_temperature_offset_value_from_asic

ALIGN 4
off_14574 DCD __FUNCTION__.8489 ; "BM1391_get_temperature_offset_value_fro"...
off_14578 DCD cgpu.T3_offset_value
off_1457C DCD cgpu.T1_offset_value
off_14580 DCD cgpu.T2_offset_value



; void __fastcall BM1391_set_default_temperature_offset_value(unsigned __int8 which_chain)
EXPORT BM1391_set_default_temperature_offset_value
BM1391_set_default_temperature_offset_value

mode= -0x24
which_sensor= -0x1C
var_18= -0x18
var_14= -0x14
var_10= -0x10
var_C= -0xC
temp= -8

which_chain = R0        ; unsigned __int8
MOVW            R3, #:lower16:Conf
PUSH.W          {R4-R11,LR}
MOV             R4, R3
MOV             R6, which_chain
MOVW            R3, #:lower16:gT3_offset_value
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
SUB             SP, SP, #0x24
MOV             R5, R3
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
MOV.W           R3, #0x1100
LDR             R1, =__FUNCTION__.8513 ; "BM1391_set_default_temperature_offset_v"...
MOVW            R7, #:lower16:read_loop
STR             R3, [SP,#0x24+var_18]
MOVW            R10, #0xEEFF
BLX             printf
LDR             R3, [SP,#0x24+var_18]
MOV             R2, R4
MOVT            R2, #:upper16:Conf
MOVT            R7, #:upper16:read_loop
STR             R2, [SP,#0x24+var_C]
MOV.W           R11, #1
MOV             R2, R5
MOV.W           R9, #0
MOVT            R2, #:upper16:gT3_offset_value
MOVT            R3, #0x101
MOVT            R10, #0xFEFE
STR.W           R9, [SP,#0x24+var_14]
STR.W           R9, [SP,#0x24+which_sensor]
STR             R2, [SP,#0x24+temp]
STR             R3, [SP,#0x24+var_18]
STR.W           R10, [SP,#0x24+var_10]

loc_145E8
i = R9                  ; unsigned int
CMP.W           i, #0
BEQ.W           loc_14756
CMP.W           i, #1
BEQ.W           loc_147A8
CMP.W           i, #2
IT NE
MOVNE.W         R10, #0
BEQ.W           loc_14782

loc_14606
data = R10              ; unsigned int
LDR             R3, [SP,#0x24+which_sensor]
CBNZ            R3, loc_14620

loc_1460A
i = R11                 ; unsigned int
CMP.W           i, #3
BEQ             loc_1461A

loc_14610
ADD.W           R9, R9, #1
ADD.W           i, i, #1
B               loc_145E8

loc_1461A
i = R11                 ; unsigned int
ADD             SP, SP, #0x24 ; '$'
POP.W           {R4-i,PC}

loc_14620
MOVW            R5, #:lower16:gChain_Asic_Interval
SUBS            R4, R3, #1
MOVT            R5, #:upper16:gChain_Asic_Interval
MOVW            R3, #:lower16:gBM1391_MISC_CONTROL_reg
LDR             R1, [R5]
UXTB            R4, R4
MOVT            R3, #:upper16:gBM1391_MISC_CONTROL_reg
LDR             R3, [R3]
MOVS            R2, #0
STR             R2, [SP,#0x24+mode] ; mode
MOV             R0, R6  ; which_chain
SMULBB          R1, R1, R4
MOVS            R2, #0x18 ; reg_addr
ORR.W           R3, R3, #0x4000
ORR.W           R3, R3, #0x30 ; '0' ; reg_data
MOV.W           R8, #0
UXTB            R1, R1  ; asic_addr
BL              BM1391_set_config
LDR             R1, [R5]
MOV             R3, R8  ; mode
MOVS            R2, #0x18 ; reg
MOV             R0, R6  ; which_chain
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
B               loc_14670

loc_1466A
read_temperature_time = R8; unsigned int
ret = R0                ; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS             loc_1468C

loc_14670
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
read_temperature_time = R8; unsigned int
ret = R0                ; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_1466A

loc_1468C
LDR             R1, [R5]
MOVS            R2, #0
MOV             R8, R2
STR             R2, [SP,#0x24+mode] ; mode
MOV             R3, data ; reg_data
MOVS            R2, #0x1C ; reg_addr
MOV             ret, R6 ; which_chain
SMULBB          R1, R1, R4
UXTB            R1, R1  ; asic_addr
BL              BM1391_set_config
B               loc_146AC

loc_146A6
read_temperature_time = R8; unsigned int
ret = R0                ; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS             loc_146C8

loc_146AC
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
read_temperature_time = R8; unsigned int
ret = R0                ; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_146A6

loc_146C8
LDR             R1, [R5]
MOV             R3, #gSensor_i2c_addr_high_4_bit
MOVS            R2, #0
LDR             R3, [R3]
MOV             R8, R2
STR             R2, [SP,#0x24+mode] ; mode
MOV             ret, R6 ; which_chain
SMULBB          LR, R1, R4
LDR             R1, [SP,#0x24+var_10]
MOVS            R2, #0x1C ; reg_addr
ANDS            R3, R1
UXTB.W          R1, LR  ; asic_addr
ORR.W           R3, R3, #0x1000000
ORR.W           R3, R3, #0x1100 ; reg_data
BL              BM1391_set_config
B               loc_146FE

loc_146F8
read_temperature_time = R8; unsigned int
ret = R0                ; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS             loc_1471A

loc_146FE
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
read_temperature_time = R8; unsigned int
ret = R0                ; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_146F8

loc_1471A
offset = R0             ; char
LDR             R3, [SP,#0x24+var_14]
SXTB            offset, offset
CMP             R3, offset
BEQ.W           loc_1460A
CMP.W           R9, #0
BEQ             loc_147E2
CMP.W           R9, #1
BEQ             loc_147C8
CMP.W           R9, #2
BNE.W           loc_1460A
MOVW            R3, #:lower16:Sensor3_OK
MOVS            R2, #0
MOVT            R3, #:upper16:Sensor3_OK
MOV             R0, #aSensor3IsError ; "!!! sensor3 is error!\n"
STRB            R2, [R3]
ADD             SP, SP, #0x24 ; '$'
POP.W           {R4-R11,LR}
B.W             j_puts

loc_14756
LDR             R1, [SP,#0x24+var_C]
MOVW            R3, #:lower16:gSensor_i2c_addr_high_4_bit
MOVW            R2, #:lower16:gT1_offset_value
MOVT            R3, #:upper16:gSensor_i2c_addr_high_4_bit
MOVT            R2, #:upper16:gT1_offset_value
LDR             R3, [R3]
LDR.W           R1, [R1,#configuration.TempSensor1]
LDRSB.W         R2, [R2]
STR             R2, [SP,#0x24+var_14]

loc_14774
which_sensor_0 = R1     ; unsigned int
STR             which_sensor_0, [SP,#0x24+which_sensor]
UXTB            R2, R2
data = R2               ; unsigned int
LDR             which_sensor_0, [SP,#0x24+var_18]
ORRS            R3, R1
ORR.W           R10, R3, data
data = R10              ; unsigned int
B               loc_14606

loc_14782
i = R9                  ; unsigned int
LDR             R1, [SP,#0x24+var_C]
MOVW            R3, #:lower16:gSensor_i2c_addr_high_4_bit
LDR             R2, [SP,#0x24+temp]
MOVT            R3, #:upper16:gSensor_i2c_addr_high_4_bit
LDR             R3, [R3]
LDR.W           R1, [R1,#configuration.TempSensor3]
LDRSB.W         R2, [R2]
STR             R1, [SP,#0x24+which_sensor]
LDR             R1, [SP,#0x24+var_18]
STR             R2, [SP,#0x24+var_14]
UXTB            R2, R2
data = R2               ; unsigned int
ORRS            R3, R1
ORR.W           R10, R3, data
data = R10              ; unsigned int
B               loc_14606

loc_147A8
MOVW            R2, #:lower16:gT2_offset_value
LDR             R1, [SP,#0x24+var_C]
MOVT            R2, #:upper16:gT2_offset_value
MOVW            R3, #:lower16:gSensor_i2c_addr_high_4_bit
LDRSB.W         R2, [R2]
MOVT            R3, #:upper16:gSensor_i2c_addr_high_4_bit
LDR             R3, [R3]
LDR.W           R1, [R1,#configuration.TempSensor2]
STR             R2, [SP,#0x24+var_14]
B               loc_14774

loc_147C8
data = R10              ; unsigned int
offset = R0             ; char
MOVW            R3, #:lower16:Sensor2_OK
MOVW            offset, #:lower16:aSensor2IsError ; "!!! sensor2 is error!\n"
MOVT            R3, #:upper16:Sensor2_OK
MOVS            R2, #0
MOVT            R0, #:upper16:aSensor2IsError ; "!!! sensor2 is error!\n"
STRB            R2, [R3]
BLX             puts
i = R11                 ; unsigned int
B               loc_14610

loc_147E2
offset = R0             ; char
MOVW            R3, #:lower16:Sensor1_OK
MOVW            offset, #:lower16:aSensor1IsError ; "!!! sensor1 is error!\n"
MOVT            R3, #:upper16:Sensor1_OK
MOVT            R0, #:upper16:aSensor1IsError ; "!!! sensor1 is error!\n"
STRB.W          R9, [R3]
BLX             puts
B               loc_1460A
; End of function BM1391_set_default_temperature_offset_value

off_147FC DCD __FUNCTION__.8513 ; "BM1391_set_default_temperature_offset_v"...



; void __fastcall BM1391_read_asic_temperature_local_remote(unsigned __int8 which_chain)
EXPORT BM1391_read_asic_temperature_local_remote
BM1391_read_asic_temperature_local_remote

mode= -0x2C
var_20= -0x20
var_1C= -0x1C
var_18= -0x18
remote_temp= -0x14
var_10= -0x10
var_C= -0xC
var_8= -8

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
MOVS            R3, #0
LDR.W           R10, =(gSensor_OK+0xC)
SUB             SP, SP, #0x2C
MOVW            R7, #:lower16:read_loop
MOVW            R2, #:lower16:Conf
STR             R3, [SP,#0x2C+remote_temp]
MOVW            R1, #:lower16:Sensor1_temp
MOVW            R4, #:lower16:Sensor2_temp
MOVW            R5, #:lower16:Sensor3_temp
MOV             R9, R3
MOV             R6, which_chain
MOVW            R3, #:lower16:gBM1391_MISC_CONTROL_reg
MOVT            R7, #:upper16:read_loop
MOVT            R2, #:upper16:Conf
MOVT            R1, #:upper16:Sensor1_temp
MOVT            R4, #:upper16:Sensor2_temp
MOVT            R5, #:upper16:Sensor3_temp
MOVT            R3, #:upper16:gBM1391_MISC_CONTROL_reg
STR             R2, [SP,#0x2C+var_18]
STR             R1, [SP,#0x2C+var_C]
STR             R4, [SP,#0x2C+var_10]
STR             R5, [SP,#0x2C+var_8]
STR             R3, [SP,#0x2C+var_1C]

loc_1484C
i = R9                  ; unsigned int
LDR             R3, [SP,#0x2C+var_18]
CMP.W           i, #0
BEQ.W           loc_14B94
CMP.W           i, #1
ITE EQ
LDREQ.W         R3, [R3,#configuration.TempSensor2]
LDRNE.W         R3, [R3,#0x12C]
STR             R3, [SP,#0x2C+var_20]

loc_14866
LDR             R3, [SP,#0x2C+var_20]
CMP             R3, #0
BNE.W           loc_1497A

loc_1486E
ADD.W           R9, R9, #1
i = R9                  ; unsigned int
ADD.W           R10, R10, #1
CMP.W           i, #3
BNE             loc_1484C
LDR             R3, [SP,#0x2C+var_C]
MOV             R7, #last_Sensor1_temp
MOVW            i, #:lower16:last_Sensor2_temp
LDR             R2, [R7]
MOVT            R9, #:upper16:last_Sensor2_temp
LDR             R4, [R3]
MOVW            R8, #:lower16:last_Sensor3_temp
LDR             R3, [SP,#0x2C+var_10]
MOVT            R8, #:upper16:last_Sensor3_temp
LDR.W           R0, [R9]
LDR             R6, [R3]
LDR             R3, [SP,#0x2C+var_8]
ADDS            R1, R4, R6
LDR             R5, [R3]
LDR.W           R3, [R8]
ADD             R1, R5
SUBS            R2, R1, R2
MOVW            R1, #:lower16:gSensor_number
SUBS            R0, R2, R0
MOVT            R1, #:upper16:gSensor_number
SUBS            R0, R0, R3
LDR             R1, [R1]
BL              __aeabi_uidiv
MOV             R3, #temp_change
STR             R0, [R3]
CBZ             R0, loc_148D8
STR             R4, [R7]
STR.W           R6, [R9]
STR.W           R5, [R8]

loc_148D8
MOV             R2, #highest_temp
LDR             R3, [R2]
CMP             R4, R3
ITT GT
MOVGT           R3, R4
STRGT           R4, [R2]
CMP             R6, R3
ITT GT
MOVGT           R3, R6
STRGT           R6, [R2]
CMP             R5, R3
ITT GT
STRGT           R5, [R2]
MOVGT           R3, R5
MOVW            R2, #:lower16:lowest_temp
CMP             R6, #0
IT NE
CMPNE           R4, R6
ITEET LE
MOVTLE          R2, #:upper16:lowest_temp
MOVTGT          R2, #0x23 ; '#'
MOVGT           R4, R6
STRLE           R4, [R2]
IT GT
STRGT           R6, [R2]
CMP             R5, #0
IT NE
CMPNE           R5, R4
IT LT
STRLT           R5, [R2]
MOV             R2, #gGlobalHighestTemp
IT LT
MOVLT           R4, R5
LDR             R1, [R2]
CMP             R1, R3
IT LT
STRLT           R3, [R2]
LDR             R2, [SP,#0x2C+var_18]
LDR.W           R2, [R2,#configuration.AlarmTemp]
CMP             R2, R3
SUB.W           R3, R3, R4
max_temp_gap = R3       ; int
ITTTT LT
MOVWLT          R2, #:lower16:gHigherThanAlarmTemp
MOVLT           R1, #1
MOVTLT          R2, #:upper16:gHigherThanAlarmTemp
STRBLT          R1, [R2]
LDR             R2, [SP,#0x2C+var_18]
LDR.W           R2, [R2,#configuration.MaxTempGap]
CMP             R2, max_temp_gap
BCS             loc_14974
MOVW            R2, #:lower16:gMaxTempGap_value
MOVW            R1, #:lower16:gHigherThanMaxTempGap
MOVT            R2, #:upper16:gMaxTempGap_value
MOVT            R1, #:upper16:gHigherThanMaxTempGap
LDR             R0, [R2]
MOVS            R4, #1
STRB            R4, [R1]
CMP             max_temp_gap, R0
BGT.W           loc_14AE2

loc_14974
ADD             SP, SP, #0x2C ; ','
POP.W           {R4-R11,PC}

loc_1497A
MOVW            R5, #:lower16:gChain_Asic_Interval
SUBS            R4, R3, #1
MOVT            R5, #:upper16:gChain_Asic_Interval
LDR             R3, [SP,#0x2C+var_1C]
LDR             R1, [R5]
UXTB            R4, R4
MOV.W           R11, #0
LDR             R3, [R3]
MOV             R0, R6  ; which_chain
MOVS            R2, #0x18 ; reg_addr
STR.W           R11, [SP,#0x2C+mode] ; mode
SMULBB          R1, R1, R4
MOV             R8, R11
ORR.W           R3, R3, #0x4000
ORR.W           R3, R3, #0x30 ; '0' ; reg_data
UXTB            R1, R1  ; asic_addr
BL              BM1391_set_config
LDR             R1, [R5]
MOV             R3, R11 ; mode
MOVS            R2, #0x18 ; reg
MOV             R0, R6  ; which_chain
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
B               loc_149C6

loc_149C0
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS             loc_149E2

loc_149C6
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_149C0

loc_149E2
LDR             R1, [R5]
MOV             R11, #gSensor_i2c_addr_high_4_bit
MOVS            R2, #0
LDR.W           R3, [R11]
MOV             R8, R2
STR             R2, [SP,#0x2C+mode] ; mode
MOV             ret, R6 ; which_chain
SMULBB          R1, R1, R4
MOVS            R2, #0x1C ; reg_addr
BIC.W           R3, R3, #0x1000100
BIC.W           R3, R3, #0x10000
ORR.W           R3, R3, #0x1000100 ; reg_data
UXTB            R1, R1  ; asic_addr
BL              BM1391_set_config
B               loc_14A1A

loc_14A12
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS.W           loc_14B1C

loc_14A1A
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_14A12
UXTB            R3, ret
MOV             R0, #aAsicDTempIsD ; "\nASIC %d TEMP is : %d\n"
LDR             R1, [SP,#0x2C+var_20]
SUBS            R3, #0x40 ; '@'
MOV             R2, R3
STR             R3, [SP,#0x2C+remote_temp]
remote_temp_0 = R2      ; int
BLX             printf
CMP.W           R9, #0
BEQ.W           loc_14B9C
CMP.W           R9, #1
ITE EQ
LDREQ           R3, [SP,#0x2C+var_10]
LDRNE           R3, [SP,#0x2C+var_8]
MOV             R2, R3
LDR             R3, [SP,#0x2C+remote_temp]
STR             R3, [R2]

loc_14A64
LDR             R3, [SP,#0x2C+var_18]
LDR             R2, [SP,#0x2C+var_20]
LDR.W           R3, [R3,#configuration.StartSensor]
CMP             R2, R3
BEQ             loc_14B40

loc_14A70
LDR             R1, [R5]
MOVS            R2, #0
LDR.W           R3, [R11]
MOV             R8, R2
STR             R2, [SP,#0x2C+mode] ; mode
MOV             R0, R6  ; which_chain
MOVS            R2, #0x1C ; reg_addr
SMULBB          R1, R1, R4
BIC.W           R3, R3, #0x1000000
BIC.W           R3, R3, #0x10000
ORR.W           R3, R3, #0x1000000 ; reg_data
UXTB            R1, R1  ; asic_addr
BL              BM1391_set_config
B               loc_14A9E

loc_14A98
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS             loc_14AF8

loc_14A9E
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_14A98
UXTB            R4, ret
MOVW            ret, #:lower16:aAsicDHashBoard ; "\nASIC %d Hash Board temperature is %d"...
LDR             R1, [SP,#0x2C+var_20]
MOVT            R0, #:upper16:aAsicDHashBoard ; "\nASIC %d Hash Board temperature is %d"...
SUBS            R4, #0x40 ; '@'
local_temp = R4         ; int
MOV             R2, local_temp
BLX             printf
LDR             R3, [SP,#0x2C+remote_temp]
MOV             R0, #aTempOffsetValu_0 ; "temp_offset_value = %d\n\n"
SUBS            R1, local_temp, R3
SXTB            R1, R1
BLX             printf
B               loc_1486E

loc_14AE2
max_temp_gap = R3       ; int
MOVW            R0, #:lower16:aGmaxtempgapVal ; "gMaxTempGap_value is %d\n\n"
MOV             R1, max_temp_gap
MOVT            R0, #:upper16:aGmaxtempgapVal ; "gMaxTempGap_value is %d\n\n"
STR             max_temp_gap, [R2]
ADD             SP, SP, #0x2C ; ','
POP.W           {R4-R11,LR}
B.W             j_printf

loc_14AF8
ret = R0                ; unsigned int
MOVW            ret, #:lower16:aSDoNotReadOutA ; "\n!!! %s: do not read out ASIC %d Hash "...
LDR             R2, [SP,#0x2C+var_20]
LDR             R1, =__FUNCTION__.8539 ; "BM1391_read_asic_temperature_local_remo"...
MOVT            R0, #:upper16:aSDoNotReadOutA ; "\n!!! %s: do not read out ASIC %d Hash "...
BLX             printf
MOVW            R3, #:lower16:gNotReadOutTemp
MOVS            R1, #1
MOVT            R3, #:upper16:gNotReadOutTemp
MOVS            R2, #0
STRB            R1, [R3]
STRB.W          R2, [R10]
B               loc_1486E

loc_14B1C
ret = R0                ; unsigned int
MOVW            ret, #:lower16:aSDoNotReadOutA_0 ; "\n!!! %s: do not read out ASIC %d tempe"...
LDR             R2, [SP,#0x2C+var_20]
LDR             R1, =__FUNCTION__.8539 ; "BM1391_read_asic_temperature_local_remo"...
MOVT            R0, #:upper16:aSDoNotReadOutA_0 ; "\n!!! %s: do not read out ASIC %d tempe"...
BLX             printf
MOVW            R3, #:lower16:gNotReadOutTemp
MOVS            R1, #1
MOVT            R3, #:upper16:gNotReadOutTemp
MOVS            R2, #0
STRB            R1, [R3]
STRB.W          R2, [R10]
B               loc_14A70

loc_14B40
LDR             R3, [SP,#0x2C+var_18]
LDR             R2, [SP,#0x2C+remote_temp]
LDR.W           R3, [R3,#configuration.StartTemp]
CMP             R2, R3
BLT             loc_14B62
MOV             R8, #gStartTest
LDRB.W          R3, [R8]
CBZ             R3, loc_14B84

loc_14B5A
MOVS            R3, #1
STRB.W          R3, [R8]
B               loc_14A70

loc_14B62
MOV             R2, #gStartTest
LDRB            R2, [R2]
CMP             R2, #0
BNE.W           loc_14A70
MOVW            R0, #:lower16:aAsicDTemperatu ; "\nASIC %d temperature is %d, waiting it"...
LDR             R2, [SP,#0x2C+remote_temp]
LDR             R1, [SP,#0x2C+var_20]
MOVT            R0, #:upper16:aAsicDTemperatu ; "\nASIC %d temperature is %d, waiting it"...
BLX             printf
B               loc_14A70

loc_14B84
MOVW            R0, #:lower16:aBeginTestStart ; "\nBegin test!!! Start sensor is %d, ASI"...
LDR             R1, [SP,#0x2C+var_20]
MOVT            R0, #:upper16:aBeginTestStart ; "\nBegin test!!! Start sensor is %d, ASI"...
BLX             printf
B               loc_14B5A

loc_14B94
LDR.W           R3, [R3,#configuration.TempSensor1]
STR             R3, [SP,#0x2C+var_20]
which_sensor = R3       ; unsigned int
B               loc_14866

loc_14B9C
LDR             R3, [SP,#0x2C+var_C]
MOV             R2, R3
LDR             R3, [SP,#0x2C+remote_temp]
STR             R3, [R2]
B               loc_14A64
; End of function BM1391_read_asic_temperature_local_remote

ALIGN 4
off_14BA8 DCD __FUNCTION__.8539 ; "BM1391_read_asic_temperature_local_remo"...
off_14BAC DCD gSensor_OK+0xC



; void __fastcall BM1391_read_asic_temperature_local(unsigned __int8 which_chain)
EXPORT BM1391_read_asic_temperature_local
BM1391_read_asic_temperature_local

mode= -0x1C
var_10= -0x10
var_C= -0xC
var_8= -8

which_chain = R0        ; unsigned __int8
MOVW            R3, #:lower16:gSensor_read_ok_counter
MOVW            R2, #:lower16:gSensor_OK
MOVT            R3, #:upper16:gSensor_read_ok_counter
PUSH.W          {R4-R11,LR}
ADD.W           R3, R3, which_chain,LSL#4
SUB             SP, SP, #0x1C
MOVT            R2, #:upper16:gSensor_OK
MOVW            R11, #:lower16:Conf
STR             R3, [SP,#0x1C+var_10]
MOV             R7, which_chain
ADD.W           R3, R2, which_chain,LSL#2
MOVT            R11, #:upper16:Conf
STR             R2, [SP,#0x1C+var_8]
MOV.W           R8, #0
STR             R3, [SP,#0x1C+var_C]

loc_14BE2
i = R8                  ; unsigned int
CMP.W           i, #0
BEQ.W           loc_14DB6
CMP.W           i, #1
IT EQ
LDREQ.W         R10, [R11,#configuration.TempSensor2]
BEQ             loc_14C04
CMP.W           i, #2
ITE EQ
LDREQ.W         R10, [R11,#configuration.TempSensor3]
LDRNE.W         R10, [R11,#configuration.TempSensor4]

loc_14C04
CMP.W           R10, #0
BNE             loc_14C1A

loc_14C0A
ADD.W           R8, R8, #1
i = R8                  ; unsigned int
CMP.W           i, #4
BNE             loc_14BE2

loc_14C14
ADD             SP, SP, #0x1C
POP.W           {R4-R11,PC}

loc_14C1A
MOVW            R6, #:lower16:gChain_Asic_Interval
ADD.W           R5, R10, #0xFFFFFFFF
MOVT            R6, #:upper16:gChain_Asic_Interval
MOVW            R3, #:lower16:gBM1391_MISC_CONTROL_reg
LDR             R1, [R6]
UXTB            R5, R5
MOVT            R3, #:upper16:gBM1391_MISC_CONTROL_reg
LDR             R3, [R3]
MOVS            R2, #0
STR             R2, [SP,#0x1C+mode] ; mode
MOV             R0, R7  ; which_chain
SMULBB          R1, R1, R5
MOVS            R2, #0x18 ; reg_addr
ORR.W           R3, R3, #0x4000
ORR.W           R3, R3, #0x30 ; '0' ; reg_data
MOVS            R4, #0
UXTB            R1, R1  ; asic_addr
MOV             R9, #read_loop
BL              BM1391_set_config
LDR             R1, [R6]
MOV             R3, R4  ; mode
MOVS            R2, #0x18 ; reg
MOV             R0, R7  ; which_chain
SMULBB          R1, R1, R5
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
B               loc_14C74

loc_14C6C
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
LDR.W           R3, [R9]
CMP             read_temperature_time, R3
BCS             loc_14C8E

loc_14C74
LDR             R1, [R6]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R7  ; which_chain
ADDS            read_temperature_time, #1
SMULBB          R1, R1, R5
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_14C6C

loc_14C8E
LDR             R1, [R6]
MOV             R3, #gSensor_i2c_addr_high_4_bit
MOVS            R2, #0
LDR             R3, [R3]
MOV             R4, R2
STR             R2, [SP,#0x1C+mode] ; mode
MOVW            R9, #:lower16:read_loop
SMULBB          R1, R1, R5
MOVS            R2, #0x1C ; reg_addr
BIC.W           R3, R3, #0x1000000
BIC.W           R3, R3, #0x10000
MOV             ret, R7 ; which_chain
ORR.W           R3, R3, #0x1000000 ; reg_data
UXTB            R1, R1  ; asic_addr
MOVT            R9, #:upper16:read_loop
BL              BM1391_set_config
B               loc_14CCC

loc_14CC4
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
LDR.W           R3, [R9]
CMP             read_temperature_time, R3
BCS             loc_14D62

loc_14CCC
LDR             R1, [R6]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R7  ; which_chain
ADDS            read_temperature_time, #1
SMULBB          R1, R1, R5
UXTB            R1, R1  ; chip_addr
BL              check_BM1391_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_14CC4
MOVW            R2, #:lower16:highest_temp
UXTB            R3, ret
MOVT            R2, #:upper16:highest_temp
LDR             R1, [R2]
SUB.W           R4, R3, #0x40 ; '@'
local_temp = R4         ; int
CMP             local_temp, R1
IT GT
STRGT           local_temp, [R2]
CMP.W           R8, #0
BEQ             loc_14DBC
CMP.W           R8, #1
BEQ.W           loc_14E20
CMP.W           R8, #2
BEQ             loc_14DE2
CMN.W           local_temp, #0x40 ; '@'
BEQ             loc_14E02
LDR             ret, [SP,#0x1C+var_10]
MOV             R2, #Sensor4_temp
MOVS            R1, #1
STR             local_temp, [R2]
LDR             R3, [R0,#0xC]
LDR             R2, [SP,#0x1C+var_C]
ADD             R3, R1
STRB            R1, [R2,#3]
STR             R3, [R0,#0xC]

loc_14D2E
MOVW            R0, #:lower16:aAsicDHashBoard_0 ; "\nASIC %d Hash Board temperature is %d"...
MOV             R2, local_temp
MOVT            R0, #:upper16:aAsicDHashBoard_0 ; "\nASIC %d Hash Board temperature is %d"...
MOV             R1, R10
BLX             printf
LDR.W           R3, [R11,#configuration.StartSensor]
CMP             R10, R3
BNE.W           loc_14C0A

loc_14D48
LDR.W           R3, [R11,#configuration.StartTemp]
CMP             R3, R4
BGT             loc_14D82
MOV             R5, #gStartTest
LDRB            R3, [R5]
CBZ             R3, loc_14DA4

loc_14D5C
MOVS            R3, #1
STRB            R3, [R5]
B               loc_14C0A

loc_14D62
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
MOV             R3, ret
MOVW            ret, #:lower16:aSDoNotReadOutA_1 ; "%s: do not read out ASIC %d Hash Boardt"...
ret = R3                ; unsigned int
MOV             R2, R10
MOVT            R0, #:upper16:aSDoNotReadOutA_1 ; "%s: do not read out ASIC %d Hash Boardt"...
LDR             R1, =__FUNCTION__.8558 ; "BM1391_read_asic_temperature_local"
BLX             printf
MOVW            R3, #:lower16:gNotReadOutTemp
MOVS            R2, #1
MOVT            R3, #:upper16:gNotReadOutTemp
STRB            R2, [R3]
B               loc_14C0A

loc_14D82
MOV             R2, #gStartTest
LDRB            R2, [R2]
CMP             R2, #0
BNE.W           loc_14C0A
MOVW            R0, #:lower16:aAsicDHashBoard_1 ; "\nASIC %d Hash Board temperature is %d,"...
MOV             R2, R4
MOV             R1, R10
MOVT            R0, #:upper16:aAsicDHashBoard_1 ; "\nASIC %d Hash Board temperature is %d,"...
BLX             printf
B               loc_14C0A

loc_14DA4
MOVW            R0, #:lower16:aBeginTestStart_0 ; "\nBegin test!!! Start sensor is %d, Has"...
MOV             R2, R4
MOV             R1, R10
MOVT            R0, #:upper16:aBeginTestStart_0 ; "\nBegin test!!! Start sensor is %d, Has"...
BLX             printf
B               loc_14D5C

loc_14DB6
LDR.W           R10, [R11,#configuration.TempSensor1]
which_sensor = R10      ; unsigned int
B               loc_14C04

loc_14DBC
ret = R0                ; unsigned int
local_temp = R4         ; int
CMN.W           local_temp, #0x40 ; '@'
BEQ             loc_14DDE
LDR             ret, [SP,#0x1C+var_10]
MOV             R2, #Sensor1_temp
MOVS            R1, #1
STR             local_temp, [R2]
LDR             R3, [R0]
LDR             R2, [SP,#0x1C+var_8]
ADD             R3, R1
STRB.W          R1, [R2,R7,LSL#2]
STR             R3, [R0]
B               loc_14D2E

loc_14DDE
ret = R0                ; unsigned int
MOVS            local_temp, #0
B               loc_14D2E

loc_14DE2
local_temp = R4         ; int
CMN.W           local_temp, #0x40 ; '@'
BEQ             loc_14DDE
LDR             ret, [SP,#0x1C+var_10]
MOV             R2, #Sensor3_temp
MOVS            R1, #1
STR             local_temp, [R2]
LDR             R3, [R0,#8]
LDR             R2, [SP,#0x1C+var_C]
ADD             R3, R1
STRB            R1, [R2,#2]
STR             R3, [R0,#8]
B               loc_14D2E

loc_14E02
ret = R0                ; unsigned int
MOVW            ret, #:lower16:aAsicDHashBoard_0 ; "\nASIC %d Hash Board temperature is %d"...
MOVS            R2, #0
MOVT            R0, #:upper16:aAsicDHashBoard_0 ; "\nASIC %d Hash Board temperature is %d"...
MOV             R1, R10
BLX             printf
LDR.W           R3, [R11,#configuration.StartSensor]
CMP             R10, R3
BNE.W           loc_14C14
MOVS            R4, #0
B               loc_14D48

loc_14E20
ret = R0                ; unsigned int
local_temp = R4         ; int
CMN.W           local_temp, #0x40 ; '@'
BEQ             loc_14DDE
LDR             R1, [SP,#0x1C+var_10]
MOVW            R2, #:lower16:Sensor2_temp
LDR             ret, [SP,#0x1C+var_C]
MOVT            R2, #:upper16:Sensor2_temp
STR             local_temp, [R2]
LDR             R3, [R1,#4]
STRB.W          R8, [R0,#1]
ADDS            R3, #1
STR             R3, [R1,#4]
B               loc_14D2E
; End of function BM1391_read_asic_temperature_local

off_14E40 DCD __FUNCTION__.8558 ; "BM1391_read_asic_temperature_local"


; Attributes: noreturn

; void *__fastcall __noreturn single_BM1391_show_status_func(void *arg)
EXPORT single_BM1391_show_status_func
single_BM1391_show_status_func

var_10= -0x10
var_C= -0xC
var_8= -8

chain_info = R0         ; chain_info *
which_chain = R6        ; unsigned __int8
MOVW            R3, #:lower16:gIsOpenCoreEnd
PUSH.W          {R4-R11,LR}
MOVT            R3, #:upper16:gIsOpenCoreEnd
SUB             SP, SP, #0x14
MOVW            R2, #:lower16:gReadingTemp
MOVW            R1, #:lower16:Conf
MOVW            R4, #:lower16:time_counter
MOVW            R11, #:lower16:gIsReadTemp
MOVW            R7, #:lower16:gValid_Nonce_Num
MOVW            R10, #:lower16:Sensor1_temp
MOVW            R9, #:lower16:lcd_fd
MOVW            R8, #:lower16:gStartTest
MOVW            R5, #:lower16:lcd_output
STR             R3, [SP,#0x14+var_10]
MOVT            R2, #:upper16:gReadingTemp
MOVT            R1, #:upper16:Conf
MOVT            R4, #:upper16:time_counter
MOVS            R3, #0
LDRB            which_chain, [chain_info]
MOVT            R11, #:upper16:gIsReadTemp
STR             R2, [SP,#0x14+var_8]
MOVT            R7, #:upper16:gValid_Nonce_Num
STR             R1, [SP,#0x14+var_C]
MOVT            R10, #:upper16:Sensor1_temp
MOVT            R9, #:upper16:lcd_fd
MOVT            R8, #:upper16:gStartTest
MOVT            R5, #:upper16:lcd_output
STR             R3, [R4]
B               loc_14EB4

loc_14EA8               ; useconds
MOV             R0, #(gAsic_Core_Nonce_Num+0x926BC)
BLX             usleep

loc_14EB4               ; n
MOVS            R2, #0x40 ; '@'
MOVS            R1, #0x20 ; ' ' ; c
MOV             R0, R5  ; s
BLX             memset
LDRB.W          R3, [R11]
CBZ             R3, loc_14ECA
LDR             R3, [SP,#0x14+var_10]
LDRB            R3, [R3]
CBNZ            R3, loc_14F2A

loc_14ECA
MOVW            R1, #:lower16:aTimeDs ; "   time %ds"
LDR             R2, [R4]
MOVT            R1, #:upper16:aTimeDs ; "   time %ds"
MOV             R0, R5  ; s
BLX             sprintf
MOVW            R1, #:lower16:aNonceD ; "   nonce=%d"
LDR.W           R2, [R7,which_chain,LSL#2]
MOVT            R1, #:upper16:aNonceD ; "   nonce=%d"
LDR             R0, =(lcd_output+0x10) ; s
BLX             sprintf
MOVW            R1, #:lower16:aT1DC ; "   T1 %d `C"
LDR.W           R2, [R10]
MOVT            R1, #:upper16:aT1DC ; "   T1 %d `C"
LDR             R0, =(lcd_output+0x20) ; s
BLX             sprintf
LDR             R3, [R4]
MOVS            R2, #0x40 ; '@' ; n
MOV             R1, R5  ; buf
LDR.W           R0, [R9] ; fd
ADDS            R3, #1
STR             R3, [R4]
BLX             write
LDRB.W          R3, [R8]
CMP             R3, #0
BEQ             loc_14EA8
MOVW            R0, #:lower16:aGvalidNonceNum ; "\ngValid_Nonce_Num = %d\n"
LDR.W           R1, [R7,which_chain,LSL#2]
MOVT            R0, #:upper16:aGvalidNonceNum ; "\ngValid_Nonce_Num = %d\n"
BLX             printf
B               loc_14EA8

loc_14F2A
LDR             R3, [SP,#0x14+var_C]
LDR             R2, [SP,#0x14+var_8]
LDR.W           R0, [R3,#configuration.timeout]
MOVS            R3, #1
STRB            R3, [R2]
RSB.W           R0, R0, R0,LSL#4 ; useconds
BLX             usleep
LDR             R3, [SP,#0x14+var_C]
LDR.W           R3, [R3,#configuration.sensor_model]
SUBS            R2, R3, #1
CMP             R2, #1
BLS             loc_14F74
SUBS            R3, #3
CMP             R3, #5
BLS             loc_14F6C
MOVW            R0, #:lower16:aSPleaseConfigS ; "\n%s: please config sensor_model in Con"...
LDR             R1, =__FUNCTION__.8567 ; "single_BM1391_show_status_func"
MOVT            R0, #:upper16:aSPleaseConfigS ; "\n%s: please config sensor_model in Con"...
BLX             printf

loc_14F5E               ; level
MOVS            R0, #6
BL              fan_control
LDR             R2, [SP,#0x14+var_8]
MOVS            R3, #0
STRB            R3, [R2]
B               loc_14ECA

loc_14F6C               ; which_chain
MOV             R0, which_chain
BL              BM1391_read_asic_temperature_local
B               loc_14F5E

loc_14F74               ; which_chain
MOV             R0, which_chain
BL              BM1391_read_asic_temperature_local_remote
B               loc_14F5E
; End of function single_BM1391_show_status_func

off_14F7C DCD lcd_output+0x10
off_14F80 DCD lcd_output+0x20
off_14F84 DCD __FUNCTION__.8567 ; "single_BM1391_show_status_func"



; int __fastcall BM1391_is_nonce_or_reg_value(unsigned int data)
EXPORT BM1391_is_nonce_or_reg_value
BM1391_is_nonce_or_reg_value
data = R0               ; unsigned int
LSRS            data, data, #0x1F
BX              LR
; End of function BM1391_is_nonce_or_reg_value




; int __fastcall BM1391_check_nonce_flag(unsigned int data)
EXPORT BM1391_check_nonce_flag
BM1391_check_nonce_flag
data = R0               ; unsigned int
PUSH            {R3,LR}
AND.W           R3, data, #0xE0
CMP             R3, #0x80
BEQ             loc_14FAA
MOV             R2, data
MOVW            data, #:lower16:aSData0x08x ; "%s: data = 0x%08x\n"
data = R2               ; unsigned int
LDR             R1, =__FUNCTION__.8575 ; "BM1391_check_nonce_flag"
MOVT            R0, #:upper16:aSData0x08x ; "%s: data = 0x%08x\n"
BLX             printf
MOVS            R0, #0
POP             {R3,PC}

loc_14FAA
data = R0               ; unsigned int
MOVS            data, #1
POP             {R3,PC}
; End of function BM1391_check_nonce_flag

ALIGN 0x10
off_14FB0 DCD __FUNCTION__.8575 ; "BM1391_check_nonce_flag"



; int __fastcall single_BM1391_check_nonce(unsigned __int8 which_chain, unsigned int *buf)
EXPORT single_BM1391_check_nonce
single_BM1391_check_nonce

var_14= -0x14
var_10= -0x10
OpenCoreNum4= -0xC
OpenCoreNum8= -8

which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
PUSH.W          {R4-R11,LR}
MOVW            R3, #:lower16:gChain_Asic_Interval
LDR             R6, [buf,#4]
MOVT            R3, #:upper16:gChain_Asic_Interval
MOVW            R5, #:lower16:Conf
SUB             SP, SP, #0x14
MOVT            R5, #:upper16:Conf
LDR.W           R9, [buf]
MOV             R8, which_chain
LDR             buf, [R3]
LSRS            which_chain, R6, #0x18
LDR.W           R4, [R5,#configuration.OpenCoreNum1]
OpenCoreNum1 = R4       ; unsigned int
BL              __aeabi_uidiv
LDR.W           R3, [R5,#configuration.OpenCoreNum4]
MOV             R2, R0
LDR.W           R1, [R5,#configuration.OpenCoreNum2]
OpenCoreNum2 = R1       ; unsigned int
UBFX.W          LR, R9, #0x10, #0xF
LDR.W           R0, [R5,#configuration.OpenCoreNum3]
OpenCoreNum3 = R0       ; unsigned int
STR             R3, [SP,#0x14+OpenCoreNum4]
OpenCoreNum4_0 = R3     ; unsigned int
LDR.W           OpenCoreNum4_0, [R5,#configuration.OpenCoreNum8]
LDR.W           R12, [R5,#configuration.OpenCoreNum5]
OpenCoreNum5 = R12      ; unsigned int
LDR.W           R10, [R5,#configuration.OpenCoreNum6]
OpenCoreNum6 = R10      ; unsigned int
LDR.W           R11, [R5,#configuration.OpenCoreNum7]
OpenCoreNum7 = R11      ; unsigned int
STR             R3, [SP,#0x14+OpenCoreNum8]
which_asic = R2         ; unsigned int
which_pattern = R14     ; unsigned int
data_0 = R9             ; unsigned int
data_1 = R6             ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
CMP             which_asic, #0
BNE.W           loc_152E8
LDR             R5, [R5,#configuration.pattern_number]
CMP             LR, R5
BCS.W           loc_15300
UXTB            R7, data_1
which_core = R7         ; unsigned int
CMP             which_core, #0x1F
BLS             loc_1509C
SUB.W           R5, which_core, #0x20 ; ' '
CMP             R5, #0x1F
BHI             loc_1511C
MOVS            OpenCoreNum8_0, #0x20 ; ' '

loc_15022
the_core_should_be_test = R2; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum1 = R4       ; unsigned int
SUBS            R3, #1
BNE             loc_15022
SUB.W           OpenCoreNum3, which_core, #0x1F

loc_15036
i = R3                  ; unsigned int
TST.W           OpenCoreNum2, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R3, R0
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
i = R3                  ; unsigned int
BNE             loc_15036

loc_1504A
SUBS            R2, #1
MOVW            R3, #:lower16:cgpu
ADD.W           R2, R2, #0x20000
MOVT            R3, #:upper16:cgpu
ADDS            R2, #0x2A ; '*'
ADD.W           LR, LR, LR,LSL#4
ADD.W           R2, R3, R2,LSL#2
LDR             R2, [R2,#4]
ADD.W           LR, R2, LR,LSL#2
work = R14              ; work *
LDR.W           R3, [LR,#4]
CMP             data_1, R3
BNE             loc_150B6
ADD.W           LR, LR, R8,LSL#2
match_nonce = R3        ; unsigned int
LDR.W           R0, [LR,#0x34]
CMP             R0, #0
BEQ             loc_15172
MOVW            match_nonce, #:lower16:gRepeated_Nonce_Id
ADDS            R0, #1
MOVT            R3, #:upper16:gRepeated_Nonce_Id
STR.W           R0, [LR,#0x34]
LDR.W           R2, [R3,R8,LSL#2]
MOVS            R0, #0
ADDS            R2, #1
STR.W           R2, [R3,R8,LSL#2]

loc_15096
data_1 = R6             ; unsigned int
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}

loc_1509C
which_asic = R2         ; unsigned int
which_core = R7         ; unsigned int
which_pattern = R14     ; unsigned int
data_0 = R9             ; unsigned int
data_1 = R6             ; unsigned int
OpenCoreNum1 = R4       ; unsigned int
OpenCoreNum2 = R1       ; unsigned int
OpenCoreNum3 = R0       ; unsigned int
OpenCoreNum5 = R12      ; unsigned int
OpenCoreNum6 = R10      ; unsigned int
OpenCoreNum7 = R11      ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
ADDS            OpenCoreNum2, which_core, #1
MOV             OpenCoreNum8_0, which_asic

loc_150A0
i = R3                  ; unsigned int
the_core_should_be_test = R2; unsigned int
TST.W           OpenCoreNum1, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R1, R3
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
i = R3                  ; unsigned int
BNE             loc_150A0
B               loc_1504A

loc_150B6
match_nonce = R3        ; unsigned int
work = R14              ; work *
MOVW            match_nonce, #:lower16:HW_check_mutex
ADD.W           OpenCoreNum6, R8, R8,LSL#1
MOVT            R3, #:upper16:HW_check_mutex
ADD.W           R10, R3, R10,LSL#3
data_1 = R6             ; unsigned int
MOV             R9, #gWork_Num_For_Hw_Check
MOV             R0, R10 ; mutex
BLX             pthread_mutex_lock
LDRB.W          OpenCoreNum1, [R9]
CMP             R4, #0
BEQ.W           loc_152DE
MOVW            R3, #:lower16:gWorks_For_Hw_Check
ADD.W           R4, R8, R8,LSL#4
MOVT            R3, #:upper16:gWorks_For_Hw_Check
ADD.W           R4, R3, R4,LSL#9
MOVS            R5, #0
B               loc_150FA

loc_150F2
i = R5                  ; unsigned int
LDRB.W          R3, [R9]
CMP             R3, i
BLS             loc_151A6

loc_150FA               ; work
MOV             R0, R4
MOVS            R2, #0  ; print
MOV             R1, data_1 ; nonce
ADDS            i, #1
ADDS            R4, #0x44 ; 'D'
BL              check_hw
i = R5                  ; unsigned int
CMP             R0, #0
BNE             loc_150F2
MOV             OpenCoreNum7, R0
MOV             R0, R10 ; mutex
BLX             pthread_mutex_unlock
MOV             R0, R11
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}

loc_1511C
which_asic = R2         ; unsigned int
which_pattern = R14     ; unsigned int
data_0 = R9             ; unsigned int
data_1 = R6             ; unsigned int
OpenCoreNum1 = R4       ; unsigned int
OpenCoreNum2 = R1       ; unsigned int
OpenCoreNum3 = R0       ; unsigned int
OpenCoreNum5 = R12      ; unsigned int
OpenCoreNum6 = R10      ; unsigned int
OpenCoreNum7 = R11      ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
SUB.W           R5, which_core, #0x40 ; '@'
CMP             R5, #0x1F
BLS             loc_151E6
SUB.W           R5, which_core, #0x60 ; '`'
CMP             R5, #0x1F
BHI             loc_1521E
LDR             OpenCoreNum8_0, [SP,#0x14+OpenCoreNum4]
MOVS            R5, #0x20 ; ' '

loc_15130
the_core_should_be_test = R2; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum1 = R4       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum2 = R1       ; unsigned int
TST.W           OpenCoreNum3, #1
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum3 = R0       ; unsigned int
SUBS            R5, #1
BNE             loc_15130
OpenCoreNum4_0 = R3     ; unsigned int
SUB.W           OpenCoreNum2, which_core, #0x5F ; '_'

loc_1515C
i = R5                  ; unsigned int
TST.W           OpenCoreNum4_0, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R1, R5
MOV.W           OpenCoreNum4_0, OpenCoreNum4_0,LSR#1
i = R5                  ; unsigned int
BNE             loc_1515C
B               loc_1504A

loc_15172
match_nonce = R3        ; unsigned int
ADD.W           which_core, which_core, R8,LSL#17
MOVS            R1, #1
MOVW            match_nonce, #:lower16:gAsic_Core_Nonce_Num
STR.W           R1, [LR,#0x34]
MOVW            R2, #:lower16:gValid_Nonce_Num
MOVT            R3, #:upper16:gAsic_Core_Nonce_Num
MOVT            R2, #:upper16:gValid_Nonce_Num
LDR.W           R1, [R3,R7,LSL#2]
LDR.W           OpenCoreNum1, [R2,R8,LSL#2]
ADDS            R1, #1
ADDS            R4, #1
STR.W           R1, [R3,R7,LSL#2]
STR.W           R4, [R2,R8,LSL#2]
ADD             SP, SP, #0x14
POP.W           {R4-OpenCoreNum7,PC}

loc_151A6
which_core = R7         ; unsigned int
i = R5                  ; unsigned int
data_1 = R6             ; unsigned int
MOV             OpenCoreNum7, R0
ret = R0                ; int
MOV             ret, R10 ; mutex
ret = R11               ; int
BLX             pthread_mutex_unlock
CMP.W           ret, #1
IT NE
MOVNE           R0, #0
BNE.W           loc_15096
MOVW            R4, #:lower16:gHw_Nonce_Num
STR             data_1, [SP,#0x14+var_10]
MOVT            R4, #:upper16:gHw_Nonce_Num
MOVW            R0, #:lower16:aSFindAHwChainD ; "%s: Find a HW. Chain%d ASIC%d Core%d : "...
LDR.W           i, [R4,R8,LSL#2]
MOV             R2, R8
STR             which_core, [SP,#0x14+var_14]
MOVT            R0, #:upper16:aSFindAHwChainD ; "%s: Find a HW. Chain%d ASIC%d Core%d : "...
MOVS            R3, #0
LDR             R1, =__FUNCTION__.8600 ; "single_BM1391_check_nonce"
ADDS            R5, #1
STR.W           R5, [R4,R8,LSL#2]
BLX             printf
MOVS            R0, #0
B               loc_15096

loc_151E6
which_asic = R2         ; unsigned int
which_pattern = R14     ; unsigned int
data_0 = R9             ; unsigned int
data_1 = R6             ; unsigned int
OpenCoreNum1 = R4       ; unsigned int
OpenCoreNum2 = R1       ; unsigned int
OpenCoreNum3 = R0       ; unsigned int
OpenCoreNum5 = R12      ; unsigned int
OpenCoreNum6 = R10      ; unsigned int
OpenCoreNum7 = R11      ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
MOVS            OpenCoreNum8_0, #0x20 ; ' '

loc_151E8
the_core_should_be_test = R2; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum1 = R4       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum2 = R1       ; unsigned int
SUBS            R3, #1
BNE             loc_151E8
SUB.W           OpenCoreNum2, which_core, #0x3F ; '?'

loc_15208
i = R3                  ; unsigned int
TST.W           OpenCoreNum3, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R3, R1
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
i = R3                  ; unsigned int
BNE             loc_15208
B               loc_1504A

loc_1521E
which_asic = R2         ; unsigned int
OpenCoreNum2 = R1       ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
SUB.W           R5, which_core, #0x80
CMP             R5, #0x1F
BLS             loc_1528C
SUB.W           R5, which_core, #0xA0
CMP             R5, #0x1F
BHI             loc_1531A
LDR             OpenCoreNum8_0, [SP,#0x14+OpenCoreNum4]
MOVS            R5, #0x20 ; ' '

loc_15232
the_core_should_be_test = R2; unsigned int
OpenCoreNum4_0 = R3     ; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum1 = R4       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum2 = R1       ; unsigned int
TST.W           OpenCoreNum3, #1
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum3 = R0       ; unsigned int
TST.W           OpenCoreNum4_0, #1
MOV.W           OpenCoreNum4_0, OpenCoreNum4_0,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum4_0 = R3     ; unsigned int
TST.W           OpenCoreNum5, #1
MOV.W           OpenCoreNum5, OpenCoreNum5,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum5 = R12      ; unsigned int
SUBS            R5, #1
BNE             loc_15232
SUB.W           OpenCoreNum4_0, which_core, #0x9F

loc_15276
i = R5                  ; unsigned int
TST.W           OpenCoreNum6, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R5, R3
MOV.W           OpenCoreNum6, OpenCoreNum6,LSR#1
i = R5                  ; unsigned int
BNE             loc_15276
B               loc_1504A

loc_1528C
which_asic = R2         ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
LDR             OpenCoreNum8_0, [SP,#0x14+OpenCoreNum4]
MOVS            R5, #0x20 ; ' '

loc_15290
the_core_should_be_test = R2; unsigned int
OpenCoreNum4_0 = R3     ; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum1 = R4       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum2 = R1       ; unsigned int
TST.W           OpenCoreNum3, #1
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum3 = R0       ; unsigned int
TST.W           OpenCoreNum4_0, #1
MOV.W           OpenCoreNum4_0, OpenCoreNum4_0,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum4_0 = R3     ; unsigned int
SUBS            R5, #1
BNE             loc_15290
SUB.W           OpenCoreNum4_0, which_core, #0x7F

loc_152C8
i = R5                  ; unsigned int
TST.W           OpenCoreNum5, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R3, R5
MOV.W           OpenCoreNum5, OpenCoreNum5,LSR#1
i = R5                  ; unsigned int
BNE             loc_152C8
B               loc_1504A

loc_152DE               ; mutex
data_1 = R6             ; unsigned int
MOV             R0, R10
BLX             pthread_mutex_unlock
MOV             R0, R4
B               loc_15096

loc_152E8
which_asic = R2         ; unsigned int
which_pattern = R14     ; unsigned int
data_0 = R9             ; unsigned int
data_1 = R6             ; unsigned int
OpenCoreNum1 = R4       ; unsigned int
OpenCoreNum2 = R1       ; unsigned int
OpenCoreNum3 = R0       ; unsigned int
OpenCoreNum5 = R12      ; unsigned int
OpenCoreNum6 = R10      ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
MOVW            OpenCoreNum3, #:lower16:aSReceivedAsic0_0 ; "%s: received ASIC%02d nonce. error!!! d"...
STR             data_1, [SP,#0x14+var_14]
MOV             OpenCoreNum8_0, data_0
MOVT            R0, #:upper16:aSReceivedAsic0_0 ; "%s: received ASIC%02d nonce. error!!! d"...
LDR             OpenCoreNum2, =__FUNCTION__.8600 ; "single_BM1391_check_nonce"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_15096

loc_15300
which_asic = R2         ; unsigned int
which_pattern = R14     ; unsigned int
OpenCoreNum2 = R1       ; unsigned int
OpenCoreNum3 = R0       ; unsigned int
OpenCoreNum5 = R12      ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
MOVW            OpenCoreNum3, #:lower16:aSReceivedWorkI_0 ; "%s: received work_id = %02d nonce. erro"...
STR             data_1, [SP,#0x14+var_14]
MOV             OpenCoreNum8_0, data_0
MOV             which_asic, LR
MOVT            R0, #:upper16:aSReceivedWorkI_0 ; "%s: received work_id = %02d nonce. erro"...
LDR             OpenCoreNum2, =__FUNCTION__.8600 ; "single_BM1391_check_nonce"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_15096

loc_1531A
which_asic = R2         ; unsigned int
which_core = R7         ; unsigned int
which_pattern = R14     ; unsigned int
OpenCoreNum2 = R1       ; unsigned int
OpenCoreNum3 = R0       ; unsigned int
OpenCoreNum5 = R12      ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
SUB.W           R5, which_core, #0xC0
LDR             OpenCoreNum8_0, [SP,#0x14+OpenCoreNum4]
CMP             R5, #0x1F
MOV.W           R5, #0x20 ; ' '
BLS             loc_1539C

loc_15328
the_core_should_be_test = R2; unsigned int
OpenCoreNum4_0 = R3     ; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum1 = R4       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum2 = R1       ; unsigned int
TST.W           OpenCoreNum3, #1
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum3 = R0       ; unsigned int
TST.W           OpenCoreNum4_0, #1
MOV.W           OpenCoreNum4_0, OpenCoreNum4_0,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum4_0 = R3     ; unsigned int
TST.W           OpenCoreNum5, #1
MOV.W           OpenCoreNum5, OpenCoreNum5,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum5 = R12      ; unsigned int
TST.W           OpenCoreNum6, #1
MOV.W           OpenCoreNum6, OpenCoreNum6,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum6 = R10      ; unsigned int
TST.W           OpenCoreNum7, #1
MOV.W           OpenCoreNum7, OpenCoreNum7,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum7 = R11      ; unsigned int
SUBS            R5, #1
BNE             loc_15328
LDR             OpenCoreNum2, [SP,#0x14+OpenCoreNum8]
SUB.W           OpenCoreNum4_0, which_core, #0xDF

loc_15386
i = R5                  ; unsigned int
OpenCoreNum8_0 = R1     ; unsigned int
TST.W           OpenCoreNum8_0, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R5, R3
MOV.W           OpenCoreNum8_0, OpenCoreNum8_0,LSR#1
i = R5                  ; unsigned int
BNE             loc_15386
B               loc_1504A

loc_1539C
OpenCoreNum2 = R1       ; unsigned int
OpenCoreNum4_0 = R3     ; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum1 = R4       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum2 = R1       ; unsigned int
TST.W           OpenCoreNum3, #1
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum3 = R0       ; unsigned int
TST.W           OpenCoreNum4_0, #1
MOV.W           OpenCoreNum4_0, OpenCoreNum4_0,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum4_0 = R3     ; unsigned int
TST.W           OpenCoreNum5, #1
MOV.W           OpenCoreNum5, OpenCoreNum5,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum5 = R12      ; unsigned int
TST.W           OpenCoreNum6, #1
MOV.W           OpenCoreNum6, OpenCoreNum6,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum6 = R10      ; unsigned int
SUBS            R5, #1
BNE             loc_1539C
SUB.W           OpenCoreNum4_0, which_core, #0xBF

loc_153EC
i = R5                  ; unsigned int
TST.W           OpenCoreNum7, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R3, R5
MOV.W           OpenCoreNum7, OpenCoreNum7,LSR#1
i = R5                  ; unsigned int
BNE             loc_153EC
B               loc_1504A
; End of function single_BM1391_check_nonce

ALIGN 4
off_15404 DCD __FUNCTION__.8600 ; "single_BM1391_check_nonce"



; int __fastcall single_BM1391_check_register_value(unsigned __int8 which_chain, unsigned int *buf)
EXPORT single_BM1391_check_register_value
single_BM1391_check_register_value
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
PUSH            {R3-R7,LR}
MOV             R5, #reg_value_buf
LDR             R3, [R5]
LDR             R3, [R3,#8]
CMP.W           R3, #0x1FE
BHI             loc_15478
LDM.W           buf, {R4,R7}
LSLS            R3, R4, #0x19
BMI             loc_154A2
ANDS.W          R6, R4, #0x20000000
BNE             loc_1548A
MOV             R0, #reg_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R2, [R5]
LSRS            R3, data_0, #8
LSRS            R5, data_0, #0x10
UBFX.W          LR, data_0, #0x18, #5
AND.W           data_0, data_0, #0xF
data_1 = R7             ; unsigned int
LDR             R1, [R2]
ADD.W           R0, R2, R1,LSL#3
ADDS            R1, #1
CMP.W           R1, #0x200
STR             data_1, [R0,#0x10]
STRB.W          LR, [R0,#0x16]
STRB            R5, [R0,#0x14]
STRB            R4, [R0,#0x17]
STRB            R3, [R0,#0x15]
MOVW            R0, #:lower16:reg_mutex
LDR             R3, [R2,#8]
MOVT            R0, #:upper16:reg_mutex ; mutex
STR             R1, [R2]
IT CS
STRCS           R6, [R2]
ADDS            R3, #1
STR             R3, [R2,#8]
BLX             pthread_mutex_unlock
MOVS            R0, #0
POP             {R3-data_1,PC}

loc_15478
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
MOVW            which_chain, #:lower16:aSRegValueBufBu ; "%s: reg_value_buf buffer is full!\n"
LDR             buf, =__FUNCTION__.8654 ; "single_BM1391_check_register_value"
MOVT            R0, #:upper16:aSRegValueBufBu ; "%s: reg_value_buf buffer is full!\n"
BLX             printf
MOVS            R0, #0
POP             {R3-R7,PC}

loc_1548A
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
data_0 = R4             ; unsigned int
data_1 = R7             ; unsigned int
MOVW            which_chain, #:lower16:aSRegTypeErrorD ; "%s: REG_TYPE error. data[0] = 0x%08x, r"...
MOV             R3, data_1
MOV             R2, data_0
LDR             buf, =__FUNCTION__.8654 ; "single_BM1391_check_register_value"
MOVT            R0, #:upper16:aSRegTypeErrorD ; "%s: REG_TYPE error. data[0] = 0x%08x, r"...
BLX             printf
MOV.W           R0, #0xFFFFFFFF
POP             {R3-data_1,PC}

loc_154A2
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
data_0 = R4             ; unsigned int
data_1 = R7             ; unsigned int
MOVW            which_chain, #:lower16:aSRegCrcErrorDa ; "%s: reg crc error. data[0] = 0x%08x, re"...
MOV             R3, data_1
MOV             R2, data_0
LDR             buf, =__FUNCTION__.8654 ; "single_BM1391_check_register_value"
MOVT            R0, #:upper16:aSRegCrcErrorDa ; "%s: reg crc error. data[0] = 0x%08x, re"...
BLX             printf
MOV.W           R0, #0xFFFFFFFF
POP             {R3-data_1,PC}
; End of function single_BM1391_check_register_value

ALIGN 4
off_154BC DCD __FUNCTION__.8654 ; "single_BM1391_check_register_value"



; void *__fastcall single_BM1391_receive_func(void *arg)
EXPORT single_BM1391_receive_func
single_BM1391_receive_func

buf= -8

chain_info = R0         ; chain_info *
which_chain = R7        ; unsigned __int8
PUSH.W          {R4-R10,LR}
MOVS            R3, #0
SUB             SP, SP, #8
MOVW            R6, #:lower16:start_receive
MOVW            R8, #:lower16:gBegin_Get_Nonce
MOVT            R6, #:upper16:start_receive
LDRB            which_chain, [chain_info]
MOVT            R8, #:upper16:gBegin_Get_Nonce
LDR.W           R9, =__FUNCTION__.8575 ; "BM1391_check_nonce_flag"
STR             R3, [SP,#8+buf]
STR             R3, [SP,#8+buf+4]
B               loc_154F8

loc_154E4               ; useconds
MOVW            R0, #0x1388
BLX             usleep
MOVS            R0, #6  ; address
BL              read_axi_fpga
UBFX.W          R4, R0, #0, #9
nonce_number = R4       ; unsigned int
CBNZ            nonce_number, loc_15504

loc_154F8
LDRB            R0, [R6]
CMP             R0, #0
BNE             loc_154E4
ADD             SP, SP, #8
POP.W           {R4-R10,PC}

loc_15504
nonce_number = R4       ; unsigned int
MOVW            R10, #:lower16:aSData0x08x ; "%s: data = 0x%08x\n"
MOVS            R5, #0
MOVT            R10, #:upper16:aSData0x08x ; "%s: data = 0x%08x\n"
B               loc_1551A

loc_15510
i = R5                  ; unsigned int
BL              single_BM1391_check_register_value

loc_15514
ADDS            i, #1
CMP             nonce_number, i
BLS             loc_154F8

loc_1551A               ; buf
MOV             R0, SP
BL              get_return_nonce
LDR             R2, [SP,#8+buf]
MOV             R1, SP  ; buf
MOV             R0, which_chain ; which_chain
CMP             R2, #0
BGE             loc_15510
LDRB.W          R3, [R8]
AND.W           R1, R2, #0xE0
CMP             R3, #0
BEQ             loc_15514
CMP             R1, #0x80
MOV             R0, R10 ; format
MOV             R1, R9
BEQ             loc_15544
BLX             printf
B               loc_15514

loc_15544               ; buf
MOV             R1, SP
MOV             R0, which_chain ; which_chain
BL              single_BM1391_check_nonce
B               loc_15514
; End of function single_BM1391_receive_func

ALIGN 0x10
off_15550 DCD __FUNCTION__.8575 ; "BM1391_check_nonce_flag"



; void singleAsicTest_BM1391()
EXPORT singleAsicTest_BM1391
singleAsicTest_BM1391

lcd_display_buf= -0x10

PUSH.W          {R4-R10,LR}
SUB             SP, SP, #0x10
LDR             R5, =dword_2A6B8
MOV             R4, SP
MOV             R6, #lcd_fd
LDR             R2, [R5,#(dword_2A6C0 - 0x2A6B8)]
LDR             R3, [R5,#(dword_2A6C4 - 0x2A6B8)]
LDR             R0, [R5]
LDR             R1, [R5,#(dword_2A6BC - 0x2A6B8)]
STM             R4!, {R0-R3}
MOVW            R0, #:lower16:aBeginSTest ; "\nBegin %s test\n"
ADD.W           R1, R5, #0x10
MOVT            R0, #:upper16:aBeginSTest ; "\nBegin %s test\n"
BLX             printf
MOV             R0, #aDate ; "date"
BLX             system
MOVS            R0, #0xA ; c
BLX             putchar
MOVW            R0, #:lower16:lcd_output
MOVS            R2, #0x40 ; '@' ; n
MOVT            R0, #:upper16:lcd_output ; s
MOVS            R1, #0x20 ; ' ' ; c
BLX             memset
LDR             R0, [R6] ; fd
CMP             R0, #0
BLE             loc_155C0
MOVS            R2, #0  ; whence
MOV             R1, R2  ; offset
BLX             lseek
MOVW            R1, #:lower16:lcd_output
LDR             R0, [R6] ; fd
MOVT            R1, #:upper16:lcd_output ; buf
MOVS            R2, #0x40 ; '@' ; n
BLX             write

loc_155C0
BL              init_fpga
MOVS            R1, #0  ; data
MOVS            R0, #0x3E ; '>' ; address
BL              write_axi_fpga
MOVW            R0, #:lower16:loc_186A0
MOVW            R4, #:lower16:gChain
MOVT            R0, #:upper16:loc_186A0 ; useconds
MOVT            R4, #:upper16:gChain
BLX             usleep
MOVS            R0, #0  ; address
BL              read_axi_fpga
ORR.W           R1, R0, #0x40000000 ; data
MOVS            R0, #0  ; address
BL              write_axi_fpga
BL              reset_single_BM1391_global_arg
BL              check_chain
LDRB            R3, [R4]
CMP             R3, #0xFF
BEQ.W           loc_1577A
LDR             R6, =cgpu.show_id
MOV             R5, #chain_info_0
MOVW            R2, #:lower16:(single_BM1391_show_status_func+1)
ADD.W           R3, R5, R3,LSL#1 ; arg
MOVT            R2, #:upper16:(single_BM1391_show_status_func+1) ; start_routine
MOV             R0, R6  ; newthread
MOVS            R1, #0  ; attr
BLX             pthread_create
thread_ret = R0         ; int
MOV             R7, thread_ret
CBZ             thread_ret, loc_1566C
LDR             thread_ret, [R6] ; th
thread_ret = R7         ; int
BLX             pthread_cancel
MOVW            R1, #:lower16:aCreatShow ; "   Creat show   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCreatShow ; "   Creat show   "
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreateSingleB ; "\n!!!%s: create single_BM1391_show_stat"...
LDR             R1, =__FUNCTION__.8732 ; "singleAsicTest_BM1391"
MOVT            R0, #:upper16:aSCreateSingleB ; "\n!!!%s: create single_BM1391_show_stat"...
BLX             printf

loc_15666
ADD             SP, SP, #0x10
POP.W           {R4-R10,PC}

loc_1566C
thread_ret = R0         ; int
BL              reset_hash_board
LDRB            R3, [R4]
MOVW            LR, #:lower16:start_receive
MOVW            R2, #:lower16:(single_BM1391_receive_func+1)
MOVT            LR, #:upper16:start_receive
MOV.W           R9, #1
MOVT            R2, #:upper16:(single_BM1391_receive_func+1) ; start_routine
MOV             R1, thread_ret ; attr
SUBS            R0, R6, #4 ; newthread
ADD.W           R3, R5, R3,LSL#1 ; arg
STRB.W          R9, [LR]
BLX             pthread_create
thread_ret = R0         ; int
MOV             R8, thread_ret
CMP             thread_ret, #0
BNE             loc_1579C
MOVS            thread_ret, #0x40 ; '@' ; address
thread_ret = R8         ; int
SUB.W           R7, R6, #0x80008
BL              read_axi_fpga
BIC.W           R1, R0, #0x8100
MOVS            R0, #0x40 ; '@' ; address
BIC.W           R1, R1, #0xE0
ORR.W           R1, R1, #0x8100 ; data
BL              write_axi_fpga
MOV             R0, #aCheckAsicNumbe ; "\n--- check asic number"
BLX             puts
MOV             R3, R9  ; mode
MOV             R2, thread_ret ; reg
MOV             R1, thread_ret ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              check_BM1391_asic_reg
LDRB            R3, [R4]
MOV             R0, #aCheckChainAsic ; "\n--- check chain: asicNum = %d\n"
ADD             R3, R7  ; cgpu
ADD.W           R3, R3, #0x100000
LDRB.W          R1, [R3,#(Conf.OpenCoreNum1+3 - 0x3310C3)]
BLX             printf
LDRB            R3, [R4]
ADD             R3, R7  ; cgpu
ADD.W           R3, R3, #0x100000
LDRB.W          R10, [R3,#(Conf.OpenCoreNum1+3 - 0x3310C3)]
CMP.W           R10, #1
BEQ             loc_157EE
LDR.W           R0, [R6,#(cgpu.receive_id - 0x2B0FCC)] ; th
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
LDRB            R3, [R4]
MOV             R1, #(aT1DT2D+0xC) ; format
ADD.W           R0, SP, #0x10+lcd_display_buf+7 ; s
ADD             R3, R7  ; cgpu
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#(Conf.OpenCoreNum1+3 - 0x3310C3)]
BLX             sprintf
MOVW            R1, #:lower16:aOnlyHave ; "   Only have    "
MOV             R0, thread_ret ; line
MOVT            R1, #:upper16:aOnlyHave ; "   Only have    "
MOVS            R2, #0x10 ; size
BL              write_lcd
MOV             R1, SP  ; buf
MOV             R0, R9  ; line
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aAsic ; "      ASIC      "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aAsic ; "      ASIC      "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
LDRB            R3, [R4]
MOVW            R0, #:lower16:aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
LDR             R1, =__FUNCTION__.8732 ; "singleAsicTest_BM1391"
MOVT            R0, #:upper16:aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
ADD             R7, R3  ; cgpu
ADD.W           R7, R7, #0x100000
LDRB.W          R2, [R7,#(Conf.OpenCoreNum1+3 - 0x3310C3)]
BLX             printf
MOV             R0, #asc_29F80 ; "----------------------------\n\n"
BLX             puts
ADD             SP, SP, #0x10
POP.W           {R4-R10,PC}

loc_1577A
MOV             R0, #aNoHashBoardPle ; "\nNo hash board, please plug in it"
BLX             puts
MOVW            R1, #:lower16:aNoHashBoard_0 ; " no hash board  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aNoHashBoard_0 ; " no hash board  "
MOVS            R0, #1  ; line
BL              write_lcd
ADD             SP, SP, #0x10
POP.W           {R4-R10,PC}

loc_1579C               ; th
thread_ret = R0         ; int
LDR.W           thread_ret, [R6,#(cgpu.receive_id - 0x2B0FCC)]
thread_ret = R8         ; int
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
MOVW            R1, #:lower16:aCreatReceive ; "  Creat receive "
MOV             R0, R7  ; line
MOVT            R1, #:upper16:aCreatReceive ; "  Creat receive "
MOVS            R2, #0x10 ; size
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOV             R0, R9  ; line
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreateSingleB_0 ; "\n!!!%s: create single_BM1391_receive_f"...
LDR             R1, =__FUNCTION__.8732 ; "singleAsicTest_BM1391"
MOVT            R0, #:upper16:aSCreateSingleB_0 ; "\n!!!%s: create single_BM1391_receive_f"...
BLX             printf
ADD             SP, SP, #0x10
POP.W           {R4-R10,PC}

loc_157EE
MOV             R7, #Conf
BL              single_BM1391_calculate_timeout_and_baud
LDR             R2, [R7,#configuration.Freq] ; freq
MOV             R3, R10 ; mode
MOV             R1, thread_ret ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              set_BM1391_freq
LDRB            R0, [R4] ; which_chain
BL              BM1391_software_set_address
LDRB.W          R1, [R7,#configuration.baud] ; baud
LDRB            R0, [R4] ; which_chain
BL              BM1391_set_baud
MOV             R3, R10 ; mode
MOVS            R2, #0x18 ; reg
MOV             R1, thread_ret ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              check_BM1391_asic_reg
LDR.W           R1, [R7,#configuration.timeout]
MOVS            R0, #0x22 ; '"' ; address
ORR.W           R1, R1, #0x80000000 ; data
BL              write_axi_fpga
LDR.W           R3, [R7,#configuration.sensor_model]
SUBS            R2, R3, #1
CMP             R2, #1
BLS             loc_1587C
SUBS            R3, #3
CMP             R3, #6
BLS             loc_158F6
LDR.W           R0, [R6,#(cgpu.receive_id - 0x2B0FCC)] ; th
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
MOVW            R1, #:lower16:aSensorModelErr ; "Sensor Model Err"
MOV             R0, thread_ret ; line
MOVT            R1, #:upper16:aSensorModelErr ; "Sensor Model Err"
MOVS            R2, #0x10 ; size
BL              write_lcd
MOVW            R0, #:lower16:aSPleaseConfigS ; "\n%s: please config sensor_model in Con"...
LDR             R1, =__FUNCTION__.8732 ; "singleAsicTest_BM1391"
MOVT            R0, #:upper16:aSPleaseConfigS ; "\n%s: please config sensor_model in Con"...
BLX             printf
B               loc_15666
ALIGN 0x10
off_15870 DCD dword_2A6B8
off_15874 DCD cgpu.show_id
off_15878 DCD __FUNCTION__.8732 ; "singleAsicTest_BM1391"

loc_1587C
MOVW            R3, #:lower16:pattern_test_time
LDRB            R0, [R4] ; which_chain
MOVT            R3, #:upper16:pattern_test_time
LDRB            R3, [R3]
CMP             R3, #0
BNE             loc_15984
BL              BM1391_soft_reset_sensor
LDRB            R0, [R4] ; which_chain
BL              BM1391_enable_extended_mode_of_temperature_sensor
LDRB            R0, [R4] ; which_chain
BL              BM1391_get_temperature_offset_value_from_asic
LDRB            R0, [R4] ; which_chain
BL              BM1391_set_default_temperature_offset_value

loc_158A2
LDR             R2, [R7,#configuration.AsicType]
MOVW            R1, #0x3657
MOVW            R3, #:lower16:gIsReadTemp
MOV.W           thread_ret, #1
MOVT            R3, #:upper16:gIsReadTemp
CMP             R2, R1
STRB.W          R8, [R3]
BEQ.W           loc_159C8
MOVW            R3, #0x3658
CMP             R2, R3
BEQ             loc_158FE
LDR             R3, =cgpu.send_id
LDR             R0, [R3,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
MOVW            R1, #:lower16:aAsicTypeErr ; " Asic Type Err  "
MOV             R0, R8  ; line
MOVT            R1, #:upper16:aAsicTypeErr ; " Asic Type Err  "
MOVS            R2, #0x10 ; size
BL              write_lcd
MOVW            R0, #:lower16:aSConfAsictypeD ; "\n!!! %s: Conf.AsicType = %d, error\n"
LDR             R2, [R7,#configuration.AsicType]
LDR             R1, =__FUNCTION__.8732 ; "singleAsicTest_BM1391"
MOVT            R0, #:upper16:aSConfAsictypeD ; "\n!!! %s: Conf.AsicType = %d, error\n"
BLX             printf
B               loc_15666

loc_158F6               ; which_chain
thread_ret = R8         ; int
LDRB            R0, [R4]
BL              BM1391_enable_extended_mode_of_temperature_sensor
B               loc_158A2

loc_158FE               ; which_chain
LDRB            R0, [R4]
BL              single_BM1391S_open_core

loc_15904
MOVW            R0, #:lower16:aBeginSendTestP ; "\nBegin send test pattern"
LDR             R6, =cgpu.send_id
MOVT            R0, #:upper16:aBeginSendTestP ; "\nBegin send test pattern"
BLX             puts
MOVS            R0, #0xA ; c
BLX             putchar
LDRB            R3, [R4]
MOVW            R2, #:lower16:(single_BM1391_send_func+1)
MOV             R0, R6  ; newthread
MOVT            R2, #:upper16:(single_BM1391_send_func+1) ; start_routine
MOVS            R1, #0  ; attr
ADD.W           R3, R5, R3,LSL#1 ; arg
BLX             pthread_create
thread_ret = R0         ; int
MOV             R5, thread_ret
CBZ             thread_ret, loc_15990
LDR             thread_ret, [R6] ; th
thread_ret = R5         ; int
BLX             pthread_cancel
LDR             R0, [R6,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R6,#(cgpu.show_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOVW            R1, #:lower16:aCreatSend ; "   Creat send   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCreatSend ; "   Creat send   "
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreateSingleB_1 ; "\n!!!%s: create single_BM1391_send_func"...
LDR             R1, =__FUNCTION__.8732 ; "singleAsicTest_BM1391"
MOVT            R0, #:upper16:aSCreateSingleB_1 ; "\n!!!%s: create single_BM1391_send_func"...
BLX             printf
B               loc_15666

loc_15984
thread_ret = R8         ; int
BL              BM1391_enable_extended_mode_of_temperature_sensor
LDRB            R0, [R4] ; which_chain
BL              BM1391_set_default_temperature_offset_value
B               loc_158A2

loc_15990               ; thread_return
thread_ret = R0         ; int
MOV             R1, thread_ret
LDR             thread_ret, [R6] ; th
thread_ret = R5         ; int
BLX             pthread_join
MOV             R1, R5  ; thread_return
LDR             R0, [R6,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_join
LDR             R0, [R6,#(cgpu.show_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDRB            R0, [R4] ; which_chain
BL              single_BM1391_get_result
result = R0             ; unsigned int
MOV             R1, result ; result
LDRB            result, [R4] ; which_chain
result = R1             ; unsigned int
BL              single_BM1391_print_lcd
MOV             R0, R5  ; speed
BL              set_fan_speed
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
B               loc_15666

loc_159C8               ; which_chain
LDRB            R0, [R4]
BL              single_BM1391P_open_core
B               loc_15904
; End of function singleAsicTest_BM1391

off_159D0 DCD cgpu.send_id
off_159D4 DCD __FUNCTION__.8732 ; "singleAsicTest_BM1391"



; int check_chain()
EXPORT check_chain
check_chain

var_C= -0xC
var_8= -8

PUSH.W          {R4-R11,LR}
MOVW            R1, #:lower16:__FUNCTION__.7893 ; "check_chain"
MOVW            R0, #:lower16:aS ; "\n--- %s\n"
LDR.W           R10, =(cgpu.subid+0x7FD54)
SUB             SP, SP, #0xC
MOVT            R1, #:upper16:__FUNCTION__.7893 ; "check_chain"
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
BLX             printf
MOVS            R3, #0
MOVS            R0, #2  ; address
STR.W           R3, [R10,#(cgpu.chain_num - 0x330FC4)]
BL              read_axi_fpga
SUBS            R2, R0, #4
SUBS            R3, R0, #1
BICS.W          R2, R2, #4
MOV             R9, R0
ret = R0                ; int
ITE NE
MOVNE           R4, #1
MOVEQ           R4, #0
CMP             R3, #1
ITE LS
MOVLS           R4, #0
ANDHI.W         R4, R4, #1
CMP             R4, #0
BNE             loc_15AA8
MOVW            R8, #:lower16:chain_info_0
MOVW            R11, #:lower16:gChain
MOVT            R8, #:upper16:chain_info_0
MOVW            R3, #:lower16:gI2c
MOVW            R7, #:lower16:__FUNCTION__.7893 ; "check_chain"
MOV             R6, R8
MOVT            R11, #:upper16:gChain
ADD.W           R5, R10, #0x2F8
MOVT            R3, #:upper16:gI2c
MOVT            R7, #:upper16:__FUNCTION__.7893 ; "check_chain"
STR             R3, [SP,#0xC+var_C]
STR             R7, [SP,#0xC+var_8]

loc_15A4A
ret = R9                ; int
ASR.W           R3, ret, R4
MOVS            R1, #0
STRB.W          R1, [R8,R4,LSL#1]
UXTB.W          LR, R4
which_chain = R14       ; unsigned __int8
ANDS.W          R3, R3, #1
STRB            R1, [R6,#1]
IT EQ
STREQ           R3, [R5]
BNE             loc_15A78

loc_15A64
ADDS            R4, #1
ADDS            R6, #2
CMP             R4, #4
ADD.W           R5, R5, #4
BNE             loc_15A4A
MOVS            R0, #0

loc_15A72
ADD             SP, SP, #0xC
POP.W           {R4-R11,PC}

loc_15A78
which_chain = R14       ; unsigned __int8
LDR             R7, [SP,#0xC+var_C]
MOVS            R3, #1
STR             R3, [R5]
MOVW            R0, #:lower16:aSGchainDGi2cD ; "\n--- %s: gChain = %d, gI2c = %d\n"
MOV             R3, R1
MOV             R2, R4
STRB            R1, [R7]
MOVT            R0, #:upper16:aSGchainDGi2cD ; "\n--- %s: gChain = %d, gI2c = %d\n"
LDR.W           R7, [R10,#(cgpu.chain_num - 0x330FC4)]
LDR             R1, [SP,#0xC+var_8]
STRB.W          LR, [R11]
ADD.W           R12, R7, #1
STRB.W          LR, [R8,R4,LSL#1]
STR.W           R12, [R10,#(cgpu.chain_num - 0x330FC4)]
BLX             printf
B               loc_15A64

loc_15AA8
ret = R0                ; int
MOVW            R1, #:lower16:__FUNCTION__.7893 ; "check_chain"
MOVW            ret, #:lower16:aSTestZhijuOnly ; "\n!!! %s: Test zhiju only support 1 plu"...
ret = R9                ; int
MOV             R2, ret
MOVT            R1, #:upper16:__FUNCTION__.7893 ; "check_chain"
MOVT            R0, #:upper16:aSTestZhijuOnly ; "\n!!! %s: Test zhiju only support 1 plu"...
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_15A72
; End of function check_chain

off_15AC4 DCD cgpu.subid+0x7FD54



; int open_lcd()
EXPORT open_lcd
open_lcd
MOVW            R0, #:lower16:aDevBitmainLcd ; "/dev/bitmain-lcd"
PUSH            {R4,LR}
MOVW            R1, #0x882 ; oflag
MOVT            R0, #:upper16:aDevBitmainLcd ; "/dev/bitmain-lcd"
MOVW            R4, #:lower16:lcd_fd
BLX             open
CMP             R0, #0
MOVT            R4, #:upper16:lcd_fd
STR             R0, [R4]
BLE             loc_15AEA
POP             {R4,PC}

loc_15AEA
MOV             R0, #aOpenLcdFailed ; "open lcd failed!!!"
BLX             puts
LDR             R0, [R4]
POP             {R4,PC}
; End of function open_lcd

ALIGN 4



; int close_lcd()
EXPORT close_lcd
close_lcd
MOVW            R3, #:lower16:lcd_fd
PUSH            {R4,LR}
MOVT            R3, #:upper16:lcd_fd
LDR             R0, [R3] ; fd
BLX             close
ret = R0                ; int
MOV             R4, ret
CBZ             ret, loc_15B20
ret = R4                ; int
MOV             R0, #aLcdCloseFailed ; "lcd close failed!!!"
BLX             puts
MOV             R0, ret
POP             {ret,PC}

loc_15B20
ret = R4                ; int
MOV             R0, #aLcdClosed ; "lcd closed!!!"
BLX             puts
MOV             R0, ret
POP             {ret,PC}
; End of function close_lcd




; void __fastcall write_lcd(unsigned int line, char *buf, unsigned int size)
EXPORT write_lcd
write_lcd
line = R0               ; unsigned int
buf = R1                ; char *
size = R2               ; unsigned int
CMP             buf, #0
BEQ             locret_15BFE
PUSH.W          {R4-R10,LR}
MOV             R7, #lcd_fd
MOV             R5, line
LDR             line, [R7] ; fd
line = R5               ; unsigned int
CMP             R0, #0
BLE             locret_15BFA
CMP             size, #0x40 ; '@'
IT LS
CMPLS           line, #3
MOV             R4, size
ITE HI
MOVHI.W         R8, #1
MOVLS.W         R8, #0
BHI             loc_15BE2
MOV             size, R8 ; whence
size = R4               ; unsigned int
MOV             R6, buf
MOV             buf, R8 ; offset
buf = R6                ; char *
BLX             lseek
MOVW            R0, #:lower16:lcd_output
MOVS            R2, #0x40 ; '@' ; n
MOVT            R0, #:upper16:lcd_output ; s
MOVS            R1, #0x20 ; ' ' ; c
BLX             memset
CBZ             size, loc_15BCE
CMP             size, #0x10
MOVW            R0, #:lower16:lcd_output
MOV             R1, R8
MOVT            R0, #:upper16:lcd_output
BLS             loc_15BC2
MOV.W           R10, line,LSL#4

loc_15B8A
Copied = R1             ; unsigned int
ADDS            R3, buf, Copied
LDR.W           R8, [R3,#4]
SUBS            size, #0x10
LDR.W           R12, [R3,#8]
ADD.W           R2, R10, Copied
LDR.W           LR, [R3,#0xC]
CMP             R4, #0x10
LDR.W           R9, [R3]
ADD.W           R3, R0, R2
ADD.W           line, line, #1
size = R4               ; unsigned int
ADD.W           Copied, Copied, #0x10
STR.W           R9, [R0,R2]
STR.W           R8, [R3,#4]
STR.W           R12, [R3,#8]
STR.W           LR, [R3,#0xC]
BHI             loc_15B8A

loc_15BC2               ; n
MOV             R2, size
ADD             R1, buf ; src
ADD.W           R0, R0, R5,LSL#4 ; dest
BLX             memcpy

loc_15BCE
MOVW            R1, #:lower16:lcd_output
LDR             R0, [R7] ; fd
MOVT            R1, #:upper16:lcd_output ; buf
MOVS            R2, #0x40 ; '@' ; n
POP.W           {size-R10,LR}
B.W             j_write

loc_15BE2
line = R5               ; unsigned int
buf = R1                ; char *
size = R2               ; unsigned int
MOVW            buf, #:lower16:__FUNCTION__.6339 ; "write_lcd"
MOVW            R0, #:lower16:aSWriteLcdSArgI ; "%s: write_lcd's arg is overflow\n"
MOVT            R1, #:upper16:__FUNCTION__.6339 ; "write_lcd"
MOVT            R0, #:upper16:aSWriteLcdSArgI ; "%s: write_lcd's arg is overflow\n"
POP.W           {R4-R10,LR}
B.W             j_printf

locret_15BFA
line = R5               ; unsigned int
buf = R1                ; char *
size = R2               ; unsigned int
POP.W           {R4-R10,PC}

locret_15BFE
line = R0               ; unsigned int
BX              LR
; End of function write_lcd




; void __fastcall write_lcd_no_memset(unsigned int line, char *buf, unsigned int size)
EXPORT write_lcd_no_memset
write_lcd_no_memset
line = R0               ; unsigned int
buf = R1                ; char *
size = R2               ; unsigned int
CMP             buf, #0
BEQ             locret_15CA2
MOVW            R3, #:lower16:lcd_fd
PUSH.W          {R4-R10,LR}
MOVT            R3, #:upper16:lcd_fd
LDR.W           R8, [R3]
CMP.W           R8, #0
BLE             locret_15C8C
CMP             size, #0x40 ; '@'
IT LS
CMPLS           line, #3
ITE HI
MOVHI           R4, #1
MOVLS           R4, #0
BHI             loc_15C90
CBZ             size, loc_15C78
CMP             size, #0x10
MOV             R6, #lcd_output
BLS             loc_15C6E
MOV.W           R10, line,LSL#4

loc_15C3A
Copied = R4             ; unsigned int
ADDS            R3, buf, Copied
LDR.W           R12, [R3,#4]
SUBS            size, #0x10 ; n
LDR.W           LR, [R3,#8]
ADD.W           R5, R10, Copied
LDR             R7, [R3,#0xC]
CMP             R2, #0x10
LDR.W           R9, [R3]
ADD.W           R3, R6, R5
ADD.W           line, line, #1
line = R0               ; unsigned int
size = R2               ; unsigned int
ADD.W           Copied, Copied, #0x10
STR.W           R9, [R6,R5]
STR.W           R12, [R3,#4]
STR.W           LR, [R3,#8]
STR             R7, [R3,#0xC]
BHI             loc_15C3A

loc_15C6E               ; src
ADD             buf, R4
ADD.W           R0, R6, R0,LSL#4 ; dest
BLX             memcpy

loc_15C78
MOVW            R1, #:lower16:lcd_output
MOV             R0, R8  ; fd
MOVT            R1, #:upper16:lcd_output ; buf
MOVS            R2, #0x40 ; '@' ; n
POP.W           {R4-R10,LR}
B.W             j_write

locret_15C8C
line = R0               ; unsigned int
buf = R1                ; char *
size = R2               ; unsigned int
POP.W           {R4-R10,PC}

loc_15C90
MOVW            line, #:lower16:aSWriteLcdSArgI ; "%s: write_lcd's arg is overflow\n"
LDR             buf, =__FUNCTION__.6349 ; "write_lcd_no_memset"
MOVT            R0, #:upper16:aSWriteLcdSArgI ; "%s: write_lcd's arg is overflow\n"
POP.W           {R4-R10,LR}
B.W             j_printf

locret_15CA2
line = R0               ; unsigned int
buf = R1                ; char *
size = R2               ; unsigned int
BX              LR
; End of function write_lcd_no_memset

off_15CA4 DCD __FUNCTION__.6349 ; "write_lcd_no_memset"



; unsigned int __fastcall check_how_many_uart_data_in_fpga(unsigned __int8 which_uart)
EXPORT check_how_many_uart_data_in_fpga
check_how_many_uart_data_in_fpga
which_uart = R0         ; unsigned __int8
PUSH            {R3,LR}
CMP             which_uart, #9 ; switch 10 cases
BHI             def_15CAE ; jumptable 00015CAE default case
TBB.W           [PC,which_uart] ; switch jump
jpt_15CAE DCB 0xB       ; jump table for switch statement
DCB 0x11
DCB 0x17
DCB 0x1D
DCB 0x23
DCB 0x29
DCB 0x2F
DCB 0x35
DCB 0x3B
DCB 5

loc_15CBC               ; jumptable 00015CAE case 9
MOVS            which_uart, #0x80
BL              read_axi_fpga
UBFX.W          R0, R0, #0, #0xA
POP             {R3,PC}

loc_15CC8               ; jumptable 00015CAE case 0
which_uart = R0         ; unsigned __int8
MOVS            which_uart, #0x7C ; '|'
BL              read_axi_fpga
UBFX.W          R0, R0, #0x10, #0xA
POP             {R3,PC}

loc_15CD4               ; jumptable 00015CAE case 1
which_uart = R0         ; unsigned __int8
MOVS            which_uart, #0x7C ; '|'
BL              read_axi_fpga
UBFX.W          R0, R0, #0, #0xA
POP             {R3,PC}

loc_15CE0               ; jumptable 00015CAE case 2
which_uart = R0         ; unsigned __int8
MOVS            which_uart, #0x7D ; '}'
BL              read_axi_fpga
UBFX.W          R0, R0, #0x10, #0xA
POP             {R3,PC}

loc_15CEC               ; jumptable 00015CAE case 3
which_uart = R0         ; unsigned __int8
MOVS            which_uart, #0x7D ; '}'
BL              read_axi_fpga
UBFX.W          R0, R0, #0, #0xA
POP             {R3,PC}

loc_15CF8               ; jumptable 00015CAE case 4
which_uart = R0         ; unsigned __int8
MOVS            which_uart, #0x7E ; '~'
BL              read_axi_fpga
UBFX.W          R0, R0, #0x10, #0xA
POP             {R3,PC}

loc_15D04               ; jumptable 00015CAE case 5
which_uart = R0         ; unsigned __int8
MOVS            which_uart, #0x7E ; '~'
BL              read_axi_fpga
UBFX.W          R0, R0, #0, #0xA
POP             {R3,PC}

loc_15D10               ; jumptable 00015CAE case 6
which_uart = R0         ; unsigned __int8
MOVS            which_uart, #0x7F
BL              read_axi_fpga
UBFX.W          R0, R0, #0x10, #0xA
POP             {R3,PC}

loc_15D1C               ; jumptable 00015CAE case 7
which_uart = R0         ; unsigned __int8
MOVS            which_uart, #0x7F
BL              read_axi_fpga
UBFX.W          R0, R0, #0, #0xA
POP             {R3,PC}

loc_15D28               ; jumptable 00015CAE case 8
which_uart = R0         ; unsigned __int8
MOVS            which_uart, #0x80
BL              read_axi_fpga
UBFX.W          R0, R0, #0x10, #0xA
POP             {R3,PC}

def_15CAE               ; jumptable 00015CAE default case
which_uart = R0         ; unsigned __int8
MOV             R2, which_uart
MOVW            R1, #:lower16:__FUNCTION__.8008 ; "check_how_many_uart_data_in_fpga"
MOVW            which_uart, #:lower16:aSTheUartDIsNot ; "%s: The uart%d is not supported!!!\n"
MOVT            R1, #:upper16:__FUNCTION__.8008 ; "check_how_many_uart_data_in_fpga"
MOVT            R0, #:upper16:aSTheUartDIsNot ; "%s: The uart%d is not supported!!!\n"
BLX             printf
MOVS            R0, #0
POP             {R3,PC}
; End of function check_how_many_uart_data_in_fpga

ALIGN 0x10



; unsigned int __fastcall read_uart_data_in_fpga(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int length)
EXPORT read_uart_data_in_fpga
read_uart_data_in_fpga
which_uart = R0         ; unsigned __int8
buf = R1                ; unsigned __int8 *
length = R2             ; unsigned int
PUSH.W          {R4-R10,LR}
MOV             R9, buf
MOV             R7, length
CMP             which_uart, #9 ; switch 10 cases
BHI             def_15D5C ; jumptable 00015D5C default case
TBB.W           [PC,which_uart] ; switch jump
jpt_15D5C DCB 0x44      ; jump table for switch statement
DCB 5
DCB 0x2C
DCB 0x2F
DCB 0x32
DCB 0x35
DCB 0x38
DCB 0x3B
DCB 0x3E
DCB 0x41

loc_15D6A               ; jumptable 00015D5C case 1
MOVS            R5, #0x87
MOVS            which_uart, #0x86 ; address

loc_15D6E
chain_read_enable_addr = R0; unsigned int
chain_read_data_addr = R5; unsigned int
UBFX.W          buf, R7, #0, #0xA
buf = R9                ; unsigned __int8 *
ORR.W           R1, R1, #0x80000000 ; data
BL              write_axi_fpga
MOVS.W          R10, length,LSR#2
read_loop = R10         ; unsigned int
BEQ             loc_15E4E
MOV.W           R8, read_loop,LSL#2
MOV             R4, buf
ADD.W           R6, buf, R8

loc_15D8A               ; address
MOV             R0, chain_read_data_addr
ADDS            R4, #4
BL              read_axi_fpga
ret_data = R0           ; unsigned int
LSRS            R1, ret_data, #0x18
LSRS            R2, ret_data, #0x10
LSRS            R3, ret_data, #8
STRB.W          ret_data, [R4,#-1]
STRB.W          R1, [R4,#-4]
STRB.W          R2, [R4,#-3]
STRB.W          R3, [R4,#-2]
CMP             R4, R6
BNE             loc_15D8A

loc_15DAC
ret_length = R8         ; unsigned int
ANDS.W          length, length, #3
read_loop = R7          ; unsigned int
BNE             loc_15DEE
MOV             R0, ret_length
POP.W           {R4-R10,PC}

loc_15DB8               ; jumptable 00015D5C case 2
which_uart = R0         ; unsigned __int8
buf = R1                ; unsigned __int8 *
length = R2             ; unsigned int
MOVS            R5, #0x89
MOVS            which_uart, #0x88
B               loc_15D6E

loc_15DBE               ; jumptable 00015D5C case 3
which_uart = R0         ; unsigned __int8
MOVS            R5, #0x8B
MOVS            which_uart, #0x8A
B               loc_15D6E

loc_15DC4               ; jumptable 00015D5C case 4
which_uart = R0         ; unsigned __int8
MOVS            R5, #0x8D
MOVS            which_uart, #0x8C
B               loc_15D6E

loc_15DCA               ; jumptable 00015D5C case 5
which_uart = R0         ; unsigned __int8
MOVS            R5, #0x8F
MOVS            which_uart, #0x8E
B               loc_15D6E

loc_15DD0               ; jumptable 00015D5C case 6
which_uart = R0         ; unsigned __int8
MOVS            R5, #0x91
MOVS            which_uart, #0x90
B               loc_15D6E

loc_15DD6               ; jumptable 00015D5C case 7
which_uart = R0         ; unsigned __int8
MOVS            R5, #0x93
MOVS            which_uart, #0x92
B               loc_15D6E

loc_15DDC               ; jumptable 00015D5C case 8
which_uart = R0         ; unsigned __int8
MOVS            R5, #0x95
MOVS            which_uart, #0x94
B               loc_15D6E

loc_15DE2               ; jumptable 00015D5C case 9
which_uart = R0         ; unsigned __int8
MOVS            R5, #0x97
MOVS            which_uart, #0x96
B               loc_15D6E

loc_15DE8               ; jumptable 00015D5C case 0
which_uart = R0         ; unsigned __int8
MOVS            R5, #0x85
MOVS            which_uart, #0x84
B               loc_15D6E

loc_15DEE               ; address
buf = R9                ; unsigned __int8 *
chain_read_data_addr = R5; unsigned int
read_loop = R7          ; unsigned int
ret_length = R8         ; unsigned int
MOV             R0, chain_read_data_addr
BL              read_axi_fpga
ret_data = R0           ; unsigned int
CMP             read_loop, #2
BEQ             loc_15E38
CMP             read_loop, #3
BNE             loc_15E16
LSRS            R4, ret_data, #0x18
LSRS            R1, ret_data, #0x10
LSRS            R3, ret_data, #8
ADD.W           R2, buf, ret_length
STRB.W          R4, [buf,R10,LSL#2]
ADD.W           ret_data, ret_length, #3
STRB            R1, [R2,#1]
STRB            R3, [R2,#2]
POP.W           {R4-R10,PC}

loc_15E16
ret_data = R0           ; unsigned int
ret_length = R8         ; unsigned int
LSRS            R3, ret_data, #0x18
ADD.W           ret_data, ret_length, #1
STRB.W          R3, [buf,R10,LSL#2]
POP.W           {R4-R10,PC}

def_15D5C               ; jumptable 00015D5C default case
which_uart = R0         ; unsigned __int8
buf = R1                ; unsigned __int8 *
length = R2             ; unsigned int
MOVW            which_uart, #:lower16:aSTheUartIsNotS ; "%s: The uart is not supported!!!\n"
LDR             buf, =__FUNCTION__.8033 ; "read_uart_data_in_fpga"
buf = R9                ; unsigned __int8 *
MOVT            R0, #:upper16:aSTheUartIsNotS ; "%s: The uart is not supported!!!\n"
BLX             printf
MOVS            R0, #0
POP.W           {R4-R10,PC}

loc_15E38
chain_read_data_addr = R5; unsigned int
read_loop = R7          ; unsigned int
ret_data = R0           ; unsigned int
ret_length = R8         ; unsigned int
LSRS            R1, ret_data, #0x18
LSRS            R3, ret_data, #0x10
ADD.W           R2, buf, ret_length
STRB.W          R1, [buf,R10,LSL#2]
ADD.W           ret_data, ret_length, #2
STRB            R3, [R2,#1]
POP.W           {R4-R10,PC}

loc_15E4E
length = R7             ; unsigned int
read_loop = R10         ; unsigned int
MOV             R8, read_loop
B               loc_15DAC
; End of function read_uart_data_in_fpga

ALIGN 4
off_15E54 DCD __FUNCTION__.8033 ; "read_uart_data_in_fpga"



; unsigned int __fastcall uart_send(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int length)
EXPORT uart_send
uart_send

buf= -0x208
send_buf= -0x204

which_uart = R0         ; unsigned __int8
buf_0 = R1              ; unsigned __int8 *
length = R2             ; unsigned int
send_data_len = R6      ; unsigned int
PUSH.W          {R4-R11,LR}
SUB.W           SP, SP, #0x20C
MOV             R11, which_uart
STR             buf_0, [SP,#0x20C+buf]
MOV             send_data_len, length
ADD             which_uart, SP, #0x20C+send_buf ; s
MOV.W           length, #0x200 ; n
MOVS            buf_0, #0 ; c
BLX             memset
MOVW            R9, #:lower16:uart_send_mutex
ADD.W           R3, R11, R11,LSL#1
MOVT            R9, #:upper16:uart_send_mutex
ADD.W           R9, R9, R3,LSL#3
MOV             R0, R9  ; mutex
BLX             pthread_mutex_lock
CMP.W           R11, #9 ; switch 10 cases
BHI.W           def_15E90 ; jumptable 00015E90 default case
TBB.W           [PC,R11] ; switch jump
jpt_15E90 DCB 0x5B      ; jump table for switch statement
DCB 0x62
DCB 5
DCB 0x2A
DCB 0x31
DCB 0x38
DCB 0x3F
DCB 0x46
DCB 0x4D
DCB 0x54

loc_15E9E               ; jumptable 00015E90 case 2
MOV.W           R8, #8
MOVS            R5, #0x69 ; 'i'
MOV.W           R10, #0x68 ; 'h'
MOVS            R7, #0x60 ; '`'

loc_15EAA
chain_send_fifo_status_addr = R7; unsigned int
chain_send_ready_addr = R10; unsigned int
chain_send_buffer_addr = R5; unsigned int
bit_shift_num = R8      ; unsigned int
MOVS            R4, #0x15

loc_15EAC               ; address
MOV             R0, chain_send_fifo_status_addr
BL              read_axi_fpga
LSR.W           R3, R0, bit_shift_num
MOVW            R0, #0xBB8 ; useconds
UXTB            R3, R3
CMP             send_data_len, R3
BLS             loc_15F66
BLX             usleep
SUBS            R4, #1
BNE             loc_15EAC
MOV             R0, R9  ; mutex
BLX             pthread_mutex_unlock
MOVW            R0, #:lower16:aSUartDAlwaysDo ; "%s: uart%d always dose not has enough s"...
MOV             R2, R11
LDR             R1, =__FUNCTION__.8070 ; "uart_send"
MOVT            R0, #:upper16:aSUartDAlwaysDo ; "%s: uart%d always dose not has enough s"...
BLX             printf
MOV             R0, R4

loc_15EE0
ADD.W           SP, SP, #0x20C
POP.W           {R4-R11,PC}

loc_15EE8               ; jumptable 00015E90 case 3
MOV.W           R8, #0
MOVS            R5, #0x6B ; 'k'
MOV.W           R10, #0x6A ; 'j'
MOVS            R7, #0x60 ; '`'
B               loc_15EAA

loc_15EF6               ; jumptable 00015E90 case 4
MOV.W           R8, #0x18
MOVS            R5, #0x6D ; 'm'
MOV.W           R10, #0x6C ; 'l'
MOVS            R7, #0x61 ; 'a'
B               loc_15EAA

loc_15F04               ; jumptable 00015E90 case 5
MOV.W           R8, #0x10
MOVS            R5, #0x6F ; 'o'
MOV.W           R10, #0x6E ; 'n'
MOVS            R7, #0x61 ; 'a'
B               loc_15EAA

loc_15F12               ; jumptable 00015E90 case 6
MOV.W           R8, #8
MOVS            R5, #0x71 ; 'q'
MOV.W           R10, #0x70 ; 'p'
MOVS            R7, #0x61 ; 'a'
B               loc_15EAA

loc_15F20               ; jumptable 00015E90 case 7
MOV.W           R8, #0
MOVS            R5, #0x73 ; 's'
MOV.W           R10, #0x72 ; 'r'
MOVS            R7, #0x61 ; 'a'
B               loc_15EAA

loc_15F2E               ; jumptable 00015E90 case 8
MOV.W           R8, #0x18
MOVS            R5, #0x75 ; 'u'
MOV.W           R10, #0x74 ; 't'
MOVS            R7, #0x62 ; 'b'
B               loc_15EAA

loc_15F3C               ; jumptable 00015E90 case 9
MOV.W           R8, #0x10
MOVS            R5, #0x77 ; 'w'
MOV.W           R10, #0x76 ; 'v'
MOVS            R7, #0x62 ; 'b'
B               loc_15EAA

loc_15F4A               ; jumptable 00015E90 case 0
MOV.W           R8, #0x18
MOVS            R5, #0x65 ; 'e'
MOV.W           R10, #0x64 ; 'd'
MOVS            R7, #0x60 ; '`'
B               loc_15EAA

loc_15F58               ; jumptable 00015E90 case 1
MOV.W           R8, #0x10
MOVS            R5, #0x67 ; 'g'
MOV.W           R10, #0x66 ; 'f'
MOVS            R7, #0x60 ; '`'
B               loc_15EAA

loc_15F66
chain_send_fifo_status_addr = R7; unsigned int
chain_send_ready_addr = R10; unsigned int
chain_send_buffer_addr = R5; unsigned int
bit_shift_num = R8      ; unsigned int
MOVS            R4, #0x16
B               loc_15F72

loc_15F6A
SUBS            R4, #1
BEQ             loc_15FF2
BLX             usleep

loc_15F72               ; address
MOV             R0, chain_send_ready_addr
BL              read_axi_fpga
CMP             R0, #0
MOVW            R0, #0xBB8 ; useconds
BLT             loc_15F6A
LDR             R1, [SP,#0x20C+buf] ; src
MOV             R2, send_data_len ; n
ADD             R0, SP, #0x20C+send_buf ; dest
BLX             memcpy
LSRS            chain_send_fifo_status_addr, send_data_len, #2
send_loop = R7          ; int
BEQ             loc_15FBC
ADD             R4, SP, #0x20C+send_buf
MOV.W           bit_shift_num, #0

loc_15F94
i = R8                  ; int
LDRB            R3, [R4,#1]
ADD.W           i, i, #1
LDRB.W          LR, [R4]
MOV             R0, chain_send_buffer_addr ; address
LDRB            R2, [R4,#3]
ADDS            R4, #4
LDRB.W          R1, [R4,#-2]
LSLS            R3, R3, #0x10
ORR.W           R3, R3, LR,LSL#24
ORRS            R3, R2
ORR.W           R1, R3, R1,LSL#8 ; data
BL              write_axi_fpga
i = R8                  ; int
CMP             send_loop, i
BNE             loc_15F94

loc_15FBC
ANDS.W          R3, send_data_len, #3
send_loop = R3          ; int
BEQ             loc_15FD8
CMP             send_loop, #2
BEQ             loc_1603E
CMP             send_loop, #3
ADD             send_loop, SP, #0x20C+send_buf
BEQ             loc_16024
LDRB.W          R1, [R3,R7,LSL#2]
LSLS            R1, R1, #0x18 ; data

loc_15FD2               ; address
send_data = R1          ; unsigned int
MOV             R0, chain_send_buffer_addr
BL              write_axi_fpga

loc_15FD8               ; address
MOV             R0, chain_send_ready_addr
ORR.W           R1, send_data_len, #0x80000000 ; data
BL              write_axi_fpga
MOV             R0, R9  ; mutex
BLX             pthread_mutex_unlock
MOV             R0, send_data_len
ADD.W           SP, SP, #0x20C
POP.W           {R4-R11,PC}

loc_15FF2               ; mutex
chain_send_fifo_status_addr = R7; unsigned int
bit_shift_num = R8      ; unsigned int
MOV             R0, R9
BLX             pthread_mutex_unlock
MOVW            R0, #:lower16:aSUartDAlwaysBu ; "%s: uart%d always busy, break\n"
MOV             R2, R11
LDR             R1, =__FUNCTION__.8070 ; "uart_send"
MOVT            R0, #:upper16:aSUartDAlwaysBu ; "%s: uart%d always busy, break\n"
BLX             printf
MOV             R0, R4
ADD.W           SP, SP, #0x20C
POP.W           {R4-R11,PC}

def_15E90               ; jumptable 00015E90 default case
MOVW            R0, #:lower16:aSTheUartIsNotS ; "%s: The uart is not supported!!!\n"
LDR             R1, =__FUNCTION__.8070 ; "uart_send"
MOVT            R0, #:upper16:aSTheUartIsNotS ; "%s: The uart is not supported!!!\n"
BLX             printf
MOVS            R0, #0
B               loc_15EE0

loc_16024
chain_send_ready_addr = R10; unsigned int
chain_send_buffer_addr = R5; unsigned int
ADD.W           R3, R3, R7,LSL#2
ADD             R2, SP, #0x20C+send_buf
LDRB.W          R2, [R2,R7,LSL#2]
LDRB            R1, [R3,#2]
LDRB            R3, [R3,#1]
LSLS            R1, R1, #8
ORR.W           R1, R1, R3,LSL#16
ORR.W           R1, R1, R2,LSL#24
send_data = R1          ; unsigned int
B               loc_15FD2

loc_1603E
send_loop = R3          ; int
ADD             send_loop, SP, #0x20C+send_buf
ADD             R2, SP, #0x20C+send_buf
ADD.W           R3, R3, R7,LSL#2
LDRB.W          R1, [R2,R7,LSL#2]
LDRB            R3, [R3,#1]
LSLS            R1, R1, #0x18
ORR.W           R1, R1, R3,LSL#16
send_data = R1          ; unsigned int
B               loc_15FD2
; End of function uart_send

off_16054 DCD __FUNCTION__.8070 ; "uart_send"



; unsigned int __fastcall uart_receive(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int buf_length)
EXPORT uart_receive
uart_receive
which_uart = R0         ; unsigned __int8
buf = R1                ; unsigned __int8 *
buf_length = R2         ; unsigned int
PUSH.W          {R4-R8,LR}
ADD.W           R3, which_uart, which_uart,LSL#1
LDR             R4, =uart_receive_mutex
MOV             R5, which_uart
MOV             R6, buf_length
MOV             R8, buf
ADD.W           R4, R4, R3,LSL#3
MOV             which_uart, R4 ; mutex
BLX             pthread_mutex_lock
MOVW            R3, #:lower16:Conf
MOVW            R2, #0x569
MOVT            R3, #:upper16:Conf
MOV             R0, R5  ; which_uart
LDR             R3, [R3,#configuration.AsicType]
CMP             R3, R2
BEQ             loc_160CA
BL              check_how_many_uart_data_in_fpga
nbytes = R0             ; unsigned int
CMP             buf_length, nbytes
IT CS
MOVCS           R2, #0  ; length
BCC             loc_160A8

loc_16092               ; buf
MOV             R1, buf
MOV             R0, R5  ; which_uart
BL              read_uart_data_in_fpga
MOV             R5, R0
len = R0                ; unsigned int
MOV             len, R4 ; mutex
len = R5                ; unsigned int
BLX             pthread_mutex_unlock
MOV             R0, len
POP.W           {R4-buf,PC}

loc_160A8
nbytes = R0             ; unsigned int
MOVS            R7, #0

loc_160AA
nbytes = R6             ; unsigned int
MOVW            R0, #:lower16:aSNbytesBufLeng ; "%s: nbytes > buf_length\n"
LDR             R1, =__FUNCTION__.8092 ; "uart_receive"
MOVT            R0, #:upper16:aSNbytesBufLeng ; "%s: nbytes > buf_length\n"
BLX             printf
MOV             R0, nbytes

loc_160BA
buf_length = R6         ; unsigned int
nbytes = R0             ; unsigned int
CMP             nbytes, R7
BCS             loc_160D8
MOV             nbytes, R4 ; mutex
BLX             pthread_mutex_unlock
MOVS            R0, #0
POP.W           {R4-buf,PC}

loc_160CA
BL              check_how_many_uart_data_in_fpga
nbytes = R0             ; unsigned int
CMP             nbytes, buf_length
MOV.W           R7, #5
BLS             loc_160BA
B               loc_160AA

loc_160D8
MOV             R1, R7
BL              __aeabi_uidiv
MUL             R2, R7, R0
B               loc_16092
; End of function uart_receive

off_160E4 DCD uart_receive_mutex
off_160E8 DCD __FUNCTION__.8092 ; "uart_receive"



; unsigned int __fastcall clear_uart_send_fifo(unsigned __int8 which_chain)
EXPORT clear_uart_send_fifo
clear_uart_send_fifo
which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R10,LR}
MOVW            R3, #:lower16:uart_send_mutex
ADD.W           R10, which_chain, which_chain,LSL#1
MOVT            R3, #:upper16:uart_send_mutex
MOV             R6, which_chain
ADD.W           R10, R3, R10,LSL#3
MOV             which_chain, R10 ; mutex
BLX             pthread_mutex_lock
CMP             R6, #9  ; switch 10 cases
BHI             def_1610C ; jumptable 0001610C default case
TBB.W           [PC,R6] ; switch jump
jpt_1610C DCB 0x69      ; jump table for switch statement
DCB 0x70
DCB 5
DCB 0x38
DCB 0x3F
DCB 0x46
DCB 0x4D
DCB 0x54
DCB 0x5B
DCB 0x62

loc_1611A               ; jumptable 0001610C case 2
MOV.W           R9, #8
MOVS            R3, #0x69 ; 'i'
MOVS            R2, #0x68 ; 'h'
MOV.W           R8, #0x60 ; '`'

loc_16126
chain_send_fifo_status_addr = R8; unsigned int
chain_send_ready_addr = R2; unsigned int
chain_send_buffer_addr = R3; unsigned int
bit_shift_num = R9      ; unsigned int
MOVW            R0, #:lower16:aSChainSendRead ; "--- %s: chain_send_ready_addr %d, chain"...
MOVW            R7, #:lower16:aSWaitingFpgaUa ; "%s: waiting fpga uart%d clear send fifo"...
MOVT            R0, #:upper16:aSChainSendRead ; "--- %s: chain_send_ready_addr %d, chain"...
LDR             R1, =__FUNCTION__.8114 ; "clear_uart_send_fifo"
MOVT            R7, #:upper16:aSWaitingFpgaUa ; "%s: waiting fpga uart%d clear send fifo"...
MOVS            R5, #0x15
BLX             printf

loc_1613E               ; address
MOV             R0, chain_send_fifo_status_addr
BL              read_axi_fpga
LSR.W           R4, R0, bit_shift_num
MOV             R2, R6
LDR             R1, =__FUNCTION__.8114 ; "clear_uart_send_fifo"
MOV             R0, R7  ; format
UXTB            R4, R4
max_fpga_can_send_uart_data_len = R4; unsigned int
CMP             max_fpga_can_send_uart_data_len, #0xFF
BEQ             loc_161FE
BLX             printf
MOVW            R0, #0xBB8 ; useconds
BLX             usleep
SUBS            R5, #1
BNE             loc_1613E
MOVW            R0, #:lower16:aSUartDAlwaysDo ; "%s: uart%d always dose not has enough s"...
MOV             R2, R6
LDR             R1, =__FUNCTION__.8114 ; "clear_uart_send_fifo"
MOVT            R0, #:upper16:aSUartDAlwaysDo ; "%s: uart%d always dose not has enough s"...
BLX             printf
MOV             R0, R10 ; mutex
BLX             pthread_mutex_unlock
MOV             R0, max_fpga_can_send_uart_data_len
POP.W           {max_fpga_can_send_uart_data_len-R10,PC}

loc_16180               ; jumptable 0001610C case 3
MOV.W           R9, #0
MOVS            R3, #0x6B ; 'k'
MOVS            R2, #0x6A ; 'j'
MOV.W           R8, #0x60 ; '`'
B               loc_16126

loc_1618E               ; jumptable 0001610C case 4
MOV.W           R9, #0x18
MOVS            R3, #0x6D ; 'm'
MOVS            R2, #0x6C ; 'l'
MOV.W           R8, #0x61 ; 'a'
B               loc_16126

loc_1619C               ; jumptable 0001610C case 5
MOV.W           R9, #0x10
MOVS            R3, #0x6F ; 'o'
MOVS            R2, #0x6E ; 'n'
MOV.W           R8, #0x61 ; 'a'
B               loc_16126

loc_161AA               ; jumptable 0001610C case 6
MOV.W           R9, #8
MOVS            R3, #0x71 ; 'q'
MOVS            R2, #0x70 ; 'p'
MOV.W           R8, #0x61 ; 'a'
B               loc_16126

loc_161B8               ; jumptable 0001610C case 7
MOV.W           R9, #0
MOVS            R3, #0x73 ; 's'
MOVS            R2, #0x72 ; 'r'
MOV.W           R8, #0x61 ; 'a'
B               loc_16126

loc_161C6               ; jumptable 0001610C case 8
MOV.W           R9, #0x18
MOVS            R3, #0x75 ; 'u'
MOVS            R2, #0x74 ; 't'
MOV.W           R8, #0x62 ; 'b'
B               loc_16126

loc_161D4               ; jumptable 0001610C case 9
MOV.W           R9, #0x10
MOVS            R3, #0x77 ; 'w'
MOVS            R2, #0x76 ; 'v'
MOV.W           R8, #0x62 ; 'b'
B               loc_16126

loc_161E2               ; jumptable 0001610C case 0
MOV.W           R9, #0x18
MOVS            R3, #0x65 ; 'e'
MOVS            R2, #0x64 ; 'd'
MOV.W           R8, #0x60 ; '`'
B               loc_16126

loc_161F0               ; jumptable 0001610C case 1
MOV.W           R9, #0x10
MOVS            R3, #0x67 ; 'g'
MOVS            R2, #0x66 ; 'f'
MOV.W           R8, #0x60 ; '`'
B               loc_16126

loc_161FE               ; mutex
chain_send_fifo_status_addr = R8; unsigned int
max_fpga_can_send_uart_data_len = R4; unsigned int
bit_shift_num = R9      ; unsigned int
MOV             R0, R10
BLX             pthread_mutex_unlock
MOVS            R0, #0
POP.W           {max_fpga_can_send_uart_data_len-R10,PC}

def_1610C               ; jumptable 0001610C default case
MOVW            R0, #:lower16:aSTheUartDIsNot ; "%s: The uart%d is not supported!!!\n"
MOV             R2, R6
LDR             R1, =__FUNCTION__.8114 ; "clear_uart_send_fifo"
MOVT            R0, #:upper16:aSTheUartDIsNot ; "%s: The uart%d is not supported!!!\n"
BLX             printf
MOV             R0, R10 ; mutex
BLX             pthread_mutex_unlock
MOVS            R0, #1
POP.W           {R4-R10,PC}
; End of function clear_uart_send_fifo

ALIGN 4
off_16228 DCD __FUNCTION__.8114 ; "clear_uart_send_fifo"



; unsigned int __fastcall clear_uart_rx_fifo(unsigned __int8 which_chain)
EXPORT clear_uart_rx_fifo
clear_uart_rx_fifo

var_C= -0xC

which_chain = R0        ; unsigned __int8
PUSH            {R4-R7,LR}
MOV             R5, which_chain
LDR             R4, =uart_receive_mutex
MOVW            which_chain, #:lower16:aS_0 ; "--- %s\n"
SUB             SP, SP, #0xC
MOVT            R0, #:upper16:aS_0 ; "--- %s\n"
LDR             R1, =__FUNCTION__.8122 ; "clear_uart_rx_fifo"
BLX             printf
ADD.W           R3, R5, R5,LSL#1
ADD.W           R4, R4, R3,LSL#3
MOV             R0, R4  ; mutex
BLX             pthread_mutex_lock
MOV             R0, R5  ; which_uart
BL              check_how_many_uart_data_in_fpga
nbytes = R0             ; unsigned int
MOV             R6, nbytes
CBZ             nbytes, loc_162A0
BLX             malloc
buf = R0                ; unsigned __int8 *
MOV             R7, buf
CBZ             buf, loc_162AC
MOV             R1, buf ; buf
MOV             R2, nbytes ; length
MOV             buf, R5 ; which_uart
buf = R1                ; unsigned __int8 *
BL              read_uart_data_in_fpga
CMP             nbytes, R0
MOV             R3, R0
len = R0                ; unsigned int
BEQ             loc_16286
MOVW            len, #:lower16:aSUartDClearRxF ; "%s: uart%d clear rx fifo error. nbytes "...
len = R3                ; unsigned int
STR             len, [SP,#0xC+var_C]
MOV             R2, R5
MOV             len, nbytes
MOVT            R0, #:upper16:aSUartDClearRxF ; "%s: uart%d clear rx fifo error. nbytes "...
LDR             R1, =__FUNCTION__.8122 ; "clear_uart_rx_fifo"
BLX             printf

loc_16286               ; ptr
MOV             R0, buf
BLX             free
MOVW            R0, #0x2710 ; useconds
BLX             usleep
MOV             R0, R4  ; mutex
BLX             pthread_mutex_unlock
MOVS            R0, #1

loc_1629C
ADD             SP, SP, #0xC
POP             {R4-R7,PC}

loc_162A0               ; mutex
nbytes = R0             ; unsigned int
MOV             nbytes, R4
nbytes = R6             ; unsigned int
BLX             pthread_mutex_unlock
MOV             R0, nbytes
ADD             SP, SP, #0xC
POP             {R4-R7,PC}

loc_162AC
buf = R0                ; unsigned __int8 *
MOVW            buf, #:lower16:aSUartDMallocBu ; "%s: uart%d malloc buffer error\n"
buf = R7                ; unsigned __int8 *
MOV             R2, R5
LDR             R1, =__FUNCTION__.8122 ; "clear_uart_rx_fifo"
MOVT            R0, #:upper16:aSUartDMallocBu ; "%s: uart%d malloc buffer error\n"
BLX             printf
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
MOV             R0, R4  ; mutex
BLX             pthread_mutex_unlock
MOVS            R0, #1
B               loc_1629C
; End of function clear_uart_rx_fifo

ALIGN 4
off_162D4 DCD uart_receive_mutex
off_162D8 DCD __FUNCTION__.8122 ; "clear_uart_rx_fifo"



; void single_asic_test()
EXPORT single_asic_test
single_asic_test
PUSH            {R3,LR}
MOV             R3, #Conf
MOVW            R2, #0x569
LDR             R1, [R3,#configuration.AsicType]
CMP             R1, R2
BEQ             loc_16326
SUB.W           R3, R1, #0x3640
SUBS            R3, #0x17
CMP             R3, #1
BLS             loc_1633A
MOVW            R3, #0x575
CMP             R1, R3
BEQ             loc_16312
MOVW            R0, #:lower16:aSingleAsicTest ; "Single ASIC test: Can't find ASIC type!"...
POP.W           {R3,LR}
MOVT            R0, #:upper16:aSingleAsicTest ; "Single ASIC test: Can't find ASIC type!"...
B.W             j_printf

loc_16312
MOV             R0, #aBeginSingleasi ; "\nBegin singleAsicTest_BM1397\n"
BLX             puts
POP.W           {R3,LR}
B.W             singleAsicTest_BM1397

loc_16326
MOV             R0, #aBeginSingleasi_0 ; "\nBegin singleAsicTest_BM1385\n"
BLX             puts
POP.W           {R3,LR}
B.W             singleAsicTest_BM1385

loc_1633A
MOV             R0, #aBeginSingleasi_1 ; "\nBegin singleAsicTest_BM1391\n"
BLX             puts
POP.W           {R3,LR}
B.W             singleAsicTest_BM1391
; End of function single_asic_test

ALIGN 0x10



; void hash_board_test()
EXPORT hash_board_test
hash_board_test
PUSH.W          {R3-R9,LR}
MOVW            R6, #:lower16:gHashBoard_V9
MOVW            R5, #:lower16:pattern_test_time
MOVW            R7, #:lower16:gHashBoard_BHB91601P
MOVW            R8, #:lower16:gHashBoard_BHB91601S
MOVW            R9, #:lower16:gHashBoard_BHB91603S
MOVT            R6, #:upper16:gHashBoard_V9
MOVT            R5, #:upper16:pattern_test_time
MOVT            R7, #:upper16:gHashBoard_BHB91601P
MOVT            R8, #:upper16:gHashBoard_BHB91601S
MOVT            R9, #:upper16:gHashBoard_BHB91603S
B               loc_163CA

loc_1637E
LDRB            R3, [R7]
CBNZ            R3, loc_163DE
LDRB.W          R3, [R8]
CBNZ            R3, loc_163DE
LDRB.W          R2, [R9]
MOV             R3, #gHashBoard_BHB07601
CBNZ            R2, loc_163E4
LDRB            R3, [R3]
CBZ             R3, loc_163EA
BL              singleBoardTest_BHB07601_BM1397

loc_1639E
MOVW            R4, #:lower16:gHowManyVoltageLevel
MOVW            R1, #:lower16:__FUNCTION__.8156 ; "hash_board_test"
MOVT            R4, #:upper16:gHowManyVoltageLevel
MOVW            R0, #:lower16:aSPatternTestTi_0 ; "%s: pattern_test_time %d, gHowManyVolta"...
LDRB            R3, [R4]
MOVT            R1, #:upper16:__FUNCTION__.8156 ; "hash_board_test"
LDRB            R2, [R5]
MOVT            R0, #:upper16:aSPatternTestTi_0 ; "%s: pattern_test_time %d, gHowManyVolta"...
BLX             printf
LDRB            R2, [R4]
LDRB            R3, [R5]
CMP             R3, #0
IT NE
CMPNE           R2, R3
BLS             loc_163FE

loc_163CA               ; useconds
MOVW            R0, #0x2710
BLX             usleep
LDRB            R3, [R6]
CMP             R3, #0
BEQ             loc_1637E
BL              singleBoardTest_V9_BM1385_45
B               loc_1639E

loc_163DE
BL              singleBoardTest_BHB91601_BM1391
B               loc_1639E

loc_163E4
BL              singleBoardTest_BHB91603_BM1391
B               loc_1639E

loc_163EA
MOVW            R1, #:lower16:__FUNCTION__.8156 ; "hash_board_test"
MOVW            R0, #:lower16:aSPleaseConfigH ; "%s: Please config HashBoard name in Con"...
MOVT            R1, #:upper16:__FUNCTION__.8156 ; "hash_board_test"
MOVT            R0, #:upper16:aSPleaseConfigH ; "%s: Please config HashBoard name in Con"...
BLX             printf

loc_163FE
MOVS            R3, #0
STRB            R3, [R5]
POP.W           {R3-R9,PC}
; End of function hash_board_test

ALIGN 4


; Attributes: noreturn

; void *__fastcall __noreturn BHB91603_show_status_func(void *arg)
EXPORT BHB91603_show_status_func
BHB91603_show_status_func

var_28= -0x28
var_24= -0x24
var_20= -0x20
var_1C= -0x1C
var_18= -0x18
var_14= -0x14
var_10= -0x10
var_C= -0xC
var_8= -8

arg = R0                ; void *
which_chain = R8        ; unsigned __int8
MOVW            R2, #:lower16:gIsReadTemp
PUSH.W          {R4-R11,LR}
MOV             R4, R2
MOVW            R2, #:lower16:gIsOpenCoreEnd
MOV             R5, R2
SUB             SP, SP, #0x2C
MOV             LR, R4
MOVT            R5, #:upper16:gIsOpenCoreEnd
MOVW            R4, #:lower16:gReadingTemp
STR             R5, [SP,#0x2C+var_20]
MOV             R5, R4
MOVW            R4, #:lower16:Sensor2_temp
MOVT            R5, #:upper16:gReadingTemp
LDRB.W          which_chain, [arg]
STR             R5, [SP,#0x2C+var_14]
MOV             R5, R4
MOVT            R5, #:upper16:Sensor2_temp
MOVW            R4, #:lower16:Sensor1_temp
STR             R5, [SP,#0x2C+var_18]
MOV             R5, R4
MOVW            R4, #:lower16:Sensor4_temp
MOV             R3, arg
chain_info = R0         ; chain_info *
MOVT            R4, #:upper16:Sensor4_temp
MOVW            R1, #:lower16:__FUNCTION__.8281 ; "BHB91603_show_status_func"
STR             R4, [SP,#0x2C+var_8]
MOVW            chain_info, #:lower16:aSWhichChainDWh_0 ; "\n--- %s: which_chain = %d, which_i2c ="...
chain_info = R3         ; chain_info *
MOVW            R4, #:lower16:Sensor3_temp
LDRB            chain_info, [chain_info,#1]
which_i2c = R3          ; unsigned __int8
MOVT            LR, #:upper16:gIsReadTemp
MOVT            R5, #:upper16:Sensor1_temp
MOVT            R4, #:upper16:Sensor3_temp
MOV             R2, which_chain
MOVT            R1, #:upper16:__FUNCTION__.8281 ; "BHB91603_show_status_func"
MOVT            R0, #:upper16:aSWhichChainDWh_0 ; "\n--- %s: which_chain = %d, which_i2c ="...
STR             R5, [SP,#0x2C+var_24]
MOVW            R6, #:lower16:Conf
STR             R4, [SP,#0x2C+var_C]
MOVW            R4, #:lower16:time_counter
LDR             R7, =(lcd_output+0x20)
MOVW            R9, #:lower16:gValid_Nonce_Num
STR.W           LR, [SP,#0x2C+var_28]
MOVW            R11, #:lower16:lcd_fd
BLX             printf
MOVW            R3, #0xCCCD
MOVW            R10, #:lower16:gStartTest
MOVT            R3, #0xCCCC
MOVT            R4, #:upper16:time_counter
STR             R3, [SP,#0x2C+var_1C]
MOVS            R3, #0
MOVT            R6, #:upper16:Conf
MOVT            R9, #:upper16:gValid_Nonce_Num
MOVT            R11, #:upper16:lcd_fd
MOVT            R10, #:upper16:gStartTest
SUB.W           R5, R7, #0x20 ; ' '
STR             R3, [R4]
B               loc_16500

loc_164BE
MOV             LR, #aTempSettingErr ; "temp setting err!"
LDM.W           LR!, {R0-R3} ; "temp setting err!"
LDRH.W          LR, [LR] ; "!"
STR             R0, [R7]
STR             R1, [R7,#(lcd_output+0x24 - 0x309AC)]
STRH.W          LR, [R7,#(lcd_output+0x30 - 0x309AC)]
STR             R2, [R7,#(lcd_output+0x28 - 0x309AC)]
STR             R3, [R7,#(lcd_output+0x2C - 0x309AC)]

loc_164DA
LDR             R3, [R4]
MOVS            R2, #0x40 ; '@' ; n
MOV             R1, R5  ; buf
LDR.W           R0, [R11] ; fd
ADDS            R3, #1
STR             R3, [R4]
BLX             write
LDRB.W          R3, [R10]
CMP             R3, #0
BNE             loc_165AE

loc_164F4               ; useconds
MOV             R0, #(gAsic_Core_Nonce_Num+0xC33FC)
BLX             usleep

loc_16500               ; n
MOVS            R2, #0x40 ; '@'
MOVS            R1, #0x20 ; ' ' ; c
MOV             R0, R5  ; s
BLX             memset
LDR             R3, =(cgpu.subid+0x7FD54)
LDRB.W          R0, [R3,#(cgpu.fan_speed - 0x330FC4)] ; level
BL              fan_control
LDR             R3, [SP,#0x2C+var_28]
LDR             R2, [R4]
LDRB            R3, [R3]
CBZ             R3, loc_16534
LDR             R3, [SP,#0x2C+var_20]
LDRB            R3, [R3]
CBZ             R3, loc_16534
LDR             R3, [SP,#0x2C+var_1C]
UMULL           R0, R1, R2, R3
LSRS            R3, R1, #3
ADD.W           R3, R3, R3,LSL#2
SUBS.W          R3, R2, R3,LSL#1
BEQ             loc_165E6

loc_16534
MOVW            R1, #:lower16:aTimeDs ; "   time %ds"
MOV             R0, R5  ; s
MOVT            R1, #:upper16:aTimeDs ; "   time %ds"
BLX             sprintf
MOVW            R1, #:lower16:aNonceD ; "   nonce=%d"
LDR.W           R2, [R9,which_chain,LSL#2]
MOVT            R1, #:upper16:aNonceD ; "   nonce=%d"
LDR             R0, =(lcd_output+0x10) ; s
BLX             sprintf
LDR.W           R3, [R6,#configuration.TempSensor1]
CMP             R3, #0
BEQ             loc_164BE
LDR.W           R3, [R6,#configuration.TempSensor2]
CBZ             R3, loc_1659A
LDR.W           R3, [R6,#configuration.TempSensor3]
CBZ             R3, loc_165C0
LDR.W           R3, [R6,#configuration.TempSensor4]
MOVW            R1, #:lower16:aT1DT2D ; " T1:%d   T2:%d"
CMP             R3, #0
BNE             loc_1660C
LDR             R3, [SP,#0x2C+var_18]
MOVT            R1, #:upper16:aT1DT2D ; " T1:%d   T2:%d"
LDR             R2, [SP,#0x2C+var_24]
LDR             R0, =(lcd_output+0x20) ; s
LDR             R3, [R3]
LDR             R2, [R2]
BLX             sprintf
LDR             R3, [SP,#0x2C+var_C]
MOV             R1, #aT3D ; " T3:%d"
LDR             R0, =(lcd_output+0x30) ; s
LDR             R2, [R3]
BLX             sprintf
B               loc_164DA

loc_1659A
LDR             R3, [SP,#0x2C+var_24]
MOV             R1, #aT1DC ; "   T1 %d `C"
LDR             R0, =(lcd_output+0x20) ; s
LDR             R2, [R3]
BLX             sprintf
B               loc_164DA

loc_165AE
MOVW            R0, #:lower16:aGvalidNonceNum ; "\ngValid_Nonce_Num = %d\n"
LDR.W           R1, [R9,which_chain,LSL#2]
MOVT            R0, #:upper16:aGvalidNonceNum ; "\ngValid_Nonce_Num = %d\n"
BLX             printf
B               loc_164F4

loc_165C0
LDR             R3, [SP,#0x2C+var_24]
MOV             R1, #aT1DC ; "   T1 %d `C"
LDR             R0, =(lcd_output+0x20) ; s
LDR             R2, [R3]
BLX             sprintf
LDR             R3, [SP,#0x2C+var_18]
MOV             R1, #aT2DC ; "   T2 %d `C"
LDR             R0, =(lcd_output+0x30) ; s
LDR             R2, [R3]
BLX             sprintf
B               loc_164DA

loc_165E6
LDR.W           R0, [R6,#configuration.timeout]
MOVS            R2, #1
STR             R3, [SP,#0x2C+var_10]
LDR             R3, [SP,#0x2C+var_14]
RSB.W           R0, R0, R0,LSL#4 ; useconds
STRB            R2, [R3]
BLX             usleep
MOV             R0, which_chain ; which_chain
BL              BM1391_read_asic_temperature_local
LDR             R3, [SP,#0x2C+var_14]
LDR             R2, [R4]
MOV             R1, R3
LDR             R3, [SP,#0x2C+var_10]
STRB            R3, [R1]
B               loc_16534

loc_1660C
LDR             R3, [SP,#0x2C+var_18]
MOVT            R1, #:upper16:aT1DT2D ; " T1:%d   T2:%d"
LDR             R2, [SP,#0x2C+var_24]
LDR             R0, =(lcd_output+0x20) ; s
LDR             R3, [R3]
LDR             R2, [R2]
BLX             sprintf
LDR             R3, [SP,#0x2C+var_8]
MOVW            R1, #:lower16:aT3DT4D ; " T3:%d   T4:%d"
LDR             R2, [SP,#0x2C+var_C]
MOVT            R1, #:upper16:aT3DT4D ; " T3:%d   T4:%d"
LDR             R0, =(lcd_output+0x30) ; s
LDR             R3, [R3]
LDR             R2, [R2]
BLX             sprintf
B               loc_164DA
; End of function BHB91603_show_status_func

ALIGN 4
off_16638 DCD lcd_output+0x20
off_1663C DCD cgpu.subid+0x7FD54
off_16640 DCD lcd_output+0x10
off_16644 DCD lcd_output+0x30



; void *__fastcall BHB91603_send_func(void *arg)
EXPORT BHB91603_send_func
BHB91603_send_func

var_A4= -0xA4
var_9C= -0x9C
var_98= -0x98
mutex= -0x94
which_core= -0x90
works= -0x8C
var_88= -0x88
var_84= -0x84
var_80= -0x80
var_7C= -0x7C
which_asic= -0x78
var_74= -0x74
var_70= -0x70
work_vil_1391= -0x6C
buf_vil= -0x38
var_4= -4

arg = R0                ; void *
work = R5               ; work *
MOV             R3, arg
chain_info = R0         ; chain_info *
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0xA4
LDRB.W          R9, [chain_info]
which_chain = R9        ; unsigned __int8
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
LDRB            work, [R3,#1]
ADD             chain_info, SP, #0xA4+buf_vil ; s
chain_info = R3         ; chain_info *
BLX             memset
MOVW            R4, #:lower16:gBegin_Get_Nonce
MOVW            R0, #:lower16:aSWhichChainDWh_0 ; "\n--- %s: which_chain = %d, which_i2c ="...
MOV             R3, work
MOV             R2, which_chain
LDR             R1, =__FUNCTION__.8326 ; "BHB91603_send_func"
MOVT            R0, #:upper16:aSWhichChainDWh_0 ; "\n--- %s: which_chain = %d, which_i2c ="...
MOVT            R4, #:upper16:gBegin_Get_Nonce
BLX             printf
LDRB            R3, [R4]
CBNZ            R3, loc_16692
MOVS            R0, #7  ; address
BL              read_axi_fpga
ORR.W           R1, R0, #0x10000 ; data
MOVS            R0, #7  ; address
BL              write_axi_fpga
MOVS            R3, #1
STRB            R3, [R4]

loc_16692
MOV             R3, #BHB91603_ASIC_NUMBER
STR             R3, [SP,#0xA4+var_70]
LDR             R3, [R3]
CMP             R3, #0
BEQ.W           loc_168EC
ADD.W           R1, which_chain, which_chain,LSL#4
ORR.W           R0, which_chain, #0x80
MOVW            R3, #:lower16:Conf
STR             R0, [SP,#0xA4+var_88]
LSLS            R1, R1, #9
MOVT            R3, #:upper16:Conf
STR             R3, [SP,#0xA4+var_9C]
ADD.W           R2, which_chain, which_chain,LSL#1
MOV             R4, R1
STR             R1, [SP,#0xA4+var_80]
MOVW            R1, #:lower16:gWorks_For_Hw_Check
LDR             work, [R3,#configuration.pattern_number]
MOV             R6, R1
LSLS            R1, R0, #0x10
LDR             R0, =(cgpu.workdataFilePrefix+0x3C)
MOV             R3, #HW_check_mutex
MOVW            R7, #:lower16:gSend_Work_Num
ADD.W           R3, R3, R2,LSL#3
MOVW            R8, #:lower16:gReadingTemp
STR             R0, [SP,#0xA4+var_74]
MOV             R0, R6
MOVT            R0, #:upper16:gWorks_For_Hw_Check
STR             R3, [SP,#0xA4+mutex]
ADDS            R4, R0, R4
ORR.W           R3, R1, #0x1000000
MOVT            R7, #:upper16:gSend_Work_Num
STR             R3, [SP,#0xA4+var_84]
MOVT            R8, #:upper16:gReadingTemp
MOVS            R3, #0
STR             R0, [SP,#0xA4+var_7C]
STR             R3, [SP,#0xA4+which_asic]
STR.W           R8, [SP,#0xA4+var_98]

loc_16706
LDR             R3, [SP,#0xA4+var_74]
MOV             R2, R3
LDR.W           R3, [R2,#4]!
STR             R3, [SP,#0xA4+works]
MOVS            R3, #0
STR             R2, [SP,#0xA4+var_74]
STR             R3, [SP,#0xA4+which_core]

loc_16716
MOVS            R6, #0
MOVW            R8, #:lower16:gChain
CMP             R6, work
MOVT            R8, #:upper16:gChain
which_pattern = R6      ; unsigned int
BCS.W           loc_16876

loc_16726
LDR             R3, [SP,#0xA4+var_98]
LDRB            R3, [R3]
CMP             R3, #0
BNE.W           loc_168E2

loc_16730               ; address
MOVS            R0, #3
MOV.W           R10, #1
BL              read_axi_fpga
work_fifo_ready = R0    ; unsigned int
LDRB.W          R3, [R8]
LSL.W           R3, R10, R3
TST             R3, work_fifo_ready
BEQ.W           loc_168D8
LDR             R3, [SP,#0xA4+which_core]
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             work_fifo_ready, SP, #0xA4+buf_vil ; s
MLA             work, work, R3, which_pattern
LDR             R3, [SP,#0xA4+works]
ADD.W           work, work, work,LSL#4
ADD.W           work, R3, work,LSL#2
BLX             memset
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             R0, SP, #0xA4+work_vil_1391 ; s
BLX             memset
LDRB.W          R0, [SP,#0xA4+var_88]
ADDS            R3, work, #7
ADD.W           R2, work, #0x13
ADD.W           R1, SP, #0xA4+work_vil_1391.work_count+3
STRB.W          R10, [SP,#0xA4+work_vil_1391]
STRB.W          R0, [SP,#0xA4+work_vil_1391.chain_id]
STR             which_pattern, [SP,#0xA4+work_vil_1391.work_count]

loc_16784
LDRB.W          R0, [R3,#1]!
CMP             R2, R3
STRB.W          R0, [R1,#1]!
BNE             loc_16784
ADD.W           R3, SP, #0xA4+work_vil_1391.data+0xB
ADD.W           R0, SP, #0xA4+work_vil_1391.midstate+0x1F

loc_16798
LDRB.W          R1, [R2,#1]!
STRB.W          R1, [R3,#1]!
CMP             R3, R0
BNE             loc_16798
ADD             R3, SP, #0xA4+work_vil_1391
LDR             R2, [SP,#0xA4+var_84]
ADD.W           R11, SP, #0xA4+work_vil_1391.data+4
MOV             R12, R3
ADD.W           R10, SP, #0xA4+var_4
STR             R2, [SP,#0xA4+buf_vil]
STR.W           which_pattern, [R10,#-0x30]!

loc_167B8
LDRB.W          R1, [R12,#9]
ADD.W           R12, R12, #4
LDRB.W          LR, [R12,#4]
LDRB.W          R2, [R12,#7]
LDRB.W          R0, [R12,#6]
CMP             R12, R11
MOV.W           R1, R1,LSL#16
ORR.W           R1, R1, LR,LSL#24
ORR.W           R2, R2, R1
ORR.W           R2, R2, R0,LSL#8
STR.W           R2, [R10,#4]!
BNE             loc_167B8
ADD.W           R12, SP, #0xA4+buf_vil+0x10
ADD.W           R10, SP, #0xA4+work_vil_1391.midstate+0xC

loc_167EC
LDRB            R1, [R3,#0x15]
ADDS            R3, #4
LDRB.W          LR, [R3,#0x10]
LDRB            R2, [R3,#0x13]
LDRB            R0, [R3,#0x12]
CMP             R3, R10
MOV.W           R1, R1,LSL#16
ORR.W           R1, R1, LR,LSL#24
ORR.W           R2, R2, R1
ORR.W           R2, R2, R0,LSL#8
STR.W           R2, [R12,#4]!
BNE             loc_167EC
ADD             R0, SP, #0xA4+buf_vil ; value
BL              set_TW_write_command
LDR             R0, [SP,#0xA4+mutex] ; mutex
BLX             pthread_mutex_lock
LDR             R3, [SP,#0xA4+var_80]
ADD.W           R0, R3, #0x2180
LDR             R3, [SP,#0xA4+var_7C]
ADDS            R0, #0x3C ; '<'
ADD             R0, R3  ; dest

loc_16828
SUB.W           R10, R0, #0x44 ; 'D'
MOVS            R2, #0x44 ; 'D' ; n
MOV             R1, R10 ; src
BLX             memcpy
CMP             R4, R10
MOV             R0, R10
BNE             loc_16828
MOVW            R2, #:lower16:gWork_Num_For_Hw_Check
MOV             R1, work ; src
MOVT            R2, #:upper16:gWork_Num_For_Hw_Check
MOV             R0, R4  ; dest
LDRB            R3, [R2]
ADDS            which_pattern, #1
ADDS            R3, #1
UXTB            R3, R3
CMP             R3, #0x7E ; '~'
IT HI
MOVHI           R3, #0x7F
STRB            R3, [R2]
MOVS            R2, #0x44 ; 'D' ; n
BLX             memcpy
LDR             R0, [SP,#0xA4+mutex] ; mutex
BLX             pthread_mutex_unlock
which_pattern = R6      ; unsigned int
LDR.W           R3, [R7,which_chain,LSL#2]
ADDS            R3, #1
STR.W           R3, [R7,which_chain,LSL#2]

loc_1686C
LDR             R3, [SP,#0xA4+var_9C]
LDR             work, [R3,#configuration.pattern_number]
CMP             which_pattern, work
BCC.W           loc_16726

loc_16876
LDR             R3, [SP,#0xA4+which_core]
ADDS            R3, #1
CMP.W           R3, #0x100
STR             R3, [SP,#0xA4+which_core]
which_core_0 = R3       ; unsigned int
BNE.W           loc_16716
LDR             which_core_0, [SP,#0xA4+var_70]
LDR             R2, [R3]
LDR             R3, [SP,#0xA4+which_asic]
ADDS            R3, #1
CMP             R2, R3
STR             R3, [SP,#0xA4+which_asic]
which_asic_0 = R3       ; unsigned int
BHI.W           loc_16706
MUL             R2, work, R2
LDR.W           which_asic_0, [R7,which_chain,LSL#2]
LDR.W           R8, [SP,#0xA4+var_98]
LSLS            R2, R2, #8
CMP             R2, R3
BLS             loc_16900
LDR             work, =__FUNCTION__.8326 ; "BHB91603_send_func"
MOVW            R4, #:lower16:aSChainDSendWor ; "\n\n---%s: Chain%d send work num : %d, "...
LDR             which_pattern, [SP,#0xA4+var_70]
MOVT            R4, #:upper16:aSChainDSendWor ; "\n\n---%s: Chain%d send work num : %d, "...
LDR.W           R10, [SP,#0xA4+var_9C]

loc_168B6
STR             R2, [SP,#0xA4+var_A4]
MOV             R1, work
MOV             R2, which_chain
MOV             R0, R4  ; format
BLX             printf
LDR.W           R1, [R10,#configuration.pattern_number]
LDR             R2, [R6]
LDR.W           R3, [R7,which_chain,LSL#2]
MUL             R2, R2, R1
LSLS            R2, R2, #8
CMP             R3, R2
BCC             loc_168B6
B               loc_16900

loc_168D8               ; useconds
which_pattern = R6      ; unsigned int
work_fifo_ready = R0    ; unsigned int
MOV.W           work_fifo_ready, #0x3E8
BLX             usleep
B               loc_1686C

loc_168E2               ; useconds
MOVW            R0, #0x2710
BLX             usleep
B               loc_16730

loc_168EC
MOVW            R3, #:lower16:gSend_Work_Num
MOVW            R8, #:lower16:gReadingTemp
MOVT            R3, #:upper16:gSend_Work_Num
MOVT            R8, #:upper16:gReadingTemp
LDR.W           R3, [R3,which_chain,LSL#2]

loc_16900
MOVW            R0, #:lower16:aSChainDSendWor_0 ; "\n\n---%s: Chain%d send work num : %d\n"
MOV             R2, which_chain
LDR             R1, =__FUNCTION__.8326 ; "BHB91603_send_func"
MOVT            R0, #:upper16:aSChainDSendWor_0 ; "\n\n---%s: Chain%d send work num : %d\n"
BLX             printf
MOVW            R0, #:lower16:aSendTestPatter ; "\nsend test pattern done"
MOVW            R4, #:lower16:gValid_Nonce_Num
MOVT            R0, #:upper16:aSendTestPatter ; "\nsend test pattern done"
MOVT            R4, #:upper16:gValid_Nonce_Num
BLX             puts
MOVW            R0, #:lower16:aDate ; "date"
MOVW            R10, #:lower16:(gAsic_Core_Nonce_Num+0xC33FC)
MOVT            R0, #:upper16:aDate ; "date"
MOVT            R10, #:upper16:(gAsic_Core_Nonce_Num+0xC33FC)
BLX             system
MOVS            R0, #0xA ; c
MOVS            work, #0
BLX             putchar
LDR.W           R7, [R4,which_chain,LSL#2]
received_data = R7      ; unsigned int
MOV             R6, received_data

loc_16946
CMP             R7, R6
ADD.W           work, work, #1
count = R5              ; unsigned int
MOV             R0, R10 ; useconds
BNE             loc_1696E
CMP             count, #2
BHI             loc_1695E
BLX             usleep

loc_16958
work = R5               ; work *
LDR.W           R6, [R4,which_chain,LSL#2]
B               loc_16946

loc_1695E
count = R5              ; unsigned int
LDRB.W          R3, [R8]
CBZ             R3, loc_16978
MOVW            R0, #0x2710 ; useconds
BLX             usleep
B               loc_1695E

loc_1696E
BLX             usleep
MOV             R7, R6
MOVS            count, #0
work = R5               ; work *
B               loc_16958

loc_16978
count = R5              ; unsigned int
MOVW            R3, #:lower16:start_receive
MOVW            R0, #:lower16:aToStopReceive ; "to stop receive"
MOVT            R3, #:upper16:start_receive
MOVS            R4, #0
MOVT            R0, #:upper16:aToStopReceive ; "to stop receive"
STRB            R4, [R3]
BLX             puts
MOV             R0, R4
ADD             SP, SP, #0xA4
POP.W           {R4-R11,PC}
; End of function BHB91603_send_func

off_16998 DCD __FUNCTION__.8326 ; "BHB91603_send_func"
off_1699C DCD cgpu.workdataFilePrefix+0x3C



; void reset_BHB91603_global_arg()
EXPORT reset_BHB91603_global_arg
reset_BHB91603_global_arg

var_C= -0xC
var_8= -8

MOVW            R3, #:lower16:gBM1391_MISC_CONTROL_reg
PUSH.W          {R4-R11,LR}
MOVW            R2, #0x3A01
SUB             SP, SP, #0xC
MOVT            R3, #:upper16:gBM1391_MISC_CONTROL_reg
MOVW            R8, #:lower16:gRepeated_Nonce_Id
STR             R2, [R3]
MOVS            R7, #0
BL              reset_global_arg
MOVW            R3, #:lower16:Conf
MOVW            R2, #:lower16:BHB91603_ASIC_NUMBER
MOVT            R3, #:upper16:Conf
MOVT            R2, #:upper16:BHB91603_ASIC_NUMBER
LDR             R5, [R3,#configuration.pattern_number]
MOVW            R3, #:lower16:cgpu
LDR             R2, [R2]
MOVT            R3, #:upper16:cgpu
LDR.W           R11, =0x3312CF
MOVW            R12, #:lower16:gValid_Nonce_Num
LDR.W           R9, =(gAsic_Core_Nonce_Num+0x3FC)
MOVW            LR, #:lower16:gSend_Work_Num
ADD.W           R6, R5, R5,LSL#4
STR             R2, [SP,#0xC+var_C]
ADD.W           R2, R2, #0x20000
ADDS            R2, #0x2A ; '*'
LSLS            R6, R6, #2
ADD.W           R3, R3, R2,LSL#2
MOVT            R8, #:upper16:gRepeated_Nonce_Id
MOVT            R12, #:upper16:gValid_Nonce_Num
MOVT            LR, #:upper16:gSend_Work_Num
MOV             R1, R7
STR             R3, [SP,#0xC+var_8]

loc_16A0C
LDR             R3, [SP,#0xC+var_C]
MOV             R4, R9
STRB.W          R1, [R11,#1]!
STR.W           R1, [R8],#4
STR.W           R1, [R12],#4
STR.W           R1, [LR],#4
LDR.W           R10, =(cgpu.workdataFilePrefix+0x3C)
CBZ             R3, loc_16A50

loc_16A26
LDR.W           R3, [R10,#4]!
SUB.W           R0, R4, #0x400
ADD             R3, R7

loc_16A30
STR.W           R1, [R0,#4]!
ADDS            R2, R3, R6
CBZ             R5, loc_16A40

loc_16A38
STR             R1, [R3,#0x34]
ADDS            R3, #0x44 ; 'D'
CMP             R3, R2
BNE             loc_16A38

loc_16A40
CMP             R0, R4
MOV             R3, R2
BNE             loc_16A30
LDR             R3, [SP,#0xC+var_8]
ADD.W           R4, R4, #0x1000
CMP             R10, R3
BNE             loc_16A26

loc_16A50
ADDS            R7, #4
ADD.W           R9, R9, #0x80000
CMP             R7, #0x10
BNE             loc_16A0C
ADD             SP, SP, #0xC
POP.W           {R4-R11,PC}
; End of function reset_BHB91603_global_arg

dword_16A60 DCD 0x3312CF
off_16A64 DCD gAsic_Core_Nonce_Num+0x3FC
off_16A68 DCD cgpu.workdataFilePrefix+0x3C



; bool __fastcall BHB91603_AT24C02_write_total_data(unsigned __int8 which_iic, unsigned __int8 which_chain)
EXPORT BHB91603_AT24C02_write_total_data
BHB91603_AT24C02_write_total_data

length= -8

which_iic = R0          ; unsigned __int8
which_chain = R1        ; unsigned __int8
PUSH.W          {R4-R10,LR}
MOV             R6, which_iic
MOVW            which_iic, #:lower16:aS ; "\n--- %s\n"
SUB             SP, SP, #8
MOV             R8, which_chain
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             which_chain, =__FUNCTION__.8151 ; "BHB91603_AT24C02_write_total_data"
MOVW            R4, #:lower16:gAT24C02_data_map
BLX             printf
LDR             R3, =(cgpu.subid+0x7FD54)
MOVT            R4, #:upper16:gAT24C02_data_map
MOVS            R2, #4
MOV             R12, #0x51EB851F
STRB.W          R2, [R4,#(gAT24C02_data_map+0x7A - 0x30C40)]
LDR.W           R3, [R3,#(cgpu.voltage - 0x330FC4)]
MOV             LR, #Conf
MOVS            R0, #0x7E ; '~'
LDR.W           R7, [LR,#configuration.TempSensor1]
MOVS            R5, #0
LDR.W           R1, [LR,#configuration.sensor_model]
ADD.W           R3, R3, R3,LSL#2
STRB            R0, [R4]
STRB.W          R7, [R4,#(gAT24C02_data_map+0x7B - 0x30C40)]
MOV             R0, R4  ; p_data
ADD.W           R2, R3, #0x3E8
LDR.W           R7, [LR,#configuration.HashBoard_Hardware_Version_2]
UMULL           R9, R10, R2, R12
LDR.W           R2, [LR,#configuration.TempSensor2]
LDR.W           R9, [LR,#configuration.HashBoard_Hardware_Version_1]
STRB.W          R1, [R4,#(gAT24C02_data_map+0x79 - 0x30C40)]
MOVS            R1, #0xFE ; w_len
STRB.W          R2, [R4,#(gAT24C02_data_map+0x7D - 0x30C40)]
LDR.W           R2, [LR,#configuration.HashBoard_Bom_Version_1]
MOV.W           R3, R10,LSR#5
LDR.W           R10, [LR,#configuration.TempSensor4]
STRB.W          R7, [R4,#(gAT24C02_data_map+0xFB - 0x30C40)]
STRB            R3, [R4,#(gAT24C02_data_map+1 - 0x30C40)]
LDRB.W          R3, [LR,#configuration.TempSensor3]
STRB.W          R2, [R4,#(gAT24C02_data_map+0xFC - 0x30C40)]
STRB.W          R5, [R4,#(gAT24C02_data_map+0x7C - 0x30C40)]
STRB.W          R3, [R4,#(gAT24C02_data_map+0x7F - 0x30C40)]
LDR.W           R3, [LR,#configuration.HashBoard_Bom_Version_2]
STRB.W          R5, [R4,#(gAT24C02_data_map+0x7E - 0x30C40)]
STRB.W          R10, [R4,#(gAT24C02_data_map+0x81 - 0x30C40)]
STRB.W          R3, [R4,#(gAT24C02_data_map+0xFD - 0x30C40)]
STRB.W          R9, [R4,#(gAT24C02_data_map+0xFA - 0x30C40)]
STRB.W          R5, [R4,#(gAT24C02_data_map+0x80 - 0x30C40)]
STRB.W          R5, [R4,#(gAT24C02_data_map+0x82 - 0x30C40)]
BL              CRC16
MOV             R7, R0
crc = R7                ; uint16_t
MOV.W           R3, #0x100
MOV.W           LR, crc,LSR#8
MOV             R0, R5  ; address
MOV             R1, R4  ; buf
STR             R3, [SP,#8+length] ; length
MOV             R2, R6  ; which_iic
MOV             R3, R8  ; which_chain
STRB.W          LR, [R4,#(gAT24C02_data_map+0xFF - 0x30C40)]
STRB.W          crc, [R4,#(gAT24C02_data_map+0xFE - 0x30C40)]
BL              AT24C02_write_bytes
MOV             R2, R8  ; which_chain
MOV             R1, R6  ; which_iic
MOVS            R0, #0xFF ; address
BL              AT24C02_read_one_byte
data = R0               ; uint8_t
LDRB.W          R3, [R4,#(gAT24C02_data_map+0xFF - 0x30C40)]
CMP             R3, data
BEQ             loc_16B74
MOVW            R3, #:lower16:gEEPROM_error
MOVW            data, #:lower16:aSSaveDataIntoE ; "!!! %s: save data into EEPROM fail! \n"
MOVT            R3, #:upper16:gEEPROM_error
MOVS            R2, #1
LDR             R1, =__FUNCTION__.8151 ; "BHB91603_AT24C02_write_total_data"
MOVT            R0, #:upper16:aSSaveDataIntoE ; "!!! %s: save data into EEPROM fail! \n"
STRB            R2, [R3]
BLX             printf
MOV             R0, R5
ret = R0                ; bool
ADD             SP, SP, #8
POP.W           {R4-R10,PC}

loc_16B74
data = R0               ; uint8_t
MOVW            data, #:lower16:aSSaveDataIntoE_0 ; "--- %s: save data into EEPROM success! "...
LDR             R1, =__FUNCTION__.8151 ; "BHB91603_AT24C02_write_total_data"
MOVT            R0, #:upper16:aSSaveDataIntoE_0 ; "--- %s: save data into EEPROM success! "...
BLX             printf
MOVS            R0, #1
ret = R0                ; bool
ADD             SP, SP, #8
POP.W           {R4-R10,PC}
; End of function BHB91603_AT24C02_write_total_data

ALIGN 4
off_16B8C DCD __FUNCTION__.8151 ; "BHB91603_AT24C02_write_total_data"
off_16B90 DCD cgpu.subid+0x7FD54



; int __fastcall BHB91603_set_voltage(unsigned __int8 which_chain, unsigned __int8 which_i2c)
EXPORT BHB91603_set_voltage
BHB91603_set_voltage
which_chain = R0        ; unsigned __int8
which_i2c = R1          ; unsigned __int8
PUSH            {R3-R5,LR}
BL              Calibration_voltage
ret = R0                ; int
MOV             R4, ret
CBNZ            ret, loc_16BA2

loc_16B9E
ret = R4                ; int
MOV             R0, ret
POP             {R3-R5,PC}

loc_16BA2
ret = R0                ; int
LDR             R5, =cgpu.show_id
LDR.W           ret, [R5],#-8 ; th
ret = R4                ; int
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R5,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
ADDS            R1, ret, #1
BEQ             loc_16C14
ADDS            R2, ret, #2
BNE             loc_16C46
MOVW            R1, #:lower16:aMaximumNValue ; " Maximum N value"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aMaximumNValue ; " Maximum N value"
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aCanNotMatch ; " can not match  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCanNotMatch ; " can not match  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aVoltage ; "    voltage     "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aVoltage ; "    voltage     "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSMaximumNValue ; "\n!!! %s: Maximum N value can't match v"...
LDR             R1, =__FUNCTION__.8157 ; "BHB91603_set_voltage"
MOVT            R0, #:upper16:aSMaximumNValue ; "\n!!! %s: Maximum N value can't match v"...
BLX             printf
MOV             R0, ret
POP             {R3-R5,PC}

loc_16C14
MOVW            R1, #:lower16:aCanNotFind ; "  Can not find  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCanNotFind ; "  Can not find  "
MOVS            R0, #1  ; line
BL              write_lcd
MOVW            R1, #:lower16:aMatchVoltage ; "  match voltage "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aMatchVoltage ; "  match voltage "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCanTFindMatch ; "\n!!! %s: Can't find match voltage!\n"
LDR             R1, =__FUNCTION__.8157 ; "BHB91603_set_voltage"
MOVT            R0, #:upper16:aSCanTFindMatch ; "\n!!! %s: Can't find match voltage!\n"
BLX             printf
MOV             R0, ret
POP             {R3-R5,PC}

loc_16C46
ADDS            R3, ret, #3
BNE             loc_16B9E
MOVW            R1, #:lower16:aMinimumNValue ; " Minimum N value"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aMinimumNValue ; " Minimum N value"
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aCanNotMatch ; " can not match  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCanNotMatch ; " can not match  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aVoltage ; "    voltage     "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aVoltage ; "    voltage     "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSMinimumNValue ; "\n!!! %s: Minimum N value can't match v"...
LDR             R1, =__FUNCTION__.8157 ; "BHB91603_set_voltage"
MOVT            R0, #:upper16:aSMinimumNValue ; "\n!!! %s: Minimum N value can't match v"...
BLX             printf
MOV             R0, ret
POP             {R3-R5,PC}
; End of function BHB91603_set_voltage

off_16C8C DCD cgpu.show_id
off_16C90 DCD __FUNCTION__.8157 ; "BHB91603_set_voltage"



; void BHB91603_calculate_timeout_and_baud()
EXPORT BHB91603_calculate_timeout_and_baud
BHB91603_calculate_timeout_and_baud

var_C= -0xC
var_8= -8

PUSH            {R4-R7,LR}
MOV.W           R0, #0x100 ; actual_core_number
SUB             SP, SP, #0xC
MOVW            R4, #:lower16:Conf
BL              calculate_core_number
MOVW            R3, #:lower16:pattern_test_time
MOV             R6, R0
temp_corenum = R0       ; unsigned int
MOVT            R3, #:upper16:pattern_test_time
LDRB            R2, [R3]
CMP             R2, #8  ; switch 9 cases
BHI             def_16CB4 ; jumptable 00016CB4 default case
TBB.W           [PC,R2] ; switch jump
jpt_16CB4 DCB 0x34      ; jump table for switch statement
DCB 0x38
DCB 0x3C
DCB 0x40
DCB 0x44
DCB 0x48
DCB 0x4C
DCB 0x50
DCB 5
ALIGN 2

loc_16CC2               ; jumptable 00016CB4 case 8
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq9]

loc_16CC8
temp_corenum = R6       ; unsigned int
temp_freq = R5          ; unsigned int
MOV             R1, temp_corenum
MOV.W           R0, #0x1000000
BL              __aeabi_uidiv
MOVW            R3, #:lower16:gChain_Asic_Interval
MOV             R1, temp_freq
MOVT            R3, #:upper16:gChain_Asic_Interval
LDR             R3, [R3]
MUL             R0, R3, R0
BL              __aeabi_uidiv
LDR             R1, =(cgpu.subid+0x7FD54)
MOVW            R3, #0x851F
STR             temp_freq, [SP,#0xC+var_8]
MOVT            R3, #0x51EB
STR             temp_freq, [R4,#configuration.Freq]
LDRB.W          temp_corenum, [R1,#(cgpu.timeout_percent - 0x330FC4)]
LDR.W           R2, [R4,#configuration.baud]
LDR             R1, =__FUNCTION__.8174 ; "BHB91603_calculate_timeout_and_baud"
MUL             R6, R6, R0
MOV             R0, #aSBaudDTimeout0 ; "\n--- %s: baud = %d, timeout = 0x%08x ="...
UMULL           R6, R7, R6, R3
LSRS            temp_freq, R7, #5
STR             R5, [SP,#0xC+var_C]
MOV             R3, R5
STR.W           R5, [R4,#configuration.timeout]
BLX             printf
ADD             SP, SP, #0xC
POP             {R4-R7,PC}

loc_16D20               ; jumptable 00016CB4 case 0
temp_corenum = R0       ; unsigned int
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq1]
temp_freq = R5          ; unsigned int
B               loc_16CC8

loc_16D28               ; jumptable 00016CB4 case 1
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq2]
temp_freq = R5          ; unsigned int
B               loc_16CC8

loc_16D30               ; jumptable 00016CB4 case 2
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq3]
temp_freq = R5          ; unsigned int
B               loc_16CC8

loc_16D38               ; jumptable 00016CB4 case 3
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq4]
temp_freq = R5          ; unsigned int
B               loc_16CC8

loc_16D40               ; jumptable 00016CB4 case 4
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq5]
temp_freq = R5          ; unsigned int
B               loc_16CC8

loc_16D48               ; jumptable 00016CB4 case 5
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq6]
temp_freq = R5          ; unsigned int
B               loc_16CC8

loc_16D50               ; jumptable 00016CB4 case 6
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq7]
temp_freq = R5          ; unsigned int
B               loc_16CC8

loc_16D58               ; jumptable 00016CB4 case 7
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq8]
temp_freq = R5          ; unsigned int
B               loc_16CC8

def_16CB4               ; jumptable 00016CB4 default case
MOVW            temp_corenum, #:lower16:aSPatternTestTi ; "%s: pattern_test_time = %d, error!!! \n"
temp_corenum = R6       ; unsigned int
LDR             R1, =__FUNCTION__.8174 ; "BHB91603_calculate_timeout_and_baud"
MOVT            R0, #:upper16:aSPatternTestTi ; "%s: pattern_test_time = %d, error!!! \n"
MOVT            R4, #:upper16:Conf
MOVS            R5, #0
BLX             printf
B               loc_16CC8
; End of function BHB91603_calculate_timeout_and_baud

ALIGN 4
off_16D78 DCD cgpu.subid+0x7FD54
off_16D7C DCD __FUNCTION__.8174 ; "BHB91603_calculate_timeout_and_baud"



; void __fastcall BHB91603_set_address(unsigned __int8 which_chain)
EXPORT BHB91603_set_address
BHB91603_set_address
which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R6, which_chain
MOVW            which_chain, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R2, R6
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
MOVW            R8, #:lower16:BHB91603_ASIC_NUMBER
LDR             R1, =__FUNCTION__.8180 ; "BHB91603_set_address"
MOVT            R8, #:upper16:BHB91603_ASIC_NUMBER
BLX             printf
MOV             R0, R6  ; which_chain
BL              BM1391_chain_inactive
LDR.W           R3, [R8]
CBZ             R3, locret_16DD8
MOVS            R4, #0
MOVW            R7, #:lower16:gChain_Asic_Interval
MOV             R5, R4
MOVT            R7, #:upper16:gChain_Asic_Interval

loc_16DB6               ; address
chip_addr = R5          ; unsigned __int8
which_asic = R4         ; unsigned __int8
MOV             R1, chip_addr
MOV             R0, R6  ; which_chain
BL              BM1391_set_address
LDR             R3, [R7]
MOVW            R0, #0x1388 ; useconds
ADDS            which_asic, #1
UXTB            R4, R4
ADD             chip_addr, R3
BLX             usleep
LDR.W           R3, [R8]
UXTB            R5, R5
chip_addr = R5          ; unsigned __int8
which_asic = R4         ; unsigned __int8
CMP             which_asic, R3
BCC             loc_16DB6

locret_16DD8
POP.W           {R4-R8,PC}
; End of function BHB91603_set_address

off_16DDC DCD __FUNCTION__.8180 ; "BHB91603_set_address"



; void __fastcall BHB91603_set_baud(unsigned __int8 which_chain, unsigned __int8 baud)
EXPORT BHB91603_set_baud
BHB91603_set_baud
which_chain = R0        ; unsigned __int8
baud = R1               ; unsigned __int8
PUSH            {R3-R5,LR}
MOV             R5, which_chain
MOVW            which_chain, #:lower16:aSChainDBaudD ; "\n--- %s: Chain : %d, baud = %d\n"
MOV             R3, baud
MOV             R4, baud
MOV             R2, R5
LDR             baud, =__FUNCTION__.8188 ; "BHB91603_set_baud"
MOVT            R0, #:upper16:aSChainDBaudD ; "\n--- %s: Chain : %d, baud = %d\n"
BLX             printf
MOV             R1, R4  ; baud
MOV             R0, R5  ; which_chain
BL              BM1391_set_baud
MOVW            R0, #0xC350 ; useconds
BLX             usleep
MOV             R0, R4  ; asic_baud
POP.W           {R3-R5,LR}
B.W             set_fpga_baud
; End of function BHB91603_set_baud

ALIGN 4
off_16E14 DCD __FUNCTION__.8188 ; "BHB91603_set_baud"



; void __fastcall BHB91603_P_open_core(unsigned __int8 which_chain)
EXPORT BHB91603_P_open_core
BHB91603_P_open_core

var_40= -0x40
buf_vil_tw= -0x38

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x44
MOV             R4, which_chain
MOVW            R3, #:lower16:gIsOpenCoreEnd
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             which_chain, SP, #0x44+buf_vil_tw ; s
MOV             R5, R3
BLX             memset
MOVW            R0, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R2, R4
LDR             R1, =__FUNCTION__.8195 ; "BHB91603_P_open_core"
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
BLX             printf
MOVW            R11, #:lower16:gIsOpeningCore
MOV             R3, R5
MOVT            R3, #:upper16:gIsOpenCoreEnd
MOVS            R6, #0
MOVS            R5, #1
MOVT            R11, #:upper16:gIsOpeningCore
MOVS            R0, #0x40 ; '@' ; address
STRB            R6, [R3]
STR             R3, [SP,#0x44+var_40]
MOV.W           R9, #0x80
STRB.W          R5, [R11]
MOVT            R9, #0x100
BL              read_axi_fpga
BIC.W           R1, R0, #0x20 ; ' ' ; data
MOVS            R0, #0x40 ; '@' ; address
BL              write_axi_fpga
LDR             R7, =__FUNCTION__.8195 ; "BHB91603_P_open_core"
MOV             R1, R6  ; data
MOVS            R0, #0x24 ; '$' ; address
MOV             R8, R6
BL              write_axi_fpga
MOVW            R10, #:lower16:Conf
MOV             R1, R6  ; c
LSLS            R5, R4
MOVW            R6, #:lower16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"
ORR.W           R9, R9, R4,LSL#16
MOVT            R10, #:upper16:Conf
MOVT            R6, #:upper16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"
ADD             R0, SP, #0x44+buf_vil_tw ; s
MOVS            R2, #0x34 ; '4' ; n
BLX             memset

loc_16E9E               ; which_chain
which_core = R8         ; unsigned int
MOV             R0, R4
MOVS            R3, #1  ; mode
UXTB.W          R2, which_core ; core_id
MOVS            R1, #0  ; which_asic
BL              BM1391_enable_core_clock
MOVW            R0, #0x1388 ; useconds
BLX             usleep
B               loc_16EC2

loc_16EB6
work_fifo_ready = R3    ; unsigned int
BLX             printf
MOVW            R0, #0xBB8 ; useconds
BLX             usleep

loc_16EC2               ; address
MOVS            R0, #3
BL              read_axi_fpga
MOV             R3, R0
work_fifo_ready = R0    ; unsigned int
MOV             R2, R4
TST             R3, R5
MOV             work_fifo_ready, R6 ; format
work_fifo_ready = R3    ; unsigned int
MOV             R1, R7
BEQ             loc_16EB6
ADD             R0, SP, #0x44+buf_vil_tw ; value
STR.W           R9, [SP,#0x44+buf_vil_tw]
ADD.W           which_core, which_core, #1
BL              set_TW_write_command
LDR.W           R0, [R10,#configuration.OpenCoreGap] ; useconds
BLX             usleep
which_core = R8         ; unsigned int
CMP.W           which_core, #0x100
BNE             loc_16E9E
MOVS            R0, #0x30 ; '0' ; address
BL              read_axi_fpga
ORR.W           R1, R0, #0x400000 ; data
MOVS            R0, #0x30 ; '0' ; address
BL              write_axi_fpga
MOVS            R2, #0
MOVS            R3, #1
STRB.W          R2, [R11]
LDR             R2, [SP,#0x44+var_40]
STRB            R3, [R2]
ADD             SP, SP, #0x44 ; 'D'
POP.W           {R4-R11,PC}
; End of function BHB91603_P_open_core

ALIGN 4
off_16F14 DCD __FUNCTION__.8195 ; "BHB91603_P_open_core"



; void __fastcall BHB91603_P_pre_open_core(unsigned __int8 which_chain)
EXPORT BHB91603_P_pre_open_core
BHB91603_P_pre_open_core

var_40= -0x40
buf_vil_tw= -0x38

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x44
MOVW            R3, #:lower16:gIsOpenCoreEnd
MOV             R4, which_chain
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             which_chain, SP, #0x44+buf_vil_tw ; s
MOV             R5, R3
BLX             memset
MOVW            R0, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R2, R4
LDR             R1, =__FUNCTION__.8207 ; "BHB91603_P_pre_open_core"
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
BLX             printf
MOVW            R11, #:lower16:gIsOpeningCore
MOV             R3, R5
MOVT            R3, #:upper16:gIsOpenCoreEnd
MOV.W           R8, #0
MOVT            R11, #:upper16:gIsOpeningCore
MOVS            R5, #1
MOVS            R0, #0x40 ; '@' ; address
STR             R3, [SP,#0x44+var_40]
STRB.W          R8, [R3]
MOVW            R9, #:lower16:Conf
STRB.W          R5, [R11]
MOVT            R9, #:upper16:Conf
BL              read_axi_fpga
BIC.W           R1, R0, #0x20 ; ' ' ; data
MOVS            R0, #0x40 ; '@' ; address
BL              write_axi_fpga
MOV             R1, R8  ; data
MOVS            R0, #0x24 ; '$' ; address
BL              write_axi_fpga
MOV             R1, R8  ; c
ADD             R0, SP, #0x44+buf_vil_tw ; s
MOVS            R2, #0x34 ; '4' ; n
BLX             memset
LDR.W           R3, [R9,#configuration.OpenCoreNum2]
CBZ             R3, loc_16FFA
MOV.W           R10, #0x80
LDR             R7, =__FUNCTION__.8207 ; "BHB91603_P_pre_open_core"
MOVT            R10, #0x100
MOVW            R6, #:lower16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"
LSLS            R5, R4
ORR.W           R10, R10, R4,LSL#16
MOVT            R6, #:upper16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"

loc_16FA6               ; which_chain
which_core = R8         ; unsigned int
MOV             R0, R4
MOVS            R3, #1  ; mode
UXTB.W          R2, which_core ; core_id
MOVS            R1, #0  ; which_asic
BL              BM1391_enable_core_clock
MOVW            R0, #0x1388 ; useconds
BLX             usleep
B               loc_16FCA

loc_16FBE
work_fifo_ready = R3    ; unsigned int
BLX             printf
MOVW            R0, #0xBB8 ; useconds
BLX             usleep

loc_16FCA               ; address
MOVS            R0, #3
BL              read_axi_fpga
MOV             R3, R0
work_fifo_ready = R0    ; unsigned int
MOV             R2, R4
TST             R3, R5
MOV             work_fifo_ready, R6 ; format
work_fifo_ready = R3    ; unsigned int
MOV             R1, R7
BEQ             loc_16FBE
ADD             R0, SP, #0x44+buf_vil_tw ; value
STR.W           R10, [SP,#0x44+buf_vil_tw]
BL              set_TW_write_command
LDR.W           R0, [R9,#configuration.OpenCoreGap] ; useconds
ADD.W           which_core, which_core, #1
BLX             usleep
which_core = R8         ; unsigned int
LDR.W           R3, [R9,#configuration.OpenCoreNum2]
CMP             R3, which_core
BHI             loc_16FA6

loc_16FFA               ; address
MOVS            R0, #0x30 ; '0'
BL              read_axi_fpga
ORR.W           R1, R0, #0x400000 ; data
MOVS            R0, #0x30 ; '0' ; address
BL              write_axi_fpga
MOVS            R2, #0
MOVS            R3, #1
STRB.W          R2, [R11]
LDR             R2, [SP,#0x44+var_40]
STRB            R3, [R2]
ADD             SP, SP, #0x44 ; 'D'
POP.W           {R4-R11,PC}
; End of function BHB91603_P_pre_open_core

off_1701C DCD __FUNCTION__.8207 ; "BHB91603_P_pre_open_core"



; void __fastcall BHB91603_S_open_core(unsigned __int8 which_chain)
EXPORT BHB91603_S_open_core
BHB91603_S_open_core

var_44= -0x44
var_40= -0x40
buf_vil_tw= -0x38

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x44
MOV             R5, which_chain
MOVW            R3, #:lower16:gIsOpenCoreEnd
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             which_chain, SP, #0x44+buf_vil_tw ; s
MOV             R4, R3
BLX             memset
MOVW            R3, #:lower16:gIsOpeningCore
MOVW            R0, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R6, R3
LDR             R1, =__FUNCTION__.8222_0 ; "BHB91603_S_open_core"
MOV             R2, R5
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
BLX             printf
MOV.W           R10, #0x80
MOV             R3, R4
MOV             R2, R6
MOVT            R3, #:upper16:gIsOpenCoreEnd
MOVT            R2, #:upper16:gIsOpeningCore
MOVS            R4, #0
MOVS            R6, #1
MOVS            R0, #0x40 ; '@' ; address
MOVT            R10, #0x100
STRB            R4, [R3]
STRB            R6, [R2]
ORR.W           R10, R10, R5,LSL#16
STR             R3, [SP,#0x44+var_44]
MOVW            R11, #:lower16:Conf
STR             R2, [SP,#0x44+var_40]
MOVW            R7, #:lower16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"
BL              read_axi_fpga
LDR.W           R8, =__FUNCTION__.8222_0 ; "BHB91603_S_open_core"
BIC.W           R1, R0, #0x20 ; ' ' ; data
MOVS            R0, #0x40 ; '@' ; address
LSLS            R6, R5
MOV             R9, R4
BL              write_axi_fpga
MOV             R1, R4  ; data
MOVS            R0, #0x24 ; '$' ; address
BL              write_axi_fpga
MOVT            R11, #:upper16:Conf
MOV             R1, R4  ; c
MOVT            R7, #:upper16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"
MOV             R4, R10
ADD             R0, SP, #0x44+buf_vil_tw ; s
MOVS            R2, #0x34 ; '4' ; n
BLX             memset

loc_170AE
core_id = R9            ; unsigned int
MOV.W           R10, #0

loc_170B2               ; useconds
slot = R10              ; unsigned int
MOV.W           R0, #0x3E8
BLX             usleep
ADD.W           R2, core_id, slot,LSL#6
core_index = R2         ; unsigned int
MOVS            R3, #1  ; mode
ADD             slot, R3
UXTB            core_index, core_index ; core_id
MOVS            R1, #0  ; which_asic
MOV             R0, R5  ; which_chain
BL              BM1391_enable_core_clock
slot = R10              ; unsigned int
CMP.W           slot, #4
BNE             loc_170B2
MOVW            R0, #0x1388 ; useconds
BLX             usleep
B               loc_170E8

loc_170DC
work_fifo_ready = R3    ; unsigned int
BLX             printf
MOVW            R0, #0xBB8 ; useconds
BLX             usleep

loc_170E8               ; address
MOVS            R0, #3
BL              read_axi_fpga
MOV             R3, R0
work_fifo_ready = R0    ; unsigned int
MOV             R2, R5
TST             R3, R6
MOV             work_fifo_ready, R7 ; format
work_fifo_ready = R3    ; unsigned int
MOV             R1, R8
BEQ             loc_170DC
ADD             R0, SP, #0x44+buf_vil_tw ; value
STR             R4, [SP,#0x44+buf_vil_tw]
ADD.W           core_id, core_id, #1
BL              set_TW_write_command
LDR.W           R0, [R11,#configuration.OpenCoreGap] ; useconds
BLX             usleep
core_id = R9            ; unsigned int
CMP.W           core_id, #0x40 ; '@'
BNE             loc_170AE
MOVS            R0, #0x30 ; '0' ; address
BL              read_axi_fpga
ORR.W           R1, R0, #0x400000 ; data
MOVS            R0, #0x30 ; '0' ; address
BL              write_axi_fpga
LDR             R1, [SP,#0x44+var_40]
MOVS            R2, #0
MOVS            R3, #1
STRB            R2, [R1]
LDR             R2, [SP,#0x44+var_44]
STRB            R3, [R2]
ADD             SP, SP, #0x44 ; 'D'
POP.W           {R4-R11,PC}
; End of function BHB91603_S_open_core

ALIGN 4
off_17138 DCD __FUNCTION__.8222_0 ; "BHB91603_S_open_core"



; void __fastcall BHB91603_S_pre_open_core(unsigned __int8 which_chain)
EXPORT BHB91603_S_pre_open_core
BHB91603_S_pre_open_core

buf_vil_tw= -0x38

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x3C
MOV             R4, which_chain
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             which_chain, SP, #0x3C+buf_vil_tw ; s
BLX             memset
MOVW            R0, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R2, R4
LDR             R1, =__FUNCTION__.8240 ; "BHB91603_S_pre_open_core"
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
BLX             printf
MOVS            R0, #0x40 ; '@' ; address
MOVW            R9, #:lower16:Conf
BL              read_axi_fpga
BIC.W           R1, R0, #0x20 ; ' ' ; data
MOVS            R0, #0x40 ; '@' ; address
BL              write_axi_fpga
MOVS            R1, #0  ; data
MOVS            R0, #0x24 ; '$' ; address
BL              write_axi_fpga
MOVT            R9, #:upper16:Conf
ADD             R0, SP, #0x3C+buf_vil_tw ; s
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
BLX             memset
LDR.W           R3, [R9,#configuration.OpenCoreNum2]
CMP             R3, #0
BEQ             loc_17218
MOV.W           R10, #0x80
MOVS            R6, #1
MOVT            R10, #0x100
LDR             R7, =__FUNCTION__.8240 ; "BHB91603_S_pre_open_core"
MOVW            R5, #:lower16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"
ORR.W           R10, R10, R4,LSL#16
LSLS            R6, R4
MOV.W           R8, #0
MOVT            R5, #:upper16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"

loc_171AE
core_id = R8            ; unsigned int
MOV.W           R11, #0

loc_171B2               ; useconds
slot = R11              ; unsigned int
MOV.W           R0, #0x3E8
BLX             usleep
ADD.W           R2, core_id, slot,LSL#6
core_index = R2         ; unsigned int
MOVS            R3, #1  ; mode
ADD             slot, R3
UXTB            core_index, core_index ; core_id
MOVS            R1, #0  ; which_asic
MOV             R0, R4  ; which_chain
BL              BM1391_enable_core_clock
slot = R11              ; unsigned int
CMP.W           slot, #4
BNE             loc_171B2
MOVW            R0, #0x1388 ; useconds
BLX             usleep
B               loc_171E8

loc_171DC
work_fifo_ready = R3    ; unsigned int
BLX             printf
MOVW            R0, #0xBB8 ; useconds
BLX             usleep

loc_171E8               ; address
MOVS            R0, #3
BL              read_axi_fpga
MOV             R3, R0
work_fifo_ready = R0    ; unsigned int
MOV             R2, R4
TST             R3, R6
MOV             work_fifo_ready, R5 ; format
work_fifo_ready = R3    ; unsigned int
MOV             R1, R7
BEQ             loc_171DC
ADD             R0, SP, #0x3C+buf_vil_tw ; value
STR.W           R10, [SP,#0x3C+buf_vil_tw]
BL              set_TW_write_command
LDR.W           R0, [R9,#configuration.OpenCoreGap] ; useconds
ADD.W           core_id, core_id, #1
BLX             usleep
core_id = R8            ; unsigned int
LDR.W           R3, [R9,#configuration.OpenCoreNum2]
CMP             R3, core_id
BHI             loc_171AE

loc_17218
ADD             SP, SP, #0x3C ; '<'
POP.W           {R4-R11,PC}
; End of function BHB91603_S_pre_open_core

ALIGN 0x10
off_17220 DCD __FUNCTION__.8240 ; "BHB91603_S_pre_open_core"



; unsigned int __fastcall BHB91603_get_result(unsigned __int8 which_chain)
EXPORT BHB91603_get_result
BHB91603_get_result

var_1C= -0x1C
which_asic= -0x18
ret= -0x14
var_10= -0x10
var_C= -0xC
var_8= -8

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x1C
STR             which_chain, [SP,#0x1C+var_10]
MOVW            R5, #:lower16:Conf
MOVW            which_chain, #:lower16:asc_29AF4 ; "\n\n-----------------------------------"...
MOVW            R3, #:lower16:BHB91603_ASIC_NUMBER
MOVT            R5, #:upper16:Conf
MOVT            R0, #:upper16:asc_29AF4 ; "\n\n-----------------------------------"...
MOV             R4, R3
BLX             puts
LDR             R1, [R5,#configuration.pattern_number]
MOV             R3, R4
MOVT            R3, #:upper16:BHB91603_ASIC_NUMBER
MOVW            R0, #:lower16:aEveryAsicRequi ; "every ASIC require nonce number: %u\n"
MOV             R4, R3
MOVT            R0, #:upper16:aEveryAsicRequi ; "every ASIC require nonce number: %u\n"
STR             R3, [SP,#0x1C+var_8]
LSLS            R1, R1, #8
BLX             printf
LDR             R3, [R4]
CBZ             R3, loc_172B8
MOVW            R7, #0xCCCD
MOVW            R6, #:lower16:aAsic02dD ; "asic[%02d]=%d\t"
MOVT            R7, #0xCCCC
MOVT            R6, #:upper16:aAsic02dD ; "asic[%02d]=%d\t"
MOVS            R4, #0
LDR.W           R8, [SP,#0x1C+var_10]
LDR.W           R9, [SP,#0x1C+var_8]
B               loc_172A0

loc_17280               ; which_asic
which_asic_0 = R4       ; unsigned int
UXTB            R1, which_asic_0
MOV.W           R2, #0x100 ; core_number
MOV             R0, R8  ; which_chain
BL              calculate_how_many_nonce_per_asic_get
per_asic_received_nonce_number = R0; unsigned int
MOV             R1, which_asic_0
MOV             R2, per_asic_received_nonce_number
MOV             per_asic_received_nonce_number, R6 ; format
per_asic_received_nonce_number = R2; unsigned int
ADDS            which_asic_0, #1
which_asic_0 = R1       ; unsigned int
BLX             printf
which_asic_0 = R4       ; unsigned int
LDR.W           R3, [R9]
CMP             R3, which_asic_0
BLS             loc_172B8

loc_172A0
UMULL           R2, R3, which_asic_0, R7
LSRS            R3, R3, #3
ADD.W           R3, R3, R3,LSL#2
CMP.W           which_asic_0, R3,LSL#1
BNE             loc_17280
MOVS            R0, #0xA ; c
BLX             putchar
B               loc_17280

loc_172B8               ; s
MOV             R0, #(aSCanTFindHashb+0x38) ; "\n"
BLX             puts
LDR             R3, [SP,#0x1C+var_8]
LDR             R3, [R3]
CMP             R3, #0
BEQ.W           loc_173D4
LDR             R1, [SP,#0x1C+var_10]
MOVS            R2, #7
LDR             R3, =(reg_mutex+0x14)
STR             R2, [SP,#0x1C+ret]
MOVS            R2, #0
ADD.W           R6, R1, #0xC
STR             R2, [SP,#0x1C+which_asic]
LSLS            R6, R6, #2
ADD.W           R3, R3, R1,LSL#19
STR             R3, [SP,#0x1C+var_C]
B               loc_172FE

loc_172E8
LDR             R3, [SP,#0x1C+var_8]
LDR             R1, [SP,#0x1C+var_C]
LDR             R2, [R3]
LDR             R3, [SP,#0x1C+which_asic]
ADD.W           R1, R1, #0x1000
STR             R1, [SP,#0x1C+var_C]
ADDS            R3, #1
CMP             R2, R3
STR             R3, [SP,#0x1C+which_asic]
which_asic_0 = R3       ; unsigned int
BLS             loc_173D8

loc_172FE               ; core_number
MOV.W           R2, #0x100
LDRB.W          R1, [SP,#0x1C+which_asic] ; which_asic
LDR             R0, [SP,#0x1C+var_10] ; which_chain
BL              calculate_how_many_nonce_per_asic_get
LDR             R1, [R5,#configuration.pattern_number]
MOV             R2, R0
per_asic_received_nonce_number = R0; unsigned int
CMP.W           per_asic_received_nonce_number, R1,LSL#8
BCS             loc_172E8
LDR             R4, [SP,#0x1C+which_asic]
per_asic_received_nonce_number = R2; unsigned int
MOV             R0, #aAsic02dD_0 ; "asic[%02d] = %d\n"
MOV             R11, #aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
MOV             R1, R4
BLX             printf
LSLS            R2, R4, #2
MOV             R1, #cgpu
LDR.W           R9, [SP,#0x1C+var_C]
ADD.W           R2, R2, #0x80000
MOVS            R3, #0
ADDS            R2, #0xAC
MOV             R4, R3
LDR             R7, [R2,R1]
works = R7              ; work *
STR             R3, [SP,#0x1C+var_1C]

loc_1734A
which_core = R4         ; unsigned int
LDR.W           R2, [R9,#4]!
LDR             R3, [R5,#configuration.pattern_number]
CMP             R2, R3
BCS             loc_173B2
LDR.W           R3, [R5,#configuration.Least_nonce_per_core]
MOV             R1, which_core
MOV             R0, R11 ; format
MOVW            R8, #:lower16:aD ; "%d  "
MOV.W           R10, #0
MOVT            R8, #:upper16:aD ; "%d  "
CMP             R2, R3
ITTT CC
LDRCC           R3, [SP,#0x1C+var_1C]
ADDCC           R3, #1
STRCC           R3, [SP,#0x1C+var_1C]
BLX             printf
LDR             R3, [R5,#configuration.pattern_number]
CBNZ            R3, loc_17386
B               loc_173AC

loc_1737C
which_pattern = R10     ; unsigned int
LDR             R3, [R5,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R3, which_pattern
BLS             loc_173AC

loc_17386
MLA             R3, R3, which_core, which_pattern
ADD.W           R3, R3, R3,LSL#4
ADD.W           R3, works, R3,LSL#2
ADD             R3, R6
LDR             R3, [R3,#4]
CMP             R3, #0
BNE             loc_1737C
MOV             R1, which_pattern
MOV             R0, R8  ; format
BLX             printf
LDR             R3, [R5,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R3, which_pattern
BHI             loc_17386

loc_173AC               ; c
MOVS            R0, #0xA
BLX             putchar

loc_173B2
ADDS            which_core, #1
CMP.W           which_core, #0x100
BNE             loc_1734A
LDR.W           R2, [R5,#configuration.Invalid_Core_Num]
LDR             R3, [SP,#0x1C+var_1C]
CMP             R3, R2
BHI.W           loc_1758E

loc_173C6               ; s
MOV             R0, #(aSCanTFindHashb+0x38) ; "\n"
BLX             puts
B               loc_172E8

loc_173D4
MOVS            R3, #7
STR             R3, [SP,#0x1C+ret]

loc_173D8
LDR             R6, [SP,#0x1C+var_10]
MOV             R4, #gHw_Nonce_Num
MOVW            R0, #:lower16:aHwNumberDConfM ; "HW number = %d, Conf.Most_HW_Num = %d\n"...
LDR.W           R2, [R5,#configuration.Most_HW_Num]
MOVT            R0, #:upper16:aHwNumberDConfM ; "HW number = %d, Conf.Most_HW_Num = %d\n"...
LDR.W           R1, [R4,R6,LSL#2]
BLX             printf
LDR.W           R3, [R5,#configuration.Most_HW_Num]
MOVW            R0, #:lower16:asc_29CA4 ; "\n-------------------------------------"...
LDR             R1, [SP,#0x1C+ret]
MOVT            R0, #:upper16:asc_29CA4 ; "\n-------------------------------------"...
LDR.W           R2, [R4,R6,LSL#2]
CMP             R2, R3
IT HI
MOVHI           R1, #6
STR             R1, [SP,#0x1C+ret]
ret_0 = R1              ; unsigned int
BLX             puts
LDR.W           R3, [R5,#configuration.TempSensor1]
CBZ             R3, loc_1742C
MOVW            R3, #:lower16:gSensor_read_ok_counter
LSLS            R2, R6, #4
MOVT            R3, #:upper16:gSensor_read_ok_counter
LDR             R3, [R3,R2]
CMP             R3, #4
BLS.W           loc_175F0

loc_1742C
LDR.W           R3, [R5,#configuration.TempSensor2]
CBZ             R3, loc_17448
LDR             R2, [SP,#0x1C+var_10]
MOV             R3, #gSensor_read_ok_counter
ADD.W           R3, R3, R2,LSL#4
LDR             R3, [R3,#4]
CMP             R3, #4
BLS.W           loc_175CE

loc_17448
LDR.W           R3, [R5,#configuration.TempSensor3]
CBZ             R3, loc_17464
LDR             R2, [SP,#0x1C+var_10]
MOV             R3, #gSensor_read_ok_counter
ADD.W           R3, R3, R2,LSL#4
LDR             R3, [R3,#8]
CMP             R3, #4
BLS.W           loc_175B8

loc_17464
LDR.W           R3, [R5,#configuration.TempSensor4]
CBZ             R3, loc_17480
LDR             R2, [SP,#0x1C+var_10]
MOV             R3, #gSensor_read_ok_counter
ADD.W           R3, R3, R2,LSL#4
LDR             R3, [R3,#0xC]
CMP             R3, #4
BLS.W           loc_175A2

loc_17480
MOVW            R3, #:lower16:gGlobalHighestTemp
LDR.W           R2, [R5,#configuration.TargetTemp]
MOVT            R3, #:upper16:gGlobalHighestTemp
LDR             R1, [SP,#0x1C+var_10]
LDR             R3, [R3]
MOV             R6, #gValid_Nonce_Num
MOVW            R0, #:lower16:aChainDTotalVal_0 ; "Chain%d total valid nonce number: %d, l"...
LDR.W           R7, [R6,R1,LSL#2]
MOVT            R0, #:upper16:aChainDTotalVal_0 ; "Chain%d total valid nonce number: %d, l"...
CMP             R2, R3
LDR             R2, [SP,#0x1C+var_8]
IT LT
LDRLT           R3, [SP,#0x1C+ret]
MOV             R8, R1
LDR             R2, [R2]
ITT LT
BICLT.W         R3, R3, #4
STRLT           R3, [SP,#0x1C+ret]
LDR             R3, [R5,#configuration.pattern_number]
MUL             R3, R2, R3
MOV             R2, R7
RSB.W           R3, R7, R3,LSL#8
BLX             printf
VLDR            S15, [R5,#configuration.pattern_number]
MOVW            R0, #:lower16:aNonceRateF ; "Nonce rate = %f \n\n"
LDR             R2, [SP,#0x1C+var_8]
MOVT            R0, #:upper16:aNonceRateF ; "Nonce rate = %f \n\n"
LDR.W           R3, [R6,R8,LSL#2]
VLDR            S11, =256.0
VLDR            S13, [R2]
VCVT.F32.U32    S15, S15
VMOV            S14, R3
VLDR            S12, =100.0
VCVT.F32.U32    S13, S13
VMUL.F32        S15, S15, S11
VCVT.F32.U32    S14, S14
VMUL.F32        S15, S15, S13
VMUL.F32        S14, S14, S12
VDIV.F32        S13, S14, S15
VCVT.F64.F32    D7, S13
VMOV            R2, R3, D7
BLX             printf
LDR             R3, [SP,#0x1C+ret]
LSLS            R1, R3, #0x1F
ITETE MI
MOVWMI          R0, #0x9D38
MOVWPL          R0, #0x9D44
MOVTMI          R0, #2
MOVTPL          R0, #2  ; s
BLX             puts
LDR             R3, [SP,#0x1C+ret]
LSLS            R2, R3, #0x1E
ITETE MI
MOVWMI          R0, #0xAB0C
MOVWPL          R0, #0xAB18
MOVTMI          R0, #2
MOVTPL          R0, #2  ; s
BLX             puts
LDR             R3, [SP,#0x1C+ret]
LSLS            R3, R3, #0x1D
ITETE MI
MOVWMI          R0, #0xBC2C
MOVWPL          R0, #0xBC3C
MOVTMI          R0, #2
MOVTPL          R0, #2  ; s
BLX             puts
LDR             R3, [SP,#0x1C+var_10]
MOV             R0, #aHwNumberD ; "HW number = %d\n\n"
LDR.W           R1, [R4,R3,LSL#2]
BLX             printf
MOVS            R0, #0x3E ; '>' ; address
BL              read_axi_fpga
MOV             R1, R0
MOV             R0, #aCrcErrorNumber ; "CRC error number = %d\n\n"
BLX             printf
LDR             R0, [SP,#0x1C+ret]
ADD             SP, SP, #0x1C
POP.W           {R4-R11,PC}

loc_1758E
which_core = R4         ; unsigned int
how_many_core_not_receive_all_nonce_per_asic = R3; unsigned int
works = R7              ; work *
MOVW            R0, #:lower16:aErrorAsicIsD ; "\n error asic is %d\n"
MOVS            how_many_core_not_receive_all_nonce_per_asic, #6
LDR             R1, [SP,#0x1C+which_asic]
MOVT            R0, #:upper16:aErrorAsicIsD ; "\n error asic is %d\n"
STR             R3, [SP,#0x1C+ret]
BLX             printf
B               loc_173C6

loc_175A2
LDR             R3, [SP,#0x1C+ret]
MOV             R0, #aSensor4CheckEr ; "\nSensor 4 check error"
BIC.W           R3, R3, #2
STR             R3, [SP,#0x1C+ret]
ret_0 = R3              ; unsigned int
BLX             puts
B               loc_17480

loc_175B8
LDR             R3, [SP,#0x1C+ret]
MOV             R0, #aSensor3CheckEr ; "\nSensor 3 check error"
BIC.W           R3, R3, #2
STR             R3, [SP,#0x1C+ret]
ret_0 = R3              ; unsigned int
BLX             puts
B               loc_17464

loc_175CE
LDR             R3, [SP,#0x1C+ret]
MOV             R0, #aSensor2CheckEr ; "\nSensor 2 check error"
BIC.W           R3, R3, #2
STR             R3, [SP,#0x1C+ret]
ret_0 = R3              ; unsigned int
BLX             puts
B               loc_17448
off_175E4 DCD reg_mutex+0x14
flt_175E8 DCFS 256.0
flt_175EC DCFS 100.0

loc_175F0
LDR             R3, [SP,#0x1C+ret]
MOV             R0, #aSensor1CheckEr ; "\nSensor 1 check error"
BIC.W           R3, R3, #2
STR             R3, [SP,#0x1C+ret]
ret_0 = R3              ; unsigned int
BLX             puts
B               loc_1742C
; End of function BHB91603_get_result

ALIGN 4



; void __fastcall BHB91603_print_lcd(unsigned int result)
EXPORT BHB91603_print_lcd
BHB91603_print_lcd
result = R0             ; unsigned int
PUSH            {R4,LR}
MOV             R4, result
BL              display_level_result_on_lcd
LSLS            R2, result, #0x1F
BPL             loc_17672
MOVW            R1, #:lower16:aPatternOk_0 ; "   Pattern OK   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aPatternOk_0 ; "   Pattern OK   "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R3, #:lower16:pattern_test_time
MOVS            R2, #0
MOVT            R3, #:upper16:pattern_test_time
STRB            R2, [R3]

loc_17630
LSLS            R3, result, #0x1E
MOV.W           R0, #2  ; line
ITETT MI
MOVWMI          R1, #0xBC64
MOVWPL          R1, #0xBC78
MOVMI           R2, #0x10
MOVTMI          R1, #2
ITT PL
MOVPL           R2, #0x10 ; size
MOVTPL          R1, #2  ; buf
BL              write_lcd_no_memset
MOV             R3, #gEEPROM_error
LDRB            R3, [R3]
CBNZ            R3, loc_17692
MOVW            R1, #:lower16:aEepromOk ; "   EEPROM OK   "
MOVS            R2, #0x10
MOVT            R1, #:upper16:aEepromOk ; "   EEPROM OK   "
MOVS            R0, #3
POP.W           {result,LR}
B.W             write_lcd_no_memset

loc_17672
result = R4             ; unsigned int
MOVW            R1, #:lower16:aPatternNg_0 ; "   Pattern NG   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aPatternNg_0 ; "   Pattern NG   "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOV             R3, #pattern_test_time
LDRB            R2, [R3]
ADDS            R2, #1
STRB            R2, [R3]
B               loc_17630

loc_17692
MOVW            R1, #:lower16:aEepromNg ; "   EEPROM NG   "
MOVS            R2, #0x10
MOVT            R1, #:upper16:aEepromNg ; "   EEPROM NG   "
MOVS            R0, #3
POP.W           {result,LR}
B.W             write_lcd_no_memset
; End of function BHB91603_print_lcd

ALIGN 4



; int __fastcall BHB91603_check_nonce(unsigned __int8 which_chain, unsigned int *buf)
EXPORT BHB91603_check_nonce
BHB91603_check_nonce

var_14= -0x14
var_10= -0x10
mutex= -0xC
ret= -8

which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
PUSH.W          {R4-R11,LR}
MOVW            R3, #:lower16:gChain_Asic_Interval
LDR             R5, [buf,#4]
MOVT            R3, #:upper16:gChain_Asic_Interval
SUB             SP, SP, #0x14
MOV             R7, which_chain
LDR.W           R8, [buf]
data_0 = R8             ; unsigned int
data_1 = R5             ; unsigned int
LDR             buf, [R3]
LSRS            which_chain, data_1, #0x18
UXTB.W          R10, data_1
BL              __aeabi_uidiv
TST.W           data_0, #0x40
MOV             R6, R0
which_asic = R0         ; unsigned int
which_core = R10        ; unsigned int
UBFX.W          R4, data_0, #0x10, #0xF
which_pattern = R4      ; unsigned int
BNE             loc_177A4

loc_176D6
which_asic = R6         ; unsigned int
MOV             R3, #BHB91603_ASIC_NUMBER
LDR             R3, [R3]
CMP             which_asic, R3
BCS.W           loc_1784C
MOV             R1, #Conf
LDR             R3, [R1,#configuration.pattern_number]
CMP             which_pattern, R3
BCS.W           loc_1784C
MOVW            R2, #:lower16:cgpu
ADD.W           R0, which_asic, #0x20000
MOVT            R2, #:upper16:cgpu
ADDS            R0, #0x2A ; '*'
MLA             R3, R3, which_core, which_pattern
ADD.W           R2, R2, R0,LSL#2
LDR             R2, [R2,#4]
ADD.W           R3, R3, R3,LSL#4
ADD.W           R3, R2, R3,LSL#2
work = R3               ; work *
LDR             R2, [work,#4]
CMP             data_1, R2
BEQ             loc_177BE
MOVW            R9, #:lower16:gHw_Nonce_Num
LDR.W           work, [R1,#configuration.Most_HW_Num]
match_nonce = R2        ; unsigned int
MOVT            R9, #:upper16:gHw_Nonce_Num
LDR.W           match_nonce, [R9,R7,LSL#2]
CMP             R2, R3
BLS             loc_17738

loc_17730
data_1 = R5             ; unsigned int
MOVS            R0, #0

loc_17732
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}

loc_17738
which_pattern = R4      ; unsigned int
data_0 = R8             ; unsigned int
data_1 = R5             ; unsigned int
MOVW            R3, #:lower16:HW_check_mutex
ADD.W           R11, R7, R7,LSL#1
MOVT            R3, #:upper16:HW_check_mutex
ADD.W           R3, R3, R11,LSL#3
data_1 = R5             ; unsigned int
MOV             R8, #gWork_Num_For_Hw_Check
MOV             R0, R3  ; mutex
STR             R3, [SP,#0x14+mutex]
BLX             pthread_mutex_lock
LDRB.W          which_pattern, [R8]
CMP             R4, #0
BEQ             loc_17856
MOVW            R3, #:lower16:gWorks_For_Hw_Check
ADD.W           R4, R7, R7,LSL#4
MOVT            R3, #:upper16:gWorks_For_Hw_Check
ADD.W           R4, R3, R4,LSL#9
MOV.W           R11, #0
B               loc_1777E

loc_17776
i = R11                 ; int
LDRB.W          R1, [R8]
CMP             R1, i
BLE             loc_1781A

loc_1777E               ; work
MOV             R0, R4
MOVS            R2, #0  ; print
MOV             R1, data_1 ; nonce
ADD.W           i, i, #1
ADDS            R4, #0x44 ; 'D'
BL              check_hw
i = R11                 ; int
CMP             R0, #0
BNE             loc_17776
STR             R0, [SP,#0x14+ret]
LDR             R0, [SP,#0x14+mutex] ; mutex
BLX             pthread_mutex_unlock
LDR             R2, [SP,#0x14+ret]
MOV             R0, R2
ADD             SP, SP, #0x14
POP.W           {R4-i,PC}

loc_177A4
which_asic = R0         ; unsigned int
which_pattern = R4      ; unsigned int
data_0 = R8             ; unsigned int
data_1 = R5             ; unsigned int
MOVW            which_asic, #:lower16:aSNonceCrcError ; "\n!!! %s: nonce crc error! nonce = 0x%0"...
which_asic = R6         ; unsigned int
STR             which_pattern, [SP,#0x14+var_10]
STR.W           which_core, [SP,#0x14+var_14]
MOV             R3, which_asic
MOV             R2, data_1
LDR             R1, =__FUNCTION__.8298 ; "BHB91603_check_nonce"
MOVT            R0, #:upper16:aSNonceCrcError ; "\n!!! %s: nonce crc error! nonce = 0x%0"...
BLX             printf
B               loc_176D6

loc_177BE
match_nonce = R2        ; unsigned int
work = R3               ; work *
ADD.W           work, work, R7,LSL#2
LDR             R0, [R3,#0x34]
CBZ             R0, loc_177E4
MOVW            match_nonce, #:lower16:gRepeated_Nonce_Id
ADDS            R0, #1
MOVT            R2, #:upper16:gRepeated_Nonce_Id
STR             R0, [R3,#0x34]
LDR.W           R3, [R2,R7,LSL#2]
MOVS            R0, #0
ADDS            R3, #1
STR.W           R3, [R2,R7,LSL#2]
ADD             SP, SP, #0x14
POP.W           {which_pattern-R11,PC}

loc_177E4
match_nonce = R2        ; unsigned int
data_0 = R8             ; unsigned int
data_1 = R5             ; unsigned int
ADD.W           which_asic, which_asic, R7,LSL#7
MOVW            match_nonce, #:lower16:gAsic_Core_Nonce_Num
MOVW            R1, #:lower16:gValid_Nonce_Num
ADD.W           which_core, which_core, R6,LSL#10
MOVT            R2, #:upper16:gAsic_Core_Nonce_Num
MOVT            R1, #:upper16:gValid_Nonce_Num
MOVS            which_pattern, #1
STR             R4, [R3,#0x34]
LDR.W           R4, [R1,R7,LSL#2]
LDR.W           R3, [R2,R10,LSL#2]
ADDS            R4, #1
ADDS            R3, #1
STR.W           R4, [R1,R7,LSL#2]
STR.W           R3, [R2,R10,LSL#2]
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}

loc_1781A
which_asic = R6         ; unsigned int
which_core = R10        ; unsigned int
data_1 = R5             ; unsigned int
i = R11                 ; int
STR             R0, [SP,#0x14+ret]
ret_0 = R0              ; int
LDR             ret_0, [SP,#0x14+mutex] ; mutex
BLX             pthread_mutex_unlock
LDR             R2, [SP,#0x14+ret]
CMP             R2, #1
BNE             loc_17730
LDR.W           R1, [R9,R7,LSL#2]
MOVW            R0, #:lower16:aSFindAHwChainD ; "%s: Find a HW. Chain%d ASIC%d Core%d : "...
STR             data_1, [SP,#0x14+var_10]
MOV             R3, which_asic
STR.W           which_core, [SP,#0x14+var_14]
MOV             R2, R7
ADDS            R4, R1, #1
MOVT            R0, #:upper16:aSFindAHwChainD ; "%s: Find a HW. Chain%d ASIC%d Core%d : "...
LDR             R1, =__FUNCTION__.8298 ; "BHB91603_check_nonce"
STR.W           R4, [R9,R7,LSL#2]
BLX             printf
B               loc_17730

loc_1784C
which_pattern = R4      ; unsigned int
data_0 = R8             ; unsigned int
data_1 = R5             ; unsigned int
MOV.W           R0, #0xFFFFFFFF
ADD             SP, SP, #0x14
POP.W           {which_pattern-R11,PC}

loc_17856               ; mutex
data_1 = R5             ; unsigned int
LDR             R0, [SP,#0x14+mutex]
BLX             pthread_mutex_unlock
MOV             R0, R4
B               loc_17732
; End of function BHB91603_check_nonce

off_17860 DCD __FUNCTION__.8298 ; "BHB91603_check_nonce"



; int __fastcall BHB91603_check_register_value(unsigned __int8 which_chain, unsigned int *buf)
EXPORT BHB91603_check_register_value
BHB91603_check_register_value
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
PUSH            {R3-R7,LR}
MOV             R5, #reg_value_buf
LDR             R4, [buf]
LDR             R2, [R5]
LDR             R7, [buf,#4]
data_0 = R4             ; unsigned int
data_1 = R7             ; unsigned int
LDR             R2, [R2,#8]
CMP.W           R2, #0x1FE
BHI             loc_178EC
LSLS            R3, data_0, #0x19
BMI             loc_17900
ANDS.W          R6, data_0, #0x20000000
BNE             loc_178D4
MOV             R0, #reg_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R2, [R5]
LSRS            R3, data_0, #8
LSRS            R5, data_0, #0x10
UBFX.W          LR, data_0, #0x18, #5
AND.W           data_0, data_0, #0xF
data_1 = R7             ; unsigned int
LDR             R1, [R2]
ADD.W           R0, R2, R1,LSL#3
ADDS            R1, #1
CMP.W           R1, #0x200
STR             data_1, [R0,#0x10]
STRB.W          LR, [R0,#0x16]
STRB            R5, [R0,#0x14]
STRB            R4, [R0,#0x17]
STRB            R3, [R0,#0x15]
MOVW            R0, #:lower16:reg_mutex
LDR             R3, [R2,#8]
MOVT            R0, #:upper16:reg_mutex ; mutex
STR             R1, [R2]
IT CS
STRCS           R6, [R2]
ADDS            R3, #1
STR             R3, [R2,#8]
BLX             pthread_mutex_unlock
MOVS            R0, #0
POP             {R3-data_1,PC}

loc_178D4
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
data_0 = R4             ; unsigned int
data_1 = R7             ; unsigned int
MOVW            which_chain, #:lower16:aSRegTypeErrorD ; "%s: REG_TYPE error. data[0] = 0x%08x, r"...
MOV             R3, data_1
MOV             R2, data_0
LDR             buf, =__FUNCTION__.8307 ; "BHB91603_check_register_value"
MOVT            R0, #:upper16:aSRegTypeErrorD ; "%s: REG_TYPE error. data[0] = 0x%08x, r"...
BLX             printf
MOV.W           R0, #0xFFFFFFFF
POP             {R3-data_1,PC}

loc_178EC
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
data_0 = R4             ; unsigned int
data_1 = R7             ; unsigned int
MOVW            which_chain, #:lower16:aSRegValueBufBu ; "%s: reg_value_buf buffer is full!\n"
LDR             buf, =__FUNCTION__.8307 ; "BHB91603_check_register_value"
MOVT            R0, #:upper16:aSRegValueBufBu ; "%s: reg_value_buf buffer is full!\n"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
POP             {R3-data_1,PC}

loc_17900
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
data_0 = R4             ; unsigned int
data_1 = R7             ; unsigned int
MOVW            which_chain, #:lower16:aSRegCrcErrorDa ; "%s: reg crc error. data[0] = 0x%08x, re"...
MOV             R3, data_1
MOV             R2, data_0
LDR             buf, =__FUNCTION__.8307 ; "BHB91603_check_register_value"
MOVT            R0, #:upper16:aSRegCrcErrorDa ; "%s: reg crc error. data[0] = 0x%08x, re"...
BLX             printf
MOV.W           R0, #0xFFFFFFFF
POP             {R3-data_1,PC}
; End of function BHB91603_check_register_value

off_17918 DCD __FUNCTION__.8307 ; "BHB91603_check_register_value"



; void *__fastcall BHB91603_receive_func(void *arg)
EXPORT BHB91603_receive_func
BHB91603_receive_func

sp= -0xC
buf= -8

arg = R0                ; void *
which_chain = R8        ; unsigned __int8
PUSH.W          {R4-which_chain,LR}
MOV             R2, arg
chain_info = R0         ; chain_info *
SUB             SP, SP, #0x10
MOVS            R3, #0
MOVS            chain_info, #1 ; algorithm
chain_info = R2         ; chain_info *
LDRB.W          which_chain, [chain_info]
LDRB            R5, [chain_info,#1]
which_i2c = R5          ; unsigned __int8
STR             R3, [SP,#0x10+buf]
STR             R3, [SP,#0x10+buf+4]
STR             R3, [SP,#0x10+sp]
BLX             sched_get_priority_max
MOV             R4, R0
priority = R0           ; const int
STR             priority, [SP,#0x10+sp]
BLX             pthread_self
ADD             R2, SP, #0x10+sp ; param
MOVS            R1, #1  ; policy
MOV             R6, R0
BLX             pthread_setschedparam
CMP             R0, #0
BEQ             loc_179CE

loc_1794E
MOVW            R0, #:lower16:aSWhichChainDWh_1 ; "\n--- %s: which_chain = %d, which_i2c ="...
MOVW            R6, #:lower16:start_receive
MOVW            R7, #:lower16:gBegin_Get_Nonce
MOV             R3, which_i2c
MOV             R2, which_chain
LDR             R1, =__FUNCTION__.8371 ; "BHB91603_receive_func"
MOVT            R0, #:upper16:aSWhichChainDWh_1 ; "\n--- %s: which_chain = %d, which_i2c ="...
MOVT            R6, #:upper16:start_receive
MOVT            R7, #:upper16:gBegin_Get_Nonce
BLX             printf
B               loc_17986

loc_17972               ; useconds
MOV.W           R0, #0x3E8
BLX             usleep
MOVS            R0, #6  ; address
BL              read_axi_fpga
UBFX.W          R4, R0, #0, #9
nonce_number = R4       ; unsigned int
CBNZ            nonce_number, loc_17992

loc_17986
LDRB            R0, [R6]
CMP             R0, #0
BNE             loc_17972
ADD             SP, SP, #0x10
POP.W           {R4-which_chain,PC}

loc_17992
nonce_number = R4       ; unsigned int
MOVS            R5, #0
B               loc_179A0

loc_17996
i = R5                  ; unsigned int
LDRB            R3, [R7]
CBNZ            R3, loc_179BA

loc_1799A
ADDS            i, #1
CMP             nonce_number, i
BLS             loc_17986

loc_179A0               ; buf
ADD             R0, SP, #0x10+buf
BL              get_return_nonce
LDR             R0, [SP,#0x10+buf] ; data
BL              BM1391_is_nonce_or_reg_value
CMP             R0, #0
BNE             loc_17996
ADD             R1, SP, #0x10+buf ; buf
MOV             R0, which_chain ; which_chain
BL              BHB91603_check_register_value
B               loc_1799A

loc_179BA               ; data
LDR             R0, [SP,#0x10+buf]
BL              BM1391_check_nonce_flag
CMP             R0, #0
BEQ             loc_1799A
ADD             R1, SP, #0x10+buf ; buf
MOV             R0, which_chain ; which_chain
BL              BHB91603_check_nonce
B               loc_1799A

loc_179CE
which_i2c = R5          ; unsigned __int8
priority = R4           ; const int
MOVW            R0, #:lower16:aSIoThreadLxUsi ; "\n--- %s: IO Thread #%lx using %d prior"...
MOV             R3, priority
MOV             R2, R6
LDR             R1, =__FUNCTION__.8371 ; "BHB91603_receive_func"
MOVT            R0, #:upper16:aSIoThreadLxUsi ; "\n--- %s: IO Thread #%lx using %d prior"...
BLX             printf
B               loc_1794E
; End of function BHB91603_receive_func

ALIGN 4
off_179E4 DCD __FUNCTION__.8371 ; "BHB91603_receive_func"



; void singleBoardTest_BHB91603_BM1391()
EXPORT singleBoardTest_BHB91603_BM1391
singleBoardTest_BHB91603_BM1391

line= -0x1C
var_18= -0x18
lcd_display_buf= -0x14

PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x1C
LDR             R5, =dword_2B8A0
ADD             R4, SP, #0x1C+lcd_display_buf
MOV             R6, #lcd_fd
LDR             R2, [R5,#(dword_2B8A8 - 0x2B8A0)]
LDR             R3, [R5,#(dword_2B8AC - 0x2B8A0)]
LDR             R0, [R5]
LDR             R1, [R5,#(dword_2B8A4 - 0x2B8A0)]
STM             R4!, {R0-R3}
MOVW            R0, #:lower16:aBeginSTest ; "\nBegin %s test\n"
ADD.W           R1, R5, #0x10
MOVT            R0, #:upper16:aBeginSTest ; "\nBegin %s test\n"
BLX             printf
MOV             R0, #aDate ; "date"
BLX             system
MOVS            R0, #0xA ; c
BLX             putchar
MOVW            R0, #:lower16:lcd_output
MOVS            R2, #0x40 ; '@' ; n
MOVT            R0, #:upper16:lcd_output ; s
MOVS            R1, #0x20 ; ' ' ; c
BLX             memset
LDR             R0, [R6] ; fd
CMP             R0, #0
BLE             loc_17A54
MOVS            R2, #0  ; whence
MOV             R1, R2  ; offset
BLX             lseek
MOVW            R1, #:lower16:lcd_output
LDR             R0, [R6] ; fd
MOVT            R1, #:upper16:lcd_output ; buf
MOVS            R2, #0x40 ; '@' ; n
BLX             write

loc_17A54
BL              init_fpga
MOVS            R0, #0x1A ; asic_baud
MOVW            R4, #:lower16:gChain
BL              set_fpga_baud
MOVS            R1, #0  ; data
MOVS            R0, #0x3E ; '>' ; address
BL              write_axi_fpga
MOVS            R0, #0  ; address
MOVT            R4, #:upper16:gChain
BL              read_axi_fpga
ORR.W           R1, R0, #0x40000000 ; data
MOVS            R0, #0  ; address
BL              write_axi_fpga
BL              reset_BHB91603_global_arg
BL              check_chain
LDRB            R3, [R4]
CMP             R3, #0xFF
BEQ.W           loc_17BDC
LDR             R7, =cgpu.show_id
MOV             R5, #chain_info_0
MOVW            R2, #:lower16:(BHB91603_show_status_func+1)
ADD.W           R3, R5, R3,LSL#1 ; arg
MOVT            R2, #:upper16:(BHB91603_show_status_func+1) ; start_routine
MOV             R0, R7  ; newthread
MOVS            R1, #0  ; attr
BLX             pthread_create
thread_ret = R0         ; unsigned int
MOV             R3, thread_ret
CBZ             thread_ret, loc_17AFA
LDR             thread_ret, [R7] ; th
thread_ret = R3         ; unsigned int
BLX             pthread_cancel
MOVW            R1, #:lower16:aCreatShow ; "   Creat show   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCreatShow ; "   Creat show   "
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreateSingleB ; "\n!!!%s: create single_BM1391_show_stat"...
LDR             R1, =__FUNCTION__.8385 ; "singleBoardTest_BHB91603_BM1391"
MOVT            R0, #:upper16:aSCreateSingleB ; "\n!!!%s: create single_BM1391_show_stat"...
BLX             printf

loc_17AF4
ADD             SP, SP, #0x1C
POP.W           {R4-R11,PC}

loc_17AFA
thread_ret = R0         ; unsigned int
MOVW            R8, #:lower16:gEEPROM_error
MOVW            thread_ret, #:lower16:i2c_mutex
thread_ret = R3         ; unsigned int
MOVT            R8, #:upper16:gEEPROM_error
MOV             R1, thread_ret ; mutexattr
MOVT            R0, #:upper16:i2c_mutex ; mutex
STRB.W          thread_ret, [R8]
BLX             pthread_mutex_init
BL              Test_EEPROM_part_area
CMP             R0, #0
BNE             loc_17BFE
MOVW            R0, #:lower16:aSCheckEepromOk ; "\n--- %s: Check EEPROM ok!!!\n"
LDR             R1, =__FUNCTION__.8385 ; "singleBoardTest_BHB91603_BM1391"
MOVT            R0, #:upper16:aSCheckEepromOk ; "\n--- %s: Check EEPROM ok!!!\n"
BLX             printf

loc_17B2A               ; data
MOVW            R1, #0xFFFF
MOVS            R0, #0xD ; address
BL              write_axi_fpga
MOVW            R6, #:lower16:gI2c
MOVW            R0, #:lower16:(gAsic_Core_Nonce_Num+0x1859C)
MOVT            R6, #:upper16:gI2c
MOVT            R0, #:upper16:(gAsic_Core_Nonce_Num+0x1859C) ; useconds
BLX             usleep
LDRB            R1, [R6] ; which_i2c
LDRB            R0, [R4] ; which_chain
BL              reset_dsPIC33EP16GS202_pic
LDRB            R1, [R6] ; which_i2c
LDRB            R0, [R4] ; which_chain
BL              jump_from_loader_to_app_dsPIC33EP16GS202
LDRB            R3, [R4]
MOV             R2, #(pic_heart_beat_func+1) ; start_routine
MOVS            R1, #0  ; attr
LDR             R0, =cgpu.pic_heart_beat_id ; newthread
ADD.W           R3, R5, R3,LSL#1 ; arg
BLX             pthread_create
thread_ret = R0         ; unsigned int
CMP             thread_ret, #0
BEQ             loc_17C14
LDR             thread_ret, [R7] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R3, =cgpu.send_id
LDR             R0, [R3,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOVW            R1, #:lower16:aCreatHeartBeat ; "Creat heart beat"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCreatHeartBeat ; "Creat heart beat"
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreatePicHear ; "\n!!!%s: create pic_heart_beat_func fai"...
LDR             R1, =__FUNCTION__.8385 ; "singleBoardTest_BHB91603_BM1391"
MOVT            R0, #:upper16:aSCreatePicHear ; "\n!!!%s: create pic_heart_beat_func fai"...
BLX             printf
ADD             SP, SP, #0x1C
POP.W           {R4-R11,PC}

loc_17BDC
MOVW            R1, #:lower16:aNoHashBoard_0 ; " no hash board  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aNoHashBoard_0 ; " no hash board  "
MOVS            R0, #1  ; line
BL              write_lcd
MOV             R0, #aNoHashBoardPle ; "\nNo hash board, please plug in it"
BLX             puts
ADD             SP, SP, #0x1C
POP.W           {R4-R11,PC}

loc_17BFE
MOVW            R0, #:lower16:aSCheckEepromEr ; "\n!!! %s: Check EEPROM error!!!\n\n"
LDR             R1, =__FUNCTION__.8385 ; "singleBoardTest_BHB91603_BM1391"
MOVT            R0, #:upper16:aSCheckEepromEr ; "\n!!! %s: Check EEPROM error!!!\n\n"
BLX             printf
MOVS            R3, #1
STRB.W          R3, [R8]
B               loc_17B2A

loc_17C14               ; useconds
MOV             R0, #(gAsic_Core_Nonce_Num+0x1859C)
BLX             usleep
LDRB            R1, [R6] ; which_iic
LDRB            R0, [R4] ; which_chain
BL              set_pre_open_core_voltage
ret = R0                ; int
MOV             R10, ret
CMP             ret, #0
BNE.W           loc_17AF4
MOV             R2, ret ; enable
LDRB            R1, [R6] ; which_i2c
LDRB            ret, [R4] ; which_chain
ret = R2                ; int
MOV.W           R11, #1
BL              enable_dsPIC33EP16GS202_clamping_voltage
MOV             R1, ret ; data
MOVS            R0, #0xD ; address
BL              write_axi_fpga
MOV             R0, #(gAsic_Core_Nonce_Num+0x1859C) ; useconds
BLX             usleep
MOVW            R3, #:lower16:start_receive
MOVW            R0, #0x2710 ; useconds
MOVT            R3, #:upper16:start_receive
STRB.W          R11, [R3]
BLX             usleep
LDRB            R3, [R4]
MOV             R2, #(BHB91603_receive_func+1) ; start_routine
MOV             R1, ret ; attr
LDR             R0, =cgpu.receive_id ; newthread
ADD.W           R3, R5, R3,LSL#1 ; arg
BLX             pthread_create
thread_ret = R0         ; unsigned int
MOV             R9, thread_ret
CMP             thread_ret, #0
BNE             loc_17D30
MOVS            thread_ret, #0x40 ; '@' ; address
thread_ret = R9         ; unsigned int
MOVW            ret, #:lower16:Conf
BL              read_axi_fpga
BIC.W           R1, R0, #0x8100
MOVS            R0, #0x40 ; '@' ; address
BIC.W           R1, R1, #0xE0
MOVT            R10, #:upper16:Conf
ORR.W           R1, R1, #0x8100 ; data
BL              write_axi_fpga
MOVW            R0, #:lower16:aSConfOpencoren ; "\n---%s: Conf.OpenCoreNum1 = %d, Conf.O"...
LDR.W           R3, [R10,#configuration.OpenCoreNum2]
LDR.W           R2, [R10,#configuration.OpenCoreNum1]
MOVT            R0, #:upper16:aSConfOpencoren ; "\n---%s: Conf.OpenCoreNum1 = %d, Conf.O"...
LDR             R1, =__FUNCTION__.8385 ; "singleBoardTest_BHB91603_BM1391"
BLX             printf
LDR.W           R3, [R10,#configuration.OpenCoreNum1]
CMP             R3, #0
BEQ             loc_17DA2
MOVW            R3, #:lower16:gHashBoard_BHB91603S
MOVW            R2, #:lower16:(gAsic_Core_Nonce_Num+0x492DC)
MOVW            R11, #:lower16:gHashBoard_BHB91603P
MOVT            R3, #:upper16:gHashBoard_BHB91603S
MOVT            R2, #:upper16:(gAsic_Core_Nonce_Num+0x492DC)
STR.W           R8, [SP,#0x1C+line]
STR             R5, [SP,#0x1C+var_18]
MOV             R8, thread_ret
MOVT            R11, #:upper16:gHashBoard_BHB91603P
MOV             thread_ret, R3
thread_ret = R8         ; unsigned int
MOV             R5, R2
B               loc_17D08

loc_17CE6
i = R8                  ; unsigned int
LDRB.W          R3, [R9]
CMP             R3, #0
BEQ.W           loc_17EB0
LDRB            R0, [R4] ; which_chain
BL              BHB91603_S_pre_open_core
MOV             R0, R5  ; useconds
BLX             usleep

loc_17CFC
LDR.W           R3, [R10,#configuration.OpenCoreNum1]
ADD.W           i, i, #1
CMP             R3, i
BLS             loc_17D9C

loc_17D08
LDRB.W          R3, [R11]
CMP             R3, #0
BEQ             loc_17CE6
LDRB            R0, [R4] ; which_chain
BL              BHB91603_P_pre_open_core
B               loc_17CFC
off_17D18 DCD dword_2B8A0
off_17D1C DCD cgpu.show_id
off_17D20 DCD __FUNCTION__.8385 ; "singleBoardTest_BHB91603_BM1391"
off_17D24 DCD cgpu.pic_heart_beat_id
off_17D28 DCD cgpu.send_id
off_17D2C DCD cgpu.receive_id

loc_17D30
thread_ret = R0         ; unsigned int
ret = R10               ; int
LDR             R4, =cgpu.send_id
LDR             thread_ret, [R7] ; th
thread_ret = R9         ; unsigned int
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R4,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDR             R0, [R4,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOVW            R1, #:lower16:aCreatReceive ; "  Creat receive "
MOV             R0, ret ; line
MOVT            R1, #:upper16:aCreatReceive ; "  Creat receive "
MOVS            R2, #0x10 ; size
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOV             R0, R11 ; line
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreateBhb9160 ; "\n!!!%s: create BHB91603_receive_func f"...
LDR             R1, =__FUNCTION__.8385 ; "singleBoardTest_BHB91603_BM1391"
MOVT            R0, #:upper16:aSCreateBhb9160 ; "\n!!!%s: create BHB91603_receive_func f"...
BLX             printf
B               loc_17AF4

loc_17D9C
i = R8                  ; unsigned int
LDR.W           i, [SP,#0x1C+line]
LDR             R5, [SP,#0x1C+var_18]

loc_17DA2
MOVW            R0, #:lower16:aBhb91603CheckA ; "\n--- BHB91603 check asic number"
MOVW            R11, #:lower16:cgpu
MOVT            R0, #:upper16:aBhb91603CheckA ; "\n--- BHB91603 check asic number"
MOVT            R11, #:upper16:cgpu
BLX             puts
MOVS            R2, #0  ; reg
MOVS            R3, #1  ; mode
MOV             R1, R2  ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              check_BM1391_asic_reg
LDRB            R1, [R4]
MOV             R0, #aCheckChainJDHa ; "\n--- check chain: J%d has asicNum = %d"...
MOV             R9, #BHB91603_ASIC_NUMBER
ADD.W           R3, R11, R1
ADDS            R1, #1
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             printf
LDRB            R0, [R4] ; which_chain
LDR.W           R2, [R9]
ADD.W           R3, R11, R0
ADD.W           R3, R3, #0x100000
LDRB.W          R3, [R3,#0x30C]
CMP             R3, R2
BEQ.W           loc_17F2E
ADD.W           R5, R11, #0x80000
LDR             R0, [R5,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R7] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R5,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDRB            R3, [R4]
MOV             R1, #(aT1DT2D+0xC) ; format
ADD.W           R0, SP, #0x1C+lcd_display_buf+7 ; s
ADD             R3, R11
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             sprintf
MOVW            R1, #:lower16:aOnlyHave ; "   Only have    "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aOnlyHave ; "   Only have    "
MOVS            R0, #0  ; line
BL              write_lcd
ADD             R1, SP, #0x1C+lcd_display_buf ; buf
MOVS            R2, #0x10 ; size
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aAsic ; "      ASIC      "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aAsic ; "      ASIC      "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
LDRB            R3, [R4]
MOVW            R0, #:lower16:aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
LDR             R1, =__FUNCTION__.8385 ; "singleBoardTest_BHB91603_BM1391"
MOVT            R0, #:upper16:aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
ADD             R3, R11
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             printf
MOV             R0, #asc_29F80 ; "----------------------------\n\n"
BLX             puts
LDR.W           R0, [R10,#configuration.close_power_delay] ; seconds
BLX             sleep

loc_17EA0               ; which_i2c
LDRB            R1, [R6]
MOVS            R2, #0  ; enable
LDRB            R0, [R4] ; which_chain
BL              enable_dsPIC33EP16GS202_dc_dc
BL              power_off
B               loc_17AF4

loc_17EB0
i = R8                  ; unsigned int
LDR             R5, =cgpu.send_id
LDR             R0, [R7] ; th
STR             R3, [SP,#0x1C+line]
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R5,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDR             R0, [R5,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R3, [SP,#0x1C+line]
MOVW            R1, #:lower16:aConfig ; "     Config     "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aConfig ; "     Config     "
MOV             R0, R3  ; line
BL              write_lcd
MOVW            R1, #:lower16:aHashboardType ; " Hashboard Type "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aHashboardType ; " Hashboard Type "
MOVS            R0, #1  ; line

loc_17EFC
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aInConfigIni ; " in Config.ini  "
MOVS            R0, #2  ; line
MOVT            R1, #:upper16:aInConfigIni ; " in Config.ini  "
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCanTFindHashb ; "\n!!!%s: Can't find Hashboard type when"...
LDR             R1, =__FUNCTION__.8385 ; "singleBoardTest_BHB91603_BM1391"
MOVT            R0, #:upper16:aSCanTFindHashb ; "\n!!!%s: Can't find Hashboard type when"...
BLX             printf

loc_17F1E               ; enable
MOVS            R2, #0
LDRB            R1, [R6] ; which_i2c
LDRB            R0, [R4] ; which_chain
BL              enable_dsPIC33EP16GS202_dc_dc
BL              power_off
B               loc_17AF4

loc_17F2E               ; baud
MOVS            R1, #0
BL              BHB91603_set_baud
LDRB            R0, [R4]
BL              reset_hash_board
MOVS            R0, #0x1A ; asic_baud
BL              set_fpga_baud
LDRB            R3, [R4]
MOVW            R0, #:lower16:aDoubleCheckAsi ; "\n--- double check asic number"
MOV.W           R2, #0
MOVT            R0, #:upper16:aDoubleCheckAsi ; "\n--- double check asic number"
ADD             R3, R11
ADD.W           R3, R3, #0x100000
STRB.W          R2, [R3,#0x30C]
BLX             puts
MOVS            R2, #0  ; reg
MOVS            R3, #1  ; mode
MOV             R1, R2  ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              check_BM1391_asic_reg
LDRB            R1, [R4]
MOV             R0, #aCheckChainJDHa ; "\n--- check chain: J%d has asicNum = %d"...
ADD.W           R3, R11, R1
ADDS            R1, #1
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             printf
LDRB            R3, [R4]
LDR.W           R2, [R9]
ADD             R3, R11
ADD.W           R3, R3, #0x100000
LDRB.W          R3, [R3,#0x30C]
CMP             R3, R2
BEQ             loc_1803C
ADD.W           R5, R11, #0x80000
LDR             R0, [R5,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R7] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R5,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDRB            R3, [R4]
MOV             R1, #(aT1DT2D+0xC) ; format
ADD.W           R0, SP, #0x1C+lcd_display_buf+7 ; s
ADD             R3, R11
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             sprintf
MOVW            R1, #:lower16:aOnlyHave ; "   Only have    "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aOnlyHave ; "   Only have    "
MOVS            R0, #0  ; line
BL              write_lcd
ADD             R1, SP, #0x1C+lcd_display_buf ; buf
MOVS            R2, #0x10 ; size
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aAsic ; "      ASIC      "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aAsic ; "      ASIC      "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
LDRB            R3, [R4]
MOV             R0, #aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
LDR             R1, =__FUNCTION__.8385 ; "singleBoardTest_BHB91603_BM1391"
ADD             R3, R11
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             printf
MOV             R0, #asc_29F80 ; "----------------------------\n\n"
BLX             puts

loc_18032               ; seconds
LDR.W           R0, [R10,#configuration.close_power_delay]
BLX             sleep
B               loc_17F1E

loc_1803C
LDR             R3, =(cgpu.subid+0x7FD54)
LDRB.W          R3, [R3,#(cgpu.Only_find_ASIC - 0x330FC4)]
STR             R3, [SP,#0x1C+line]
CBZ             R3, loc_180B8
ADD.W           R11, R11, #0x80000
LDR.W           R0, [R11,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R7] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR.W           R0, [R11,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOVW            R1, #:lower16:aFindAllAsic ; " find all ASIC  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aFindAllAsic ; " find all ASIC  "
MOVS            R0, #1  ; line
BL              write_lcd
MOVW            R1, #:lower16:aOk ; "       OK       "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aOk ; "       OK       "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aFindDAsicOk ; "\nFind %d ASIC, OK\n"
LDR.W           R1, [R9]
MOVT            R0, #:upper16:aFindDAsicOk ; "\nFind %d ASIC, OK\n"
BLX             printf
B               loc_18032
ALIGN 4
off_180AC DCD cgpu.send_id
off_180B0 DCD __FUNCTION__.8385 ; "singleBoardTest_BHB91603_BM1391"
off_180B4 DCD cgpu.subid+0x7FD54

loc_180B8
BL              BHB91603_calculate_timeout_and_baud
LDR.W           R9, [SP,#0x1C+line]
MOVS            R3, #1  ; mode
LDR.W           R2, [R10,#configuration.Freq] ; freq
LDRB            R0, [R4] ; which_chain
MOV             R1, R9  ; chip_addr
BL              set_BM1391_freq
LDRB            R0, [R4] ; which_chain
BL              BHB91603_set_address
LDR             R3, =(cgpu.subid+0x7FD54)
LDRB            R0, [R4] ; which_chain
LDRB.W          R1, [R3,#(cgpu.baud - 0x330FC4)] ; baud
BL              BHB91603_set_baud
MOVS            R3, #1  ; mode
MOVS            R2, #0x3F ; '?' ; tm
MOV             R1, R9  ; asic_addr
LDRB            R0, [R4] ; which_chain
BL              BM1391_set_TM
LDR.W           R1, [R10,#configuration.timeout]
MOVS            R0, #0x22 ; '"' ; address
ORR.W           R1, R1, #0x80000000 ; data
BL              write_axi_fpga
MOVW            R0, #0x2710 ; useconds
BLX             usleep
LDRB            R0, [R4] ; which_chain
BL              BM1391_soft_reset_sensor
LDRB            R0, [R4] ; which_chain
BL              BM1391_enable_extended_mode_of_temperature_sensor
MOVW            R2, #:lower16:gHashBoard_BHB91603P
MOVW            R3, #:lower16:gIsReadTemp
MOVT            R2, #:upper16:gHashBoard_BHB91603P
MOVT            R3, #:upper16:gIsReadTemp
LDRB            R2, [R2]
MOV.W           R1, #1
STRB            R1, [R3]
CMP             R2, #0
BNE.W           loc_18272
MOV             R3, #gHashBoard_BHB91603S
LDRB.W          R9, [R3]
CMP.W           R9, #0
BEQ             loc_18222
LDRB            R0, [R4] ; which_chain
BL              BHB91603_S_open_core

loc_18144               ; which_iic
LDRB            R1, [R6]
MOVW            R9, #:lower16:gStartTest
LDRB            R0, [R4] ; which_chain
MOVT            R9, #:upper16:gStartTest
BL              adjust_voltage
MOV             R0, #aBeginSendTestP ; "\nBegin send test pattern"
BLX             puts
LDRB.W          R3, [R9]
CBNZ            R3, loc_18198
MOVW            R11, #:lower16:time_counter
LDR.W           R3, [R10,#configuration.HeatingUpTime]
MOVT            R11, #:upper16:time_counter
LDR.W           R2, [R11]
CMP             R2, R3
BCC             loc_18188
B               loc_1827A

loc_1817C
LDR.W           R2, [R10,#configuration.HeatingUpTime]
LDR.W           R3, [R11]
CMP             R2, R3
BLS             loc_1827A

loc_18188               ; useconds
MOVW            R0, #0x2710
BLX             usleep
LDRB.W          R3, [R9]
CMP             R3, #0
BEQ             loc_1817C

loc_18198
LDRB            R3, [R4]
MOVW            R2, #:lower16:(BHB91603_send_func+1)
LDR             R7, =cgpu.send_id
MOVT            R2, #:upper16:(BHB91603_send_func+1) ; start_routine
MOVS            R1, #0  ; attr
ADD.W           R3, R5, R3,LSL#1 ; arg
MOV             R0, R7  ; newthread
BLX             pthread_create
thread_ret = R0         ; unsigned int
MOV             R5, thread_ret
CMP             thread_ret, #0
BEQ.W           loc_18302
LDR             thread_ret, [R7,#(cgpu.show_id - 0x2B0FC4)] ; th
thread_ret = R5         ; unsigned int
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R7,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDR             R0, [R7,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOVW            R1, #:lower16:aCreatSend ; "   Creat send   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCreatSend ; "   Creat send   "
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreateBhb9160_0 ; "\n!!!%s: create BHB91603_send_func fail"...
LDR             R1, =__FUNCTION__.8385 ; "singleBoardTest_BHB91603_BM1391"
MOVT            R0, #:upper16:aSCreateBhb9160_0 ; "\n!!!%s: create BHB91603_send_func fail"...
BLX             printf
B               loc_17EA0

loc_18222               ; th
LDR             R0, [R7]
ADD.W           R11, R11, #0x80000
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR.W           R0, [R11,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDR.W           R0, [R11,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOVW            R1, #:lower16:aConfig ; "     Config     "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aConfig ; "     Config     "
MOV             R0, R9  ; line
BL              write_lcd
MOVW            R1, #:lower16:aHashboardType ; " Hashboard Type "
MOVS            R0, #1
MOVT            R1, #:upper16:aHashboardType ; " Hashboard Type "
MOVS            R2, #0x10
B               loc_17EFC

loc_18272               ; which_chain
LDRB            R0, [R4]
BL              BHB91603_P_open_core
B               loc_18144

loc_1827A
LDR             R5, =cgpu.send_id
LDR             R0, [R5,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R7] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R5,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #aCanTOpenCoreCh ; "Can't open core, change to next voltage"...
BLX             puts
MOVW            R1, #:lower16:aCanTOpenCore ; "Can't open core "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCanTOpenCore ; "Can't open core "
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aChangeToNext ; "change  to  next"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aChangeToNext ; "change  to  next"
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:(aCanTOpenCoreCh+0x20) ; "voltage and freq"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:(aCanTOpenCoreCh+0x20) ; buf
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R3, #:lower16:pattern_test_time
LDRB            R0, [R4] ; which_chain
MOVT            R3, #:upper16:pattern_test_time
LDRB            R1, [R6] ; which_i2c
LDRB            R4, [R3]
MOVS            R2, #0  ; enable
ADDS            R4, #1
STRB            R4, [R3]
BL              enable_dsPIC33EP16GS202_dc_dc
BL              power_off
B.W             loc_17AF4

loc_18302               ; thread_return
thread_ret = R0         ; unsigned int
MOV             R1, thread_ret
LDR             thread_ret, [R7] ; th
thread_ret = R5         ; unsigned int
BLX             pthread_join
MOV             R1, R5  ; thread_return
LDR             R0, [R7,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_join
LDR             R0, [R7,#(cgpu.show_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDRB            R0, [R4] ; which_chain
BL              BHB91603_get_result
LSLS            R3, R0, #0x1F
MOV             R5, R0
result = R0             ; unsigned int
BPL             loc_18394
LDRB.W          R3, [R8]
CMP             R3, #0
BNE             loc_183C8
LDRB            R1, [R4] ; which_chain
LDRB            result, [R6] ; which_iic
result = R5             ; unsigned int
BL              BHB91603_AT24C02_write_total_data
CMP             R0, #0
BEQ             loc_183BA
MOV             R0, #aEepromOk_0 ; "\nEEPROM OK\n"
BLX             puts

loc_18344               ; result
MOV             R0, result
BL              BHB91603_print_lcd
LDR.W           R0, [R10,#configuration.close_power_delay] ; seconds
BLX             sleep

loc_18352               ; which_i2c
LDRB            R1, [R6]
MOVS            R2, #0  ; enable
LDRB            R0, [R4] ; which_chain
BL              enable_dsPIC33EP16GS202_dc_dc
BL              power_off

loc_18360               ; mutex
MOV             R0, #i2c_mutex
BLX             pthread_mutex_lock
LDR             R0, [R7,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOVS            R0, #0  ; speed
BL              set_fan_speed
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
B.W             loc_17AF4

loc_18394
result = R0             ; unsigned int
BL              BHB91603_print_lcd
LDR.W           R0, [R10,#configuration.close_power_delay] ; seconds
BLX             sleep
MOVW            R2, #:lower16:pattern_test_time
MOVW            R3, #:lower16:gHowManyVoltageLevel
MOVT            R2, #:upper16:pattern_test_time
MOVT            R3, #:upper16:gHowManyVoltageLevel
LDRB            R2, [R2]
LDRB            R3, [R3]
CMP             R2, R3
BCS             loc_18352
B               loc_18360

loc_183BA
MOV             R0, #aEepromNg_0 ; "\nEEPROM NG\n"
BLX             puts
B               loc_18344

loc_183C8
result = R0             ; unsigned int
MOVW            result, #:lower16:aSDonTSaveDataI ; "\n!!!%s: Don't save data into EEPROM, b"...
result = R5             ; unsigned int
LDR             R1, =__FUNCTION__.8385 ; "singleBoardTest_BHB91603_BM1391"
MOVT            R0, #:upper16:aSDonTSaveDataI ; "\n!!!%s: Don't save data into EEPROM, b"...
BLX             printf
B               loc_18344
; End of function singleBoardTest_BHB91603_BM1391

off_183D8 DCD cgpu.subid+0x7FD54
off_183DC DCD cgpu.send_id
off_183E0 DCD __FUNCTION__.8385 ; "singleBoardTest_BHB91603_BM1391"



; void read_config()
EXPORT read_config
read_config

var_41C= -0x41C
var_418= -0x418
var_414= -0x414
temp= -0x410
starttemp= -0x408
str= -0x404

PUSH.W          {R4-R11,LR}
SUBW            SP, SP, #0x41C
MOV.W           R2, #0x400 ; n
MOVS            R1, #0  ; c
ADD             R0, SP, #0x41C+str ; s
MOVW            R5, #0x2111
BLX             memset
MOVW            R1, #:lower16:(aV9CheckAsicNum+0x18) ; "r"
MOVW            R0, #:lower16:aMntCardConfigI ; "/mnt/card/Config.ini"
MOVS            R3, #0
MOVW            R2, #:lower16:gHashBoard_BHB07601
MOVW            R10, #0x3631
MOVT            R1, #:upper16:(aV9CheckAsicNum+0x18) ; modes
MOVT            R0, #:upper16:aMntCardConfigI ; "/mnt/card/Config.ini"
STR             R2, [SP,#0x41C+var_41C]
STR             R5, [SP,#0x41C+var_414]
MOVW            R4, #:lower16:Conf
STR             R3, [SP,#0x41C+starttemp]
MOVW            R8, #:lower16:gHashBoard_BHB91601P
STR.W           R10, [SP,#0x41C+var_418]
MOVW            R7, #:lower16:gHashBoard_BHB91603S
BLX             fopen
LDR             R2, [SP,#0x41C+var_41C]
MOVW            R6, #:lower16:gHashBoard_V9
LDR             R3, [SP,#0x41C+var_414]
MOVW            R9, #0x4842
MOVW            R11, #0x3637
MOVT            R4, #:upper16:Conf
MOVT            R2, #:upper16:gHashBoard_BHB07601
MOV             R5, R0
file = R0               ; FILE *
STR             R2, [SP,#0x41C+var_41C]
MOV             R2, R3
LDR             R3, [SP,#0x41C+var_418]
MOVT            R8, #:upper16:gHashBoard_BHB91601P
MOVT            R7, #:upper16:gHashBoard_BHB91603S
MOVT            R6, #:upper16:gHashBoard_V9
MOVT            R9, #0x3942
MOVT            R11, #0x3130
MOVT            R10, #0x3130
MOVT            R2, #0x211
MOVT            R3, #0x3330
STR             R2, [SP,#0x41C+var_414]
STR             R3, [SP,#0x41C+var_418]

loc_18474               ; stream
file = R5               ; FILE *
MOV             R2, file
MOVW            R1, #0x3FF ; n
ADD             R0, SP, #0x41C+str ; s
BLX             fgets
CMP             R0, #0
BEQ             loc_18536

loc_18484
LDRB.W          R3, [SP,#0x41C+str]
CMP             R3, #0x23 ; '#'
BEQ             loc_18474
LDRB.W          R3, [SP,#0x41C+str+1]
CMP             R3, #0x23 ; '#'
BEQ             loc_18474
MOVW            R1, #:lower16:aName ; "Name="
ADD             R0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aName ; "Name="
BLX             strstr
temp_0 = R0             ; char *
CMP             temp_0, #0
BEQ.W           loc_1866A
LDR             R1, =0x3312FF
MOVS            R2, #0
LDRB.W          R3, [R0,#5]!
temp_0 = R0             ; char *
B               loc_184B8

loc_184B2
i = R2                  ; int
CMP             i, #0x40 ; '@'
BEQ.W           loc_18662

loc_184B8
STRB.W          R3, [R1,#1]!
ADDS            i, #1
LDRB.W          R3, [R0,#1]!
CMP             R3, #0xD
IT NE
CMPNE           R3, #0xA
BNE             loc_184B2
MOV             LR, R2

loc_184CC
MOVS            R1, #0
MOVW            R3, #:lower16:gHashBoard_BHB91601S
STRB            R1, [R4,R2]
MOVW            R2, #:lower16:gName_len
LDR             R0, [R4]
MOVT            R3, #:upper16:gHashBoard_BHB91601S
MOVT            R2, #:upper16:gName_len
STRB.W          R1, [R8]
STRB            R1, [R7]
CMP             R0, R9
STRB            R1, [R6]
STRB            R1, [R3]
STR.W           LR, [R2]
BEQ.W           loc_18630

loc_184F6
MOV             R3, #0x30424842
CMP             R0, R3
BEQ.W           loc_1860C

loc_18504
LDRH            R2, [R4]
MOVW            R3, #0x3956
CMP             R2, R3
BNE             loc_18474
MOVW            R1, #:lower16:__FUNCTION__.8218 ; "read_config"
MOVW            R0, #:lower16:aSGhashboardV9 ; "\n---%s: gHashBoard_V9\n\n"
MOVT            R1, #:upper16:__FUNCTION__.8218 ; "read_config"
MOVS            R3, #1
MOVT            R0, #:upper16:aSGhashboardV9 ; "\n---%s: gHashBoard_V9\n\n"
STRB            R3, [R6]
BLX             printf
MOV             R2, file ; stream
MOVW            R1, #0x3FF ; n
ADD             R0, SP, #0x41C+str ; s
BLX             fgets
CMP             R0, #0
BNE             loc_18484

loc_18536
LDR             file, [R4,#configuration.AsicNum]
CMP             R5, #1
BEQ.W           loc_1874C
LDRB            R3, [R6]
CMP             R3, #0
BNE.W           loc_1875E
LDRB.W          R3, [R8]
CBNZ            R3, loc_18558
MOV             R3, #gHashBoard_BHB91601S
LDRB            R3, [R3]
CBZ             R3, loc_185AA

loc_18558
MOVW            R3, #:lower16:BHB91601_WorkDataPathPrefix
LDR             R0, =cgpu.workdataPathPrefix ; dest
MOVT            R3, #:upper16:BHB91601_WorkDataPathPrefix
LDR             R1, [R3] ; "/mnt/card/minertest-BM1391/btc-asic-" ...
BLX             strcpy
MOVW            R3, #:lower16:BTC_WorkDataFilePrefix
LDR             R0, =cgpu.workdataFilePrefix ; dest
MOVT            R3, #:upper16:BTC_WorkDataFilePrefix
LDR             R1, [R3] ; "/btc-core-" ...
BLX             strcpy
MOVW            R2, #:lower16:gPic_addr_high_4_bit
MOVW            R3, #:lower16:gChain_Asic_Interval
MOVT            R2, #:upper16:gPic_addr_high_4_bit
MOV.W           R0, #0x400000
CMP             R5, #0x3C ; '<'
MOVT            R3, #:upper16:gChain_Asic_Interval
MOV.W           R1, #3
STR             R0, [R2]
MOV.W           R2, #0x100
STR             R1, [R3]
STR             R2, [R4,#configuration.CoreNum]
BNE.W           loc_186AA

loc_185A0
MOV             R3, #BHB91601_ASIC_NUMBER
STR             R5, [R3]

loc_185AA
LDRB            R3, [R7]
CMP             R3, #0
BNE.W           loc_186EC

loc_185B2
LDR             R3, [SP,#0x41C+var_41C]
LDRB            R3, [R3]
CBZ             R3, loc_18604
MOVW            R3, #:lower16:BHB07601_WorkDataPathPrefix
LDR             R0, =cgpu.workdataPathPrefix ; dest
MOVT            R3, #:upper16:BHB07601_WorkDataPathPrefix
MOV.W           R7, #0x400000
LDR             R1, [R3] ; "/mnt/card/" ...
MOVS            R6, #5
BLX             strcpy
MOVW            R3, #:lower16:BHB07601_WorkDataFilePrefix
LDR             R0, =cgpu.workdataFilePrefix ; dest
MOVT            R3, #:upper16:BHB07601_WorkDataFilePrefix
MOVS            R5, #0x30 ; '0'
LDR             R1, [R3] ; "07601_pattern_48" ...
BLX             strcpy
MOVW            R1, #:lower16:gPic_addr_high_4_bit
MOVW            R2, #:lower16:gChain_Asic_Interval
MOVW            R3, #:lower16:BHB07601_ASIC_NUMBER
MOVT            R1, #:upper16:gPic_addr_high_4_bit
MOVT            R2, #:upper16:gChain_Asic_Interval
MOVT            R3, #:upper16:BHB07601_ASIC_NUMBER
MOV.W           R0, #0x2A0
STR             R7, [R1]
STR             R6, [R2]
STR             R5, [R3]
STR             R0, [R4,#configuration.CoreNum]

loc_18604
ADDW            SP, SP, #0x41C
POP.W           {R4-R11,PC}

loc_1860C
file = R5               ; FILE *
LDR             R3, [R4,#configuration.name+4]
CMP             R3, R11
BNE.W           loc_18504
LDR             R2, [SP,#0x41C+var_41C]
MOVW            R1, #:lower16:__FUNCTION__.8218 ; "read_config"
MOVW            R0, #:lower16:aSGhashboardBhb ; "\n---%s: gHashBoard_BHB07601\n\n"
MOVS            R3, #1
MOVT            R1, #:upper16:__FUNCTION__.8218 ; "read_config"
MOVT            R0, #:upper16:aSGhashboardBhb ; "\n---%s: gHashBoard_BHB07601\n\n"
STRB            R3, [R2]
BLX             printf
B               loc_18504

loc_18630
LDR             R2, [R4,#configuration.name+4]
CMP             R2, R10
BEQ             loc_186B8

loc_18636
LDR             R3, [SP,#0x41C+var_418]
CMP             R2, R3
BNE.W           loc_18504
LDRB            R3, [R4,#configuration.name+8]
CMP             R3, #0x53 ; 'S'
BNE.W           loc_18504
MOVW            R1, #:lower16:__FUNCTION__.8218 ; "read_config"
MOVW            R0, #:lower16:aSGhashboardBhb_0 ; "\n---%s: gHashBoard_BHB91603S\n\n"
MOVS            R3, #1
MOVT            R1, #:upper16:__FUNCTION__.8218 ; "read_config"
MOVT            R0, #:upper16:aSGhashboardBhb_0 ; "\n---%s: gHashBoard_BHB91603S\n\n"
STRB            R3, [R7]
BLX             printf
LDR             R0, [R4]
B               loc_184F6

loc_18662
i = R2                  ; int
MOV.W           LR, #0x41 ; 'A'
MOV             i, LR
B               loc_184CC

loc_1866A
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aPatternNumber ; "pattern_number="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aPatternNumber ; "pattern_number="
BLX             strstr
temp_0 = R0             ; char *
CMP             temp_0, #0
BEQ.W           loc_18878
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.pattern_number
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xF
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
LDR             R2, [R4,#configuration.pattern_number]
MOVW            R3, #:lower16:gPattern_number
MOVW            R0, #:lower16:aGpatternNumber ; "gPattern_number = %d\n"
MOVT            R3, #:upper16:gPattern_number
MOVT            R0, #:upper16:aGpatternNumber ; "gPattern_number = %d\n"

loc_186A0
MOV             R1, R2
STR             R2, [R3]
BLX             printf
B               loc_18474

loc_186AA
CMP             R5, #0x48 ; 'H'
BEQ.W           loc_185A0
CMP             R5, #0x54 ; 'T'
BEQ.W           loc_185A0
B               loc_187E8

loc_186B8
file = R5               ; FILE *
LDRB            R2, [R4,#configuration.name+8]
CMP             R2, #0x50 ; 'P'
BEQ.W           loc_188D4

loc_186C0
LDRB            R2, [R4,#configuration.name+8]
CMP             R2, #0x53 ; 'S'
BNE.W           loc_18504
MOVW            R1, #:lower16:__FUNCTION__.8218 ; "read_config"
MOVW            R0, #:lower16:aSGhashboardBhb_1 ; "\n---%s: gHashBoard_BHB91601S\n\n"
MOVS            R2, #1
MOVT            R1, #:upper16:__FUNCTION__.8218 ; "read_config"
MOVT            R0, #:upper16:aSGhashboardBhb_1 ; "\n---%s: gHashBoard_BHB91601S\n\n"
STRB            R2, [R3]
BLX             printf
LDR             R0, [R4]
CMP             R0, R9
BNE.W           loc_184F6
LDR             R2, [R4,#configuration.name+4]
B               loc_18636

loc_186EC
MOVW            R3, #:lower16:BHB91603_WorkDataPathPrefix
LDR             R0, =cgpu.workdataPathPrefix ; dest
MOVT            R3, #:upper16:BHB91603_WorkDataPathPrefix
MOV.W           R6, #0x400000
LDR             R1, [R3] ; "/mnt/card/minertest-BHB91603-BM1391/btc"... ...
MOVS            R5, #2
BLX             strcpy
MOVW            R3, #:lower16:BTC_WorkDataFilePrefix
LDR             R0, =cgpu.workdataFilePrefix ; dest
MOVT            R3, #:upper16:BTC_WorkDataFilePrefix
LDR             R1, [R3] ; "/btc-core-" ...
BLX             strcpy
MOVW            R1, #:lower16:gPic_addr_high_4_bit
MOVW            R2, #:lower16:gChain_Asic_Interval
MOVT            R1, #:upper16:gPic_addr_high_4_bit
MOVW            R3, #:lower16:BHB91601_ASIC_NUMBER
MOVT            R2, #:upper16:gChain_Asic_Interval
MOVT            R3, #:upper16:BHB91601_ASIC_NUMBER
MOVS            R0, #0x60 ; '`'
STR             R6, [R1]
MOV.W           R1, #0x100
STR             R5, [R2]
STR             R0, [R3]
STR             R1, [R4,#configuration.CoreNum]
B               loc_185B2
ALIGN 4
dword_1873C DCD 0x3312FF
off_18740 DCD cgpu.workdataPathPrefix
off_18744 DCD cgpu.workdataFilePrefix
off_18748 DCD Conf.pattern_number

loc_1874C
LDR             R5, [R4,#configuration.AsicType]
MOVW            R3, #0x569
CMP             R5, R3
BEQ.W           loc_18904
LDRB            R3, [R6]
CMP             R3, #0
BEQ             loc_1880A

loc_1875E
MOV             R5, #BTC_WorkDataFilePrefix

loc_18766
MOVW            R3, #:lower16:V9_WorkDataPathPrefix
LDR             R0, =cgpu.workdataPathPrefix ; dest
MOVT            R3, #:upper16:V9_WorkDataPathPrefix
MOVW            R6, #:lower16:gPic_addr_high_4_bit
LDR             R1, [R3] ; "/mnt/card/minertest64-BM1385/btc-asic-" ...
MOVT            R6, #:upper16:gPic_addr_high_4_bit
BLX             strcpy
LDR             R1, [R5] ; "/btc-core-" ...
MOVW            R9, #:lower16:gChain_Asic_Interval
LDR             R0, =cgpu.workdataFilePrefix ; dest
MOVT            R9, #:upper16:gChain_Asic_Interval
BLX             strcpy
LDRB.W          R3, [R8]
MOV.W           R2, #0xA00000
MOVS            R1, #4
STR             R2, [R6]
MOVS            R2, #0x2D ; '-'
STR.W           R1, [R9]
STR             R2, [R4,#configuration.AsicNum]
MOVS            R1, #0x32 ; '2'
MOVW            R2, #0x569
STR             R1, [R4,#configuration.CoreNum]
STR             R2, [R4,#configuration.AsicType]
CBNZ            R3, loc_187BE
MOV             R3, #gHashBoard_BHB91601S
LDRB            R3, [R3]
CMP             R3, #0
BEQ.W           loc_185AA

loc_187BE
MOVW            R3, #:lower16:BHB91601_WorkDataPathPrefix
LDR             R0, =cgpu.workdataPathPrefix ; dest
MOVT            R3, #:upper16:BHB91601_WorkDataPathPrefix
LDR             R1, [R3] ; "/mnt/card/minertest-BM1391/btc-asic-" ...
BLX             strcpy
LDR             R1, [R5] ; "/btc-core-" ...
LDR             R0, =cgpu.workdataFilePrefix ; dest
BLX             strcpy
MOV.W           R1, #0x100
MOV.W           R2, #0x400000
MOVS            R3, #3
STR             R1, [R4,#configuration.CoreNum]
STR             R2, [R6]
STR.W           R3, [R9]

loc_187E8
MOVW            R3, #:lower16:BHB91601_ASIC_NUMBER
MOVW            R1, #:lower16:__FUNCTION__.8218 ; "read_config"
MOVW            R0, #:lower16:aSDonTFindAsicn ; "\n!!! %s: Don't find AsicNum in Config."...
MOVT            R3, #:upper16:BHB91601_ASIC_NUMBER
MOVS            R2, #0x54 ; 'T'
MOVT            R1, #:upper16:__FUNCTION__.8218 ; "read_config"
MOVT            R0, #:upper16:aSDonTFindAsicn ; "\n!!! %s: Don't find AsicNum in Config."...
STR             R2, [R3]
BLX             printf
B               loc_185AA

loc_1880A
SUB.W           R3, R5, #0x3640
SUBS            R3, #0x17
CMP             R3, #1
BLS.W           loc_18932

loc_18816
MOVW            R3, #0x1397
CMP             R5, R3
BEQ.W           loc_1895A

loc_18820
LDRB.W          R3, [R8]
CBNZ            R3, loc_18836
MOV             R3, #gHashBoard_BHB91601S
LDRB            R3, [R3]
CMP             R3, #0
BEQ.W           loc_185AA

loc_18836
MOVW            R3, #:lower16:BHB91601_WorkDataPathPrefix
LDR             R0, =cgpu.workdataPathPrefix ; dest
MOVT            R3, #:upper16:BHB91601_WorkDataPathPrefix
MOV.W           R5, #0x400000
LDR             R1, [R3] ; "/mnt/card/minertest-BM1391/btc-asic-" ...
BLX             strcpy
MOVW            R3, #:lower16:BTC_WorkDataFilePrefix
LDR             R0, =cgpu.workdataFilePrefix ; dest
MOVT            R3, #:upper16:BTC_WorkDataFilePrefix
LDR             R1, [R3] ; "/btc-core-" ...
BLX             strcpy
MOVW            R2, #:lower16:gPic_addr_high_4_bit
MOVW            R3, #:lower16:gChain_Asic_Interval
MOVT            R2, #:upper16:gPic_addr_high_4_bit
MOVT            R3, #:upper16:gChain_Asic_Interval
MOVS            R0, #3
MOV.W           R1, #0x100
STR             R5, [R2]
STR             R0, [R3]
STR             R1, [R4,#configuration.CoreNum]
B               loc_187E8

loc_18878
file = R5               ; FILE *
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aAsicnum ; "AsicNum="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aAsicnum ; "AsicNum="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_188B0
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #8
temp_0 = R0             ; char *
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.AsicNum
BLX             __isoc99_sscanf
LDR             R3, [R4,#configuration.AsicNum]
CMP             R3, #1
BNE.W           loc_18474
MOVW            R3, #:lower16:gChain_Asic_Interval
MOV.W           R2, #0x100
MOVT            R3, #:upper16:gChain_Asic_Interval
STR             R2, [R3]
B               loc_18474

loc_188B0
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aAsictype ; "AsicType="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aAsictype ; "AsicType="
BLX             strstr
temp_0 = R0             ; char *
CMP             temp_0, #0
BEQ             loc_18982
MOVW            R1, #:lower16:aX ; "%x"
LDR             R2, =Conf.AsicType
MOVT            R1, #:upper16:aX ; "%x"
ADDS            R0, #9
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B               loc_18474

loc_188D4
MOVW            R1, #:lower16:__FUNCTION__.8218 ; "read_config"
MOVW            R0, #:lower16:aSGhashboardBhb_2 ; "\n---%s: gHashBoard_BHB91601P\n\n"
MOVS            R2, #1
MOVT            R1, #:upper16:__FUNCTION__.8218 ; "read_config"
MOVT            R0, #:upper16:aSGhashboardBhb_2 ; "\n---%s: gHashBoard_BHB91601P\n\n"
STR             R3, [SP,#0x41C+temp]
STRB.W          R2, [R8]
BLX             printf
LDR             R0, [R4]
CMP             R0, R9
BNE.W           loc_184F6
LDR             R2, [R4,#configuration.name+4]
LDR             R3, [SP,#0x41C+temp]
CMP             R2, R10
BEQ.W           loc_186C0
B               loc_18636

loc_18904
MOVW            R3, #:lower16:Single_BM1385_WorkDataPathPrefix
MOVW            R5, #:lower16:BTC_WorkDataFilePrefix
MOVT            R3, #:upper16:Single_BM1385_WorkDataPathPrefix
LDR             R0, =cgpu.workdataPathPrefix ; dest
LDR             R1, [R3] ; "/mnt/card/single-BM1385-ASIC-test" ...
MOVT            R5, #:upper16:BTC_WorkDataFilePrefix
BLX             strcpy
LDR             R1, [R5] ; "/btc-core-" ...
LDR             R0, =cgpu.workdataFilePrefix ; dest
BLX             strcpy
LDRB            R3, [R6]
MOVS            R2, #0x32 ; '2'
STR             R2, [R4,#configuration.CoreNum]
CMP             R3, #0
BNE.W           loc_18766
B               loc_18820

loc_18932
MOVW            R3, #:lower16:Single_BM1391_WorkDataPathPrefix
LDR             R0, =cgpu.workdataPathPrefix ; dest
MOVT            R3, #:upper16:Single_BM1391_WorkDataPathPrefix
LDR             R1, [R3] ; "/mnt/card/single-BM1391-ASIC-test" ...
BLX             strcpy
MOVW            R3, #:lower16:BTC_WorkDataFilePrefix
LDR             R0, =cgpu.workdataFilePrefix ; dest
MOVT            R3, #:upper16:BTC_WorkDataFilePrefix
LDR             R1, [R3] ; "/btc-core-" ...
BLX             strcpy
MOV.W           R3, #0x100
STR             R3, [R4,#configuration.CoreNum]
B               loc_18816

loc_1895A
MOVW            R3, #:lower16:Single_BM1397_WorkDataPathPrefix
LDR             R0, =cgpu.workdataPathPrefix ; dest
MOVT            R3, #:upper16:Single_BM1397_WorkDataPathPrefix
LDR             R1, [R3] ; "/mnt/card/" ...
BLX             strcpy
MOVW            R3, #:lower16:Single_BM1397_WorkDataFilePrefix
LDR             R0, =cgpu.workdataFilePrefix ; dest
MOVT            R3, #:upper16:Single_BM1397_WorkDataFilePrefix
LDR             R1, [R3] ; "07601_pattern_48" ...
BLX             strcpy
MOV.W           R3, #0x2A0
STR             R3, [R4,#configuration.CoreNum]
B               loc_18820

loc_18982
file = R5               ; FILE *
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aFreq1 ; "Freq1="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aFreq1 ; "Freq1="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_189A4
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Freq1
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #6
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B               loc_18474

loc_189A4
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aFreq2 ; "Freq2="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aFreq2 ; "Freq2="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_189C6
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Freq2
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #6
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B               loc_18474

loc_189C6
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aFreq3 ; "Freq3="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aFreq3 ; "Freq3="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_189E8
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Freq3
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #6
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B               loc_18474

loc_189E8
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aFreq4 ; "Freq4="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aFreq4 ; "Freq4="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18A0A
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Freq4
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #6
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B               loc_18474

loc_18A0A
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aFreq5 ; "Freq5="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aFreq5 ; "Freq5="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18A2C
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Freq5
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #6
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B               loc_18474

loc_18A2C
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aFreq6 ; "Freq6="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aFreq6 ; "Freq6="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18A4E
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Freq6
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #6
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B               loc_18474

loc_18A4E
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aFreq7 ; "Freq7="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aFreq7 ; "Freq7="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18A9C
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Freq7
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #6
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B               loc_18474
off_18A70 DCD cgpu.workdataPathPrefix
off_18A74 DCD cgpu.workdataFilePrefix
off_18A78 DCD Conf.AsicNum
off_18A7C DCD Conf.AsicType
off_18A80 DCD Conf.Freq1
off_18A84 DCD Conf.Freq2
off_18A88 DCD Conf.Freq3
off_18A8C DCD Conf.Freq4
off_18A90 DCD Conf.Freq5
off_18A94 DCD Conf.Freq6
off_18A98 DCD Conf.Freq7

loc_18A9C
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aFreq8 ; "Freq8="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aFreq8 ; "Freq8="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18ABE
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Freq8
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #6
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B               loc_18474

loc_18ABE
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aFreq9 ; "Freq9="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aFreq9 ; "Freq9="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18AE0
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Freq9
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #6
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B               loc_18474

loc_18AE0
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aVoltage1 ; "Voltage1="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aVoltage1 ; "Voltage1="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18B22
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #9
temp_0 = R0             ; char *
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Voltage1
BLX             __isoc99_sscanf
LDR.W           R1, [R4,#configuration.Voltage1]
CBZ             R1, loc_18B14
MOV             R3, #gHowManyVoltageLevel
LDRB            R2, [R3]
ADDS            R2, #1
STRB            R2, [R3]

loc_18B14
MOV             R0, #aVoltage1D ; "Voltage1 = %d\n"
BLX             printf
B               loc_18474

loc_18B22
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aVoltage2 ; "Voltage2="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aVoltage2 ; "Voltage2="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18B5C
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #9
temp_0 = R0             ; char *
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Voltage2
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.Voltage2]
CMP             R3, #0
BEQ.W           loc_18474

loc_18B4C
MOV             R3, #gHowManyVoltageLevel
LDRB            R2, [R3]
ADDS            R2, #1
STRB            R2, [R3]
B               loc_18474

loc_18B5C
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aVoltage3 ; "Voltage3="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aVoltage3 ; "Voltage3="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18B88
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #9
temp_0 = R0             ; char *
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Voltage3
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.Voltage3]
CMP             R3, #0
BEQ.W           loc_18474
B               loc_18B4C

loc_18B88
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aVoltage4 ; "Voltage4="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aVoltage4 ; "Voltage4="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18BB4
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #9
temp_0 = R0             ; char *
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Voltage4
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.Voltage4]
CMP             R3, #0
BEQ.W           loc_18474
B               loc_18B4C

loc_18BB4
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aVoltage5 ; "Voltage5="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aVoltage5 ; "Voltage5="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18BE0
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #9
temp_0 = R0             ; char *
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Voltage5
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.Voltage5]
CMP             R3, #0
BEQ.W           loc_18474
B               loc_18B4C

loc_18BE0
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aVoltage6 ; "Voltage6="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aVoltage6 ; "Voltage6="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18C0C
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #9
temp_0 = R0             ; char *
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Voltage6
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.Voltage6]
CMP             R3, #0
BEQ.W           loc_18474
B               loc_18B4C

loc_18C0C
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aVoltage7 ; "Voltage7="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aVoltage7 ; "Voltage7="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18C38
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #9
temp_0 = R0             ; char *
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Voltage7
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.Voltage7]
CMP             R3, #0
BEQ.W           loc_18474
B               loc_18B4C

loc_18C38
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aVoltage8 ; "Voltage8="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aVoltage8 ; "Voltage8="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18C64
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #9
temp_0 = R0             ; char *
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Voltage8
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.Voltage8]
CMP             R3, #0
BEQ.W           loc_18474
B               loc_18B4C

loc_18C64
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aVoltage9 ; "Voltage9="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aVoltage9 ; "Voltage9="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18C90
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #9
temp_0 = R0             ; char *
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Voltage9
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.Voltage9]
CMP             R3, #0
BEQ.W           loc_18474
B               loc_18B4C

loc_18C90
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aVoltageAccurac ; "Voltage_accuracy="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aVoltageAccurac ; "Voltage_accuracy="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18CB4
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Voltage_accuracy
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0x11
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474

loc_18CB4
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aOpencoregap ; "OpenCoreGap="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aOpencoregap ; "OpenCoreGap="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18CD8
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.OpenCoreGap
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xC
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474

loc_18CD8
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aChecktemp ; "CheckTemp="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aChecktemp ; "CheckTemp="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18CFC
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.checktemp
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xA
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474

loc_18CFC
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aOpenCoreNum1 ; "Open_Core_Num1="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aOpenCoreNum1 ; "Open_Core_Num1="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18D20
MOVW            R1, #:lower16:aX ; "%x"
LDR             R2, =Conf.OpenCoreNum1
MOVT            R1, #:upper16:aX ; "%x"
ADDS            R0, #0xF
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474

loc_18D20
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aOpenCoreNum2 ; "Open_Core_Num2="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aOpenCoreNum2 ; "Open_Core_Num2="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18D44
MOVW            R1, #:lower16:aX ; "%x"
LDR             R2, =Conf.OpenCoreNum2
MOVT            R1, #:upper16:aX ; "%x"
ADDS            R0, #0xF
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474

loc_18D44
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aOpenCoreNum3 ; "Open_Core_Num3="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aOpenCoreNum3 ; "Open_Core_Num3="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18D68
MOVW            R1, #:lower16:aX ; "%x"
LDR             R2, =Conf.OpenCoreNum3
MOVT            R1, #:upper16:aX ; "%x"
ADDS            R0, #0xF
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474

loc_18D68
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aOpenCoreNum4 ; "Open_Core_Num4="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aOpenCoreNum4 ; "Open_Core_Num4="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18D8C
MOVW            R1, #:lower16:aX ; "%x"
LDR             R2, =Conf.OpenCoreNum4
MOVT            R1, #:upper16:aX ; "%x"
ADDS            R0, #0xF
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474

loc_18D8C
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aOpenCoreNum5 ; "Open_Core_Num5="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aOpenCoreNum5 ; "Open_Core_Num5="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18DFC
MOVW            R1, #:lower16:aX ; "%x"
LDR             R2, =Conf.OpenCoreNum5
MOVT            R1, #:upper16:aX ; "%x"
ADDS            R0, #0xF
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474
off_18DB0 DCD Conf.Freq8
off_18DB4 DCD Conf.Freq9
off_18DB8 DCD Conf.Voltage1
off_18DBC DCD Conf.Voltage2
off_18DC0 DCD Conf.Voltage3
off_18DC4 DCD Conf.Voltage4
off_18DC8 DCD Conf.Voltage5
off_18DCC DCD Conf.Voltage6
off_18DD0 DCD Conf.Voltage7
off_18DD4 DCD Conf.Voltage8
off_18DD8 DCD Conf.Voltage9
off_18DDC DCD Conf.Voltage_accuracy
off_18DE0 DCD Conf.OpenCoreGap
off_18DE4 DCD Conf.checktemp
off_18DE8 DCD Conf.OpenCoreNum1
off_18DEC DCD Conf.OpenCoreNum2
off_18DF0 DCD Conf.OpenCoreNum3
off_18DF4 DCD Conf.OpenCoreNum4
off_18DF8 DCD Conf.OpenCoreNum5

loc_18DFC
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aOpenCoreNum6 ; "Open_Core_Num6="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aOpenCoreNum6 ; "Open_Core_Num6="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18E20
MOVW            R1, #:lower16:aX ; "%x"
LDR             R2, =Conf.OpenCoreNum6
MOVT            R1, #:upper16:aX ; "%x"
ADDS            R0, #0xF
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474

loc_18E20
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aOpenCoreNum7 ; "Open_Core_Num7="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aOpenCoreNum7 ; "Open_Core_Num7="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18E44
MOVW            R1, #:lower16:aX ; "%x"
LDR             R2, =Conf.OpenCoreNum7
MOVT            R1, #:upper16:aX ; "%x"
ADDS            R0, #0xF
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474

loc_18E44
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aOpenCoreNum8 ; "Open_Core_Num8="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aOpenCoreNum8 ; "Open_Core_Num8="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18E68
MOVW            R1, #:lower16:aX ; "%x"
LDR             R2, =Conf.OpenCoreNum8
MOVT            R1, #:upper16:aX ; "%x"
ADDS            R0, #0xF
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474

loc_18E68
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aSensorModel ; "sensor_model="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aSensorModel ; "sensor_model="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18EAA
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xD
temp_0 = R0             ; char *
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.sensor_model
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.sensor_model]
CMP             R3, #6
BEQ             loc_18ECE
CMP             R3, #7
MOVW            R3, #:lower16:gSensor_i2c_addr_high_4_bit
ITE EQ
MOVEQ.W         R2, #0x9C0000
MOVNE.W         R2, #0x980000
MOVT            R3, #:upper16:gSensor_i2c_addr_high_4_bit
STR             R2, [R3]
B.W             loc_18474

loc_18EAA
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aRemoteLocalGap ; "remote_local_gap="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aRemoteLocalGap ; "remote_local_gap="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18EE0
MOVW            R1, #:lower16:aUd ; "%ud"
LDR             R2, =Conf.remote_local_gap
MOVT            R1, #:upper16:aUd ; "%ud"
ADDS            R0, #0x11
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474

loc_18ECE
MOVW            R3, #:lower16:gSensor_i2c_addr_high_4_bit
MOV.W           R2, #0x9A0000
MOVT            R3, #:upper16:gSensor_i2c_addr_high_4_bit
STR             R2, [R3]
B.W             loc_18474

loc_18EE0
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aTempsensor1 ; "TempSensor1="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aTempsensor1 ; "TempSensor1="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18F1C
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xC
temp_0 = R0             ; char *
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.TempSensor1
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.TempSensor1]
CMP             R3, #0
BEQ.W           loc_18474

loc_18F0A
MOV             R3, #gSensor_number
LDR             R2, [R3]
ADDS            R2, #1
STR             R2, [R3]
B.W             loc_18474

loc_18F1C
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aTempsensor2 ; "TempSensor2="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aTempsensor2 ; "TempSensor2="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18F48
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xC
temp_0 = R0             ; char *
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.TempSensor2
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.TempSensor2]
CMP             R3, #0
BEQ.W           loc_18474
B               loc_18F0A

loc_18F48
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aTempsensor3 ; "TempSensor3="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aTempsensor3 ; "TempSensor3="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18F74
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xC
temp_0 = R0             ; char *
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.TempSensor3
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.TempSensor3]
CMP             R3, #0
BEQ.W           loc_18474
B               loc_18F0A

loc_18F74
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aTempsensor4 ; "TempSensor4="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aTempsensor4 ; "TempSensor4="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18FA0
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xC
temp_0 = R0             ; char *
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.TempSensor4
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.TempSensor4]
CMP             R3, #0
BEQ.W           loc_18474
B               loc_18F0A

loc_18FA0
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aStartsensor ; "StartSensor="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aStartsensor ; "StartSensor="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_18FC4
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.StartSensor
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xC
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474

loc_18FC4
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aStarttemp ; "StartTemp="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aStarttemp ; "StartTemp="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_1901E
ADD.W           R3, temp_0, #0xA
temp_0 = R3             ; char *
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
MOV             R0, temp_0
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.StartTemp
STR             temp_0, [SP,#0x41C+temp]
BLX             __isoc99_sscanf
LDR             R3, [SP,#0x41C+temp]
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
ADD             R2, SP, #0x41C+starttemp
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
MOV             R0, R3
BLX             __isoc99_sscanf
LDR             R1, [SP,#0x41C+starttemp]
MOV             R0, #aStarttempD ; "StartTemp = %d\n"
CMP             R1, #0
ITTTT LT
NEGLT           R1, R1
SXTBLT          R3, R1
STRLT           R1, [SP,#0x41C+starttemp]
NEGLT           R1, R3
STR.W           R1, [R4,#configuration.StartTemp]
BLX             printf
B.W             loc_18474

loc_1901E
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aTargettemp ; "TargetTemp="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aTargettemp ; "TargetTemp="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_19052
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.TargetTemp
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xB
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
MOVW            R0, #:lower16:aTargettempD ; "TargetTemp = %d\n"
LDR.W           R1, [R4,#configuration.TargetTemp]
MOVT            R0, #:upper16:aTargettempD ; "TargetTemp = %d\n"
BLX             printf
B.W             loc_18474

loc_19052
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aAddVoltageAfte ; "add_voltage_after_test_ok="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aAddVoltageAfte ; "add_voltage_after_test_ok="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_19076
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.add_voltage_after_test_ok
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0x1A
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474

loc_19076
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aAddVoltageValu ; "add_voltage_value="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aAddVoltageValu ; "add_voltage_value="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_1909A
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.add_voltage_value
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0x12
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474

loc_1909A
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aAlarmtemp ; "AlarmTemp="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aAlarmtemp ; "AlarmTemp="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_190CE
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.AlarmTemp
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xA
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
MOVW            R0, #:lower16:aAlarmtempD ; "AlarmTemp = %d\n"
LDR.W           R1, [R4,#configuration.AlarmTemp]
MOVT            R0, #:upper16:aAlarmtempD ; "AlarmTemp = %d\n"
BLX             printf
B.W             loc_18474

loc_190CE
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aHeatinguptime ; "HeatingUpTime="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aHeatinguptime ; "HeatingUpTime="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_190F2
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.HeatingUpTime
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xE
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474

loc_190F2
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aMaxtempgap ; "MaxTempGap="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aMaxtempgap ; "MaxTempGap="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_1915C
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.MaxTempGap
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xB
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474
ALIGN 4
off_19118 DCD Conf.OpenCoreNum6
off_1911C DCD Conf.OpenCoreNum7
off_19120 DCD Conf.OpenCoreNum8
off_19124 DCD Conf.sensor_model
off_19128 DCD Conf.remote_local_gap
off_1912C DCD Conf.TempSensor1
off_19130 DCD Conf.TempSensor2
off_19134 DCD Conf.TempSensor3
off_19138 DCD Conf.TempSensor4
off_1913C DCD Conf.StartSensor
off_19140 DCD Conf.StartTemp
off_19144 DCD Conf.TargetTemp
off_19148 DCD Conf.add_voltage_after_test_ok
off_1914C DCD Conf.add_voltage_value
off_19150 DCD Conf.AlarmTemp
off_19154 DCD Conf.HeatingUpTime
off_19158 DCD Conf.MaxTempGap

loc_1915C
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aInvalidAsicNum ; "Invalid_Asic_Num="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aInvalidAsicNum ; "Invalid_Asic_Num="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_19190
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Invalid_Asic_Num
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0x11
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
MOVW            R0, #:lower16:aInvalidAsicNum_0 ; "Invalid_Asic_Num = %d\n"
LDR.W           R1, [R4,#configuration.Invalid_Asic_Num]
MOVT            R0, #:upper16:aInvalidAsicNum_0 ; "Invalid_Asic_Num = %d\n"
BLX             printf
B.W             loc_18474

loc_19190
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aInvalidCoreNum ; "Invalid_Core_Num="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aInvalidCoreNum ; "Invalid_Core_Num="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_191C4
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Invalid_Core_Num
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0x11
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
MOVW            R0, #:lower16:aInvalidCoreNum_0 ; "Invalid_Core_Num = %d\n"
LDR.W           R1, [R4,#configuration.Invalid_Core_Num]
MOVT            R0, #:upper16:aInvalidCoreNum_0 ; "Invalid_Core_Num = %d\n"
BLX             printf
B.W             loc_18474

loc_191C4
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aLeastNoncePerC ; "Least_nonce_per_core="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aLeastNoncePerC ; "Least_nonce_per_core="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_191F8
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Least_nonce_per_core
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0x15
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
MOVW            R0, #:lower16:aLeastNoncePerC_0 ; "Least_nonce_per_core = %d\n"
LDR.W           R1, [R4,#configuration.Least_nonce_per_core]
MOVT            R0, #:upper16:aLeastNoncePerC_0 ; "Least_nonce_per_core = %d\n"
BLX             printf
B.W             loc_18474

loc_191F8
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aMostHwNum ; "Most_HW_Num="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aMostHwNum ; "Most_HW_Num="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_1922C
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Most_HW_Num
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xC
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
MOVW            R0, #:lower16:aMostHwNumD ; "Most_HW_Num = %d\n"
LDR.W           R1, [R4,#configuration.Most_HW_Num]
MOVT            R0, #:upper16:aMostHwNumD ; "Most_HW_Num = %d\n"
BLX             printf
B.W             loc_18474

loc_1922C
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aClosePowerDela ; "close_power_delay="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aClosePowerDela ; "close_power_delay="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_19250
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.close_power_delay
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0x12
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
B.W             loc_18474

loc_19250
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aFanSpeed ; "fan_speed="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aFanSpeed ; "fan_speed="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_1928A
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.fan_speed
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xA
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.fan_speed]
MOVW            R0, #:lower16:aFanSpeedD ; "fan_speed = %d\n"
LDR             R2, =cgpu.fan_speed
MOVT            R0, #:upper16:aFanSpeedD ; "fan_speed = %d\n"
MOV             R1, R3
STRB            R3, [R2]
BLX             printf
B.W             loc_18474

loc_1928A
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aHashboardHardw ; "HashBoard_Hardware_Version_1="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aHashboardHardw ; "HashBoard_Hardware_Version_1="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_192BE
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.HashBoard_Hardware_Version_1
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0x1D
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
MOVW            R0, #:lower16:aHashboardHardw_0 ; "HashBoard_Hardware_Version_1 = %d\n"
LDR.W           R1, [R4,#configuration.HashBoard_Hardware_Version_1]
MOVT            R0, #:upper16:aHashboardHardw_0 ; "HashBoard_Hardware_Version_1 = %d\n"
BLX             printf
B.W             loc_18474

loc_192BE
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aHashboardHardw_1 ; "HashBoard_Hardware_Version_2="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aHashboardHardw_1 ; "HashBoard_Hardware_Version_2="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_192F2
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.HashBoard_Hardware_Version_2
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0x1D
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
MOVW            R0, #:lower16:aHashboardHardw_2 ; "HashBoard_Hardware_Version_2 = %d\n"
LDR.W           R1, [R4,#configuration.HashBoard_Hardware_Version_2]
MOVT            R0, #:upper16:aHashboardHardw_2 ; "HashBoard_Hardware_Version_2 = %d\n"
BLX             printf
B.W             loc_18474

loc_192F2
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aHashboardBomVe ; "HashBoard_Bom_Version_1="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aHashboardBomVe ; "HashBoard_Bom_Version_1="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_19326
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.HashBoard_Bom_Version_1
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0x18
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
MOVW            R0, #:lower16:aHashboardBomVe_0 ; "HashBoard_Bom_Version_1 = %d\n"
LDR.W           R1, [R4,#configuration.HashBoard_Bom_Version_1]
MOVT            R0, #:upper16:aHashboardBomVe_0 ; "HashBoard_Bom_Version_1 = %d\n"
BLX             printf
B.W             loc_18474

loc_19326
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aHashboardBomVe_1 ; "HashBoard_Bom_Version_2="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aHashboardBomVe_1 ; "HashBoard_Bom_Version_2="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_1935A
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.HashBoard_Bom_Version_2
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0x18
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
MOVW            R0, #:lower16:aHashboardBomVe_2 ; "HashBoard_Bom_Version_2 = %d\n"
LDR.W           R1, [R4,#configuration.HashBoard_Bom_Version_2]
MOVT            R0, #:upper16:aHashboardBomVe_2 ; "HashBoard_Bom_Version_2 = %d\n"
BLX             printf
B.W             loc_18474

loc_1935A
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aHashboardProdu ; "HashBoard_Product_ID="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aHashboardProdu ; "HashBoard_Product_ID="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_1938E
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.HashBoard_Product_ID
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0x15
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
MOVW            R0, #:lower16:aHashboardProdu_0 ; "HashBoard_Product_ID = %d\n"
LDR.W           R1, [R4,#configuration.HashBoard_Product_ID]
MOVT            R0, #:upper16:aHashboardProdu_0 ; "HashBoard_Product_ID = %d\n"
BLX             printf
B.W             loc_18474

loc_1938E
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aTimeoutPercent ; "timeout_percent="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aTimeoutPercent ; "timeout_percent="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_193C8
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.timeout_percent
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0x10
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.timeout_percent]
MOVW            R0, #:lower16:aTimeoutPercent_0 ; "timeout_percent = %d\n"
LDR             R2, =cgpu.timeout_percent
MOVT            R0, #:upper16:aTimeoutPercent_0 ; "timeout_percent = %d\n"
UXTB            R1, R3
STRB            R3, [R2]
BLX             printf
B.W             loc_18474

loc_193C8
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aBaudrate ; "baudrate="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aBaudrate ; "baudrate="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_19402
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.baud
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #9
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.baud]
MOVW            R0, #:lower16:aBaudrateD ; "baudrate = %d\n"
LDR             R2, =cgpu.baud
MOVT            R0, #:upper16:aBaudrateD ; "baudrate = %d\n"
UXTB            R1, R3
STRB            R3, [R2]
BLX             printf
B.W             loc_18474

loc_19402
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aOnlyFindAsic ; "Only_find_ASIC="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aOnlyFindAsic ; "Only_find_ASIC="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_1943C
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Only_find_ASIC
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xF
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.Only_find_ASIC]
MOVW            R0, #:lower16:aOnlyFindAsicD ; "Only_find_ASIC = %d\n"
LDR             R2, =cgpu.Only_find_ASIC
MOVT            R0, #:upper16:aOnlyFindAsicD ; "Only_find_ASIC = %d\n"
UXTB            R1, R3
STRB            R3, [R2]
BLX             printf
B.W             loc_18474

loc_1943C
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aPreOpenCoreVol ; "pre_open_core_voltage="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aPreOpenCoreVol ; "pre_open_core_voltage="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_19470
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.pre_open_core_voltage
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0x16
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
MOVW            R0, #:lower16:aPreOpenCoreVol_0 ; "pre_open_core_voltage = %d\n"
LDR.W           R1, [R4,#configuration.pre_open_core_voltage]
MOVT            R0, #:upper16:aPreOpenCoreVol_0 ; "pre_open_core_voltage = %d\n"
BLX             printf
B.W             loc_18474

loc_19470
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aIoStrength ; "io_strength="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aIoStrength ; "io_strength="
BLX             strstr
temp_0 = R0             ; char *
CMP             temp_0, #0
BEQ             loc_1950C
MOVW            R1, #:lower16:aX ; "%x"
ADDS            R0, #0xC
temp_0 = R0             ; char *
MOVT            R1, #:upper16:aX ; "%x"
LDR             R2, =Conf.io_strength
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.io_strength]
CBNZ            R3, loc_194A0
LDR             R2, [SP,#0x41C+var_414]
MOV             R3, R2
STR.W           R2, [R4,#configuration.io_strength]

loc_194A0
LDR             R2, =cgpu.io_strength
MOVW            R0, #:lower16:aIoStrength0x08 ; "io_strength = 0x%08x\n"
MOV             R1, R3
MOVT            R0, #:upper16:aIoStrength0x08 ; "io_strength = 0x%08x\n"
STR             R3, [R2]
BLX             printf
B.W             loc_18474
ALIGN 4
off_194B8 DCD Conf.Invalid_Asic_Num
off_194BC DCD Conf.Invalid_Core_Num
off_194C0 DCD Conf.Least_nonce_per_core
off_194C4 DCD Conf.Most_HW_Num
off_194C8 DCD Conf.close_power_delay
off_194CC DCD Conf.fan_speed
off_194D0 DCD cgpu.fan_speed
off_194D4 DCD Conf.HashBoard_Hardware_Version_1
off_194D8 DCD Conf.HashBoard_Hardware_Version_2
off_194DC DCD Conf.HashBoard_Bom_Version_1
off_194E0 DCD Conf.HashBoard_Bom_Version_2
off_194E4 DCD Conf.HashBoard_Product_ID
off_194E8 DCD Conf.timeout_percent
off_194EC DCD cgpu.timeout_percent
off_194F0 DCD Conf.baud
off_194F4 DCD cgpu.baud
off_194F8 DCD Conf.Only_find_ASIC
off_194FC DCD cgpu.Only_find_ASIC
off_19500 DCD Conf.pre_open_core_voltage
off_19504 DCD Conf.io_strength
off_19508 DCD cgpu.io_strength

loc_1950C
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aRepairMode ; "repair_mode="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aRepairMode ; "repair_mode="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_19546
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.repair_mode
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xC
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
LDR.W           R3, [R4,#configuration.repair_mode]
MOVW            R0, #:lower16:aRepairModeD ; "repair_mode = %d\n"
LDR             R2, =cgpu.repair_mode
MOVT            R0, #:upper16:aRepairModeD ; "repair_mode = %d\n"
MOV             R1, R3
STR             R3, [R2]
BLX             printf
B.W             loc_18474

loc_19546
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aDumpLostNonce ; "Dump_Lost_Nonce="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aDumpLostNonce ; "Dump_Lost_Nonce="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_1957A
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.Dump_Lost_Nonce
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0x10
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
MOVW            R0, #:lower16:aDumpLostNonceD ; "Dump_Lost_Nonce = %d\n"
LDR.W           R1, [R4,#configuration.Dump_Lost_Nonce]
MOVT            R0, #:upper16:aDumpLostNonceD ; "Dump_Lost_Nonce = %d\n"
BLX             printf
B.W             loc_18474

loc_1957A
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aCoreclockdelay ; "CoreClockDelay="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aCoreclockdelay ; "CoreClockDelay="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_195AE
MOVW            R1, #:lower16:aX ; "%x"
LDR             R2, =Conf.CoreClockDelay
MOVT            R1, #:upper16:aX ; "%x"
ADDS            R0, #0xF
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
MOVW            R0, #:lower16:aCoreclockdelay_0 ; "CoreClockDelay = 0x%02x\n"
LDR.W           R1, [R4,#configuration.CoreClockDelay]
MOVT            R0, #:upper16:aCoreclockdelay_0 ; "CoreClockDelay = 0x%02x\n"
BLX             printf
B.W             loc_18474

loc_195AE
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aBadChipNonceRa ; "bad_chip_nonce_rate="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aBadChipNonceRa ; "bad_chip_nonce_rate="
BLX             strstr
temp_0 = R0             ; char *
CBZ             temp_0, loc_195E2
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.bad_chip_nonce_rate
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0x14
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
MOVW            R0, #:lower16:aBadChipNonceRa_0 ; "bad_chip_nonce_rate = %d\n"
LDR.W           R1, [R4,#configuration.bad_chip_nonce_rate]
MOVT            R0, #:upper16:aBadChipNonceRa_0 ; "bad_chip_nonce_rate = %d\n"
BLX             printf
B.W             loc_18474

loc_195E2
temp_0 = R0             ; char *
MOVW            R1, #:lower16:aBadChipNum ; "bad_chip_num="
ADD             temp_0, SP, #0x41C+str ; haystack
MOVT            R1, #:upper16:aBadChipNum ; "bad_chip_num="
BLX             strstr
temp_0 = R0             ; char *
CMP             temp_0, #0
BEQ.W           loc_18474
MOVW            R1, #:lower16:(aT1DT2D+0xC) ; "%d"
LDR             R2, =Conf.bad_chip_num
MOVT            R1, #:upper16:(aT1DT2D+0xC) ; "%d"
ADDS            R0, #0xD
temp_0 = R0             ; char *
BLX             __isoc99_sscanf
MOVW            R0, #:lower16:aBadChipNumD ; "bad_chip_num = %d\n"
LDR.W           R1, [R4,#configuration.bad_chip_num]
MOVT            R0, #:upper16:aBadChipNumD ; "bad_chip_num = %d\n"
BLX             printf
B.W             loc_18474
; End of function read_config

ALIGN 4
off_1961C DCD Conf.repair_mode
off_19620 DCD cgpu.repair_mode
off_19624 DCD Conf.Dump_Lost_Nonce
off_19628 DCD Conf.CoreClockDelay
off_1962C DCD Conf.bad_chip_nonce_rate
off_19630 DCD Conf.bad_chip_num
ALIGN 8


; Attributes: noreturn

; void *__fastcall __noreturn V9_show_status_func(void *arg)
EXPORT V9_show_status_func
V9_show_status_func

which_i2c= -0x10
var_C= -0xC
format= -8

arg = R0                ; void *
which_chain = R5        ; unsigned __int8
MOVW            R2, #:lower16:aTimeDs ; "   time %ds"
PUSH.W          {R4-R11,LR}
MOVT            R2, #:upper16:aTimeDs ; "   time %ds"
SUB             SP, SP, #0x14
MOVW            R3, #:lower16:Conf
MOVW            R6, #:lower16:time_counter
STR             R2, [SP,#0x14+format]
chain_info = R0         ; chain_info *
MOVT            R3, #:upper16:Conf
LDRB            R2, [chain_info,#1]
MOVW            R8, #:lower16:gValid_Nonce_Num
MOVW            R10, #:lower16:gHighest_Temp
MOVW            R11, #:lower16:lcd_fd
MOVW            R9, #:lower16:gStartTest
MOVW            R7, #:lower16:lcd_output
STR             R3, [SP,#0x14+var_C]
MOVT            R6, #:upper16:time_counter
MOVS            R3, #0
LDRB            which_chain, [chain_info]
MOVT            R8, #:upper16:gValid_Nonce_Num
MOVT            R10, #:upper16:gHighest_Temp
MOVT            R11, #:upper16:lcd_fd
MOVT            R9, #:upper16:gStartTest
MOVT            R7, #:upper16:lcd_output
STR             R2, [SP,#0x14+which_i2c]
STR             R3, [R6]
B               loc_196BE

loc_1968E
temp = R4               ; int
CMP             R3, #0
BEQ             loc_1973E

loc_19692
MOVS            R3, #1
STRB.W          R3, [R9]

loc_19698               ; speed
MOVS            R0, #0
BL              set_fan_speed
MOVW            R0, #:lower16:aChainDGetValid ; "\nChain%d get valid nonce number : %d. "...
MOV             R3, temp
LDR.W           R2, [R8,which_chain,LSL#2]
MOVT            R0, #:upper16:aChainDGetValid ; "\nChain%d get valid nonce number : %d. "...
MOV             R1, which_chain
BLX             printf
MOV             R0, #(gAsic_Core_Nonce_Num+0xC33FC) ; useconds
BLX             usleep

loc_196BE               ; n
MOVS            R2, #0x40 ; '@'
MOVS            R1, #0x20 ; ' ' ; c
MOV             R0, R7  ; s
BLX             memset
LDR             R1, [SP,#0x14+which_i2c] ; which_i2c
MOV             R0, which_chain ; which_chain
BL              read_temperature_through_fpga_iic_register
LDR             R2, [R6]
MOV             R4, R0
temp = R0               ; int
LDR             R1, [SP,#0x14+format] ; format
MOV             temp, R7 ; s
temp = R4               ; int
BLX             sprintf
MOVW            R1, #:lower16:aNonceD ; "   nonce=%d"
LDR.W           R2, [R8,which_chain,LSL#2]
MOVT            R1, #:upper16:aNonceD ; "   nonce=%d"
LDR             R0, =(lcd_output+0x10) ; s
BLX             sprintf
MOVW            R1, #:lower16:aTempDC ; "   temp %d `C"
MOV             R2, temp
MOVT            R1, #:upper16:aTempDC ; "   temp %d `C"
LDR             R0, =(lcd_output+0x20) ; s
BLX             sprintf
LDR.W           R3, [R10]
MOVS            R2, #0x40 ; '@' ; n
MOV             R1, R7  ; buf
LDR.W           R0, [R11] ; fd
CMP             temp, R3
LDR             R3, [R6]
IT HI
STRHI.W         temp, [R10]
ADDS            R3, #1
STR             R3, [R6]
BLX             write
LDR             R3, [SP,#0x14+var_C]
LDR.W           R2, [R3,#configuration.StartTemp]
LDRB.W          R3, [R9]
CMP             temp, R2
BGE             loc_1968E
CMP             R3, #0
BNE             loc_19698
MOVW            R0, #:lower16:aHashBoardTempe ; "\nHash Board temperature is %d, waiting"...
MOV             R1, temp
MOVT            R0, #:upper16:aHashBoardTempe ; "\nHash Board temperature is %d, waiting"...
BLX             printf
B               loc_19698

loc_1973E
MOVW            R0, #:lower16:aBeginTestHashB ; "\nBegin test!!! Hash Board temperature "...
MOV             R1, temp
MOVT            R0, #:upper16:aBeginTestHashB ; "\nBegin test!!! Hash Board temperature "...
BLX             printf
B               loc_19692
; End of function V9_show_status_func

ALIGN 0x10
off_19750 DCD lcd_output+0x10
off_19754 DCD lcd_output+0x20



; void *__fastcall V9_send_func(void *arg)
EXPORT V9_send_func
V9_send_func

var_64= -0x64
mutex= -0x5C
which_core= -0x58
var_54= -0x54
works= -0x50
dest= -0x4C
var_48= -0x48
data_fil= -0x44

chain_info = R0         ; chain_info *
PUSH.W          {R4-R11,LR}
MOVW            R3, #:lower16:Conf
LDRB.W          R11, [chain_info]
which_chain = R11       ; unsigned __int8
SUB             SP, SP, #0x64
MOVS            R2, #0x40 ; '@' ; n
MOVS            R1, #0  ; c
MOV             R5, R3
ADD             chain_info, SP, #0x64+data_fil ; s
BLX             memset
MOV             R3, R5
ADD.W           R4, which_chain, which_chain,LSL#4
MOVT            R3, #:upper16:Conf
MOV             R2, R3
STR             R3, [SP,#0x64+var_54]
LDR             R3, =(cgpu.workdataFilePrefix+0x3C)
LSLS            R4, R4, #9
LDR             R2, [R2,#configuration.pattern_number]
MOVW            R10, #:lower16:gSend_Work_Num
ADD.W           R1, R4, #0x2180
MOVT            R10, #:upper16:gSend_Work_Num
STR             R3, [SP,#0x64+var_48]
MOV             R3, #gWorks_For_Hw_Check
ADDS            R1, #0x3C ; '<'
ADD             R4, R3
ADD             R3, R1
STR             R3, [SP,#0x64+dest]

loc_197A4
LDR             R3, [SP,#0x64+var_48]
MOV             R1, R3
LDR.W           R3, [R1,#4]!
STR             R3, [SP,#0x64+works]
MOVS            R3, #0
STR             R1, [SP,#0x64+var_48]
STR             R3, [SP,#0x64+which_core]

loc_197B4
CMP             R2, #0
BEQ             loc_19892
MOVW            R8, #:lower16:HW_check_mutex
ADD.W           R3, which_chain, which_chain,LSL#1
MOVT            R8, #:upper16:HW_check_mutex
MOVW            R9, #:lower16:gWork_Num_For_Hw_Check
ADD.W           R3, R8, R3,LSL#3
MOVT            R9, #:upper16:gWork_Num_For_Hw_Check
MOVS            R7, #0
ADD.W           R5, SP, #0x64+data_fil+0x1F
STR             R3, [SP,#0x64+mutex]

loc_197D8
which_pattern = R7      ; unsigned int
LDR             R3, [SP,#0x64+which_core]
LDR             R1, [SP,#0x64+works]
MLA             R2, R2, R3, which_pattern
ADD.W           R3, SP, #0x64+var_48+3
ADD.W           R2, R2, R2,LSL#4
ADD.W           R6, R1, R2,LSL#2
work = R6               ; work *
ADD.W           R0, work, #0x13
MOV             R2, R0

loc_197F2
LDRB.W          R1, [R2,#1]!
STRB.W          R1, [R3,#1]!
CMP             R5, R3
BNE             loc_197F2
LDR             R1, [work,#4]
temp_nonce = R1         ; unsigned int
ADDS            R3, work, #7
ADD.W           R2, SP, #0x64+data_fil+0x33
STRB.W          which_pattern, [SP,#0x64+data_fil+0x33]
STRB.W          temp_nonce, [SP,#0x64+data_fil+0x2F]
MOV.W           R12, temp_nonce,LSR#24
MOV.W           LR, temp_nonce,LSR#16
LSRS            temp_nonce, temp_nonce, #8
STRB.W          R12, [SP,#0x64+data_fil+0x2C]
STRB.W          LR, [SP,#0x64+data_fil+0x2D]
STRB.W          R1, [SP,#0x64+data_fil+0x2E]

loc_19824
LDRB.W          R1, [R3,#1]!
CMP             R3, R0
STRB.W          R1, [R2,#1]!
BNE             loc_19824
MOVS            R2, #0x40 ; '@' ; length
ADD             R1, SP, #0x64+data_fil ; buf
MOV             R0, which_chain ; which_uart
BL              uart_send
LDR             R0, [SP,#0x64+mutex] ; mutex
BLX             pthread_mutex_lock
LDR             R0, [SP,#0x64+dest] ; dest

loc_19842
SUB.W           R8, R0, #0x44 ; 'D'
MOVS            R2, #0x44 ; 'D' ; n
MOV             R1, R8  ; src
BLX             memcpy
CMP             R8, R4
MOV             R0, R8
BNE             loc_19842
LDRB.W          R3, [R9]
MOVS            R2, #0x44 ; 'D' ; n
MOV             R1, work ; src
MOV             R0, R4  ; dest
ADDS            which_pattern, #1
ADDS            R3, #1
UXTB            R3, R3
CMP             R3, #0x7E ; '~'
IT HI
MOVHI           R3, #0x7F
STRB.W          R3, [R9]
BLX             memcpy
LDR             R0, [SP,#0x64+mutex] ; mutex
BLX             pthread_mutex_unlock
LDR.W           R3, [R10,which_chain,LSL#2]
MOV.W           R0, #0x7D0 ; useconds
ADDS            R3, #1
STR.W           R3, [R10,which_chain,LSL#2]
BLX             usleep
which_pattern = R7      ; unsigned int
LDR             R3, [SP,#0x64+var_54]
LDR             R2, [R3,#configuration.pattern_number]
CMP             R2, which_pattern
BHI             loc_197D8

loc_19892
LDR             R3, [SP,#0x64+which_core]
ADDS            R3, #1
CMP             R3, #0x32 ; '2'
STR             R3, [SP,#0x64+which_core]
which_core_0 = R3       ; unsigned int
BNE             loc_197B4
LDR             which_core_0, [SP,#0x64+var_48]
MOV             R1, R3
LDR             R3, =(cgpu.works+0xB0)
CMP             R1, R3
BNE.W           loc_197A4
MOVW            R4, #0x8CA
LDR.W           R3, [R10,which_chain,LSL#2]
MUL             R2, R4, R2
CMP             R3, R2
BCS             loc_198E4
LDR             R7, [SP,#0x64+var_54]
MOVW            R6, #:lower16:__FUNCTION__.8213_0 ; "V9_send_func"
MOVW            R5, #:lower16:aSChainDSendWor ; "\n\n---%s: Chain%d send work num : %d, "...
MOVT            R6, #:upper16:__FUNCTION__.8213_0 ; "V9_send_func"
MOVT            R5, #:upper16:aSChainDSendWor ; "\n\n---%s: Chain%d send work num : %d, "...

loc_198CA
STR             R2, [SP,#0x64+var_64]
MOV             R1, R6
MOV             R2, which_chain
MOV             R0, R5  ; format
BLX             printf
LDR             R2, [R7,#configuration.pattern_number]
LDR.W           R3, [R10,which_chain,LSL#2]
MUL             R2, R4, R2
CMP             R3, R2
BCC             loc_198CA

loc_198E4
MOVW            R1, #:lower16:__FUNCTION__.8213_0 ; "V9_send_func"
MOVW            R0, #:lower16:aSChainDSendWor_0 ; "\n\n---%s: Chain%d send work num : %d\n"
MOV             R2, which_chain
MOVT            R1, #:upper16:__FUNCTION__.8213_0 ; "V9_send_func"
MOVT            R0, #:upper16:aSChainDSendWor_0 ; "\n\n---%s: Chain%d send work num : %d\n"
MOVS            R4, #0
BLX             printf
MOV             R0, #aSendTestPatter ; "\nsend test pattern done"
BLX             puts
MOV             R0, #aDate ; "date"
BLX             system
MOVS            R0, #0xA ; c
BLX             putchar
MOVW            R0, #0x9C40 ; useconds
BLX             usleep
MOVW            R3, #:lower16:start_receive
MOVW            R0, #:lower16:aToStopReceive ; "to stop receive"
MOVT            R3, #:upper16:start_receive
MOVT            R0, #:upper16:aToStopReceive ; "to stop receive"
STRB            R4, [R3]
BLX             puts
MOV             R0, R4
ADD             SP, SP, #0x64 ; 'd'
POP.W           {R4-which_chain,PC}
; End of function V9_send_func

off_19940 DCD cgpu.workdataFilePrefix+0x3C
off_19944 DCD cgpu.works+0xB0



; void reset_V9_global_arg()
EXPORT reset_V9_global_arg
reset_V9_global_arg
PUSH.W          {R3-R11,LR}
MOVW            R8, #:lower16:gRepeated_Nonce_Id
BL              reset_global_arg
MOVW            R3, #:lower16:Conf
MOVW            R12, #:lower16:gValid_Nonce_Num
MOVT            R3, #:upper16:Conf
LDR.W           R11, =0x3312CF
LDR             R5, [R3,#configuration.pattern_number]
MOVW            LR, #:lower16:gSend_Work_Num
LDR.W           R9, =(gAsic_Core_Nonce_Num+0xC4)
MOVS            R7, #0
MOVT            R8, #:upper16:gRepeated_Nonce_Id
MOVT            R12, #:upper16:gValid_Nonce_Num
MOVT            LR, #:upper16:gSend_Work_Num
MOV             R1, R7
ADD.W           R6, R5, R5,LSL#4
LSLS            R6, R6, #2

loc_19984
LDR.W           R10, =(cgpu.workdataFilePrefix+0x3C)
MOV             R4, R9
STRB.W          R1, [R11,#1]!
STR.W           R1, [R8],#4
STR.W           R1, [R12],#4
STR.W           R1, [LR],#4

loc_1999A
LDR.W           R3, [R10,#4]!
SUB.W           R0, R4, #0xC8
ADD             R3, R7

loc_199A4
STR.W           R1, [R0,#4]!
ADDS            R2, R3, R6
CBZ             R5, loc_199B4

loc_199AC
STR             R1, [R3,#0x34]
ADDS            R3, #0x44 ; 'D'
CMP             R3, R2
BNE             loc_199AC

loc_199B4
CMP             R4, R0
MOV             R3, R2
BNE             loc_199A4
LDR             R3, =(cgpu.works+0xB0)
ADD.W           R4, R4, #0x1000
CMP             R10, R3
BNE             loc_1999A
ADDS            R7, #4
ADD.W           R9, R9, #0x80000
CMP             R7, #0x10
BNE             loc_19984
POP.W           {R3-R11,PC}
; End of function reset_V9_global_arg

ALIGN 4
off_199D4 DCD cgpu.works+0xB0
dword_199D8 DCD 0x3312CF
off_199DC DCD gAsic_Core_Nonce_Num+0xC4
off_199E0 DCD cgpu.workdataFilePrefix+0x3C



; void __fastcall V9_set_voltage(unsigned __int8 which_chain, unsigned __int8 which_i2c, bool whether_add_voltage)
EXPORT V9_set_voltage
V9_set_voltage

var_1C= -0x1C
var_14= -0x14
var_8= -8

which_chain = R0        ; unsigned __int8
which_i2c = R1          ; unsigned __int8
whether_add_voltage = R2; bool
MOVW            R3, #:lower16:pattern_test_time
PUSH            {R4-R7,LR}
MOVT            R3, #:upper16:pattern_test_time
MOV             R7, which_i2c
SUB             SP, SP, #0x1C
MOV             R6, which_chain
LDRB            which_i2c, [R3]
CMP             R1, #8  ; switch 9 cases
BHI             def_199FA ; jumptable 000199FA default case
TBB.W           [PC,R1] ; switch jump
jpt_199FA DCB 0x3D      ; jump table for switch statement
DCB 0x6E
DCB 0x60
DCB 0x67
DCB 0x44
DCB 0x4B
DCB 0x52
DCB 0x59
DCB 5
ALIGN 2

loc_19A08               ; jumptable 000199FA case 8
MOV             R4, #Conf
LDR.W           R5, [R4,#configuration.Voltage9]

loc_19A14
real_voltage = R5       ; unsigned int
CBZ             R2, loc_19A1C
LDR.W           R3, [R4,#configuration.add_voltage_value]
ADD             real_voltage, R3

loc_19A1C
VMOV            S15, real_voltage
MOVW            R0, #:lower16:aSRealVoltageDT ; "\n--- %s: real voltage = %d, temp_volta"...
VCVT.F64.U32    D6, S15
MOV             R2, real_voltage
VLDR            D5, =152.134146
MOVT            R0, #:upper16:aSRealVoltageDT ; "\n--- %s: real voltage = %d, temp_volta"...
VLDR            D4, =100.0
VLDR            D7, =1742.06996
LDR             R1, =__FUNCTION__.8075 ; "V9_set_voltage"
VMUL.F64        D6, D6, D5
VDIV.F64        D5, D6, D4
VSUB.F64        D7, D7, D5
VCVT.U32.F64    S13, D7
VSTR            D7, [SP,#0x1C+var_1C]
VMOV            R4, S13
Pic_Voltage = R4        ; unsigned int
VSTR            S13, [SP,#0x1C+var_14]
BLX             printf
UXTB            R2, Pic_Voltage ; voltage
MOV             R1, R7  ; which_i2c
MOV             R0, R6  ; which_chain
BL              set_PIC16F1704_voltage
MOV             R0, #0x186A0 ; useconds
ADD             SP, SP, #0x1C
POP.W           {Pic_Voltage-R7,LR}
B.W             j_usleep

loc_19A78               ; jumptable 000199FA case 0
which_chain = R0        ; unsigned __int8
whether_add_voltage = R2; bool
MOV             R4, #Conf
LDR.W           R5, [R4,#configuration.Voltage1]
real_voltage = R5       ; unsigned int
B               loc_19A14

loc_19A86               ; jumptable 000199FA case 4
MOV             R4, #Conf
LDR.W           R5, [R4,#configuration.Voltage5]
real_voltage = R5       ; unsigned int
B               loc_19A14

loc_19A94               ; jumptable 000199FA case 5
MOV             R4, #Conf
LDR.W           R5, [R4,#configuration.Voltage6]
real_voltage = R5       ; unsigned int
B               loc_19A14

loc_19AA2               ; jumptable 000199FA case 6
MOV             R4, #Conf
LDR.W           R5, [R4,#configuration.Voltage7]
real_voltage = R5       ; unsigned int
B               loc_19A14

loc_19AB0               ; jumptable 000199FA case 7
MOV             R4, #Conf
LDR.W           R5, [R4,#configuration.Voltage8]
real_voltage = R5       ; unsigned int
B               loc_19A14

loc_19ABE               ; jumptable 000199FA case 2
MOV             R4, #Conf
LDR.W           R5, [R4,#configuration.Voltage3]
real_voltage = R5       ; unsigned int
B               loc_19A14

loc_19ACC               ; jumptable 000199FA case 3
MOV             R4, #Conf
LDR.W           R5, [R4,#configuration.Voltage4]
real_voltage = R5       ; unsigned int
B               loc_19A14

loc_19ADA               ; jumptable 000199FA case 1
MOV             R4, #Conf
LDR.W           R5, [R4,#configuration.Voltage2]
real_voltage = R5       ; unsigned int
B               loc_19A14

def_199FA               ; jumptable 000199FA default case
MOVW            R4, #:lower16:Conf
MOVW            which_chain, #:lower16:aCanTFindVoltag ; "\n--- Can't find voltage%d\n"
MOVT            R4, #:upper16:Conf
MOVT            R0, #:upper16:aCanTFindVoltag ; "\n--- Can't find voltage%d\n"
STR             whether_add_voltage, [SP,#0x1C+var_8]
LDR.W           R5, [R4,#configuration.Voltage1]
real_voltage = R5       ; unsigned int
BLX             printf
LDR             R2, [SP,#0x1C+var_8]
B               loc_19A14
; End of function V9_set_voltage

ALIGN 4
dbl_19B08 DCFD 152.134146
dbl_19B10 DCFD 100.0
dbl_19B18 DCFD 1742.06996
off_19B20 DCD __FUNCTION__.8075 ; "V9_set_voltage"



; void V9_calculate_timeout_and_baud()
EXPORT V9_calculate_timeout_and_baud
V9_calculate_timeout_and_baud

var_8= -8

PUSH            {R4-R6,LR}
MOVS            R0, #0x32 ; '2' ; actual_core_number
SUB             SP, SP, #8
MOVW            R4, #:lower16:Conf
BL              calculate_core_number
MOVW            R3, #:lower16:pattern_test_time
MOV             R5, R0
temp_corenum = R0       ; unsigned int
MOVT            R3, #:upper16:pattern_test_time
LDRB            R2, [R3]
CMP             R2, #8  ; switch 9 cases
BHI             def_19B42 ; jumptable 00019B42 default case
TBB.W           [PC,R2] ; switch jump
jpt_19B42 DCB 0x49      ; jump table for switch statement
DCB 0x65
DCB 0x5D
DCB 0x61
DCB 0x4D
DCB 0x51
DCB 0x55
DCB 0x59
DCB 5
ALIGN 2

loc_19B50               ; jumptable 00019B42 case 8
MOVT            R4, #:upper16:Conf
LDR             R6, [R4,#configuration.Freq9]

loc_19B56
temp_corenum = R5       ; unsigned int
temp_freq = R6          ; unsigned int
MOV             R1, temp_corenum
MOV.W           R0, #0x1000000
BL              __aeabi_uidiv
MOVW            R3, #:lower16:gChain_Asic_Interval
MOV             R1, temp_freq
MOVT            R3, #:upper16:gChain_Asic_Interval
LDR             R3, [R3]
MUL             R0, R3, R0
BL              __aeabi_uidiv
MOV             R3, R0
MOVW            R2, #0x851F
ADD.W           R1, R3, R3,LSL#1
MOVT            R2, #0x51EB
MOVW            R0, #:lower16:(gAsic_Core_Nonce_Num+0x166026)
RSB.W           R3, R3, R1,LSL#5
MOVT            R0, #:upper16:(gAsic_Core_Nonce_Num+0x166026)
UMULL           R2, R3, R3, R2
LSRS            temp_corenum, R3, #5
MOV             R1, R5
STR.W           R5, [R4,#configuration.timeout]
BL              __aeabi_uidiv
LSLS            R1, R0, #9
MOV             R0, #(cgpu.subid+0x49C98)
BL              __aeabi_uidiv
SUBS            R3, R0, #1
CMP             R3, #0x1A
STR.W           R3, [R4,#configuration.baud]
BHI             loc_19C18
SUBS            R0, #2
CMP             R0, #0x19
IT HI
MOVHI           R2, #0
BLS             loc_19C18

loc_19BC0
MOVW            R0, #:lower16:aSBaudDTimeout0_0 ; "\n--- %s: baud = %d, timeout = 0x%08x ="...
STR             R5, [SP,#8+var_8]
MOV             R3, R5
LDR             R1, =__FUNCTION__.8093 ; "V9_calculate_timeout_and_baud"
MOVT            R0, #:upper16:aSBaudDTimeout0_0 ; "\n--- %s: baud = %d, timeout = 0x%08x ="...
BLX             printf
STR             temp_freq, [R4,#configuration.Freq]
ADD             SP, SP, #8
POP             {R4-temp_freq,PC}

loc_19BD8               ; jumptable 00019B42 case 0
temp_corenum = R0       ; unsigned int
MOVT            R4, #:upper16:Conf
LDR             R6, [R4,#configuration.Freq1]
temp_freq = R6          ; unsigned int
B               loc_19B56

loc_19BE0               ; jumptable 00019B42 case 4
MOVT            R4, #:upper16:Conf
LDR             R6, [R4,#configuration.Freq5]
temp_freq = R6          ; unsigned int
B               loc_19B56

loc_19BE8               ; jumptable 00019B42 case 5
MOVT            R4, #:upper16:Conf
LDR             R6, [R4,#configuration.Freq6]
temp_freq = R6          ; unsigned int
B               loc_19B56

loc_19BF0               ; jumptable 00019B42 case 6
MOVT            R4, #:upper16:Conf
LDR             R6, [R4,#configuration.Freq7]
temp_freq = R6          ; unsigned int
B               loc_19B56

loc_19BF8               ; jumptable 00019B42 case 7
MOVT            R4, #:upper16:Conf
LDR             R6, [R4,#configuration.Freq8]
temp_freq = R6          ; unsigned int
B               loc_19B56

loc_19C00               ; jumptable 00019B42 case 2
MOVT            R4, #:upper16:Conf
LDR             R6, [R4,#configuration.Freq3]
temp_freq = R6          ; unsigned int
B               loc_19B56

loc_19C08               ; jumptable 00019B42 case 3
MOVT            R4, #:upper16:Conf
LDR             R6, [R4,#configuration.Freq4]
temp_freq = R6          ; unsigned int
B               loc_19B56

loc_19C10               ; jumptable 00019B42 case 1
MOVT            R4, #:upper16:Conf
LDR             R6, [R4,#configuration.Freq2]
temp_freq = R6          ; unsigned int
B               loc_19B56

loc_19C18
MOVS            R2, #1
STR.W           R2, [R4,#configuration.baud]
B               loc_19BC0

def_19B42               ; jumptable 00019B42 default case
temp_corenum = R0       ; unsigned int
MOVW            temp_corenum, #:lower16:aSPatternTestTi ; "%s: pattern_test_time = %d, error!!! \n"
temp_corenum = R5       ; unsigned int
LDR             R1, =__FUNCTION__.8093 ; "V9_calculate_timeout_and_baud"
MOVT            R0, #:upper16:aSPatternTestTi ; "%s: pattern_test_time = %d, error!!! \n"
MOVT            R4, #:upper16:Conf
MOVS            R6, #0
BLX             printf
B               loc_19B56
; End of function V9_calculate_timeout_and_baud

ALIGN 4
off_19C38 DCD __FUNCTION__.8093 ; "V9_calculate_timeout_and_baud"



; void __fastcall V9_set_address(unsigned __int8 which_chain)
EXPORT V9_set_address
V9_set_address
which_chain = R0        ; unsigned __int8
PUSH            {R3-R7,LR}
MOV             R6, which_chain
MOVW            which_chain, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R2, R6
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
MOVW            R7, #:lower16:gChain_Asic_Interval
LDR             R1, =__FUNCTION__.8099 ; "V9_set_address"
MOVT            R7, #:upper16:gChain_Asic_Interval
BLX             printf
MOV             R0, R6  ; which_chain
MOVS            R5, #0x2D ; '-'
MOVS            R4, #0
BL              BM1385_chain_inactive

loc_19C62               ; address
chip_addr = R4          ; unsigned __int8
MOV             R1, chip_addr
MOV             R0, R6  ; which_chain
BL              BM1385_set_address
LDR             R3, [R7]
MOVW            R0, #0x1388 ; useconds
ADD             chip_addr, R3
BLX             usleep
SUBS            R3, R5, #1
UXTB            R4, R4
chip_addr = R4          ; unsigned __int8
ANDS.W          R5, R3, #0xFF
BNE             loc_19C62
POP             {R3-R7,PC}
; End of function V9_set_address

ALIGN 4
off_19C84 DCD __FUNCTION__.8099 ; "V9_set_address"



; void __fastcall V9_set_baud(unsigned __int8 which_chain, unsigned __int8 baud)
EXPORT V9_set_baud
V9_set_baud
which_chain = R0        ; unsigned __int8
baud = R1               ; unsigned __int8
PUSH            {R3-R5,LR}
MOV             R5, which_chain
MOVW            which_chain, #:lower16:aSChainDBaudD ; "\n--- %s: Chain : %d, baud = %d\n"
MOV             R4, baud
MOV             R3, baud
MOV             R2, R5
LDR             baud, =__FUNCTION__.8107 ; "V9_set_baud"
MOVT            R0, #:upper16:aSChainDBaudD ; "\n--- %s: Chain : %d, baud = %d\n"
BLX             printf
MOV             R0, R5  ; which_chain
MOV             R2, R4  ; baud
MOVS            R3, #1  ; mode
MOVS            R1, #0  ; chip_addr
BL              BM1385_set_baud
MOVW            R0, #0xC350 ; useconds
BLX             usleep
MOV             R0, R4  ; asic_baud
POP.W           {R3-R5,LR}
B.W             set_fpga_baud
; End of function V9_set_baud

ALIGN 0x10
off_19CC0 DCD __FUNCTION__.8107 ; "V9_set_baud"



; void __fastcall V9_open_core(unsigned __int8 which_chain)
EXPORT V9_open_core
V9_open_core

data= -0x44

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x44
MOV             R6, which_chain
MOVS            R2, #0x40 ; '@' ; n
MOVS            R1, #0  ; c
MOV             which_chain, SP ; s
BLX             memset
MOVW            R0, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOVS            R3, #0xFF
MOV.W           R10, #0
MOV             R2, R6
LDR             R1, =__FUNCTION__.8114_0 ; "V9_open_core"
MOVW            R8, #:lower16:gIsOpenCoreEnd
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
MOVW            R9, #:lower16:gIsOpeningCore
STRB.W          R3, [SP,#0x44+data]
MOV.W           R11, #1
BLX             printf
MOVT            R8, #:upper16:gIsOpenCoreEnd
MOV             R1, R10 ; c
MOVS            R2, #0x40 ; '@' ; n
MOVT            R9, #:upper16:gIsOpeningCore
MOV             R0, SP  ; s
MOVW            R7, #:lower16:Conf
STRB.W          R10, [R8]
MOV             R5, SP
STRB.W          R11, [R9]
MOVT            R7, #:upper16:Conf
BLX             memset
MOV             R2, R11 ; mode
MOV             R1, R10 ; chip_addr
MOV             R0, R6  ; which_chain
MOVS            R4, #0x32 ; '2'
BL              BM1385_set_gateblk

loc_19D2C               ; length
MOVS            R2, #0x40 ; '@'
MOV             R1, R5  ; buf
MOV             R0, R6  ; which_uart
BL              uart_send
LDR.W           R0, [R7,#configuration.OpenCoreGap] ; useconds
BLX             usleep
SUBS            R4, #1
BNE             loc_19D2C
MOV             R1, R4  ; c
MOVS            R2, #0x40 ; '@' ; n
MOV             R0, R5  ; s
BLX             memset
ADD             R1, SP, #0x44+data+0x34
MOV             R3, R5

loc_19D50
SUBS            R2, R3, R5
STRB.W          R2, [R3],#1
CMP             R3, R1
BNE             loc_19D50
MOVS            R3, #0xFF
MOVS            R2, #1  ; mode
MOVS            R1, #0  ; chip_addr
MOV             R0, R6  ; which_chain
MOVS            R4, #0x3C ; '<'
STRB.W          R3, [SP,#0x44+data+0x34]
BL              BM1385_set_gateblk

loc_19D6C               ; length
MOVS            R2, #0x40 ; '@'
MOV             R1, R5  ; buf
MOV             R0, R6  ; which_uart
BL              uart_send
LDR.W           R0, [R7,#configuration.OpenCoreGap] ; useconds
BLX             usleep
SUBS            R4, #1
BNE             loc_19D6C
MOV             R0, R6  ; which_chain
BL              clear_uart_rx_fifo
MOVS            R3, #1
STRB.W          R4, [R9]
STRB.W          R3, [R8]
ADD             SP, SP, #0x44 ; 'D'
POP.W           {R4-R11,PC}
; End of function V9_open_core

off_19D98 DCD __FUNCTION__.8114_0 ; "V9_open_core"



; unsigned int __fastcall V9_get_result(unsigned __int8 which_chain)
EXPORT V9_get_result
V9_get_result

how_many_core_not_receive_all_nonce_per_asic= -0x18
format= -0x14
which_asic= -0x10
var_C= -0xC
var_8= -8

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x1C
STR             which_chain, [SP,#0x1C+var_C]
MOVW            R5, #:lower16:Conf
MOVW            which_chain, #:lower16:asc_29AF4 ; "\n\n-----------------------------------"...
MOVT            R5, #:upper16:Conf
MOVT            R0, #:upper16:asc_29AF4 ; "\n\n-----------------------------------"...
MOVS            R4, #0x32 ; '2'
BLX             puts
LDR             R1, [R5,#configuration.pattern_number]
MOVW            R0, #:lower16:aEveryAsicRequi ; "every ASIC require nonce number: %u\n"
MOVS            R6, #0
MOVW            R9, #0x8E39
MOVW            R7, #:lower16:aAsic02dD ; "asic[%02d]=%d\t"
MOVT            R0, #:upper16:aEveryAsicRequi ; "every ASIC require nonce number: %u\n"
MOV             R10, R4
MOVT            R9, #0x38E3
MUL             R1, R4, R1
MOVT            R7, #:upper16:aAsic02dD ; "asic[%02d]=%d\t"
MOV             R4, R6
MOV.W           R8, #7
BLX             printf
B               loc_19E1C

loc_19DE8               ; which_asic
which_asic_0 = R4       ; unsigned int
how_many_asic_not_receive_all_nonce = R6; unsigned int
ret = R8                ; unsigned int
UXTB            R1, which_asic_0
MOVS            R2, #0x32 ; '2' ; core_number
LDR             R0, [SP,#0x1C+var_C] ; which_chain
BL              calculate_how_many_nonce_per_asic_get
MOV             R1, which_asic_0
MOV             R2, R0
MOV             R11, R0
per_asic_received_nonce_number = R0; unsigned int
MOV             per_asic_received_nonce_number, R7 ; format
per_asic_received_nonce_number = R2; unsigned int
BLX             printf
LDR             R2, [R5,#configuration.pattern_number]
ADDS            which_asic_0, #1
MUL             R2, R10, R2
CMP             per_asic_received_nonce_number, R2
BCS             loc_19E18
LDR.W           R3, [R5,#configuration.Invalid_Asic_Num]
ADDS            how_many_asic_not_receive_all_nonce, #1
CMP             how_many_asic_not_receive_all_nonce, R3
IT HI
MOVHI.W         ret, #6

loc_19E18
which_asic_0 = R4       ; unsigned int
CMP             which_asic_0, #0x2D ; '-'
BEQ             loc_19E32

loc_19E1C
UMULL           R2, R3, which_asic_0, R9
LSRS            R3, R3, #1
ADD.W           R3, R3, R3,LSL#3
CMP             which_asic_0, R3
BNE             loc_19DE8
MOVS            R0, #0xA ; c
BLX             putchar
B               loc_19DE8

loc_19E32
per_asic_received_nonce_number = R11; unsigned int
MOVW            R0, #:lower16:(aSCanTFindHashb+0x38) ; "\n"
MOVS            R3, #0
MOVT            R0, #:upper16:(aSCanTFindHashb+0x38) ; s
STR             R3, [SP,#0x1C+which_asic]
BLX             puts
LDR             R1, [SP,#0x1C+var_C]
LDR             R3, =(reg_mutex+0x14)
ADD.W           how_many_asic_not_receive_all_nonce, R1, #0xC
LSLS            R6, R6, #2
ADD.W           R3, R3, R1,LSL#19
STR             R3, [SP,#0x1C+var_8]
B               loc_19E66

loc_19E54
LDR             R3, [SP,#0x1C+which_asic]
LDR             R2, [SP,#0x1C+var_8]
ADDS            R3, #1
CMP             R3, #0x2D ; '-'
ADD.W           R2, R2, #0x1000
STR             R3, [SP,#0x1C+which_asic]
which_asic_0 = R3       ; unsigned int
STR             R2, [SP,#0x1C+var_8]
BEQ             loc_19F46

loc_19E66               ; core_number
MOVS            R2, #0x32 ; '2'
LDRB.W          R1, [SP,#0x1C+which_asic] ; which_asic
LDR             R0, [SP,#0x1C+var_C] ; which_chain
BL              calculate_how_many_nonce_per_asic_get
LDR             R1, [R5,#configuration.pattern_number]
MOVS            R3, #0x32 ; '2'
MOV             R2, R0
per_asic_received_nonce_number = R0; unsigned int
MUL             R3, R3, R1
CMP             per_asic_received_nonce_number, R3
BCS             loc_19E54
LDR             R4, [SP,#0x1C+which_asic]
per_asic_received_nonce_number = R2; unsigned int
MOV             R0, #aAsic02dD_0 ; "asic[%02d] = %d\n"
MOV             R1, R4
BLX             printf
LSLS            R3, R4, #2
MOV             R2, #cgpu
LDR.W           R9, [SP,#0x1C+var_8]
ADD.W           R3, R3, #0x80000
MOVS            R1, #0
ADDS            R3, #0xAC
MOVW            R0, #:lower16:aCore02dDLostTh ; "core[%02d] = %d,      lost these nonce "...
LDR.W           R11, [R3,R2]
works = R11             ; work *
MOV             R4, R1
MOVT            R0, #:upper16:aCore02dDLostTh ; "core[%02d] = %d,      lost these nonce "...
STR             R1, [SP,#0x1C+how_many_core_not_receive_all_nonce_per_asic]
STR             R0, [SP,#0x1C+format]

loc_19EB8
which_core = R4         ; unsigned int
LDR.W           R7, [R9,#4]!
LDR             R2, [R5,#configuration.pattern_number]
CMP             R7, R2
BCS             loc_19F32
LDR             R3, [SP,#0x1C+how_many_core_not_receive_all_nonce_per_asic]
MOV             R2, R7
LDR.W           R1, [R5,#configuration.Invalid_Core_Num]
MOV.W           R10, #0
LDR.W           R0, [R5,#configuration.Least_nonce_per_core]
ADDS            R3, #1
CMP             R3, R1
IT HI
MOVHI.W         ret, #6
MOV             R1, which_core
CMP             R7, R0
IT CC
MOVCC.W         R8, #6
LDR             R0, [SP,#0x1C+format] ; format
STR             R3, [SP,#0x1C+how_many_core_not_receive_all_nonce_per_asic]
how_many_core_not_receive_all_nonce_per_asic_0 = R3; unsigned int
ret = R8                ; unsigned int
MOVW            R7, #:lower16:aD ; "%d  "
BLX             printf
LDR             R1, [R5,#configuration.pattern_number]
MOVT            R7, #:upper16:aD ; "%d  "
CBNZ            R1, loc_19F06
B               loc_19F2C

loc_19EFC
which_pattern = R10     ; unsigned int
LDR             R1, [R5,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R1, which_pattern
BLS             loc_19F2C

loc_19F06
MLA             R1, which_core, R1, which_pattern
ADD.W           R1, R1, R1,LSL#4
ADD.W           R1, works, R1,LSL#2
ADD             R1, R6
LDR             R3, [R1,#4]
CMP             R3, #0
BNE             loc_19EFC
MOV             R1, which_pattern
MOV             R0, R7  ; format
BLX             printf
LDR             R1, [R5,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R1, which_pattern
BHI             loc_19F06

loc_19F2C               ; c
MOVS            R0, #0xA
BLX             putchar

loc_19F32
ADDS            which_core, #1
CMP             which_core, #0x32 ; '2'
BNE             loc_19EB8
MOV             R0, #(aSCanTFindHashb+0x38) ; s
BLX             puts
B               loc_19E54

loc_19F46
which_asic_0 = R3       ; unsigned int
LDR             R2, [SP,#0x1C+var_C]
MOV             R4, #gHw_Nonce_Num
LDR.W           which_asic_0, [R5,#configuration.Most_HW_Num]
LDR.W           R2, [R4,R2,LSL#2]
CMP             R2, R3
BLS             loc_19F6E
MOVW            R0, #:lower16:aRetD ; "ret = %d\n"
MOV.W           R8, #6
MOVT            R0, #:upper16:aRetD ; "ret = %d\n"
MOV             R1, R8
BLX             printf

loc_19F6E
ret = R8                ; unsigned int
MOV             R0, #asc_29CA4 ; "\n-------------------------------------"...
BLX             puts
LDR             R2, [SP,#0x1C+var_C]
MOV             R3, #gSensor_OK
LDRB.W          R3, [R3,R2,LSL#2]
CBNZ            R3, loc_19F8E
BIC.W           ret, ret, #2

loc_19F8E
MOV             R3, #gHigherThanAlarmTemp
LDRB            R3, [R3]
CBZ             R3, loc_19F9E
BIC.W           ret, ret, #4

loc_19F9E
LDR             R1, [SP,#0x1C+var_C]
MOV             R3, #gValid_Nonce_Num
MOV             R0, #aChainDTotalVal ; "Chain%d total valid nonce number: %d\n"...
LDR.W           R2, [R3,R1,LSL#2]
BLX             printf
TST.W           ret, #1
ITETE NE
MOVWNE          R0, #0x9D38
MOVWEQ          R0, #0x9D44
MOVTNE          R0, #2
MOVTEQ          R0, #2  ; s
BLX             puts
TST.W           ret, #2
ITETE NE
MOVWNE          R0, #0xAB0C
MOVWEQ          R0, #0xAB18
MOVTNE          R0, #2
MOVTEQ          R0, #2  ; s
BLX             puts
TST.W           ret, #4
ITETE NE
MOVWNE          R0, #0xBC2C
MOVWEQ          R0, #0xBC3C
MOVTNE          R0, #2
MOVTEQ          R0, #2  ; s
BLX             puts
LDR             R3, [SP,#0x1C+var_C]
MOV             R0, #aHwNumberD ; "HW number = %d\n\n"
LDR.W           R1, [R4,R3,LSL#2]
BLX             printf
MOV             R0, ret
ADD             SP, SP, #0x1C
POP.W           {R4-R11,PC}
; End of function V9_get_result

off_1A020 DCD reg_mutex+0x14



; void __fastcall V9_print_lcd(unsigned int result)
EXPORT V9_print_lcd
V9_print_lcd
result = R0             ; unsigned int
PUSH            {R4,LR}
MOV             R4, result
BL              display_level_result_on_lcd
LSLS            R1, result, #0x1F
BPL             loc_1A086
MOVW            R1, #:lower16:aPatternOk_0 ; "   Pattern OK   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aPatternOk_0 ; "   Pattern OK   "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R3, #:lower16:pattern_test_time
MOVS            R2, #0
MOVT            R3, #:upper16:pattern_test_time
STRB            R2, [R3]

loc_1A04C
LSLS            R2, result, #0x1E
MOV.W           R0, #2  ; line
ITETT MI
MOVWMI          R1, #0xBC64
MOVWPL          R1, #0xBC78
MOVMI           R2, #0x10
MOVTMI          R1, #2
ITT PL
MOVPL           R2, #0x10 ; size
MOVTPL          R1, #2  ; buf
BL              write_lcd_no_memset
LSLS            R3, result, #0x1D
BMI             loc_1A0A6
MOVW            R1, #:lower16:aTemperatureNg ; " Temperature NG "
MOVS            R2, #0x10
MOVT            R1, #:upper16:aTemperatureNg ; " Temperature NG "
MOVS            R0, #3
POP.W           {result,LR}
B.W             write_lcd_no_memset

loc_1A086
result = R4             ; unsigned int
MOVW            R1, #:lower16:aPatternNg_0 ; "   Pattern NG   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aPatternNg_0 ; "   Pattern NG   "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOV             R3, #pattern_test_time
LDRB            R2, [R3]
ADDS            R2, #1
STRB            R2, [R3]
B               loc_1A04C

loc_1A0A6
MOVW            R1, #:lower16:aTemperatureOk ; " Temperature OK "
MOVS            R2, #0x10
MOVT            R1, #:upper16:aTemperatureOk ; " Temperature OK "
MOVS            R0, #3
POP.W           {result,LR}
B.W             write_lcd_no_memset
; End of function V9_print_lcd

ALIGN 4



; int __fastcall v9_check_nonce(unsigned __int8 which_chain, unsigned __int8 *nonce_data)
EXPORT v9_check_nonce
v9_check_nonce

var_14= -0x14
var_10= -0x10
ret= -8

which_chain = R0        ; unsigned __int8
nonce_data = R1         ; unsigned __int8 *
PUSH.W          {R4-R11,LR}
MOV             R4, nonce_data
LDRB            R3, [R4]
MOV             R8, which_chain
MOVW            nonce_data, #:lower16:gChain_Asic_Interval
nonce_data = R4         ; unsigned __int8 *
SUB             SP, SP, #0x14
LDRB            R5, [nonce_data,#1]
MOVT            R1, #:upper16:gChain_Asic_Interval
MOV             which_chain, R3
LDRB            R2, [nonce_data,#3]
LSLS            R3, R3, #0x18
LDRB            R6, [nonce_data,#2]
LDR             R1, [R1]
ORR.W           R3, R3, R5,LSL#16
AND.W           R11, R2, #0x3F ; '?'
ORRS            R3, R2
ORR.W           R6, R3, R6,LSL#8
temp_nonce = R6         ; unsigned int
BL              __aeabi_uidiv
which_asic = R0         ; unsigned int
which_core = R11        ; unsigned int
CMP             which_asic, #0x2C ; ','
LDRB            R3, [nonce_data,#4]
BHI.W           loc_1A26E
CMP.W           which_core, #0x31 ; '1'
ITTT HI
MOVWHI          which_asic, #:lower16:aSReceivedCore0 ; "%s: received core%02d nonce. error!!!\t"
MOVHI           R2, which_core
MOVTHI          R0, #:upper16:aSReceivedCore0 ; "%s: received core%02d nonce. error!!!\t"
BHI.W           loc_1A24E
AND.W           R2, R3, #0x7F
which_pattern = R2      ; unsigned int
MOV             R3, #Conf
LDR             R3, [R3,#configuration.pattern_number]
CMP             which_pattern, R3
BCS.W           loc_1A246
MOV             R9, R0
MOVW            R1, #:lower16:cgpu
ADD.W           R0, R0, #0x20000
MOVT            R1, #:upper16:cgpu
ADDS            R0, #0x2A ; '*'
MLA             R3, R3, which_core, which_pattern
ADD.W           R1, R1, R0,LSL#2
LDR             which_pattern, [R1,#4]
ADD.W           R3, R3, R3,LSL#4
ADD.W           R3, R2, R3,LSL#2
work = R3               ; work *
LDR             R2, [work,#4]
CMP             temp_nonce, R2
BEQ             loc_1A1AA
MOVW            work, #:lower16:HW_check_mutex
match_nonce = R2        ; unsigned int
ADD.W           R10, R8, R8,LSL#1
MOVT            R3, #:upper16:HW_check_mutex
ADD.W           R10, R3, R10,LSL#3
MOV             R7, #gWork_Num_For_Hw_Check
MOV             R0, R10 ; mutex
BLX             pthread_mutex_lock
LDRB            nonce_data, [R7]
CMP             R4, #0
BEQ.W           loc_1A274
MOVW            R3, #:lower16:gWorks_For_Hw_Check
ADD.W           R4, R8, R8,LSL#4
MOVT            R3, #:upper16:gWorks_For_Hw_Check
ADD.W           R4, R3, R4,LSL#9
MOVS            R5, #0
B               loc_1A186

loc_1A180
i = R5                  ; int
LDRB            R2, [R7]
CMP             R2, i
BLE             loc_1A206

loc_1A186               ; work
MOV             R0, R4
MOVS            R2, #0  ; print
MOV             R1, temp_nonce ; nonce
ADDS            i, #1
ADDS            R4, #0x44 ; 'D'
BL              check_hw
i = R5                  ; int
CMP             R0, #0
BNE             loc_1A180
STR             R0, [SP,#0x14+ret]
MOV             R0, R10 ; mutex
BLX             pthread_mutex_unlock
LDR             R3, [SP,#0x14+ret]
MOV             R0, R3
ADD             SP, SP, #0x14
POP.W           {R4-which_core,PC}

loc_1A1AA
nonce_data = R4         ; unsigned __int8 *
match_nonce = R2        ; unsigned int
work = R3               ; work *
ADD.W           work, work, R8,LSL#2
LDR             R0, [R3,#0x34]
CBZ             R0, loc_1A1D0
MOVW            match_nonce, #:lower16:gRepeated_Nonce_Id
ADDS            R0, #1
MOVT            R2, #:upper16:gRepeated_Nonce_Id
STR             R0, [R3,#0x34]
LDR.W           R3, [R2,R8,LSL#2]
MOVS            R0, #0
ADDS            R3, #1
STR.W           R3, [R2,R8,LSL#2]

loc_1A1CA
ADD             SP, SP, #0x14
POP.W           {R4-which_core,PC}

loc_1A1D0
nonce_data = R4         ; unsigned __int8 *
match_nonce = R2        ; unsigned int
ADD.W           R9, R9, R8,LSL#7
MOVW            match_nonce, #:lower16:gAsic_Core_Nonce_Num
MOVW            R1, #:lower16:gValid_Nonce_Num
ADD.W           which_core, which_core, R9,LSL#10
MOVT            R2, #:upper16:gAsic_Core_Nonce_Num
MOVT            R1, #:upper16:gValid_Nonce_Num
MOVS            nonce_data, #1
STR             R4, [R3,#0x34]
LDR.W           R4, [R1,R8,LSL#2]
LDR.W           R3, [R2,R11,LSL#2]
ADDS            R4, #1
ADDS            R3, #1
STR.W           R4, [R1,R8,LSL#2]
STR.W           R3, [R2,R11,LSL#2]
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}

loc_1A206
which_core = R11        ; unsigned int
i = R5                  ; int
STR             R0, [SP,#0x14+ret]
ret_0 = R0              ; int
MOV             ret_0, R10 ; mutex
BLX             pthread_mutex_unlock
LDR             R3, [SP,#0x14+ret]
CMP             R3, #1
IT NE
MOVNE           R0, #0
BNE             loc_1A1CA
MOVW            i, #:lower16:gHw_Nonce_Num
STR             temp_nonce, [SP,#0x14+var_10]
MOVT            R5, #:upper16:gHw_Nonce_Num
MOVW            R0, #:lower16:aSFindAHwChainD ; "%s: Find a HW. Chain%d ASIC%d Core%d : "...
LDR.W           R4, [R5,R8,LSL#2]
MOV             R3, R9
STR.W           which_core, [SP,#0x14+var_14]
MOV             R2, R8
MOVT            R0, #:upper16:aSFindAHwChainD ; "%s: Find a HW. Chain%d ASIC%d Core%d : "...
LDR             R1, =__FUNCTION__.8173 ; "v9_check_nonce"
ADDS            R4, #1
STR.W           R4, [R5,R8,LSL#2]
BLX             printf
MOVS            R0, #0
B               loc_1A1CA

loc_1A246
nonce_data = R4         ; unsigned __int8 *
which_pattern = R2      ; unsigned int
MOV             R0, #aSReceivedWorkI ; "%s: received work_id = %02d nonce. erro"...

loc_1A24E
LDR             R1, =__FUNCTION__.8173 ; "v9_check_nonce"
BLX             printf
LDRB            R3, [nonce_data,#2]
MOVW            R0, #:lower16:aReceivedDataIs ; ",received data is : 0x%02x%02x%02x%02x%"...
LDRB            R2, [nonce_data,#1]
MOVT            R0, #:upper16:aReceivedDataIs ; ",received data is : 0x%02x%02x%02x%02x%"...
LDRB            R1, [nonce_data]
LDRB            R5, [nonce_data,#4]
LDRB            nonce_data, [nonce_data,#3]
STMEA.W         SP, {R4,R5}
BLX             printf

loc_1A26E
MOV.W           R0, #0xFFFFFFFF
B               loc_1A1CA

loc_1A274               ; mutex
MOV             R0, R10
BLX             pthread_mutex_unlock
MOV             R0, R4
B               loc_1A1CA
; End of function v9_check_nonce

ALIGN 0x10
off_1A280 DCD __FUNCTION__.8173 ; "v9_check_nonce"



; int __fastcall V9_check_register_value(unsigned __int8 which_chain, unsigned __int8 *register_data)
EXPORT V9_check_register_value
V9_check_register_value
which_chain = R0        ; unsigned __int8
register_data = R1      ; unsigned __int8 *
PUSH            {R3-R7,LR}
MOV             R3, #reg_value_buf
LDR             R3, [R3]
LDR             R6, [R3,#8]
CMP.W           R6, #0x1FE
BHI             loc_1A2D8
LDRB            R5, [register_data,#1]
ADDS            R6, #1
LDRB.W          LR, [register_data]
LDRB            R4, [register_data,#3]
LDRB            R7, [register_data,#2]
LSLS            R5, R5, #0x10
LDR             R2, [R3]
ORR.W           R5, R5, LR,LSL#24
ORRS            R4, R5
ADD.W           R5, R3, R2,LSL#3
ORR.W           R4, R4, R7,LSL#8
ADDS            R2, #1
CMP.W           R2, #0x200
STR             R4, [R5,#0x10]
LDRB            register_data, [register_data,#4]
STRB            which_chain, [R5,#0x17]
MOV.W           which_chain, #0
AND.W           R1, R1, #0x1F
STRB            R1, [R5,#0x16]
STR             R6, [R3,#8]
STR             R2, [R3]
BCC             locret_1A2D6
STR             R0, [R3]
POP             {R3-R7,PC}

locret_1A2D6
POP             {R3-R7,PC}

loc_1A2D8
which_chain = R0        ; unsigned __int8
register_data = R1      ; unsigned __int8 *
MOVW            which_chain, #:lower16:aSRegValueBufBu ; "%s: reg_value_buf buffer is full!\n"
LDR             register_data, =__FUNCTION__.8181 ; "V9_check_register_value"
MOVT            R0, #:upper16:aSRegValueBufBu ; "%s: reg_value_buf buffer is full!\n"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
POP             {R3-R7,PC}
; End of function V9_check_register_value

off_1A2EC DCD __FUNCTION__.8181 ; "V9_check_register_value"



; void *__fastcall V9_receive_func(void *arg)
EXPORT V9_receive_func
V9_receive_func

var_628= -0x628
var_624= -0x624
var_620= -0x620
temp_buf= -0x61C
var_617= -0x617
var_615= -0x615
data_buf= -0x614
receive_buf= -0x420

arg = R0                ; void *
which_chain = R6        ; unsigned __int8
PUSH.W          {R4-R11,LR}
MOV             R3, arg
chain_info = R0         ; chain_info *
SUBW            SP, SP, #0x62C
LDRB            which_chain, [chain_info]
MOVW            R2, #0x41A ; n
MOVS            R1, #0  ; c
LDRB            R4, [R3,#1]
which_i2c = R4          ; unsigned __int8
ADD             chain_info, SP, #0x62C+receive_buf ; s
chain_info = R3         ; chain_info *
BLX             memset
MOV.W           R2, #0x1F4 ; n
MOVS            R1, #0  ; c
ADD             R0, SP, #0x62C+data_buf ; s
MOVS            R5, #0
BLX             memset
MOVW            R0, #:lower16:aSWhichChainDWh ; "%s: which_chain = %d, which_i2c = %d\n"
MOV             R3, which_i2c
MOV             R2, which_chain
LDR             R1, =__FUNCTION__.8235 ; "V9_receive_func"
MOVT            R0, #:upper16:aSWhichChainDWh ; "%s: which_chain = %d, which_i2c = %d\n"
STR             R5, [SP,#0x62C+temp_buf]
STRB.W          R5, [SP,#0x62C+temp_buf+4]
MOVW            R8, #:lower16:start_receive
BLX             printf
MOVW            R3, #:lower16:gStartTest
MOV             R0, which_chain ; which_chain
MOV             R7, R3
MOVW            R3, #:lower16:gIsOpenCoreEnd
STR             R3, [SP,#0x62C+var_628]
MOVW            which_i2c, #:lower16:gIsOpeningCore
BL              clear_uart_rx_fifo
MOV             R3, R7
MOVW            R10, #0xCCCD
MOVT            R3, #:upper16:gStartTest
MOVT            R8, #:upper16:start_receive
STR             R3, [SP,#0x62C+var_620]
MOVT            R4, #:upper16:gIsOpeningCore
LDR             R3, [SP,#0x62C+var_628]
MOVT            R10, #0xCCCC
MOVT            R3, #:upper16:gIsOpenCoreEnd
STR             R3, [SP,#0x62C+var_628]

loc_1A36A
LDRB.W          R0, [R8]
CBZ             R0, loc_1A3B6

loc_1A370               ; useconds
MOVW            R0, #0x1388
MOVW            R7, #0x4B40
BLX             usleep
MOVT            R7, #0x4C ; 'L'
B               loc_1A38A

loc_1A382               ; useconds
MOVW            R0, #0x4E20
BLX             usleep

loc_1A38A
LDRB            R3, [R4]
CMP             R3, #0
BNE             loc_1A382
MOVW            R2, #0x41A ; n
MOVS            R1, #0  ; c
ADD             R0, SP, #0x62C+receive_buf ; s
BLX             memset
MOV.W           R2, #0x3E8 ; buf_length
ADD             R1, SP, #0x62C+receive_buf ; buf
MOV             R0, which_chain ; which_uart
BL              uart_receive
len = R0                ; unsigned int
CBNZ            len, loc_1A3BE
SUBS            R7, #1
BNE             loc_1A38A
LDRB.W          len, [R8]
CMP             R0, #0
BNE             loc_1A370

loc_1A3B6
ADDW            SP, SP, #0x62C
POP.W           {R4-R11,PC}

loc_1A3BE
len = R0                ; unsigned int
ADD             R3, SP, #0x62C+data_buf
SUBS            R2, R5, #1
ADD             R2, R3
ADDW            R1, SP, #0x62C+data_buf+0x1F3
MOVS            R3, #0

loc_1A3CA
data_buf_w_p = R5       ; unsigned int
j = R3                  ; unsigned int
LDRB.W          R7, [R1,#1]!
ADDS            j, #1
CMP             len, R3
ADD.W           data_buf_w_p, data_buf_w_p, #1
j = R3                  ; unsigned int
STRB.W          R7, [R2,#1]!
BHI             loc_1A3CA
CMP             data_buf_w_p, #4
BLS             loc_1A36A
UMULL           len, R1, data_buf_w_p, R10
ADD.W           R9, SP, #0x62C+data_buf
MOV             R3, R9
ADD.W           R11, SP, #0x62C+var_617
LSRS            R7, R1, #2
ADD.W           R7, R7, R7,LSL#2
ADD             R3, R7
STR             R3, [SP,#0x62C+var_624]

loc_1A3F8
ADD             R3, SP, #0x62C+temp_buf
MOV             R2, R9
MOVS            R1, #0
STR             R1, [SP,#0x62C+temp_buf]
STRB.W          R1, [SP,#0x62C+temp_buf+4]

loc_1A404
LDRB.W          R1, [R2],#1
STRB.W          R1, [R3],#1
CMP             R3, R11
BNE             loc_1A404
LDRB.W          R0, [SP,#0x62C+temp_buf+4] ; data
BL              BM1385_is_nonce_or_reg_value
CBZ             R0, loc_1A450
LDR             R3, [SP,#0x62C+var_620]
LDRB            R3, [R3]
CBZ             R3, loc_1A426
LDR             R3, [SP,#0x62C+var_628]
LDRB            R3, [R3]
CBNZ            R3, loc_1A45A

loc_1A426
LDR             R3, [SP,#0x62C+var_624]
ADD.W           R9, R9, #5
CMP             R3, R9
BNE             loc_1A3F8
SUBS            data_buf_w_p, data_buf_w_p, R7
remaining_len = R5      ; unsigned int
BEQ             loc_1A36A
SUBS            R3, R7, #1
ADD             R1, SP, #0x62C+data_buf
ADDS            R0, R3, remaining_len
ADD.W           R2, SP, #0x62C+var_615
ADD             R3, R1
ADD             R0, R1

loc_1A442
LDRB.W          R1, [R3,#1]!
CMP             R3, R0
STRB.W          R1, [R2,#1]!
BNE             loc_1A442
B               loc_1A36A

loc_1A450               ; register_data
data_buf_w_p = R5       ; unsigned int
ADD             R1, SP, #0x62C+temp_buf
MOV             R0, which_chain ; which_chain
BL              V9_check_register_value
B               loc_1A426

loc_1A45A               ; nonce_data
ADD             R1, SP, #0x62C+temp_buf
MOV             R0, which_chain ; which_chain
BL              v9_check_nonce
B               loc_1A426
; End of function V9_receive_func

off_1A464 DCD __FUNCTION__.8235 ; "V9_receive_func"



; void singleBoardTest_V9_BM1385_45()
EXPORT singleBoardTest_V9_BM1385_45
singleBoardTest_V9_BM1385_45

lcd_display_buf= -0x14

PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x14
LDR             R5, =dword_2C8BC
MOV             R4, SP
MOV             R6, #lcd_fd
LDR             R2, [R5,#(dword_2C8C4 - 0x2C8BC)]
LDR             R3, [R5,#(dword_2C8C8 - 0x2C8BC)]
LDR             R0, [R5]
LDR             R1, [R5,#(dword_2C8C0 - 0x2C8BC)]
STM             R4!, {R0-R3}
MOVW            R0, #:lower16:aBeginSTest ; "\nBegin %s test\n"
ADD.W           R1, R5, #0x10
MOVT            R0, #:upper16:aBeginSTest ; "\nBegin %s test\n"
BLX             printf
MOV             R0, #aDate ; "date"
BLX             system
MOVS            R0, #0xA ; c
BLX             putchar
MOVW            R0, #:lower16:lcd_output
MOVS            R2, #0x40 ; '@' ; n
MOVT            R0, #:upper16:lcd_output ; s
MOVS            R1, #0x20 ; ' ' ; c
BLX             memset
LDR             R0, [R6] ; fd
CMP             R0, #0
BLE             loc_1A4D4
MOVS            R2, #0  ; whence
MOV             R1, R2  ; offset
BLX             lseek
MOVW            R1, #:lower16:lcd_output
LDR             R0, [R6] ; fd
MOVT            R1, #:upper16:lcd_output ; buf
MOVS            R2, #0x40 ; '@' ; n
BLX             write

loc_1A4D4
BL              init_fpga
MOVS            R0, #0x1A ; asic_baud
MOVW            R4, #:lower16:gChain
BL              set_fpga_baud
MOVS            R0, #0  ; address
MOVT            R4, #:upper16:gChain
BL              read_axi_fpga
ORR.W           R1, R0, #0x20000000 ; data
MOVS            R0, #0  ; address
BL              write_axi_fpga
BL              reset_V9_global_arg
BL              check_chain
LDRB            R3, [R4]
CMP             R3, #0xFF
BEQ.W           loc_1A6C4
LDR             R6, =cgpu.show_id
MOV             R8, #chain_info_0
MOVW            R2, #:lower16:(V9_show_status_func+1)
ADD.W           R3, R8, R3,LSL#1 ; arg
MOVT            R2, #:upper16:(V9_show_status_func+1) ; start_routine
MOVS            R1, #0  ; attr
MOV             R0, R6  ; newthread
MOVW            R5, #:lower16:gI2c
BLX             pthread_create
MOVW            R1, #0xFFFF ; data
MOVS            R0, #0xD ; address
BL              write_axi_fpga
MOVW            R0, #:lower16:(gAsic_Core_Nonce_Num+0x1859C)
MOVT            R5, #:upper16:gI2c
MOVT            R0, #:upper16:(gAsic_Core_Nonce_Num+0x1859C) ; useconds
MOV.W           R10, #1
BLX             usleep
LDRB            R1, [R5] ; which_i2c
SUB.W           R9, R6, #0x80008
LDRB            R0, [R4] ; which_chain
MOVW            R7, #:lower16:Conf
BL              reset_PIC16F1704_pic
LDRB            R1, [R5] ; which_i2c
MOVT            R7, #:upper16:Conf
LDRB            R0, [R4] ; which_chain
BL              jump_from_loader_to_app_PIC16F1704
LDRB            R1, [R5] ; which_i2c
MOVS            R2, #0  ; whether_add_voltage
LDRB            R0, [R4] ; which_chain
BL              V9_set_voltage
LDRB            R1, [R5] ; which_i2c
MOV             R2, R10 ; enable
LDRB            R0, [R4] ; which_chain
BL              enable_PIC16F1704_dc_dc
LDRB            R3, [R4]
MOV             R2, #(pic_heart_beat_func+1) ; start_routine
MOVS            R1, #0  ; attr
ADDS            R0, R6, #4 ; newthread
ADD.W           R3, R8, R3,LSL#1 ; arg
BLX             pthread_create
MOV             R0, #(gAsic_Core_Nonce_Num+0x1859C) ; useconds
BLX             usleep
MOVS            R1, #0  ; data
MOVS            R0, #0xD ; address
BL              write_axi_fpga
MOV             R0, #(gAsic_Core_Nonce_Num+0x1859C) ; useconds
BLX             usleep
LDRB            R3, [R4]
MOV             R1, #start_receive
MOV             R2, #(V9_receive_func+1) ; start_routine
STRB.W          R10, [R1]
SUBS            R0, R6, #4 ; newthread
MOVS            R1, #0  ; attr
ADD.W           R3, R8, R3,LSL#1 ; arg
BLX             pthread_create
MOV             R0, #aV9CheckAsicNum ; "\n--- V9 check asic number"
BLX             puts
MOVS            R2, #0  ; reg
MOV             R3, R10 ; mode
MOV             R1, R2  ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              check_BM1385_asic_reg
LDRB            R1, [R4]
MOV             R0, #aCheckChainJDHa ; "\n--- check chain: J%d has asicNum = %d"...
ADD.W           R3, R9, R1
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             printf
LDRB            R0, [R4] ; which_chain
LDR             R2, [R7,#configuration.AsicNum]
ADD.W           R3, R9, R0
ADD.W           R3, R3, #0x100000
LDRB.W          R3, [R3,#0x30C]
CMP             R3, R2
BEQ             loc_1A710
LDR.W           R0, [R6,#(cgpu.receive_id - 0x2B0FCC)] ; th
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R6,#(cgpu.pic_heart_beat_id - 0x2B0FCC)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDRB            R3, [R4]
MOV             R1, #(aT1DT2D+0xC) ; format
ADD.W           R0, SP, #0x14+lcd_display_buf+7 ; s
ADD             R3, R9
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             sprintf
MOVW            R1, #:lower16:aOnlyHave ; "   Only have    "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aOnlyHave ; "   Only have    "
MOVS            R0, #0  ; line
BL              write_lcd
MOV             R1, SP  ; buf
MOV             R0, R10 ; line
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aAsic ; "      ASIC      "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aAsic ; "      ASIC      "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
LDRB            R3, [R4]
MOVW            R0, #:lower16:aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
LDR             R1, =__FUNCTION__.8262 ; "singleBoardTest_V9_BM1385_45"
MOVT            R0, #:upper16:aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
ADD             R9, R3
ADD.W           R9, R9, #0x100000
LDRB.W          R2, [R9,#0x30C]
BLX             printf
MOV             R0, #asc_29F80 ; "----------------------------\n\n"
BLX             puts
LDR.W           R0, [R7,#configuration.close_power_delay] ; seconds
BLX             sleep
LDRB            R1, [R5] ; which_i2c
MOVS            R2, #0  ; enable
LDRB            R0, [R4] ; which_chain
BL              enable_PIC16F1704_dc_dc

loc_1A6BE
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}

loc_1A6C4
LDR             R4, =cgpu.send_id
LDR             R0, [R4,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R4,#(cgpu.show_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
MOVW            R1, #:lower16:aNoHashBoard_0 ; " no hash board  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aNoHashBoard_0 ; " no hash board  "
MOVS            R0, #1  ; line
BL              write_lcd
MOV             R0, #aNoHashBoardPle ; "\nNo hash board, please plug in it"
BLX             puts
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}
off_1A700 DCD dword_2C8BC
off_1A704 DCD cgpu.show_id
off_1A708 DCD __FUNCTION__.8262 ; "singleBoardTest_V9_BM1385_45"
off_1A70C DCD cgpu.send_id

loc_1A710               ; baud
MOV             R1, R10
MOV.W           R11, #0
BL              V9_set_baud
LDRB            R0, [R4]
BL              reset_hash_board
MOVS            R0, #0x1A ; asic_baud
BL              set_fpga_baud
LDRB            R3, [R4]
MOV             R0, #aDoubleCheckAsi ; "\n--- double check asic number"
ADD             R3, R9
ADD.W           R3, R3, #0x100000
STRB.W          R11, [R3,#0x30C]
BLX             puts
MOV             R3, R10 ; mode
MOV             R2, R11 ; reg
MOV             R1, R11 ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              check_BM1385_asic_reg
LDRB            R1, [R4]
MOV             R0, #aCheckChainJDHa ; "\n--- check chain: J%d has asicNum = %d"...
ADD.W           R3, R9, R1
ADDS            R1, #1
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             printf
LDRB            R3, [R4]
LDR             R2, [R7,#configuration.AsicNum]
ADD             R3, R9
ADD.W           R3, R3, #0x100000
LDRB.W          R3, [R3,#0x30C]
CMP             R3, R2
BEQ             loc_1A828
LDR.W           R0, [R6,#(cgpu.receive_id - 0x2B0FCC)] ; th
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R6,#(cgpu.pic_heart_beat_id - 0x2B0FCC)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDRB            R3, [R4]
MOV             R1, #(aT1DT2D+0xC) ; format
ADD.W           R0, SP, #0x14+lcd_display_buf+7 ; s
ADD             R3, R9
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             sprintf
MOVW            R1, #:lower16:aOnlyHave ; "   Only have    "
MOV             R0, R11 ; line
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aOnlyHave ; "   Only have    "
BL              write_lcd
MOV             R1, SP  ; buf
MOV             R0, R10 ; line
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aAsic ; "      ASIC      "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aAsic ; "      ASIC      "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
LDRB            R3, [R4]
MOVW            R0, #:lower16:aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
LDR             R1, =__FUNCTION__.8262 ; "singleBoardTest_V9_BM1385_45"
MOVT            R0, #:upper16:aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
ADD             R9, R3
ADD.W           R9, R9, #0x100000
LDRB.W          R2, [R9,#0x30C]
BLX             printf
MOV             R0, #asc_29F80 ; "----------------------------\n\n"
BLX             puts
LDR.W           R0, [R7,#configuration.close_power_delay] ; seconds
BLX             sleep
MOV             R2, R11 ; enable
LDRB            R1, [R5] ; which_i2c
LDRB            R0, [R4] ; which_chain
BL              enable_PIC16F1704_dc_dc
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}

loc_1A828
BL              V9_calculate_timeout_and_baud
MOV             R3, R10 ; mode
LDR             R2, [R7,#configuration.Freq] ; freq
MOV             R1, R11 ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              set_BM1385_freq
LDRB            R0, [R4] ; which_chain
MOVW            R9, #:lower16:gStartTest
BL              V9_set_address
LDRB.W          R1, [R7,#configuration.baud] ; baud
MOVT            R9, #:upper16:gStartTest
LDRB            R0, [R4] ; which_chain
BL              V9_set_baud
LDRB            R0, [R4] ; which_chain
BL              V9_open_core
MOV             R0, #aBeginSendTestP ; "\nBegin send test pattern"
BLX             puts
LDRB.W          R3, [R9]
CBNZ            R3, loc_1A89A
MOVW            R10, #:lower16:time_counter
LDR.W           R3, [R7,#configuration.HeatingUpTime]
MOVT            R10, #:upper16:time_counter
LDR.W           R2, [R10]
CMP             R2, R3
BCC             loc_1A88A
B               loc_1A934

loc_1A87E
LDR.W           R2, [R7,#configuration.HeatingUpTime]
LDR.W           R3, [R10]
CMP             R2, R3
BLS             loc_1A934

loc_1A88A               ; useconds
MOVW            R0, #0x2710
BLX             usleep
LDRB.W          R3, [R9]
CMP             R3, #0
BEQ             loc_1A87E

loc_1A89A
LDRB            R3, [R4]
MOVW            R2, #:lower16:(V9_send_func+1)
LDR             R6, =cgpu.send_id
MOVT            R2, #:upper16:(V9_send_func+1) ; start_routine
MOVS            R1, #0  ; attr
ADD.W           R3, R8, R3,LSL#1 ; arg
MOV             R0, R6  ; newthread
BLX             pthread_create
MOVS            R1, #0  ; thread_return
LDR             R0, [R6] ; th
BLX             pthread_join
LDR             R0, [R6,#(cgpu.show_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOVS            R1, #0  ; thread_return
LDR             R0, [R6,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_join
LDRB            R0, [R4] ; which_chain
BL              V9_get_result
MOV             R8, R0
result = R0             ; unsigned int
BL              V9_print_lcd
CMP.W           result, #7
BEQ             loc_1A994
TST.W           result, #1
BNE             loc_1A8F8
MOVW            R2, #:lower16:pattern_test_time
MOVW            R3, #:lower16:gHowManyVoltageLevel
MOVT            R2, #:upper16:pattern_test_time
MOVT            R3, #:upper16:gHowManyVoltageLevel
LDRB            R2, [R2]
LDRB            R3, [R3]
CMP             R2, R3
BCC             loc_1A902

loc_1A8F8               ; which_i2c
LDRB            R1, [R5]
MOVS            R2, #0  ; enable
LDRB            R0, [R4] ; which_chain
BL              enable_PIC16F1704_dc_dc

loc_1A902               ; mutex
MOV             R0, #i2c_mutex
BLX             pthread_mutex_lock
LDR             R0, [R6,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOVS            R0, #0  ; speed
BL              set_fan_speed
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
B               loc_1A6BE

loc_1A934
LDR             R4, =cgpu.send_id
LDR             R0, [R4,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
LDR             R0, [R4,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #aCanTOpenCoreCh ; "Can't open core, change to next voltage"...
BLX             puts
MOVW            R1, #:lower16:aCanTOpenCore ; "Can't open core "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCanTOpenCore ; "Can't open core "
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aChangeToNext ; "change  to  next"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aChangeToNext ; "change  to  next"
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:(aCanTOpenCoreCh+0x20) ; "voltage and freq"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:(aCanTOpenCoreCh+0x20) ; buf
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOV             R3, #pattern_test_time
LDRB            R2, [R3]
ADDS            R2, #1
STRB            R2, [R3]
B               loc_1A6BE

loc_1A994
result = R8             ; unsigned int
LDR.W           R3, [R7,#configuration.add_voltage_after_test_ok]
CMP             R3, #0
BEQ             loc_1A8F8
MOVS            R2, #1  ; whether_add_voltage
LDRB            R1, [R5] ; which_i2c
LDRB            R0, [R4] ; which_chain
BL              V9_set_voltage
B               loc_1A8F8
; End of function singleBoardTest_V9_BM1385_45

off_1A9A8 DCD __FUNCTION__.8262 ; "singleBoardTest_V9_BM1385_45"
off_1A9AC DCD cgpu.send_id



; void __fastcall i2c_write(unsigned int config_data)
EXPORT i2c_write
i2c_write
config_data = R0        ; unsigned int
PUSH            {R4,LR}
MOV             R4, config_data
B               loc_1A9BA

loc_1A9B6
config_data = R4        ; unsigned int
BLX             usleep

loc_1A9BA               ; address
MOVS            R0, #0xC
BL              read_axi_fpga
CMP             R0, #0
MOVW            R0, #0x1388 ; useconds
BGE             loc_1A9B6
MOV             R1, config_data ; data
MOVS            R0, #0xC ; address
POP.W           {config_data,LR}
config_data = R1        ; unsigned int
B.W             write_axi_fpga
; End of function i2c_write




; unsigned __int8 __fastcall i2c_read(unsigned int config_data)
EXPORT i2c_read
i2c_read
config_data = R0        ; unsigned int
PUSH            {R3,LR}
ORR.W           config_data, config_data, #0x2000000 ; config_data
BL              i2c_write

loc_1A9DE               ; useconds
MOVW            R0, #0x1388
BLX             usleep
MOVS            R0, #0xC ; address
BL              read_axi_fpga
ret_data = R0           ; unsigned int
CMP             ret_data, #0
BGE             loc_1A9DE
UXTB            ret_data, ret_data
POP             {R3,PC}
; End of function i2c_read

ALIGN 8



; void power_check_type()
EXPORT power_check_type
power_check_type
ret = R4                ; uint8_t
MOVW            R0, #:lower16:i2c_mutex
PUSH            {ret,LR}
MOVT            R0, #:upper16:i2c_mutex ; mutex
BLX             pthread_mutex_lock
MOV.W           R0, #0x5200000 ; config_data
BL              i2c_read
MOV             ret, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
CMP             ret, #0xF5
BEQ             loc_1AA3A
MOV             R0, #aPowerTypeApw82 ; "power type APW8 2000W"
BLX             puts
MOVW            R3, #:lower16:g_power_type
MOVS            R2, #1
MOVT            R3, #:upper16:g_power_type
STRH            R2, [R3]
POP             {ret,PC}

loc_1AA3A
MOV             R0, #aPowerTypeApw93 ; "power type APW9 3600W"
BLX             puts
MOVW            R3, #:lower16:g_power_type
MOVS            R2, #2
MOVT            R3, #:upper16:g_power_type
STRH            R2, [R3]
POP             {ret,PC}
; End of function power_check_type




; int open_power_control()
EXPORT open_power_control
open_power_control
PUSH            {R4,LR}
MOVW            R4, #:lower16:power_control_fd
BL              power_check_type
MOVW            R0, #:lower16:aSysClassGpioGp ; "/sys/class/gpio/gpio907/value"
MOVW            R1, #0x801 ; oflag
MOVT            R0, #:upper16:aSysClassGpioGp ; "/sys/class/gpio/gpio907/value"
MOVT            R4, #:upper16:power_control_fd
BLX             open
CMP             R0, #0
STR             R0, [R4]
BLT             loc_1AA7A
POP             {R4,PC}

loc_1AA7A
MOV             R0, #aOpenPowerContr ; "open power control gpio failed!!!"
BLX             puts
LDR             R0, [R4]
POP             {R4,PC}
; End of function open_power_control

ALIGN 4



; void close_power_control()
EXPORT close_power_control
close_power_control
PUSH            {R3,LR}
MOV             R3, #power_control_fd
LDR             R0, [R3] ; fd
BLX             close
MOVW            R0, #:lower16:aPowerControlGp ; "power control gpio closed!!!"
POP.W           {R3,LR}
MOVT            R0, #:upper16:aPowerControlGp ; "power control gpio closed!!!"
B.W             j_puts
; End of function close_power_control




; void power_on()
EXPORT power_on
power_on
MOVW            R3, #:lower16:power_control_fd
MOVW            R1, #:lower16:a0 ; "0"
MOVT            R3, #:upper16:power_control_fd
MOVT            R1, #:upper16:a0 ; "0"
LDR             R0, [R3] ; fd
MOVS            R2, #1  ; n
B.W             j_write
; End of function power_on




; void power_off()
EXPORT power_off
power_off
MOVW            R3, #:lower16:power_control_fd
MOVW            R1, #:lower16:a1 ; "1"
MOVT            R3, #:upper16:power_control_fd
MOVT            R1, #:upper16:a1 ; "1"
LDR             R0, [R3] ; fd
MOVS            R2, #1  ; n
B.W             j_write
; End of function power_off




; unsigned int get_target_voltage()
EXPORT get_target_voltage
get_target_voltage
MOVW            R3, #:lower16:pattern_test_time
PUSH            {R4,LR}
MOVT            R3, #:upper16:pattern_test_time
LDRB            R2, [R3]
CMP             R2, #8  ; switch 9 cases
BHI             def_1AAEC ; jumptable 0001AAEC default case
TBB.W           [PC,R2] ; switch jump
jpt_1AAEC DCB 0x1B      ; jump table for switch statement
DCB 0x22
DCB 0x29
DCB 0x30
DCB 0x37
DCB 0x3E
DCB 0x45
DCB 0x4C
DCB 5
ALIGN 2

loc_1AAFA               ; jumptable 0001AAEC case 8
MOV             R3, #Conf
LDR.W           R4, [R3,#configuration.Voltage9]

loc_1AB06
voltage = R4            ; unsigned int
LDR             R3, =(cgpu.subid+0x7FD54)
MOVW            R1, #:lower16:__FUNCTION__.8004 ; "get_target_voltage"
MOVW            R0, #:lower16:aSTargetVoltage ; "\n--- %s: target voltage is %d\n"
MOVT            R1, #:upper16:__FUNCTION__.8004 ; "get_target_voltage"
MOV             R2, voltage
MOVT            R0, #:upper16:aSTargetVoltage ; "\n--- %s: target voltage is %d\n"
STR.W           voltage, [R3,#(cgpu.voltage - 0x330FC4)]
BLX             printf
MOV             R0, voltage
POP             {voltage,PC}

loc_1AB26               ; jumptable 0001AAEC case 0
MOV             R3, #Conf
LDR.W           R4, [R3,#configuration.Voltage1]
voltage = R4            ; unsigned int
B               loc_1AB06

loc_1AB34               ; jumptable 0001AAEC case 1
MOV             R3, #Conf
LDR.W           R4, [R3,#configuration.Voltage2]
voltage = R4            ; unsigned int
B               loc_1AB06

loc_1AB42               ; jumptable 0001AAEC case 2
MOV             R3, #Conf
LDR.W           R4, [R3,#configuration.Voltage3]
voltage = R4            ; unsigned int
B               loc_1AB06

loc_1AB50               ; jumptable 0001AAEC case 3
MOV             R3, #Conf
LDR.W           R4, [R3,#configuration.Voltage4]
voltage = R4            ; unsigned int
B               loc_1AB06

loc_1AB5E               ; jumptable 0001AAEC case 4
MOV             R3, #Conf
LDR.W           R4, [R3,#configuration.Voltage5]
voltage = R4            ; unsigned int
B               loc_1AB06

loc_1AB6C               ; jumptable 0001AAEC case 5
MOV             R3, #Conf
LDR.W           R4, [R3,#configuration.Voltage6]
voltage = R4            ; unsigned int
B               loc_1AB06

loc_1AB7A               ; jumptable 0001AAEC case 6
MOV             R3, #Conf
LDR.W           R4, [R3,#configuration.Voltage7]
voltage = R4            ; unsigned int
B               loc_1AB06

loc_1AB88               ; jumptable 0001AAEC case 7
MOV             R3, #Conf
LDR.W           R4, [R3,#configuration.Voltage8]
voltage = R4            ; unsigned int
B               loc_1AB06

def_1AAEC               ; jumptable 0001AAEC default case
MOVW            R3, #:lower16:Conf
MOVW            R1, #:lower16:__FUNCTION__.8004 ; "get_target_voltage"
MOVW            R0, #:lower16:aSNotSupportVol ; "!!!%s: not support Voltage%d, we use Vo"...
MOVT            R3, #:upper16:Conf
MOVT            R1, #:upper16:__FUNCTION__.8004 ; "get_target_voltage"
MOVT            R0, #:upper16:aSNotSupportVol ; "!!!%s: not support Voltage%d, we use Vo"...
LDR.W           R4, [R3,#configuration.Voltage1]
voltage = R4            ; unsigned int
BLX             printf
B               loc_1AB06
; End of function get_target_voltage

off_1ABB8 DCD cgpu.subid+0x7FD54



; bool __fastcall power_check_reply(uint8_t *cmd, uint8_t *reply_buf, uint8_t reply_len)
EXPORT power_check_reply
power_check_reply
cmd = R0                ; uint8_t *
reply_buf = R1          ; uint8_t *
reply_len = R2          ; uint8_t
PUSH            {R4-R6,LR}
MOV             R4, reply_buf
LDRB            R3, [R4]
MOV             R5, reply_len
LDRB            reply_buf, [cmd]
reply_buf = R4          ; uint8_t *
CMP             R1, R3
BEQ             loc_1AC02

loc_1ABCA
MOV             R0, #aPowerReplyData ; "power reply data error:"
BLX             puts
UXTH            R2, R5
CBZ             R2, loc_1ABF8
SUBS            R5, R2, #1
MOVW            R6, #:lower16:a02x ; "%02x "
UXTAH.W         R5, reply_buf, R5
MOVT            R6, #:upper16:a02x ; "%02x "
SUBS            reply_buf, #1

loc_1ABEA
LDRB.W          R1, [R4,#1]!
MOV             R0, R6  ; format
BLX             printf
CMP             R5, R4
BNE             loc_1ABEA

loc_1ABF8               ; c
MOVS            R0, #0xA
BLX             putchar
MOVS            R0, #0
POP             {R4-R6,PC}

loc_1AC02
cmd = R0                ; uint8_t *
reply_buf = R4          ; uint8_t *
reply_len = R2          ; uint8_t
LDRB            reply_len, [cmd,#1]
LDRB            R3, [reply_buf,#1]
CMP             R2, R3
BNE             loc_1ABCA
LDRB            R2, [cmd,#3]
LDRB            R3, [reply_buf,#3]
CMP             R2, R3
BNE             loc_1ABCA
LDRB            cmd, [reply_buf,#2]
ADDS            R3, R0, #2
CMP             R3, R5
BNE             loc_1ABCA
CMP             R0, #2
IT LE
MOVLE           R1, #0
BLE             loc_1AC34
MOVS            R3, #2
MOVS            R1, #0

loc_1AC26
crc = R1                ; uint16_t
i = R3                  ; uint16_t
LDRB            R2, [reply_buf,i]
ADDS            i, #1
UXTH            R3, R3
CMP             R0, R3
ADD             crc, R2
UXTH            R1, R1
crc = R1                ; uint16_t
i = R3                  ; uint16_t
BGT             loc_1AC26

loc_1AC34
ADDS            R3, reply_buf, R5
LDRB.W          R0, [R3,#-1]
LDRB.W          R2, [R3,#-2]
ADD.W           R2, R2, R0,LSL#8
UXTH            R2, R2
crc_reply = R2          ; uint16_t
CMP             crc_reply, R1
BEQ             loc_1AC7A
MOV             R0, #aPowerReplyCrcE ; "power reply crc error, crc %04x != crc_"...
BLX             printf
UXTH            R2, R5
CMP             R2, #0
BEQ             loc_1ABF8
SUBS            R5, R2, #1
MOVW            R6, #:lower16:a02x ; "%02x "
UXTAH.W         R5, reply_buf, R5
MOVT            R6, #:upper16:a02x ; "%02x "
SUBS            reply_buf, #1

loc_1AC6A
LDRB.W          R1, [R4,#1]!
MOV             R0, R6  ; format
BLX             printf
CMP             R5, R4
BNE             loc_1AC6A
B               loc_1ABF8

loc_1AC7A
reply_buf = R4          ; uint8_t *
crc_reply = R2          ; uint16_t
MOVS            R0, #1
POP             {reply_buf-R6,PC}
; End of function power_check_reply

ALIGN 0x10



; bool __fastcall power_send_cmd(uint8_t *cmd, uint8_t len, uint8_t *reply_buf, uint8_t reply_len)
EXPORT power_send_cmd
power_send_cmd
cmd = R0                ; uint8_t *
len = R1                ; uint8_t
reply_buf = R2          ; uint8_t *
reply_len = R3          ; uint8_t
PUSH.W          {reply_len-R11,LR}
MOV             R10, len
ADD.W           R5, R10, #0xFFFFFFFF
MOV             R7, cmd
UXTB            R5, R5
MOVW            cmd, #:lower16:i2c_mutex
cmd = R7                ; uint8_t *
MOVS            R6, #1
ADD             R5, cmd
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOV             R9, reply_buf
MOV             R8, reply_len
BLX             pthread_mutex_lock

loc_1ACA2
CMP.W           R10, #0
BEQ             loc_1ACC2
MOV.W           R11, #0x1100
SUBS            R4, cmd, #1
MOVT            R11, #0x520

loc_1ACB2
LDRB.W          R0, [R4,#1]!
ORR.W           R0, R0, R11 ; config_data
BL              i2c_write
CMP             R4, R5
BNE             loc_1ACB2

loc_1ACC2
ADD.W           R11, R8, #0xFFFFFFFF
MOVW            R0, #:lower16:(gAsic_Core_Nonce_Num+0x492DC)
UXTB.W          R11, R11
MOVT            R0, #:upper16:(gAsic_Core_Nonce_Num+0x492DC) ; useconds
ADD.W           R4, reply_buf, #0xFFFFFFFF
BLX             usleep
ADD             R11, reply_buf
CMP.W           R8, #0
BEQ             loc_1ACF2

loc_1ACE2               ; config_data
MOV.W           R0, #0x4200000
BL              i2c_read
STRB.W          R0, [R4,#1]!
CMP             R4, R11
BNE             loc_1ACE2

loc_1ACF2               ; reply_len
MOV             R2, R8
MOV             R1, reply_buf ; reply_buf
MOV             R0, cmd ; cmd
BL              power_check_reply
MOV             R4, R0
CBNZ            R0, loc_1AD16
retry = R6              ; uint8_t
MOVW            R0, #:lower16:aPowerSendCmd0x ; "power send cmd 0x%02x failed, retry for"...
MOV             R2, retry
MOVT            R0, #:upper16:aPowerSendCmd0x ; "power send cmd 0x%02x failed, retry for"...
ADDS            retry, #1
LDRB            R1, [cmd,#3]
BLX             printf
CMP             R6, #4
BNE             loc_1ACA2

loc_1AD16               ; mutex
MOV             R0, #i2c_mutex
BLX             pthread_mutex_unlock
MOV             R0, R4
POP.W           {R3-R11,PC}
; End of function power_send_cmd




; unsigned __int8 __fastcall APW8_calculate_voltage(unsigned int voltage)
EXPORT APW8_calculate_voltage
APW8_calculate_voltage

var_10= -0x10
var_4= -4

voltage = R0            ; unsigned int
MOVW            R3, #:lower16:gHashBoard_BHB91601S
PUSH            {R4,LR}
MOVT            R3, #:upper16:gHashBoard_BHB91601S
VPUSH           {D8}
SUB             SP, SP, #0x10
LDRB            R3, [R3]
VMOV            S12, voltage
CBNZ            R3, loc_1AD8C
MOV             R3, #gHashBoard_BHB91601P
LDRB            R3, [R3]
CBZ             R3, loc_1AD80
MOVW            R3, #:lower16:BHB91601_ASIC_NUMBER
VCVT.F64.U32    D6, S12
MOVT            R3, #:upper16:BHB91601_ASIC_NUMBER
LDR             R3, [R3]
CMP             R3, #0x54 ; 'T'
BEQ             loc_1ADFE
CMP             R3, #0x3C ; '<'
BNE             loc_1AE40
VLDR            D5, =156.145833
VLDR            D4, =100.0
VLDR            D7, =1336.07353
VMUL.F64        D6, D6, D5
VDIV.F64        D5, D6, D4
VSUB.F64        D7, D7, D5
VCVT.F32.F64    S16, D7
B               loc_1ADAC

loc_1AD80
MOV             R3, #gHashBoard_BHB07601
LDRB            R3, [R3]
CBZ             R3, loc_1ADE6

loc_1AD8C
VLDR            D5, =59.9315068
VCVT.F64.U32    D6, S12
VLDR            D4, =100.0
VLDR            D7, =1215.89444
VMUL.F64        D6, D6, D5
VDIV.F64        D5, D6, D4
VSUB.F64        D7, D7, D5
VCVT.F32.F64    S16, D7

loc_1ADAC
VCVT.U32.F32    S15, S16
VCMPE.F32       S16, #0.0
VMRS            APSR_nzcv, FPSCR
VSTR            S15, [SP,#0x10+var_4]
LDRB.W          R4, [SP,#0x10+var_4]
N = R4                  ; unsigned __int8
BMI             loc_1AE1C
VCVT.F64.F32    D7, S16
MOV             R3, N

loc_1ADC8
MOVW            R0, #:lower16:aSVoltageNFND ; "\n--- %s: voltage_n = %f, N = %d\n"
STR             R3, [SP,#0x10+var_10]
LDR             R1, =__FUNCTION__.8046 ; "APW8_calculate_voltage"
MOVT            R0, #:upper16:aSVoltageNFND ; "\n--- %s: voltage_n = %f, N = %d\n"
VMOV            R2, R3, D7
BLX             printf
MOV             R0, N
ADD             SP, SP, #0x10
VPOP            {D8}
POP             {N,PC}

loc_1ADE6
voltage = R0            ; unsigned int
MOVW            voltage, #:lower16:aSPleaseCheckHa ; "\n!!! %s Please check Hashboard type!\n"...
LDR             R1, =__FUNCTION__.8046 ; "APW8_calculate_voltage"
MOVT            R0, #:upper16:aSPleaseCheckHa ; "\n!!! %s Please check Hashboard type!\n"...
BLX             printf
MOVS            R3, #0xFF
VLDR            D7, =255.0
MOV             R4, R3
B               loc_1ADC8

loc_1ADFE
voltage = R0            ; unsigned int
VLDR            D5, =171.875
VLDR            D4, =100.0
VLDR            D7, =1925.73529
VMUL.F64        D6, D6, D5
VDIV.F64        D5, D6, D4
VSUB.F64        D7, D7, D5
VCVT.F32.F64    S16, D7
B               loc_1ADAC

loc_1AE1C
VCVT.F64.F32    D7, S16
MOVS            R4, #0
MOVW            R0, #:lower16:aSVoltageNFWeUs ; "\n!!! %s: voltage_n = %f, we use N = %d"...
STR             R4, [SP,#0x10+var_10]
LDR             R1, =__FUNCTION__.8046 ; "APW8_calculate_voltage"
MOVT            R0, #:upper16:aSVoltageNFWeUs ; "\n!!! %s: voltage_n = %f, we use N = %d"...
VMOV            R2, R3, D7
BLX             printf
N = R4                  ; unsigned __int8
MOV             R0, N
ADD             SP, SP, #0x10
VPOP            {D8}
POP             {N,PC}

loc_1AE40
voltage = R0            ; unsigned int
VLDR            D5, =171.875
MOVW            voltage, #:lower16:aSUseBhb9160184 ; "\n!!! %s Use BHB91601 84P power as defa"...
VLDR            D4, =100.0
MOVT            R0, #:upper16:aSUseBhb9160184 ; "\n!!! %s Use BHB91601 84P power as defa"...
VLDR            D7, =1925.73529
LDR             R1, =__FUNCTION__.8046 ; "APW8_calculate_voltage"
VMUL.F64        D6, D6, D5
VDIV.F64        D5, D6, D4
VSUB.F64        D7, D7, D5
VCVT.F32.F64    S16, D7
BLX             printf
B               loc_1ADAC
; End of function APW8_calculate_voltage

ALIGN 0x10
dbl_1AE70 DCFD 156.145833
dbl_1AE78 DCFD 100.0
dbl_1AE80 DCFD 1336.07353
dbl_1AE88 DCFD 59.9315068
dbl_1AE90 DCFD 1215.89444
dbl_1AE98 DCFD 255.0
dbl_1AEA0 DCFD 171.875
dbl_1AEA8 DCFD 1925.73529
off_1AEB0 DCD __FUNCTION__.8046 ; "APW8_calculate_voltage"



; void __fastcall APW8_set_voltage(unsigned __int8 N)
EXPORT APW8_set_voltage
APW8_set_voltage
N = R0                  ; unsigned __int8
ORR.W           N, N, #0x5200000
ORR.W           R0, R0, #0x200
B.W             i2c_write
; End of function APW8_set_voltage




; unsigned __int8 __fastcall APW9_calculate_voltage(unsigned int voltage)
EXPORT APW9_calculate_voltage
APW9_calculate_voltage

var_10= -0x10
voltage= -4

voltage_0 = R0          ; unsigned int
MOVW            R3, #:lower16:gHashBoard_BHB07601
PUSH            {R4,LR}
MOVT            R3, #:upper16:gHashBoard_BHB07601
SUB             SP, SP, #0x10
LDRB            R3, [R3]
STR             voltage_0, [SP,#0x10+voltage]
CBZ             R3, loc_1AF2C
VMOV            S15, voltage_0
VCVT.F64.U32    D6, S15
VLDR            D5, =35.833333
VLDR            D4, =100.0
VLDR            D7, =765.411764
VMUL.F64        D6, D6, D5
VDIV.F64        D5, D6, D4
VSUB.F64        D7, D7, D5
VCVT.F32.F64    S14, D7
VCMPE.F32       S14, #0.0
VMRS            APSR_nzcv, FPSCR
BMI             loc_1AF44
VCVT.U32.F32    S15, S14
VSTR            S15, [SP,#0x10+voltage]
LDRB.W          R4, [SP,#0x10+voltage]
VCVT.F64.F32    D7, S14
MOV             R3, R4

loc_1AF12
N = R4                  ; unsigned __int8
MOVW            R0, #:lower16:aSVoltageNFND ; "\n--- %s: voltage_n = %f, N = %d\n"
STR             R3, [SP,#0x10+var_10]
LDR             R1, =__FUNCTION__.8056 ; "APW9_calculate_voltage"
MOVT            R0, #:upper16:aSVoltageNFND ; "\n--- %s: voltage_n = %f, N = %d\n"
VMOV            R2, R3, D7
BLX             printf
MOV             R0, N
ADD             SP, SP, #0x10
POP             {N,PC}

loc_1AF2C
voltage_0 = R0          ; unsigned int
MOVW            voltage_0, #:lower16:aSPleaseCheckHa ; "\n!!! %s Please check Hashboard type!\n"...
LDR             R1, =__FUNCTION__.8056 ; "APW9_calculate_voltage"
MOVT            R0, #:upper16:aSPleaseCheckHa ; "\n!!! %s Please check Hashboard type!\n"...
BLX             printf
MOVS            R3, #0xFF
VLDR            D7, =255.0
MOV             R4, R3
B               loc_1AF12

loc_1AF44
voltage_0 = R0          ; unsigned int
VCVT.F64.F32    D7, S14
MOVS            R4, #0
MOVW            voltage_0, #:lower16:aSVoltageNFWeUs ; "\n!!! %s: voltage_n = %f, we use N = %d"...
STR             R4, [SP,#0x10+var_10]
LDR             R1, =__FUNCTION__.8056 ; "APW9_calculate_voltage"
MOVT            R0, #:upper16:aSVoltageNFWeUs ; "\n!!! %s: voltage_n = %f, we use N = %d"...
VMOV            R2, R3, D7
BLX             printf
N = R4                  ; unsigned __int8
MOV             R0, N
ADD             SP, SP, #0x10
POP             {N,PC}
; End of function APW9_calculate_voltage

ALIGN 8
dbl_1AF68 DCFD 35.833333
dbl_1AF70 DCFD 100.0
dbl_1AF78 DCFD 765.411764
dbl_1AF80 DCFD 255.0
off_1AF88 DCD __FUNCTION__.8056 ; "APW9_calculate_voltage"



; void __fastcall APW9_set_voltage(unsigned __int8 N)
EXPORT APW9_set_voltage
APW9_set_voltage

cmd= -0x28
reply= -0x20

N = R0                  ; unsigned __int8
MOVW            R3, #:lower16:__FUNCTION__.8004 ; "get_target_voltage"
PUSH            {R4-R6,LR}
MOVT            R3, #:upper16:__FUNCTION__.8004 ; "get_target_voltage"
MOV             R6, N
SUB             SP, SP, #0x28
MOVS            R2, #0x20 ; ' ' ; n
LDR.W           N, [R3,#(off_2CAFC - 0x2CAB8)]!
MOV             R4, SP
LDR             R1, [R3,#(dword_2CB00 - 0x2CAFC)]
STM             R4!, {R0,R1}
MOVS            R1, #0  ; c
MOV             R0, R4  ; s
BLX             memset
LDRB.W          R0, [SP,#0x28+cmd+2]
MOVS            R3, #8  ; reply_len
LDRB.W          R5, [SP,#0x28+cmd+3]
ADD.W           R2, SP, R3 ; reply_buf
LDRB.W          R4, [SP,#0x28+cmd+5]
MOV             R1, R3  ; len
ADD             R0, R6
STRB.W          R6, [SP,#0x28+cmd+4]
ADD             R5, R0
crc = R5                ; uint16_t
MOV             R0, SP  ; cmd
ADD             R4, crc
UXTH            R4, R4
crc = R4                ; uint16_t
LSR.W           R5, crc, R3
STRB.W          crc, [SP,#0x28+cmd+6]
STRB.W          R5, [SP,#0x28+cmd+7]
BL              power_send_cmd
ADD             SP, SP, #0x28 ; '('
POP             {crc-R6,PC}
; End of function APW9_set_voltage




; unsigned __int8 __fastcall power_calculate_voltage(unsigned int voltage)
EXPORT power_calculate_voltage
power_calculate_voltage
voltage = R0            ; unsigned int
PUSH            {R3,LR}
MOV             R3, #g_power_type
LDRH            R3, [R3]
CMP             R3, #1
BEQ             loc_1AFFC
BL              APW9_calculate_voltage
ret = R0                ; int
UXTB            ret, ret ; voltage
POP             {R3,PC}

loc_1AFFC
voltage = R0            ; unsigned int
BL              APW8_calculate_voltage
ret = R0                ; int
UXTB            ret, ret
POP             {R3,PC}
; End of function power_calculate_voltage




; void __fastcall power_set_voltage(unsigned __int8 N)
EXPORT power_set_voltage
power_set_voltage
N = R0                  ; unsigned __int8
MOV             R3, #g_power_type
LDRH            R3, [R3]
CMP             R3, #1
BEQ             loc_1B016
B.W             APW9_set_voltage

loc_1B016
N = R0                  ; unsigned __int8
ORR.W           N, N, #0x5200000
ORR.W           R0, R0, #0x200
B.W             i2c_write
; End of function power_set_voltage

ALIGN 4



; int __fastcall Calibration_voltage(unsigned __int8 which_chain, unsigned __int8 which_iic)
EXPORT Calibration_voltage
Calibration_voltage

var_24= -0x24
var_20= -0x20
var_1C= -0x1C
vol0= -0x14
vol1= -0x10
vol2= -0xC
vol3= -8

which_chain = R0        ; unsigned __int8
which_iic = R1          ; unsigned __int8
PUSH.W          {R4-R11,LR}
MOVS            R3, #0
VPUSH           {D8-D15}
SUB             SP, SP, #0x24
MOV             R7, which_iic
MOV             R6, which_chain
STR             R3, [SP,#0x24+vol0]
MOVW            R11, #:lower16:power_control_fd
STR             R3, [SP,#0x24+vol1]
MOVT            R11, #:upper16:power_control_fd
STR             R3, [SP,#0x24+vol2]
MOV.W           R4, #0x100
STR             R3, [SP,#0x24+vol3]
ADD.W           R9, SP, #0x24+vol3
BL              get_target_voltage
MOV             R10, R0
target_V0 = R0          ; unsigned int
VLDR            S30, =0.0
BL              power_calculate_voltage
MOV             R5, R0
N = R5                  ; unsigned __int8
VLDR            D11, =3.3
BL              power_set_voltage
MOVW            R0, #:lower16:aSTargetV0DND ; "\n--- %s: target_V0 = %d, N = %d\n"
MOV             R3, N
MOV             R2, target_V0
LDR             R1, =__FUNCTION__.8088_0 ; "Calibration_voltage"
MOVT            R0, #:upper16:aSTargetV0DND ; "\n--- %s: target_V0 = %d, N = %d\n"
VLDR            D10, =0.000244140625
BLX             printf
MOVW            R1, #:lower16:a0 ; "0"
MOVS            R2, #1  ; n
MOVT            R1, #:upper16:a0 ; "0"
LDR.W           R0, [R11] ; fd
BLX             write
MOVW            R0, #:lower16:(gAsic_Core_Nonce_Num+0x492DC)
VLDR            D12, =73.0
MOVT            R0, #:upper16:(gAsic_Core_Nonce_Num+0x492DC) ; useconds
VLDR            D9, =100.0
BLX             usleep
MOV             R1, R7  ; which_i2c
MOV             R0, R6  ; which_chain
MOVS            R2, #1  ; enable
VLDR            D14, =43.0
BL              enable_dsPIC33EP16GS202_dc_dc
MOVW            R0, #:lower16:(gAsic_Core_Nonce_Num+0x492DC)
ADD.W           R8, SP, #0x24+vol2
MOVT            R0, #:upper16:(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
B               loc_1B0C4

loc_1B0C0
ret = R0                ; unsigned int
SUBS            R4, #1
BEQ             loc_1B1BA

loc_1B0C4               ; vol3
STR.W           R9, [SP,#0x24+var_20]
ADD             R3, SP, #0x24+vol1 ; vol1
STR.W           R8, [SP,#0x24+var_24] ; vol2
ADD             R2, SP, #0x24+vol0 ; vol0
MOV             R1, R6  ; which_chain
MOV             R0, R7  ; which_iic
BL              dsPIC33EP16GS202_read_out_4_voltage
ret = R0                ; unsigned int
CMP             ret, #1
BNE             loc_1B0C0
MOV             R3, #gHashBoard_BHB91601P
LDRB            R3, [R3]
CMP             R3, #0
BEQ             loc_1B1DA
MOV             R3, #BHB91601_ASIC_NUMBER
LDR             R3, [R3]
CMP             R3, #0x3C ; '<'
BEQ.W           loc_1B222
CMP             R3, #0x54 ; 'T'
BNE             loc_1B126
VLDR            S15, [SP,#0x24+vol0]
VLDR            D5, =40.0
VMOV.F64        D6, #10.0
VCVT.F64.U32    D7, S15
VMUL.F64        D7, D7, D11
VMUL.F64        D7, D7, D10
VMUL.F64        D7, D7, D5
VDIV.F64        D15, D7, D6
VMUL.F64        D15, D15, D9
VCVT.F32.F64    S30, D15

loc_1B126
VMOV            S15, target_V0
MOVW            R0, #:lower16:aSVoltageV0FTar ; "\n--- %s: voltage_V0 = %f, target_V0 = "...
VCVT.F32.U32    S26, S15
MOVT            R0, #:upper16:aSVoltageV0FTar ; "\n--- %s: voltage_V0 = %f, target_V0 = "...
VCVT.F64.F32    D8, S30
STR.W           target_V0, [SP,#0x24+var_24]
LDR             R1, =__FUNCTION__.8088_0 ; "Calibration_voltage"
VSUB.F32        S31, S30, S26
VMOV            R2, R3, D8
VCVT.F64.F32    D6, S31
VSTR            D6, [SP,#0x24+var_1C]
BLX             printf
MOVW            R3, #:lower16:Conf
VCMPE.F32       S31, #0.0
MOVT            R3, #:upper16:Conf
VMRS            APSR_nzcv, FPSCR
LDR.W           R3, [R3,#configuration.Voltage_accuracy]
IT MI
VNEGMI.F32      S31, S31
VMOV            S15, R3
VCVT.F32.U32    S14, S15
VCMPE.F32       S31, S14
VMRS            APSR_nzcv, FPSCR
BMI             loc_1B248
VCMPE.F32       S30, S26
VMRS            APSR_nzcv, FPSCR
BLE             loc_1B20C
CMP             N, #0xFF
BEQ.W           loc_1B2A4
ADDS            N, #1

loc_1B192
UXTB            R5, R5
N = R5                  ; unsigned __int8
MOVW            R0, #:lower16:aSND ; "\n--- %s: N = %d\n"
LDR             R1, =__FUNCTION__.8088_0 ; "Calibration_voltage"
MOVT            R0, #:upper16:aSND ; "\n--- %s: N = %d\n"
MOV             R2, N
BLX             printf
MOV             R0, N   ; N
BL              power_set_voltage
MOV             R0, #(gAsic_Core_Nonce_Num+0xC33FC) ; useconds
BLX             usleep
SUBS            R4, #1
BNE             loc_1B0C4

loc_1B1BA
MOVW            R0, #:lower16:aSCalibrationCo ; "\n!!! %s: calibration_counter = %d, fai"...
MOV.W           R2, #0x100
LDR             R1, =__FUNCTION__.8088_0 ; "Calibration_voltage"
MOVT            R0, #:upper16:aSCalibrationCo ; "\n!!! %s: calibration_counter = %d, fai"...
BLX             printf
MOV.W           R0, #0xFFFFFFFF
ADD             SP, SP, #0x24 ; '$'
VPOP            {D8-D15}
POP.W           {R4-R11,PC}

loc_1B1DA
ret = R0                ; unsigned int
MOV             R3, #gHashBoard_BHB91601S
LDRB            R3, [R3]
CBZ             R3, loc_1B212
VLDR            S15, [SP,#0x24+vol0]
VMOV.F64        D6, #10.0
VCVT.F64.U32    D7, S15
VMUL.F64        D7, D7, D11
VMUL.F64        D7, D7, D10
VMUL.F64        D7, D7, D12
VDIV.F64        D15, D7, D6
VMUL.F64        D15, D15, D9
VCVT.F32.F64    S30, D15
B               loc_1B126

loc_1B20C
CBZ             N, loc_1B26A
SUBS            N, #1
B               loc_1B192

loc_1B212
N = R5                  ; unsigned __int8
ret = R0                ; unsigned int
MOVW            ret, #:lower16:aSPleaseCheckHa ; "\n!!! %s Please check Hashboard type!\n"...
LDR             R1, =__FUNCTION__.8088_0 ; "Calibration_voltage"
MOVT            R0, #:upper16:aSPleaseCheckHa ; "\n!!! %s Please check Hashboard type!\n"...
BLX             printf
B               loc_1B126

loc_1B222
ret = R0                ; unsigned int
VLDR            S15, [SP,#0x24+vol0]
VMOV.F64        D6, #10.0
VCVT.F64.U32    D7, S15
VMUL.F64        D7, D7, D11
VMUL.F64        D7, D7, D10
VMUL.F64        D7, D7, D14
VDIV.F64        D15, D7, D6
VMUL.F64        D15, D15, D9
VCVT.F32.F64    S30, D15
B               loc_1B126

loc_1B248
MOVW            R0, #:lower16:aSCalibrationVo ; "\n--- %s: Calibration voltage done. vol"...
STR             R3, [SP,#0x24+var_20]
STR             N, [SP,#0x24+var_24]
MOVT            R0, #:upper16:aSCalibrationVo ; "\n--- %s: Calibration voltage done. vol"...
VMOV            R2, R3, D8
LDR             R1, =__FUNCTION__.8088_0 ; "Calibration_voltage"
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x24 ; '$'
VPOP            {D8-D15}
POP.W           {R4-R11,PC}

loc_1B26A
MOVW            R0, #:lower16:aSNDFail ; "\n!!! %s: N = %d, fail\n"
MOV             R2, N
LDR             R1, =__FUNCTION__.8088_0 ; "Calibration_voltage"
MOVT            R0, #:upper16:aSNDFail ; "\n!!! %s: N = %d, fail\n"
BLX             printf
MOV             R2, N   ; enable
MOV             R1, R7  ; which_i2c
MOV             R0, R6  ; which_chain
BL              enable_dsPIC33EP16GS202_dc_dc
MOVW            R1, #:lower16:a1 ; "1"
LDR.W           R0, [R11] ; fd
MOVT            R1, #:upper16:a1 ; "1"
MOVS            R2, #1  ; n
BLX             write
MOV             R0, #0xFFFFFFFD
ADD             SP, SP, #0x24 ; '$'
VPOP            {D8-D15}
POP.W           {R4-R11,PC}

loc_1B2A4
MOVW            R0, #:lower16:aSNDFail ; "\n!!! %s: N = %d, fail\n"
MOV             R2, N
LDR             R1, =__FUNCTION__.8088_0 ; "Calibration_voltage"
MOVT            R0, #:upper16:aSNDFail ; "\n!!! %s: N = %d, fail\n"
BLX             printf
MOV             R1, R7  ; which_i2c
MOV             R0, R6  ; which_chain
MOVS            R2, #0  ; enable
BL              enable_dsPIC33EP16GS202_dc_dc
MOVW            R1, #:lower16:a1 ; "1"
LDR.W           R0, [R11] ; fd
MOVT            R1, #:upper16:a1 ; "1"
MOVS            R2, #1  ; n
BLX             write
MOV             R0, #0xFFFFFFFE
ADD             SP, SP, #0x24 ; '$'
VPOP            {D8-D15}
POP.W           {R4-R11,PC}
; End of function Calibration_voltage

ALIGN 0x10
dbl_1B2E0 DCFD 3.3
dbl_1B2E8 DCFD 0.000244140625
dbl_1B2F0 DCFD 73.0
dbl_1B2F8 DCFD 100.0
dbl_1B300 DCFD 43.0
dbl_1B308 DCFD 40.0
flt_1B310 DCFS 0.0
off_1B314 DCD __FUNCTION__.8088_0 ; "Calibration_voltage"



; int __fastcall set_pre_open_core_voltage(unsigned __int8 which_chain, unsigned __int8 which_iic)
EXPORT set_pre_open_core_voltage
set_pre_open_core_voltage
which_chain = R0        ; unsigned __int8
which_iic = R1          ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R5, #Conf
LDR             R4, =__FUNCTION__.8104 ; "set_pre_open_core_voltage"
MOV             R7, which_chain
MOV             R8, which_iic
LDR.W           which_chain, [R5,#configuration.pre_open_core_voltage] ; voltage
BL              power_calculate_voltage
MOV             R6, R0
N = R6                  ; unsigned __int8
BL              power_set_voltage
MOVW            R0, #:lower16:aSConfPreOpenCo ; "\n--- %s: Conf.pre_open_core_voltage = "...
LDR.W           R2, [R5,#configuration.pre_open_core_voltage]
MOV             R3, N
MOV             R1, R4
MOVT            R0, #:upper16:aSConfPreOpenCo ; "\n--- %s: Conf.pre_open_core_voltage = "...
MOVW            N, #:lower16:(gAsic_Core_Nonce_Num+0x492DC)
BLX             printf
MOVW            R3, #:lower16:power_control_fd
MOVW            R1, #:lower16:a0 ; "0"
MOVT            R3, #:upper16:power_control_fd
MOVT            R1, #:upper16:a0 ; "0"
LDR             R0, [R3] ; fd
MOVS            R2, #1  ; n
MOVT            R6, #:upper16:(gAsic_Core_Nonce_Num+0x492DC)
MOVW            R5, #:lower16:(gAsic_Core_Nonce_Num+0x1859C)
BLX             write
MOV             R0, R6  ; useconds
MOVT            R5, #:upper16:(gAsic_Core_Nonce_Num+0x1859C)
BLX             usleep
MOVW            R0, #:lower16:aSLineDEnterHas ; "%s line %d: Enter hash board power on f"...
MOVW            R2, #0x1FB
MOV             R1, R4
MOVT            R0, #:upper16:aSLineDEnterHas ; "%s line %d: Enter hash board power on f"...
BLX             printf
MOVW            R1, #0xFFFF ; data
MOVS            R0, #0xD ; address
BL              write_axi_fpga
MOV             R0, R5  ; useconds
BLX             usleep
MOVW            R0, #:lower16:aSLineDResetHas ; "%s line %d: Reset hash board done\n"
MOV             R1, R4
MOVW            R2, #0x1FF
MOVT            R0, #:upper16:aSLineDResetHas ; "%s line %d: Reset hash board done\n"
BLX             printf
MOV             R1, R8  ; which_i2c
MOVS            R2, #1  ; enable
MOV             R0, R7  ; which_chain
BL              enable_dsPIC33EP16GS202_dc_dc
MOV             R0, R6  ; useconds
BLX             usleep
MOVW            R0, #:lower16:aSLineDDcDcEnab ; "%s line %d: dc dc enable done\n"
MOVW            R2, #0x203
MOV             R1, R4
MOVT            R0, #:upper16:aSLineDDcDcEnab ; "%s line %d: dc dc enable done\n"
BLX             printf
MOVS            R1, #0  ; data
MOVS            R0, #0xD ; address
BL              write_axi_fpga
MOV             R0, R5  ; useconds
BLX             usleep
MOVW            R0, #:lower16:aSLineDReleaseH ; "%s line %d: release hash board reset do"...
MOV             R1, R4
MOVW            R2, #0x207
MOVT            R0, #:upper16:aSLineDReleaseH ; "%s line %d: release hash board reset do"...
BLX             printf
MOVS            R0, #0
POP.W           {R4-R8,PC}
; End of function set_pre_open_core_voltage

ALIGN 4
off_1B3F8 DCD __FUNCTION__.8104 ; "set_pre_open_core_voltage"



; void __fastcall adjust_voltage(unsigned __int8 which_chain, unsigned __int8 which_iic)
EXPORT adjust_voltage
adjust_voltage
which_chain = R0        ; unsigned __int8
which_iic = R1          ; unsigned __int8
PUSH            {R4-R6,LR}
BL              get_target_voltage
target_V0 = R0          ; unsigned int
BL              power_calculate_voltage
MOVW            R3, #:lower16:Conf
MOV             R5, R0
target_N = R5           ; unsigned __int8
MOVT            R3, #:upper16:Conf
LDR.W           R0, [R3,#configuration.pre_open_core_voltage] ; voltage
BL              power_calculate_voltage
MOV             R4, R0
origin_N = R0           ; unsigned __int8
MOV             R3, origin_N
MOVW            origin_N, #:lower16:aSTargetNDOrigi ; "\n--- %s: target_N = %d, origin_N = %d"...
origin_N = R3           ; unsigned __int8
MOV             R2, target_N
LDR             R1, =__FUNCTION__.8114_1 ; "adjust_voltage"
MOVT            R0, #:upper16:aSTargetNDOrigi ; "\n--- %s: target_N = %d, origin_N = %d"...
ADDS            R4, #0x14
BLX             printf
CMP             R4, target_N
ITT CC
MOVWCC          R6, #:lower16:(gAsic_Core_Nonce_Num+0xC33FC)
MOVTCC          R6, #:upper16:(gAsic_Core_Nonce_Num+0xC33FC)
BCS             loc_1B450

loc_1B43C
origin_N = R4           ; unsigned __int8
UXTB            origin_N, origin_N
MOV             R0, origin_N ; N
ADDS            origin_N, #0x14
origin_N = R0           ; unsigned __int8
BL              power_set_voltage
MOV             R0, R6  ; useconds
BLX             usleep
CMP             R4, target_N
BCC             loc_1B43C

loc_1B450               ; N
MOV             R0, target_N
BL              power_set_voltage
MOV             R0, #(gAsic_Core_Nonce_Num+0xC33FC) ; useconds
BLX             usleep
MOVW            R0, #:lower16:aSDone ; "\n--- %s: done\n"
LDR             R1, =__FUNCTION__.8114_1 ; "adjust_voltage"
MOVT            R0, #:upper16:aSDone ; "\n--- %s: done\n"
POP.W           {R4-R6,LR}
B.W             j_printf
; End of function adjust_voltage

off_1B474 DCD __FUNCTION__.8114_1 ; "adjust_voltage"



; unsigned int get_fan_speed()
EXPORT get_fan_speed
get_fan_speed
MOVS            R0, #1  ; address
B.W             read_axi_fpga
; End of function get_fan_speed

ALIGN 0x10



; void __fastcall set_fan_speed(unsigned int speed)
EXPORT set_fan_speed
set_fan_speed
speed = R0              ; unsigned int
MOV             R1, speed ; data
MOVS            speed, #0x21 ; '!' ; address
speed = R1              ; unsigned int
B.W             write_axi_fpga
; End of function set_fan_speed




; void __fastcall fan_control(unsigned __int8 level)
EXPORT fan_control
fan_control
level = R0              ; unsigned __int8
CMP             level, #0xA
ITETT LS
MOVWLS          R3, #0xCF94
MOVHI.W         R1, #0x640000
MOVTLS          R3, #2
LDRLS.W         R1, [R3,level,LSL#2] ; data
speed = R1              ; unsigned int
MOVS            level, #0x21 ; '!' ; address
B.W             write_axi_fpga
; End of function fan_control

ALIGN 4



; void __fastcall sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb)
EXPORT sha256_transf
sha256_transf

var_144= -0x144
i= -0x140
block_nb= -0x13C
message= -0x138
var_134= -0x134
var_130= -0x130
var_12C= -0x12C
var_128= -0x128
wv= -0x124
w= -0x104

ctx = R0                ; sha256_ctx *
message_0 = R1          ; const unsigned __int8 *
block_nb_0 = R2         ; unsigned int
SUBS            R3, block_nb_0, #0
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x144
STR             message_0, [SP,#0x144+message]
STR             R3, [SP,#0x144+block_nb]
BLE.W           loc_1B618
MOVW            R3, #:lower16:sha256_k
MOVS            block_nb_0, #0
MOVT            R3, #:upper16:sha256_k
STR             R2, [SP,#0x144+i]
STR             R3, [SP,#0x144+var_144]
ADD.W           R3, ctx, #0x84
STR             R3, [SP,#0x144+var_12C]
ADD.W           R3, ctx, #0xA4
STR             R3, [SP,#0x144+var_134]
ADD.W           R3, ctx, #0x88
STR             R3, [SP,#0x144+var_128]
ADD.W           R3, ctx, #0xA8
STR             R3, [SP,#0x144+var_130]

loc_1B4DA
LDR             R3, [SP,#0x144+message]
ADD             R5, SP, #0x144+wv+0x1C
LDR             R2, [SP,#0x144+i]
MOVS            R4, #0
ADD.W           R6, R3, R2,LSL#6

loc_1B4E6
j = R4                  ; int
ADD.W           R2, R6, j,LSL#2
LDRB.W          R0, [R6,j,LSL#2]
ADDS            j, #1
LDRB            R3, [R2,#3]
CMP             j, #0x10
LDRB            R1, [R2,#2]
LDRB            R2, [R2,#1]
ORR.W           R3, R3, R0,LSL#24
ORR.W           R3, R3, R1,LSL#8
ORR.W           R3, R3, R2,LSL#16
STR.W           R3, [R5,#4]!
BNE             loc_1B4E6
ADD             R6, SP, #0x144+w

loc_1B50C
LDR             R4, [R6,#0x38]
MOV             R1, R6
LDR.W           R0, [R6,#4]!
LDR             R5, [R1,#0x24]
LDR             R2, [R1]
MOV.W           R1, R4,ROR#19
MOV.W           R3, R0,ROR#18
EOR.W           R1, R1, R4,ROR#17
ADD             R2, R5
EOR.W           R3, R3, R0,ROR#7
EOR.W           R1, R1, R4,LSR#10
EOR.W           R3, R3, R0,LSR#3
ADD             R2, R1
ADD             R3, R2
STR             R3, [R6,#0x3C]
ADD             R3, SP, #0x144+w+0xC0
CMP             R3, R6
BNE             loc_1B50C
LDR             R3, [SP,#0x144+var_12C]
ADD             R2, SP, #0x144+var_128
LDR             R0, [SP,#0x144+var_134]

loc_1B544
LDR.W           R1, [R3,#4]!
CMP             R0, R3
STR.W           R1, [R2,#4]!
BNE             loc_1B544
ADD             R7, SP, #0x144+wv
LDR             R3, [SP,#0x144+wv+0x1C]
MOV.W           LR, #0
LDR             R6, [SP,#0x144+wv+0x10]
LDR.W           R10, [SP,#0x144+wv+0x14]
LDR.W           R9, [SP,#0x144+wv+0x18]
LDM.W           R7, {R7,R8,R12}
LDR.W           R11, [SP,#0x144+wv+0xC]
B               loc_1B578

loc_1B56C
j = R14                 ; int
MOV             R12, R8
MOV             R9, R10
MOV             R8, R7
MOV             R10, R6
MOV             R7, R4
MOV             R6, R5

loc_1B578
MOV.W           R0, R6,ROR#11
AND.W           R4, R6, R10
BIC.W           R2, R9, R6
MOV.W           R1, R7,ROR#13
EOR.W           R0, R0, R6,ROR#6
EORS            R2, R4
ADD             R4, SP, #0x144+w
EOR.W           R1, R1, R7,ROR#2
EOR.W           R0, R0, R6,ROR#25
LDR.W           R5, [R4,LR,LSL#2]
EOR.W           R1, R1, R7,ROR#22
ADD             R2, R0
LDR             R0, [SP,#0x144+var_144]
ADD             R2, R5
LDR.W           R4, [R0,LR,LSL#2]
EOR.W           R0, R12, R8
ADD.W           LR, LR, #1
ANDS            R0, R7
CMP.W           LR, #0x40 ; '@'
ADD             R2, R4
AND.W           R4, R8, R12
EOR.W           R0, R0, R4
ADD             R3, R2
t1 = R3                 ; uint32_t
j = R14                 ; int
ADD             R1, R0
ADD.W           R5, t1, R11
ADD.W           R4, R1, t1
MOV             R11, R12
MOV             t1, R9
BNE             loc_1B56C
STR.W           R9, [SP,#0x144+wv+0x1C]
ADD.W           R9, SP, #0x144+wv
LDR.W           LR, [SP,#0x144+var_128]
STR.W           R10, [SP,#0x144+wv+0x18]
STR             R6, [SP,#0x144+wv+0x14]
STR             R5, [SP,#0x144+wv+0x10]
STR.W           R12, [SP,#0x144+wv+0xC]
STR.W           R8, [SP,#0x144+wv+8]
STR             R7, [SP,#0x144+wv+4]
STR             R4, [SP,#0x144+wv]
LDR             R2, [SP,#0x144+var_130]
B               loc_1B5FC

loc_1B5F8
LDR.W           R4, [R9,#4]!

loc_1B5FC
LDR.W           R3, [LR]
ADD             R3, R4
STR.W           R3, [LR],#4
CMP             LR, R2
BNE             loc_1B5F8
LDR             R3, [SP,#0x144+i]
LDR             R2, [SP,#0x144+block_nb]
ADDS            R3, #1
CMP             R3, R2
STR             R3, [SP,#0x144+i]
i_0 = R3                ; int
BNE.W           loc_1B4DA

loc_1B618
ADD             SP, SP, #0x144
POP.W           {R4-R11,PC}
; End of function sha256_transf

ALIGN 0x10



; void __fastcall sha256_init(sha256_ctx *ctx)
EXPORT sha256_init
sha256_init
ctx = R0                ; sha256_ctx *
LDR             R2, =(sha256_k+0xFC)
ADD.W           R3, ctx, #0x84
PUSH            {R4}
ADD.W           R4, ctx, #0xA4

loc_1B62C
LDR.W           R1, [R2,#4]!
STR.W           R1, [R3,#4]!
CMP             R3, R4
BNE             loc_1B62C
MOVS            R3, #0
POP.W           {R4}
STR             R3, [ctx,#4]
STR             R3, [ctx]
BX              LR
; End of function sha256_init

off_1B644 DCD sha256_k+0xFC



; void __fastcall sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len)
EXPORT sha256_update
sha256_update
ctx = R0                ; sha256_ctx *
message = R1            ; const unsigned __int8 *
len = R2                ; unsigned int
shifted_message = R5    ; const unsigned __int8 *
PUSH.W          {R4-R8,LR}
MOV             R4, ctx
LDR             ctx, [ctx,#4]
ctx = R4                ; sha256_ctx *
MOV             R6, len
MOV             R7, message
RSB.W           shifted_message, R0, #0x40 ; '@'
ADDS            R0, #8
CMP             shifted_message, len
ADD             R0, ctx ; dest
IT CS
MOVCS           shifted_message, len
MOV             len, shifted_message ; n
len = R6                ; unsigned int
BLX             memcpy
LDR             R3, [ctx,#4]
ADD             R3, len
CMP             R3, #0x3F ; '?'
BHI             loc_1B676
STR             R3, [ctx,#4]
POP.W           {ctx-R8,PC}

loc_1B676
SUBS            len, len, shifted_message
new_len = R6            ; unsigned int
ADD.W           R8, ctx, #8
ADD             shifted_message, message
LSRS            message, new_len, #6
block_nb = R7           ; unsigned int
MOV             R1, R8  ; message
MOVS            R2, #1  ; block_nb
MOV             R0, ctx ; ctx
BL              sha256_transf
AND.W           new_len, new_len, #0x3F ; '?'
MOV             R2, block_nb ; block_nb
MOV             R1, shifted_message ; message
MOV             R0, ctx ; ctx
BL              sha256_transf
rem_len = R6            ; unsigned int
ADD.W           R1, shifted_message, block_nb,LSL#6 ; src
MOV             R0, R8  ; dest
MOV             R2, rem_len ; n
BLX             memcpy
LDR             R3, [ctx]
ADDS            block_nb, #1
STR             rem_len, [ctx,#4]
ADD.W           R7, R3, R7,LSL#6
STR             R7, [ctx]
POP.W           {ctx-R8,PC}
; End of function sha256_update




; void __fastcall sha256_final(sha256_ctx *ctx, unsigned __int8 *digest)
EXPORT sha256_final
sha256_final

var_8= -8

ctx = R0                ; sha256_ctx *
digest = R1             ; unsigned __int8 *
block_nb = R11          ; unsigned int
LDR             R3, [ctx,#4]
PUSH.W          {R4-block_nb,LR}
MOV             R6, ctx
LDR.W           R7, [R6],#8
MOV             R4, ctx
AND.W           R2, R3, #0x3F ; '?'
SUB             SP, SP, #0xC
CMP             R2, #0x38 ; '8'
MOV             R5, digest
ITE CC
MOVCC           R2, #0x40 ; '@'
MOVCS           R2, #0x80
ADD             R7, R3
SUB.W           R2, R2, R3 ; n
ADD.W           ctx, R6, R3 ; s
ctx = R4                ; sha256_ctx *
MOV.W           digest, #0 ; c
digest = R5             ; unsigned __int8 *
ITETE CC
MOVCC           R3, #0x3C ; '<'
MOVCS           R3, #0x7C ; '|'
MOVCC.W         R8, #0x3D ; '='
MOVCS.W         R8, #0x7D ; '}'
ITETE CC
MOVCC.W         R9, #0x3E ; '>'
MOVCS.W         R9, #0x7E ; '~'
MOVCC.W         R10, #0x3F ; '?'
MOVCS.W         R10, #0x7F
ITE CC
MOVCC.W         block_nb, #1
MOVCS.W         block_nb, #2
STR             R3, [SP,#0xC+var_8]
LSLS            R7, R7, #3
len_b = R7              ; unsigned int
BLX             memset
LDR             R1, [ctx,#4]
MOVS            R0, #0x80
LSRS            R3, len_b, #0x18
MOV.W           R12, len_b,LSR#8
MOV.W           LR, len_b,LSR#16
ADD             R1, ctx
STRB            R0, [R1,#8]
MOV             R2, block_nb ; block_nb
STRB.W          len_b, [R6,R10]
MOV             R0, ctx ; ctx
LDR             len_b, [SP,#0xC+var_8]
MOV             R1, R6  ; message
STRB.W          R12, [R6,R9]
ADDS            ctx, #0x88
ctx = R0                ; sha256_ctx *
STRB.W          LR, [R6,R8]
STRB            R3, [R6,R7]
BL              sha256_transf
MOVS            R3, #0

loc_1B742
i = R3                  ; int
LDR             R1, [R4]
ADD.W           R2, digest, i,LSL#2
MOV             R0, R4
STRB            R1, [R2,#3]
LDR             R1, [R4]
LSRS            R1, R1, #8
STRB            R1, [R2,#2]
LDR.W           R1, [R4],#4
LSRS            R1, R1, #0x10
STRB            R1, [R2,#1]
LDRB            R2, [R0,#3]
STRB.W          R2, [digest,i,LSL#2]
ADDS            i, #1
CMP             i, #8
BNE             loc_1B742
ADD             SP, SP, #0xC
POP.W           {R4-block_nb,PC}
; End of function sha256_final




; void __fastcall sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest)
EXPORT sha256
sha256

ctx= -0xA8
var_s0=  0

message = R0            ; const unsigned __int8 *
len = R1                ; unsigned int
digest = R2             ; unsigned __int8 *
LDR             R3, =(sha256_k+0xFC)
PUSH            {R4-R6,LR}
SUB             SP, SP, #0xA8
MOV             R6, digest
ADD             digest, SP, #0xA8+ctx.block+0x7C
digest = R6             ; unsigned __int8 *
ADD.W           R5, R3, #0x20 ; ' '

loc_1B77A
LDR.W           R4, [R3,#4]!
CMP             R3, R5
STR.W           R4, [R2,#4]!
BNE             loc_1B77A
MOVS            R3, #0
ADD             R4, SP, #0xA8+var_s0
STR.W           R3, [R4,#-0xA8]!
MOV             R2, len ; len
MOV             len, message ; message
len = R2                ; unsigned int
MOV             message, R4 ; ctx
message = R1            ; const unsigned __int8 *
STR             R3, [SP,#0xA8+ctx.len]
BL              sha256_update
MOV             R1, digest ; digest
MOV             R0, R4  ; ctx
BL              sha256_final
ADD             SP, SP, #0xA8
POP             {R4-digest,PC}
; End of function sha256

ALIGN 4
off_1B7A8 DCD sha256_k+0xFC


; Attributes: noreturn

; void *__fastcall __noreturn BHB91601_show_status_func(void *arg)
EXPORT BHB91601_show_status_func
BHB91601_show_status_func

var_28= -0x28
var_24= -0x24
var_20= -0x20
var_1C= -0x1C
var_18= -0x18
var_14= -0x14
var_10= -0x10
var_C= -0xC
var_8= -8

arg = R0                ; void *
which_chain = R8        ; unsigned __int8
MOVW            R2, #:lower16:gIsReadTemp
PUSH.W          {R4-R11,LR}
MOV             R4, R2
MOVW            R2, #:lower16:gIsOpenCoreEnd
MOV             R5, R2
SUB             SP, SP, #0x2C
MOV             LR, R4
MOVT            R5, #:upper16:gIsOpenCoreEnd
MOVW            R4, #:lower16:gReadingTemp
STR             R5, [SP,#0x2C+var_20]
MOV             R5, R4
MOVW            R4, #:lower16:Sensor2_temp
MOVT            R5, #:upper16:gReadingTemp
LDRB.W          which_chain, [arg]
STR             R5, [SP,#0x2C+var_14]
MOV             R5, R4
MOVT            R5, #:upper16:Sensor2_temp
MOVW            R4, #:lower16:Sensor1_temp
STR             R5, [SP,#0x2C+var_18]
MOV             R5, R4
MOVW            R4, #:lower16:Sensor4_temp
MOV             R3, arg
chain_info = R0         ; chain_info *
MOVT            R4, #:upper16:Sensor4_temp
MOVW            R1, #:lower16:__FUNCTION__.8285 ; "BHB91601_show_status_func"
STR             R4, [SP,#0x2C+var_8]
MOVW            chain_info, #:lower16:aSWhichChainDWh_0 ; "\n--- %s: which_chain = %d, which_i2c ="...
chain_info = R3         ; chain_info *
MOVW            R4, #:lower16:Sensor3_temp
LDRB            chain_info, [chain_info,#1]
which_i2c = R3          ; unsigned __int8
MOVT            LR, #:upper16:gIsReadTemp
MOVT            R5, #:upper16:Sensor1_temp
MOVT            R4, #:upper16:Sensor3_temp
MOV             R2, which_chain
MOVT            R1, #:upper16:__FUNCTION__.8285 ; "BHB91601_show_status_func"
MOVT            R0, #:upper16:aSWhichChainDWh_0 ; "\n--- %s: which_chain = %d, which_i2c ="...
STR             R5, [SP,#0x2C+var_24]
MOVW            R6, #:lower16:Conf
STR             R4, [SP,#0x2C+var_C]
MOVW            R4, #:lower16:time_counter
LDR             R7, =(lcd_output+0x20)
MOVW            R9, #:lower16:gValid_Nonce_Num
STR.W           LR, [SP,#0x2C+var_28]
MOVW            R11, #:lower16:lcd_fd
BLX             printf
MOVW            R3, #0xCCCD
MOVW            R10, #:lower16:gStartTest
MOVT            R3, #0xCCCC
MOVT            R4, #:upper16:time_counter
STR             R3, [SP,#0x2C+var_1C]
MOVS            R3, #0
MOVT            R6, #:upper16:Conf
MOVT            R9, #:upper16:gValid_Nonce_Num
MOVT            R11, #:upper16:lcd_fd
MOVT            R10, #:upper16:gStartTest
SUB.W           R5, R7, #0x20 ; ' '
STR             R3, [R4]
B               loc_1B8A4

loc_1B862
MOV             LR, #aTempSettingErr ; "temp setting err!"
LDM.W           LR!, {R0-R3} ; "temp setting err!"
LDRH.W          LR, [LR] ; "!"
STR             R0, [R7]
STR             R1, [R7,#(lcd_output+0x24 - 0x309AC)]
STRH.W          LR, [R7,#(lcd_output+0x30 - 0x309AC)]
STR             R2, [R7,#(lcd_output+0x28 - 0x309AC)]
STR             R3, [R7,#(lcd_output+0x2C - 0x309AC)]

loc_1B87E
LDR             R3, [R4]
MOVS            R2, #0x40 ; '@' ; n
MOV             R1, R5  ; buf
LDR.W           R0, [R11] ; fd
ADDS            R3, #1
STR             R3, [R4]
BLX             write
LDRB.W          R3, [R10]
CMP             R3, #0
BNE             loc_1B952

loc_1B898               ; useconds
MOV             R0, #(gAsic_Core_Nonce_Num+0xC33FC)
BLX             usleep

loc_1B8A4               ; n
MOVS            R2, #0x40 ; '@'
MOVS            R1, #0x20 ; ' ' ; c
MOV             R0, R5  ; s
BLX             memset
LDR             R3, =(cgpu.subid+0x7FD54)
LDRB.W          R0, [R3,#(cgpu.fan_speed - 0x330FC4)] ; level
BL              fan_control
LDR             R3, [SP,#0x2C+var_28]
LDR             R2, [R4]
LDRB            R3, [R3]
CBZ             R3, loc_1B8D8
LDR             R3, [SP,#0x2C+var_20]
LDRB            R3, [R3]
CBZ             R3, loc_1B8D8
LDR             R3, [SP,#0x2C+var_1C]
UMULL           R0, R1, R2, R3
LSRS            R3, R1, #3
ADD.W           R3, R3, R3,LSL#2
SUBS.W          R3, R2, R3,LSL#1
BEQ             loc_1B98A

loc_1B8D8
MOVW            R1, #:lower16:aTimeDs ; "   time %ds"
MOV             R0, R5  ; s
MOVT            R1, #:upper16:aTimeDs ; "   time %ds"
BLX             sprintf
MOVW            R1, #:lower16:aNonceD ; "   nonce=%d"
LDR.W           R2, [R9,which_chain,LSL#2]
MOVT            R1, #:upper16:aNonceD ; "   nonce=%d"
LDR             R0, =(lcd_output+0x10) ; s
BLX             sprintf
LDR.W           R3, [R6,#configuration.TempSensor1]
CMP             R3, #0
BEQ             loc_1B862
LDR.W           R3, [R6,#configuration.TempSensor2]
CBZ             R3, loc_1B93E
LDR.W           R3, [R6,#configuration.TempSensor3]
CBZ             R3, loc_1B964
LDR.W           R3, [R6,#configuration.TempSensor4]
MOVW            R1, #:lower16:aT1DT2D ; " T1:%d   T2:%d"
CMP             R3, #0
BNE             loc_1B9B0
LDR             R3, [SP,#0x2C+var_18]
MOVT            R1, #:upper16:aT1DT2D ; " T1:%d   T2:%d"
LDR             R2, [SP,#0x2C+var_24]
LDR             R0, =(lcd_output+0x20) ; s
LDR             R3, [R3]
LDR             R2, [R2]
BLX             sprintf
LDR             R3, [SP,#0x2C+var_C]
MOV             R1, #aT3D ; " T3:%d"
LDR             R0, =(lcd_output+0x30) ; s
LDR             R2, [R3]
BLX             sprintf
B               loc_1B87E

loc_1B93E
LDR             R3, [SP,#0x2C+var_24]
MOV             R1, #aT1DC ; "   T1 %d `C"
LDR             R0, =(lcd_output+0x20) ; s
LDR             R2, [R3]
BLX             sprintf
B               loc_1B87E

loc_1B952
MOVW            R0, #:lower16:aGvalidNonceNum ; "\ngValid_Nonce_Num = %d\n"
LDR.W           R1, [R9,which_chain,LSL#2]
MOVT            R0, #:upper16:aGvalidNonceNum ; "\ngValid_Nonce_Num = %d\n"
BLX             printf
B               loc_1B898

loc_1B964
LDR             R3, [SP,#0x2C+var_24]
MOV             R1, #aT1DC ; "   T1 %d `C"
LDR             R0, =(lcd_output+0x20) ; s
LDR             R2, [R3]
BLX             sprintf
LDR             R3, [SP,#0x2C+var_18]
MOV             R1, #aT2DC ; "   T2 %d `C"
LDR             R0, =(lcd_output+0x30) ; s
LDR             R2, [R3]
BLX             sprintf
B               loc_1B87E

loc_1B98A
LDR.W           R0, [R6,#configuration.timeout]
MOVS            R2, #1
STR             R3, [SP,#0x2C+var_10]
LDR             R3, [SP,#0x2C+var_14]
RSB.W           R0, R0, R0,LSL#4 ; useconds
STRB            R2, [R3]
BLX             usleep
MOV             R0, which_chain ; which_chain
BL              BM1391_read_asic_temperature_local
LDR             R3, [SP,#0x2C+var_14]
LDR             R2, [R4]
MOV             R1, R3
LDR             R3, [SP,#0x2C+var_10]
STRB            R3, [R1]
B               loc_1B8D8

loc_1B9B0
LDR             R3, [SP,#0x2C+var_18]
MOVT            R1, #:upper16:aT1DT2D ; " T1:%d   T2:%d"
LDR             R2, [SP,#0x2C+var_24]
LDR             R0, =(lcd_output+0x20) ; s
LDR             R3, [R3]
LDR             R2, [R2]
BLX             sprintf
LDR             R3, [SP,#0x2C+var_8]
MOVW            R1, #:lower16:aT3DT4D ; " T3:%d   T4:%d"
LDR             R2, [SP,#0x2C+var_C]
MOVT            R1, #:upper16:aT3DT4D ; " T3:%d   T4:%d"
LDR             R0, =(lcd_output+0x30) ; s
LDR             R3, [R3]
LDR             R2, [R2]
BLX             sprintf
B               loc_1B87E
; End of function BHB91601_show_status_func

ALIGN 4
off_1B9DC DCD lcd_output+0x20
off_1B9E0 DCD cgpu.subid+0x7FD54
off_1B9E4 DCD lcd_output+0x10
off_1B9E8 DCD lcd_output+0x30



; void *__fastcall BHB91601_send_func(void *arg)
EXPORT BHB91601_send_func
BHB91601_send_func

var_A4= -0xA4
var_9C= -0x9C
var_98= -0x98
mutex= -0x94
which_core= -0x90
works= -0x8C
var_88= -0x88
var_84= -0x84
var_80= -0x80
var_7C= -0x7C
which_asic= -0x78
var_74= -0x74
var_70= -0x70
work_vil_1391= -0x6C
buf_vil= -0x38
var_4= -4

arg = R0                ; void *
work = R5               ; work *
MOV             R3, arg
chain_info = R0         ; chain_info *
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0xA4
LDRB.W          R9, [chain_info]
which_chain = R9        ; unsigned __int8
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
LDRB            work, [R3,#1]
ADD             chain_info, SP, #0xA4+buf_vil ; s
chain_info = R3         ; chain_info *
BLX             memset
MOVW            R4, #:lower16:gBegin_Get_Nonce
MOVW            R0, #:lower16:aSWhichChainDWh_0 ; "\n--- %s: which_chain = %d, which_i2c ="...
MOV             R3, work
MOV             R2, which_chain
LDR             R1, =__FUNCTION__.8330 ; "BHB91601_send_func"
MOVT            R0, #:upper16:aSWhichChainDWh_0 ; "\n--- %s: which_chain = %d, which_i2c ="...
MOVT            R4, #:upper16:gBegin_Get_Nonce
BLX             printf
LDRB            R3, [R4]
CBNZ            R3, loc_1BA36
MOVS            R0, #7  ; address
BL              read_axi_fpga
ORR.W           R1, R0, #0x10000 ; data
MOVS            R0, #7  ; address
BL              write_axi_fpga
MOVS            R3, #1
STRB            R3, [R4]

loc_1BA36
MOV             R3, #BHB91601_ASIC_NUMBER
STR             R3, [SP,#0xA4+var_70]
LDR             R3, [R3]
CMP             R3, #0
BEQ.W           loc_1BC90
ADD.W           R1, which_chain, which_chain,LSL#4
ORR.W           R0, which_chain, #0x80
MOVW            R3, #:lower16:Conf
STR             R0, [SP,#0xA4+var_88]
LSLS            R1, R1, #9
MOVT            R3, #:upper16:Conf
STR             R3, [SP,#0xA4+var_9C]
ADD.W           R2, which_chain, which_chain,LSL#1
MOV             R4, R1
STR             R1, [SP,#0xA4+var_80]
MOVW            R1, #:lower16:gWorks_For_Hw_Check
LDR             work, [R3,#configuration.pattern_number]
MOV             R6, R1
LSLS            R1, R0, #0x10
LDR             R0, =(cgpu.workdataFilePrefix+0x3C)
MOV             R3, #HW_check_mutex
MOVW            R7, #:lower16:gSend_Work_Num
ADD.W           R3, R3, R2,LSL#3
MOVW            R8, #:lower16:gReadingTemp
STR             R0, [SP,#0xA4+var_74]
MOV             R0, R6
MOVT            R0, #:upper16:gWorks_For_Hw_Check
STR             R3, [SP,#0xA4+mutex]
ADDS            R4, R0, R4
ORR.W           R3, R1, #0x1000000
MOVT            R7, #:upper16:gSend_Work_Num
STR             R3, [SP,#0xA4+var_84]
MOVT            R8, #:upper16:gReadingTemp
MOVS            R3, #0
STR             R0, [SP,#0xA4+var_7C]
STR             R3, [SP,#0xA4+which_asic]
STR.W           R8, [SP,#0xA4+var_98]

loc_1BAAA
LDR             R3, [SP,#0xA4+var_74]
MOV             R2, R3
LDR.W           R3, [R2,#4]!
STR             R3, [SP,#0xA4+works]
MOVS            R3, #0
STR             R2, [SP,#0xA4+var_74]
STR             R3, [SP,#0xA4+which_core]

loc_1BABA
MOVS            R6, #0
MOVW            R8, #:lower16:gChain
CMP             R6, work
MOVT            R8, #:upper16:gChain
which_pattern = R6      ; unsigned int
BCS.W           loc_1BC1A

loc_1BACA
LDR             R3, [SP,#0xA4+var_98]
LDRB            R3, [R3]
CMP             R3, #0
BNE.W           loc_1BC86

loc_1BAD4               ; address
MOVS            R0, #3
MOV.W           R10, #1
BL              read_axi_fpga
work_fifo_ready = R0    ; unsigned int
LDRB.W          R3, [R8]
LSL.W           R3, R10, R3
TST             R3, work_fifo_ready
BEQ.W           loc_1BC7C
LDR             R3, [SP,#0xA4+which_core]
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             work_fifo_ready, SP, #0xA4+buf_vil ; s
MLA             work, work, R3, which_pattern
LDR             R3, [SP,#0xA4+works]
ADD.W           work, work, work,LSL#4
ADD.W           work, R3, work,LSL#2
BLX             memset
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             R0, SP, #0xA4+work_vil_1391 ; s
BLX             memset
LDRB.W          R0, [SP,#0xA4+var_88]
ADDS            R3, work, #7
ADD.W           R2, work, #0x13
ADD.W           R1, SP, #0xA4+work_vil_1391.work_count+3
STRB.W          R10, [SP,#0xA4+work_vil_1391]
STRB.W          R0, [SP,#0xA4+work_vil_1391.chain_id]
STR             which_pattern, [SP,#0xA4+work_vil_1391.work_count]

loc_1BB28
LDRB.W          R0, [R3,#1]!
CMP             R2, R3
STRB.W          R0, [R1,#1]!
BNE             loc_1BB28
ADD.W           R3, SP, #0xA4+work_vil_1391.data+0xB
ADD.W           R0, SP, #0xA4+work_vil_1391.midstate+0x1F

loc_1BB3C
LDRB.W          R1, [R2,#1]!
STRB.W          R1, [R3,#1]!
CMP             R3, R0
BNE             loc_1BB3C
ADD             R3, SP, #0xA4+work_vil_1391
LDR             R2, [SP,#0xA4+var_84]
ADD.W           R11, SP, #0xA4+work_vil_1391.data+4
MOV             R12, R3
ADD.W           R10, SP, #0xA4+var_4
STR             R2, [SP,#0xA4+buf_vil]
STR.W           which_pattern, [R10,#-0x30]!

loc_1BB5C
LDRB.W          R1, [R12,#9]
ADD.W           R12, R12, #4
LDRB.W          LR, [R12,#4]
LDRB.W          R2, [R12,#7]
LDRB.W          R0, [R12,#6]
CMP             R12, R11
MOV.W           R1, R1,LSL#16
ORR.W           R1, R1, LR,LSL#24
ORR.W           R2, R2, R1
ORR.W           R2, R2, R0,LSL#8
STR.W           R2, [R10,#4]!
BNE             loc_1BB5C
ADD.W           R12, SP, #0xA4+buf_vil+0x10
ADD.W           R10, SP, #0xA4+work_vil_1391.midstate+0xC

loc_1BB90
LDRB            R1, [R3,#0x15]
ADDS            R3, #4
LDRB.W          LR, [R3,#0x10]
LDRB            R2, [R3,#0x13]
LDRB            R0, [R3,#0x12]
CMP             R3, R10
MOV.W           R1, R1,LSL#16
ORR.W           R1, R1, LR,LSL#24
ORR.W           R2, R2, R1
ORR.W           R2, R2, R0,LSL#8
STR.W           R2, [R12,#4]!
BNE             loc_1BB90
ADD             R0, SP, #0xA4+buf_vil ; value
BL              set_TW_write_command
LDR             R0, [SP,#0xA4+mutex] ; mutex
BLX             pthread_mutex_lock
LDR             R3, [SP,#0xA4+var_80]
ADD.W           R0, R3, #0x2180
LDR             R3, [SP,#0xA4+var_7C]
ADDS            R0, #0x3C ; '<'
ADD             R0, R3  ; dest

loc_1BBCC
SUB.W           R10, R0, #0x44 ; 'D'
MOVS            R2, #0x44 ; 'D' ; n
MOV             R1, R10 ; src
BLX             memcpy
CMP             R4, R10
MOV             R0, R10
BNE             loc_1BBCC
MOVW            R2, #:lower16:gWork_Num_For_Hw_Check
MOV             R1, work ; src
MOVT            R2, #:upper16:gWork_Num_For_Hw_Check
MOV             R0, R4  ; dest
LDRB            R3, [R2]
ADDS            which_pattern, #1
ADDS            R3, #1
UXTB            R3, R3
CMP             R3, #0x7E ; '~'
IT HI
MOVHI           R3, #0x7F
STRB            R3, [R2]
MOVS            R2, #0x44 ; 'D' ; n
BLX             memcpy
LDR             R0, [SP,#0xA4+mutex] ; mutex
BLX             pthread_mutex_unlock
which_pattern = R6      ; unsigned int
LDR.W           R3, [R7,which_chain,LSL#2]
ADDS            R3, #1
STR.W           R3, [R7,which_chain,LSL#2]

loc_1BC10
LDR             R3, [SP,#0xA4+var_9C]
LDR             work, [R3,#configuration.pattern_number]
CMP             which_pattern, work
BCC.W           loc_1BACA

loc_1BC1A
LDR             R3, [SP,#0xA4+which_core]
ADDS            R3, #1
CMP.W           R3, #0x100
STR             R3, [SP,#0xA4+which_core]
which_core_0 = R3       ; unsigned int
BNE.W           loc_1BABA
LDR             which_core_0, [SP,#0xA4+var_70]
LDR             R2, [R3]
LDR             R3, [SP,#0xA4+which_asic]
ADDS            R3, #1
CMP             R2, R3
STR             R3, [SP,#0xA4+which_asic]
which_asic_0 = R3       ; unsigned int
BHI.W           loc_1BAAA
MUL             R2, work, R2
LDR.W           which_asic_0, [R7,which_chain,LSL#2]
LDR.W           R8, [SP,#0xA4+var_98]
LSLS            R2, R2, #8
CMP             R2, R3
BLS             loc_1BCA4
LDR             work, =__FUNCTION__.8330 ; "BHB91601_send_func"
MOVW            R4, #:lower16:aSChainDSendWor ; "\n\n---%s: Chain%d send work num : %d, "...
LDR             which_pattern, [SP,#0xA4+var_70]
MOVT            R4, #:upper16:aSChainDSendWor ; "\n\n---%s: Chain%d send work num : %d, "...
LDR.W           R10, [SP,#0xA4+var_9C]

loc_1BC5A
STR             R2, [SP,#0xA4+var_A4]
MOV             R1, work
MOV             R2, which_chain
MOV             R0, R4  ; format
BLX             printf
LDR.W           R1, [R10,#configuration.pattern_number]
LDR             R2, [R6]
LDR.W           R3, [R7,which_chain,LSL#2]
MUL             R2, R2, R1
LSLS            R2, R2, #8
CMP             R3, R2
BCC             loc_1BC5A
B               loc_1BCA4

loc_1BC7C               ; useconds
which_pattern = R6      ; unsigned int
work_fifo_ready = R0    ; unsigned int
MOV.W           work_fifo_ready, #0x3E8
BLX             usleep
B               loc_1BC10

loc_1BC86               ; useconds
MOVW            R0, #0x2710
BLX             usleep
B               loc_1BAD4

loc_1BC90
MOVW            R3, #:lower16:gSend_Work_Num
MOVW            R8, #:lower16:gReadingTemp
MOVT            R3, #:upper16:gSend_Work_Num
MOVT            R8, #:upper16:gReadingTemp
LDR.W           R3, [R3,which_chain,LSL#2]

loc_1BCA4
MOVW            R0, #:lower16:aSChainDSendWor_0 ; "\n\n---%s: Chain%d send work num : %d\n"
MOV             R2, which_chain
LDR             R1, =__FUNCTION__.8330 ; "BHB91601_send_func"
MOVT            R0, #:upper16:aSChainDSendWor_0 ; "\n\n---%s: Chain%d send work num : %d\n"
BLX             printf
MOVW            R0, #:lower16:aSendTestPatter ; "\nsend test pattern done"
MOVW            R4, #:lower16:gValid_Nonce_Num
MOVT            R0, #:upper16:aSendTestPatter ; "\nsend test pattern done"
MOVT            R4, #:upper16:gValid_Nonce_Num
BLX             puts
MOVW            R0, #:lower16:aDate ; "date"
MOVW            R10, #:lower16:(gAsic_Core_Nonce_Num+0xC33FC)
MOVT            R0, #:upper16:aDate ; "date"
MOVT            R10, #:upper16:(gAsic_Core_Nonce_Num+0xC33FC)
BLX             system
MOVS            R0, #0xA ; c
MOVS            work, #0
BLX             putchar
LDR.W           R7, [R4,which_chain,LSL#2]
received_data = R7      ; unsigned int
MOV             R6, received_data

loc_1BCEA
CMP             R7, R6
ADD.W           work, work, #1
count = R5              ; unsigned int
MOV             R0, R10 ; useconds
BNE             loc_1BD12
CMP             count, #2
BHI             loc_1BD02
BLX             usleep

loc_1BCFC
work = R5               ; work *
LDR.W           R6, [R4,which_chain,LSL#2]
B               loc_1BCEA

loc_1BD02
count = R5              ; unsigned int
LDRB.W          R3, [R8]
CBZ             R3, loc_1BD1C
MOVW            R0, #0x2710 ; useconds
BLX             usleep
B               loc_1BD02

loc_1BD12
BLX             usleep
MOV             R7, R6
MOVS            count, #0
work = R5               ; work *
B               loc_1BCFC

loc_1BD1C
count = R5              ; unsigned int
MOVW            R3, #:lower16:start_receive
MOVW            R0, #:lower16:aToStopReceive ; "to stop receive"
MOVT            R3, #:upper16:start_receive
MOVS            R4, #0
MOVT            R0, #:upper16:aToStopReceive ; "to stop receive"
STRB            R4, [R3]
BLX             puts
MOV             R0, R4
ADD             SP, SP, #0xA4
POP.W           {R4-R11,PC}
; End of function BHB91601_send_func

off_1BD3C DCD __FUNCTION__.8330 ; "BHB91601_send_func"
off_1BD40 DCD cgpu.workdataFilePrefix+0x3C



; void reset_BHB91601_global_arg()
EXPORT reset_BHB91601_global_arg
reset_BHB91601_global_arg

var_10= -0x10
var_C= -0xC
var_8= -8

MOVW            R3, #:lower16:gBM1391_MISC_CONTROL_reg
PUSH.W          {R4-R11,LR}
MOVW            R2, #0x3A01
SUB             SP, SP, #0x14
MOVT            R3, #:upper16:gBM1391_MISC_CONTROL_reg
MOVW            R9, #:lower16:gRepeated_Nonce_Id
STR             R2, [R3]
MOVW            R8, #:lower16:gValid_Nonce_Num
BL              reset_global_arg
MOVW            R3, #:lower16:Conf
MOVW            R2, #:lower16:BHB91601_ASIC_NUMBER
MOVT            R3, #:upper16:Conf
MOVT            R2, #:upper16:BHB91601_ASIC_NUMBER
LDR             R5, [R3,#configuration.pattern_number]
MOVW            R3, #:lower16:cgpu
LDR             R2, [R2]
MOVT            R3, #:upper16:cgpu
LDR             R1, =0x3312CF
MOVW            R12, #:lower16:gSend_Work_Num
LDR.W           R10, =(gAsic_Core_Nonce_Num+0x3FC)
MOVW            R7, #:lower16:gSensor_OK
ADD.W           R6, R5, R5,LSL#4
STR             R2, [SP,#0x14+var_C]
ADD.W           R2, R2, #0x20000
STR             R1, [SP,#0x14+var_10]
ADDS            R2, #0x2A ; '*'
MOV.W           LR, #0
LSLS            R6, R6, #2
ADD.W           R3, R3, R2,LSL#2
MOVT            R9, #:upper16:gRepeated_Nonce_Id
MOVT            R8, #:upper16:gValid_Nonce_Num
MOVT            R12, #:upper16:gSend_Work_Num
MOVT            R7, #:upper16:gSensor_OK
MOV             R1, LR
STR             R3, [SP,#0x14+var_8]

loc_1BDBA
LDR             R3, [SP,#0x14+var_10]
MOV             R4, R10
STR.W           R1, [R9],#4
STR.W           R1, [R8],#4
STRB.W          R1, [R3,#1]!
STR             R3, [SP,#0x14+var_10]
LDR             R3, [SP,#0x14+var_C]
STR.W           R1, [R12],#4
LDR.W           R11, =(cgpu.workdataFilePrefix+0x3C)
CBZ             R3, loc_1BE02

loc_1BDD8
LDR.W           R3, [R11,#4]!
SUB.W           R0, R4, #0x400
ADD             R3, LR

loc_1BDE2
STR.W           R1, [R0,#4]!
ADDS            R2, R3, R6
CBZ             R5, loc_1BDF2

loc_1BDEA
STR             R1, [R3,#0x34]
ADDS            R3, #0x44 ; 'D'
CMP             R3, R2
BNE             loc_1BDEA

loc_1BDF2
CMP             R0, R4
MOV             R3, R2
BNE             loc_1BDE2
LDR             R3, [SP,#0x14+var_8]
ADD.W           R4, R4, #0x1000
CMP             R11, R3
BNE             loc_1BDD8

loc_1BE02
ADD.W           LR, LR, #4
STRB            R1, [R7]
CMP.W           LR, #0x10
STRB            R1, [R7,#1]
STRB            R1, [R7,#2]
ADD.W           R10, R10, #0x80000
STRB            R1, [R7,#3]
ADD.W           R7, R7, #4
BNE             loc_1BDBA
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}
; End of function reset_BHB91601_global_arg

ALIGN 4
dword_1BE24 DCD 0x3312CF
off_1BE28 DCD gAsic_Core_Nonce_Num+0x3FC
off_1BE2C DCD cgpu.workdataFilePrefix+0x3C



; bool __fastcall BHB91601_AT24C02_write_total_data(unsigned __int8 which_iic, unsigned __int8 which_chain)
EXPORT BHB91601_AT24C02_write_total_data
BHB91601_AT24C02_write_total_data

length= -8

which_iic = R0          ; unsigned __int8
which_chain = R1        ; unsigned __int8
PUSH.W          {R4-R10,LR}
MOV             R6, which_iic
MOVW            which_iic, #:lower16:aS ; "\n--- %s\n"
SUB             SP, SP, #8
MOV             R8, which_chain
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             which_chain, =__FUNCTION__.8155 ; "BHB91601_AT24C02_write_total_data"
MOVW            R4, #:lower16:gAT24C02_data_map
BLX             printf
LDR             R3, =(cgpu.subid+0x7FD54)
MOVT            R4, #:upper16:gAT24C02_data_map
MOVS            R2, #4
MOV             R12, #0x51EB851F
STRB.W          R2, [R4,#(gAT24C02_data_map+0x7A - 0x30C40)]
LDR.W           R3, [R3,#(cgpu.voltage - 0x330FC4)]
MOV             LR, #Conf
MOVS            R0, #0x7E ; '~'
LDR.W           R7, [LR,#configuration.TempSensor1]
MOVS            R5, #0
LDR.W           R1, [LR,#configuration.sensor_model]
ADD.W           R3, R3, R3,LSL#2
STRB            R0, [R4]
STRB.W          R7, [R4,#(gAT24C02_data_map+0x7B - 0x30C40)]
MOV             R0, R4  ; p_data
ADD.W           R2, R3, #0x3E8
LDR.W           R7, [LR,#configuration.HashBoard_Hardware_Version_2]
UMULL           R9, R10, R2, R12
LDR.W           R2, [LR,#configuration.TempSensor2]
LDR.W           R9, [LR,#configuration.HashBoard_Hardware_Version_1]
STRB.W          R1, [R4,#(gAT24C02_data_map+0x79 - 0x30C40)]
MOVS            R1, #0xFE ; w_len
STRB.W          R2, [R4,#(gAT24C02_data_map+0x7D - 0x30C40)]
LDR.W           R2, [LR,#configuration.HashBoard_Bom_Version_1]
MOV.W           R3, R10,LSR#5
LDR.W           R10, [LR,#configuration.TempSensor4]
STRB.W          R7, [R4,#(gAT24C02_data_map+0xFB - 0x30C40)]
STRB            R3, [R4,#(gAT24C02_data_map+1 - 0x30C40)]
LDRB.W          R3, [LR,#configuration.TempSensor3]
STRB.W          R2, [R4,#(gAT24C02_data_map+0xFC - 0x30C40)]
STRB.W          R5, [R4,#(gAT24C02_data_map+0x7C - 0x30C40)]
STRB.W          R3, [R4,#(gAT24C02_data_map+0x7F - 0x30C40)]
LDR.W           R3, [LR,#configuration.HashBoard_Bom_Version_2]
STRB.W          R5, [R4,#(gAT24C02_data_map+0x7E - 0x30C40)]
STRB.W          R10, [R4,#(gAT24C02_data_map+0x81 - 0x30C40)]
STRB.W          R3, [R4,#(gAT24C02_data_map+0xFD - 0x30C40)]
STRB.W          R9, [R4,#(gAT24C02_data_map+0xFA - 0x30C40)]
STRB.W          R5, [R4,#(gAT24C02_data_map+0x80 - 0x30C40)]
STRB.W          R5, [R4,#(gAT24C02_data_map+0x82 - 0x30C40)]
BL              CRC16
MOV             R7, R0
crc = R7                ; uint16_t
MOV.W           R3, #0x100
MOV.W           LR, crc,LSR#8
MOV             R0, R5  ; address
MOV             R1, R4  ; buf
STR             R3, [SP,#8+length] ; length
MOV             R2, R6  ; which_iic
MOV             R3, R8  ; which_chain
STRB.W          LR, [R4,#(gAT24C02_data_map+0xFF - 0x30C40)]
STRB.W          crc, [R4,#(gAT24C02_data_map+0xFE - 0x30C40)]
BL              AT24C02_write_bytes
MOV             R2, R8  ; which_chain
MOV             R1, R6  ; which_iic
MOVS            R0, #0xFF ; address
BL              AT24C02_read_one_byte
data = R0               ; uint8_t
LDRB.W          R3, [R4,#(gAT24C02_data_map+0xFF - 0x30C40)]
CMP             R3, data
BEQ             loc_1BF38
MOVW            R3, #:lower16:gEEPROM_error
MOVW            data, #:lower16:aSSaveDataIntoE ; "!!! %s: save data into EEPROM fail! \n"
MOVT            R3, #:upper16:gEEPROM_error
MOVS            R2, #1
LDR             R1, =__FUNCTION__.8155 ; "BHB91601_AT24C02_write_total_data"
MOVT            R0, #:upper16:aSSaveDataIntoE ; "!!! %s: save data into EEPROM fail! \n"
STRB            R2, [R3]
BLX             printf
MOV             R0, R5
ret = R0                ; bool
ADD             SP, SP, #8
POP.W           {R4-R10,PC}

loc_1BF38
data = R0               ; uint8_t
MOVW            data, #:lower16:aSSaveDataIntoE_0 ; "--- %s: save data into EEPROM success! "...
LDR             R1, =__FUNCTION__.8155 ; "BHB91601_AT24C02_write_total_data"
MOVT            R0, #:upper16:aSSaveDataIntoE_0 ; "--- %s: save data into EEPROM success! "...
BLX             printf
MOVS            R0, #1
ret = R0                ; bool
ADD             SP, SP, #8
POP.W           {R4-R10,PC}
; End of function BHB91601_AT24C02_write_total_data

ALIGN 0x10
off_1BF50 DCD __FUNCTION__.8155 ; "BHB91601_AT24C02_write_total_data"
off_1BF54 DCD cgpu.subid+0x7FD54



; int __fastcall BHB91601_set_voltage(unsigned __int8 which_chain, unsigned __int8 which_i2c)
EXPORT BHB91601_set_voltage
BHB91601_set_voltage
which_chain = R0        ; unsigned __int8
which_i2c = R1          ; unsigned __int8
PUSH            {R3-R5,LR}
BL              Calibration_voltage
ret = R0                ; int
MOV             R4, ret
CBNZ            ret, loc_1BF66

loc_1BF62
ret = R4                ; int
MOV             R0, ret
POP             {R3-R5,PC}

loc_1BF66
ret = R0                ; int
LDR             R5, =cgpu.show_id
LDR.W           ret, [R5],#-8 ; th
ret = R4                ; int
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R5,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
ADDS            R1, ret, #1
BEQ             loc_1BFD8
ADDS            R2, ret, #2
BNE             loc_1C00A
MOVW            R1, #:lower16:aMaximumNValue ; " Maximum N value"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aMaximumNValue ; " Maximum N value"
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aCanNotMatch ; " can not match  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCanNotMatch ; " can not match  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aVoltage ; "    voltage     "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aVoltage ; "    voltage     "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSMaximumNValue ; "\n!!! %s: Maximum N value can't match v"...
LDR             R1, =__FUNCTION__.8161 ; "BHB91601_set_voltage"
MOVT            R0, #:upper16:aSMaximumNValue ; "\n!!! %s: Maximum N value can't match v"...
BLX             printf
MOV             R0, ret
POP             {R3-R5,PC}

loc_1BFD8
MOVW            R1, #:lower16:aCanNotFind ; "  Can not find  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCanNotFind ; "  Can not find  "
MOVS            R0, #1  ; line
BL              write_lcd
MOVW            R1, #:lower16:aMatchVoltage ; "  match voltage "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aMatchVoltage ; "  match voltage "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCanTFindMatch ; "\n!!! %s: Can't find match voltage!\n"
LDR             R1, =__FUNCTION__.8161 ; "BHB91601_set_voltage"
MOVT            R0, #:upper16:aSCanTFindMatch ; "\n!!! %s: Can't find match voltage!\n"
BLX             printf
MOV             R0, ret
POP             {R3-R5,PC}

loc_1C00A
ADDS            R3, ret, #3
BNE             loc_1BF62
MOVW            R1, #:lower16:aMinimumNValue ; " Minimum N value"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aMinimumNValue ; " Minimum N value"
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aCanNotMatch ; " can not match  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCanNotMatch ; " can not match  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aVoltage ; "    voltage     "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aVoltage ; "    voltage     "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSMinimumNValue ; "\n!!! %s: Minimum N value can't match v"...
LDR             R1, =__FUNCTION__.8161 ; "BHB91601_set_voltage"
MOVT            R0, #:upper16:aSMinimumNValue ; "\n!!! %s: Minimum N value can't match v"...
BLX             printf
MOV             R0, ret
POP             {R3-R5,PC}
; End of function BHB91601_set_voltage

off_1C050 DCD cgpu.show_id
off_1C054 DCD __FUNCTION__.8161 ; "BHB91601_set_voltage"



; void BHB91601_calculate_timeout_and_baud()
EXPORT BHB91601_calculate_timeout_and_baud
BHB91601_calculate_timeout_and_baud

var_C= -0xC
var_8= -8

PUSH            {R4-R7,LR}
MOV.W           R0, #0x100 ; actual_core_number
SUB             SP, SP, #0xC
MOVW            R4, #:lower16:Conf
BL              calculate_core_number
MOVW            R3, #:lower16:pattern_test_time
MOV             R6, R0
temp_corenum = R0       ; unsigned int
MOVT            R3, #:upper16:pattern_test_time
LDRB            R2, [R3]
CMP             R2, #8  ; switch 9 cases
BHI             def_1C078 ; jumptable 0001C078 default case
TBB.W           [PC,R2] ; switch jump
jpt_1C078 DCB 0x34      ; jump table for switch statement
DCB 0x38
DCB 0x3C
DCB 0x40
DCB 0x44
DCB 0x48
DCB 0x4C
DCB 0x50
DCB 5
ALIGN 2

loc_1C086               ; jumptable 0001C078 case 8
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq9]

loc_1C08C
temp_corenum = R6       ; unsigned int
temp_freq = R5          ; unsigned int
MOV             R1, temp_corenum
MOV.W           R0, #0x1000000
BL              __aeabi_uidiv
MOVW            R3, #:lower16:gChain_Asic_Interval
MOV             R1, temp_freq
MOVT            R3, #:upper16:gChain_Asic_Interval
LDR             R3, [R3]
MUL             R0, R3, R0
BL              __aeabi_uidiv
LDR             R1, =(cgpu.subid+0x7FD54)
MOVW            R3, #0x851F
STR             temp_freq, [SP,#0xC+var_8]
MOVT            R3, #0x51EB
STR             temp_freq, [R4,#configuration.Freq]
LDRB.W          temp_corenum, [R1,#(cgpu.timeout_percent - 0x330FC4)]
LDR.W           R2, [R4,#configuration.baud]
LDR             R1, =__FUNCTION__.8178 ; "BHB91601_calculate_timeout_and_baud"
MUL             R6, R6, R0
MOV             R0, #aSBaudDTimeout0 ; "\n--- %s: baud = %d, timeout = 0x%08x ="...
UMULL           R6, R7, R6, R3
LSRS            temp_freq, R7, #5
STR             R5, [SP,#0xC+var_C]
MOV             R3, R5
STR.W           R5, [R4,#configuration.timeout]
BLX             printf
ADD             SP, SP, #0xC
POP             {R4-R7,PC}

loc_1C0E4               ; jumptable 0001C078 case 0
temp_corenum = R0       ; unsigned int
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq1]
temp_freq = R5          ; unsigned int
B               loc_1C08C

loc_1C0EC               ; jumptable 0001C078 case 1
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq2]
temp_freq = R5          ; unsigned int
B               loc_1C08C

loc_1C0F4               ; jumptable 0001C078 case 2
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq3]
temp_freq = R5          ; unsigned int
B               loc_1C08C

loc_1C0FC               ; jumptable 0001C078 case 3
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq4]
temp_freq = R5          ; unsigned int
B               loc_1C08C

loc_1C104               ; jumptable 0001C078 case 4
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq5]
temp_freq = R5          ; unsigned int
B               loc_1C08C

loc_1C10C               ; jumptable 0001C078 case 5
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq6]
temp_freq = R5          ; unsigned int
B               loc_1C08C

loc_1C114               ; jumptable 0001C078 case 6
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq7]
temp_freq = R5          ; unsigned int
B               loc_1C08C

loc_1C11C               ; jumptable 0001C078 case 7
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq8]
temp_freq = R5          ; unsigned int
B               loc_1C08C

def_1C078               ; jumptable 0001C078 default case
MOVW            temp_corenum, #:lower16:aSPatternTestTi ; "%s: pattern_test_time = %d, error!!! \n"
temp_corenum = R6       ; unsigned int
LDR             R1, =__FUNCTION__.8178 ; "BHB91601_calculate_timeout_and_baud"
MOVT            R0, #:upper16:aSPatternTestTi ; "%s: pattern_test_time = %d, error!!! \n"
MOVT            R4, #:upper16:Conf
MOVS            R5, #0
BLX             printf
B               loc_1C08C
; End of function BHB91601_calculate_timeout_and_baud

ALIGN 4
off_1C13C DCD cgpu.subid+0x7FD54
off_1C140 DCD __FUNCTION__.8178 ; "BHB91601_calculate_timeout_and_baud"



; void __fastcall BHB91601_set_address(unsigned __int8 which_chain)
EXPORT BHB91601_set_address
BHB91601_set_address
which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R6, which_chain
MOVW            which_chain, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R2, R6
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
MOVW            R8, #:lower16:BHB91601_ASIC_NUMBER
LDR             R1, =__FUNCTION__.8184_0 ; "BHB91601_set_address"
MOVT            R8, #:upper16:BHB91601_ASIC_NUMBER
BLX             printf
MOV             R0, R6  ; which_chain
BL              BM1391_chain_inactive
LDR.W           R3, [R8]
CBZ             R3, locret_1C19C
MOVS            R4, #0
MOVW            R7, #:lower16:gChain_Asic_Interval
MOV             R5, R4
MOVT            R7, #:upper16:gChain_Asic_Interval

loc_1C17A               ; address
chip_addr = R5          ; unsigned __int8
which_asic = R4         ; unsigned __int8
MOV             R1, chip_addr
MOV             R0, R6  ; which_chain
BL              BM1391_set_address
LDR             R3, [R7]
MOVW            R0, #0x1388 ; useconds
ADDS            which_asic, #1
UXTB            R4, R4
ADD             chip_addr, R3
BLX             usleep
LDR.W           R3, [R8]
UXTB            R5, R5
chip_addr = R5          ; unsigned __int8
which_asic = R4         ; unsigned __int8
CMP             which_asic, R3
BCC             loc_1C17A

locret_1C19C
POP.W           {R4-R8,PC}
; End of function BHB91601_set_address

off_1C1A0 DCD __FUNCTION__.8184_0 ; "BHB91601_set_address"



; void __fastcall BHB91601_set_baud(unsigned __int8 which_chain, unsigned __int8 baud)
EXPORT BHB91601_set_baud
BHB91601_set_baud
which_chain = R0        ; unsigned __int8
baud = R1               ; unsigned __int8
PUSH            {R3-R5,LR}
MOV             R5, which_chain
MOVW            which_chain, #:lower16:aSChainDBaudD ; "\n--- %s: Chain : %d, baud = %d\n"
MOV             R3, baud
MOV             R4, baud
MOV             R2, R5
LDR             baud, =__FUNCTION__.8192 ; "BHB91601_set_baud"
MOVT            R0, #:upper16:aSChainDBaudD ; "\n--- %s: Chain : %d, baud = %d\n"
BLX             printf
MOV             R1, R4  ; baud
MOV             R0, R5  ; which_chain
BL              BM1391_set_baud
MOVW            R0, #0xC350 ; useconds
BLX             usleep
MOV             R0, R4  ; asic_baud
POP.W           {R3-R5,LR}
B.W             set_fpga_baud
; End of function BHB91601_set_baud

ALIGN 4
off_1C1D8 DCD __FUNCTION__.8192 ; "BHB91601_set_baud"



; void __fastcall BHB91601_P_open_core(unsigned __int8 which_chain)
EXPORT BHB91601_P_open_core
BHB91601_P_open_core

var_40= -0x40
buf_vil_tw= -0x38

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x44
MOV             R4, which_chain
MOVW            R3, #:lower16:gIsOpenCoreEnd
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             which_chain, SP, #0x44+buf_vil_tw ; s
MOV             R5, R3
BLX             memset
MOVW            R0, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R2, R4
LDR             R1, =__FUNCTION__.8199 ; "BHB91601_P_open_core"
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
BLX             printf
MOVW            R11, #:lower16:gIsOpeningCore
MOV             R3, R5
MOVT            R3, #:upper16:gIsOpenCoreEnd
MOVS            R6, #0
MOVS            R5, #1
MOVT            R11, #:upper16:gIsOpeningCore
MOVS            R0, #0x40 ; '@' ; address
STRB            R6, [R3]
STR             R3, [SP,#0x44+var_40]
MOV.W           R9, #0x80
STRB.W          R5, [R11]
MOVT            R9, #0x100
BL              read_axi_fpga
BIC.W           R1, R0, #0x20 ; ' ' ; data
MOVS            R0, #0x40 ; '@' ; address
BL              write_axi_fpga
LDR             R7, =__FUNCTION__.8199 ; "BHB91601_P_open_core"
MOV             R1, R6  ; data
MOVS            R0, #0x24 ; '$' ; address
MOV             R8, R6
BL              write_axi_fpga
MOVW            R10, #:lower16:Conf
MOV             R1, R6  ; c
LSLS            R5, R4
MOVW            R6, #:lower16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"
ORR.W           R9, R9, R4,LSL#16
MOVT            R10, #:upper16:Conf
MOVT            R6, #:upper16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"
ADD             R0, SP, #0x44+buf_vil_tw ; s
MOVS            R2, #0x34 ; '4' ; n
BLX             memset

loc_1C262               ; which_chain
which_core = R8         ; unsigned int
MOV             R0, R4
MOVS            R3, #1  ; mode
UXTB.W          R2, which_core ; core_id
MOVS            R1, #0  ; which_asic
BL              BM1391_enable_core_clock
MOVW            R0, #0x1388 ; useconds
BLX             usleep
B               loc_1C286

loc_1C27A
work_fifo_ready = R3    ; unsigned int
BLX             printf
MOVW            R0, #0xBB8 ; useconds
BLX             usleep

loc_1C286               ; address
MOVS            R0, #3
BL              read_axi_fpga
MOV             R3, R0
work_fifo_ready = R0    ; unsigned int
MOV             R2, R4
TST             R3, R5
MOV             work_fifo_ready, R6 ; format
work_fifo_ready = R3    ; unsigned int
MOV             R1, R7
BEQ             loc_1C27A
ADD             R0, SP, #0x44+buf_vil_tw ; value
STR.W           R9, [SP,#0x44+buf_vil_tw]
ADD.W           which_core, which_core, #1
BL              set_TW_write_command
LDR.W           R0, [R10,#configuration.OpenCoreGap] ; useconds
BLX             usleep
which_core = R8         ; unsigned int
CMP.W           which_core, #0x100
BNE             loc_1C262
MOVS            R0, #0x30 ; '0' ; address
BL              read_axi_fpga
ORR.W           R1, R0, #0x400000 ; data
MOVS            R0, #0x30 ; '0' ; address
BL              write_axi_fpga
MOVS            R2, #0
MOVS            R3, #1
STRB.W          R2, [R11]
LDR             R2, [SP,#0x44+var_40]
STRB            R3, [R2]
ADD             SP, SP, #0x44 ; 'D'
POP.W           {R4-R11,PC}
; End of function BHB91601_P_open_core

ALIGN 4
off_1C2D8 DCD __FUNCTION__.8199 ; "BHB91601_P_open_core"



; void __fastcall BHB91601_P_pre_open_core(unsigned __int8 which_chain)
EXPORT BHB91601_P_pre_open_core
BHB91601_P_pre_open_core

var_40= -0x40
buf_vil_tw= -0x38

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x44
MOVW            R3, #:lower16:gIsOpenCoreEnd
MOV             R4, which_chain
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             which_chain, SP, #0x44+buf_vil_tw ; s
MOV             R5, R3
BLX             memset
MOVW            R0, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R2, R4
LDR             R1, =__FUNCTION__.8211 ; "BHB91601_P_pre_open_core"
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
BLX             printf
MOVW            R11, #:lower16:gIsOpeningCore
MOV             R3, R5
MOVT            R3, #:upper16:gIsOpenCoreEnd
MOV.W           R8, #0
MOVT            R11, #:upper16:gIsOpeningCore
MOVS            R5, #1
MOVS            R0, #0x40 ; '@' ; address
STR             R3, [SP,#0x44+var_40]
STRB.W          R8, [R3]
MOVW            R9, #:lower16:Conf
STRB.W          R5, [R11]
MOVT            R9, #:upper16:Conf
BL              read_axi_fpga
BIC.W           R1, R0, #0x20 ; ' ' ; data
MOVS            R0, #0x40 ; '@' ; address
BL              write_axi_fpga
MOV             R1, R8  ; data
MOVS            R0, #0x24 ; '$' ; address
BL              write_axi_fpga
MOV             R1, R8  ; c
ADD             R0, SP, #0x44+buf_vil_tw ; s
MOVS            R2, #0x34 ; '4' ; n
BLX             memset
LDR.W           R3, [R9,#configuration.OpenCoreNum2]
CBZ             R3, loc_1C3BE
MOV.W           R10, #0x80
LDR             R7, =__FUNCTION__.8211 ; "BHB91601_P_pre_open_core"
MOVT            R10, #0x100
MOVW            R6, #:lower16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"
LSLS            R5, R4
ORR.W           R10, R10, R4,LSL#16
MOVT            R6, #:upper16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"

loc_1C36A               ; which_chain
which_core = R8         ; unsigned int
MOV             R0, R4
MOVS            R3, #1  ; mode
UXTB.W          R2, which_core ; core_id
MOVS            R1, #0  ; which_asic
BL              BM1391_enable_core_clock
MOVW            R0, #0x1388 ; useconds
BLX             usleep
B               loc_1C38E

loc_1C382
work_fifo_ready = R3    ; unsigned int
BLX             printf
MOVW            R0, #0xBB8 ; useconds
BLX             usleep

loc_1C38E               ; address
MOVS            R0, #3
BL              read_axi_fpga
MOV             R3, R0
work_fifo_ready = R0    ; unsigned int
MOV             R2, R4
TST             R3, R5
MOV             work_fifo_ready, R6 ; format
work_fifo_ready = R3    ; unsigned int
MOV             R1, R7
BEQ             loc_1C382
ADD             R0, SP, #0x44+buf_vil_tw ; value
STR.W           R10, [SP,#0x44+buf_vil_tw]
BL              set_TW_write_command
LDR.W           R0, [R9,#configuration.OpenCoreGap] ; useconds
ADD.W           which_core, which_core, #1
BLX             usleep
which_core = R8         ; unsigned int
LDR.W           R3, [R9,#configuration.OpenCoreNum2]
CMP             R3, which_core
BHI             loc_1C36A

loc_1C3BE               ; address
MOVS            R0, #0x30 ; '0'
BL              read_axi_fpga
ORR.W           R1, R0, #0x400000 ; data
MOVS            R0, #0x30 ; '0' ; address
BL              write_axi_fpga
MOVS            R2, #0
MOVS            R3, #1
STRB.W          R2, [R11]
LDR             R2, [SP,#0x44+var_40]
STRB            R3, [R2]
ADD             SP, SP, #0x44 ; 'D'
POP.W           {R4-R11,PC}
; End of function BHB91601_P_pre_open_core

off_1C3E0 DCD __FUNCTION__.8211 ; "BHB91601_P_pre_open_core"



; void __fastcall BHB91601_S_open_core(unsigned __int8 which_chain)
EXPORT BHB91601_S_open_core
BHB91601_S_open_core

var_44= -0x44
var_40= -0x40
buf_vil_tw= -0x38

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x44
MOV             R5, which_chain
MOVW            R3, #:lower16:gIsOpenCoreEnd
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             which_chain, SP, #0x44+buf_vil_tw ; s
MOV             R4, R3
BLX             memset
MOVW            R3, #:lower16:gIsOpeningCore
MOVW            R0, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R6, R3
LDR             R1, =__FUNCTION__.8226 ; "BHB91601_S_open_core"
MOV             R2, R5
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
BLX             printf
MOV.W           R10, #0x80
MOV             R3, R4
MOV             R2, R6
MOVT            R3, #:upper16:gIsOpenCoreEnd
MOVT            R2, #:upper16:gIsOpeningCore
MOVS            R4, #0
MOVS            R6, #1
MOVS            R0, #0x40 ; '@' ; address
MOVT            R10, #0x100
STRB            R4, [R3]
STRB            R6, [R2]
ORR.W           R10, R10, R5,LSL#16
STR             R3, [SP,#0x44+var_44]
MOVW            R11, #:lower16:Conf
STR             R2, [SP,#0x44+var_40]
MOVW            R7, #:lower16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"
BL              read_axi_fpga
LDR.W           R8, =__FUNCTION__.8226 ; "BHB91601_S_open_core"
BIC.W           R1, R0, #0x20 ; ' ' ; data
MOVS            R0, #0x40 ; '@' ; address
LSLS            R6, R5
MOV             R9, R4
BL              write_axi_fpga
MOV             R1, R4  ; data
MOVS            R0, #0x24 ; '$' ; address
BL              write_axi_fpga
MOVT            R11, #:upper16:Conf
MOV             R1, R4  ; c
MOVT            R7, #:upper16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"
MOV             R4, R10
ADD             R0, SP, #0x44+buf_vil_tw ; s
MOVS            R2, #0x34 ; '4' ; n
BLX             memset

loc_1C472
core_id = R9            ; unsigned int
MOV.W           R10, #0

loc_1C476               ; useconds
slot = R10              ; unsigned int
MOV.W           R0, #0x3E8
BLX             usleep
ADD.W           R2, core_id, slot,LSL#6
core_index = R2         ; unsigned int
MOVS            R3, #1  ; mode
ADD             slot, R3
UXTB            core_index, core_index ; core_id
MOVS            R1, #0  ; which_asic
MOV             R0, R5  ; which_chain
BL              BM1391_enable_core_clock
slot = R10              ; unsigned int
CMP.W           slot, #4
BNE             loc_1C476
MOVW            R0, #0x1388 ; useconds
BLX             usleep
B               loc_1C4AC

loc_1C4A0
work_fifo_ready = R3    ; unsigned int
BLX             printf
MOVW            R0, #0xBB8 ; useconds
BLX             usleep

loc_1C4AC               ; address
MOVS            R0, #3
BL              read_axi_fpga
MOV             R3, R0
work_fifo_ready = R0    ; unsigned int
MOV             R2, R5
TST             R3, R6
MOV             work_fifo_ready, R7 ; format
work_fifo_ready = R3    ; unsigned int
MOV             R1, R8
BEQ             loc_1C4A0
ADD             R0, SP, #0x44+buf_vil_tw ; value
STR             R4, [SP,#0x44+buf_vil_tw]
ADD.W           core_id, core_id, #1
BL              set_TW_write_command
LDR.W           R0, [R11,#configuration.OpenCoreGap] ; useconds
BLX             usleep
core_id = R9            ; unsigned int
CMP.W           core_id, #0x40 ; '@'
BNE             loc_1C472
MOVS            R0, #0x30 ; '0' ; address
BL              read_axi_fpga
ORR.W           R1, R0, #0x400000 ; data
MOVS            R0, #0x30 ; '0' ; address
BL              write_axi_fpga
LDR             R1, [SP,#0x44+var_40]
MOVS            R2, #0
MOVS            R3, #1
STRB            R2, [R1]
LDR             R2, [SP,#0x44+var_44]
STRB            R3, [R2]
ADD             SP, SP, #0x44 ; 'D'
POP.W           {R4-R11,PC}
; End of function BHB91601_S_open_core

ALIGN 4
off_1C4FC DCD __FUNCTION__.8226 ; "BHB91601_S_open_core"



; void __fastcall BHB91601_S_pre_open_core(unsigned __int8 which_chain)
EXPORT BHB91601_S_pre_open_core
BHB91601_S_pre_open_core

buf_vil_tw= -0x38

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x3C
MOV             R4, which_chain
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             which_chain, SP, #0x3C+buf_vil_tw ; s
BLX             memset
MOVW            R0, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R2, R4
LDR             R1, =__FUNCTION__.8244 ; "BHB91601_S_pre_open_core"
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
BLX             printf
MOVS            R0, #0x40 ; '@' ; address
MOVW            R9, #:lower16:Conf
BL              read_axi_fpga
BIC.W           R1, R0, #0x20 ; ' ' ; data
MOVS            R0, #0x40 ; '@' ; address
BL              write_axi_fpga
MOVS            R1, #0  ; data
MOVS            R0, #0x24 ; '$' ; address
BL              write_axi_fpga
MOVT            R9, #:upper16:Conf
ADD             R0, SP, #0x3C+buf_vil_tw ; s
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
BLX             memset
LDR.W           R3, [R9,#configuration.OpenCoreNum2]
CMP             R3, #0
BEQ             loc_1C5DC
MOV.W           R10, #0x80
MOVS            R6, #1
MOVT            R10, #0x100
LDR             R7, =__FUNCTION__.8244 ; "BHB91601_S_pre_open_core"
MOVW            R5, #:lower16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"
ORR.W           R10, R10, R4,LSL#16
LSLS            R6, R4
MOV.W           R8, #0
MOVT            R5, #:upper16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"

loc_1C572
core_id = R8            ; unsigned int
MOV.W           R11, #0

loc_1C576               ; useconds
slot = R11              ; unsigned int
MOV.W           R0, #0x3E8
BLX             usleep
ADD.W           R2, core_id, slot,LSL#6
core_index = R2         ; unsigned int
MOVS            R3, #1  ; mode
ADD             slot, R3
UXTB            core_index, core_index ; core_id
MOVS            R1, #0  ; which_asic
MOV             R0, R4  ; which_chain
BL              BM1391_enable_core_clock
slot = R11              ; unsigned int
CMP.W           slot, #4
BNE             loc_1C576
MOVW            R0, #0x1388 ; useconds
BLX             usleep
B               loc_1C5AC

loc_1C5A0
work_fifo_ready = R3    ; unsigned int
BLX             printf
MOVW            R0, #0xBB8 ; useconds
BLX             usleep

loc_1C5AC               ; address
MOVS            R0, #3
BL              read_axi_fpga
MOV             R3, R0
work_fifo_ready = R0    ; unsigned int
MOV             R2, R4
TST             R3, R6
MOV             work_fifo_ready, R5 ; format
work_fifo_ready = R3    ; unsigned int
MOV             R1, R7
BEQ             loc_1C5A0
ADD             R0, SP, #0x3C+buf_vil_tw ; value
STR.W           R10, [SP,#0x3C+buf_vil_tw]
BL              set_TW_write_command
LDR.W           R0, [R9,#configuration.OpenCoreGap] ; useconds
ADD.W           core_id, core_id, #1
BLX             usleep
core_id = R8            ; unsigned int
LDR.W           R3, [R9,#configuration.OpenCoreNum2]
CMP             R3, core_id
BHI             loc_1C572

loc_1C5DC
ADD             SP, SP, #0x3C ; '<'
POP.W           {R4-R11,PC}
; End of function BHB91601_S_pre_open_core

ALIGN 4
off_1C5E4 DCD __FUNCTION__.8244 ; "BHB91601_S_pre_open_core"



; unsigned int __fastcall BHB91601_get_result(unsigned __int8 which_chain)
EXPORT BHB91601_get_result
BHB91601_get_result

var_1C= -0x1C
which_asic= -0x18
var_14= -0x14
var_10= -0x10
ret= -0xC
var_8= -8

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x1C
STR             which_chain, [SP,#0x1C+var_10]
MOVW            R5, #:lower16:Conf
MOVW            which_chain, #:lower16:asc_29AF4 ; "\n\n-----------------------------------"...
MOVW            R3, #:lower16:BHB91601_ASIC_NUMBER
MOVT            R5, #:upper16:Conf
MOVT            R0, #:upper16:asc_29AF4 ; "\n\n-----------------------------------"...
MOV             R4, R3
BLX             puts
LDR             R1, [R5,#configuration.pattern_number]
MOV             R3, R4
MOVT            R3, #:upper16:BHB91601_ASIC_NUMBER
MOVW            R0, #:lower16:aEveryAsicRequi ; "every ASIC require nonce number: %u\n"
MOV             R4, R3
MOVT            R0, #:upper16:aEveryAsicRequi ; "every ASIC require nonce number: %u\n"
STR             R3, [SP,#0x1C+var_8]
LSLS            R1, R1, #8
BLX             printf
LDR             R3, [R4]
CBZ             R3, loc_1C67C
MOVW            R7, #0xCCCD
MOVW            R6, #:lower16:aAsic02dD ; "asic[%02d]=%d\t"
MOVT            R7, #0xCCCC
MOVT            R6, #:upper16:aAsic02dD ; "asic[%02d]=%d\t"
MOVS            R4, #0
LDR.W           R8, [SP,#0x1C+var_10]
LDR.W           R9, [SP,#0x1C+var_8]
B               loc_1C664

loc_1C644               ; which_asic
which_asic_0 = R4       ; unsigned int
UXTB            R1, which_asic_0
MOV.W           R2, #0x100 ; core_number
MOV             R0, R8  ; which_chain
BL              calculate_how_many_nonce_per_asic_get
per_asic_received_nonce_number = R0; unsigned int
MOV             R1, which_asic_0
MOV             R2, per_asic_received_nonce_number
MOV             per_asic_received_nonce_number, R6 ; format
per_asic_received_nonce_number = R2; unsigned int
ADDS            which_asic_0, #1
which_asic_0 = R1       ; unsigned int
BLX             printf
which_asic_0 = R4       ; unsigned int
LDR.W           R3, [R9]
CMP             R3, which_asic_0
BLS             loc_1C67C

loc_1C664
UMULL           R2, R3, which_asic_0, R7
LSRS            R3, R3, #3
ADD.W           R3, R3, R3,LSL#2
CMP.W           which_asic_0, R3,LSL#1
BNE             loc_1C644
MOVS            R0, #0xA ; c
BLX             putchar
B               loc_1C644

loc_1C67C               ; s
MOV             R0, #(aSCanTFindHashb+0x38) ; "\n"
BLX             puts
LDR             R3, [SP,#0x1C+var_8]
LDR             R3, [R3]
CMP             R3, #0
BEQ.W           loc_1C798
LDR             R1, [SP,#0x1C+var_10]
MOVS            R2, #7
LDR             R3, =(reg_mutex+0x14)
STR             R2, [SP,#0x1C+ret]
MOVS            R2, #0
ADD.W           R6, R1, #0xC
STR             R2, [SP,#0x1C+which_asic]
LSLS            R6, R6, #2
ADD.W           R3, R3, R1,LSL#19
STR             R3, [SP,#0x1C+var_14]
B               loc_1C6C2

loc_1C6AC
LDR             R3, [SP,#0x1C+var_8]
LDR             R1, [SP,#0x1C+var_14]
LDR             R2, [R3]
LDR             R3, [SP,#0x1C+which_asic]
ADD.W           R1, R1, #0x1000
STR             R1, [SP,#0x1C+var_14]
ADDS            R3, #1
CMP             R2, R3
STR             R3, [SP,#0x1C+which_asic]
which_asic_0 = R3       ; unsigned int
BLS             loc_1C79C

loc_1C6C2               ; core_number
MOV.W           R2, #0x100
LDRB.W          R1, [SP,#0x1C+which_asic] ; which_asic
LDR             R0, [SP,#0x1C+var_10] ; which_chain
BL              calculate_how_many_nonce_per_asic_get
LDR             R1, [R5,#configuration.pattern_number]
MOV             R2, R0
per_asic_received_nonce_number = R0; unsigned int
CMP.W           per_asic_received_nonce_number, R1,LSL#8
BCS             loc_1C6AC
LDR             R4, [SP,#0x1C+which_asic]
per_asic_received_nonce_number = R2; unsigned int
MOV             R0, #aAsic02dD_0 ; "asic[%02d] = %d\n"
MOV             R11, #aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
MOV             R1, R4
BLX             printf
LSLS            R2, R4, #2
MOV             R1, #cgpu
LDR.W           R9, [SP,#0x1C+var_14]
ADD.W           R2, R2, #0x80000
MOVS            R3, #0
ADDS            R2, #0xAC
MOV             R4, R3
LDR             R7, [R2,R1]
works = R7              ; work *
STR             R3, [SP,#0x1C+var_1C]

loc_1C70E
which_core = R4         ; unsigned int
LDR.W           R2, [R9,#4]!
LDR             R3, [R5,#configuration.pattern_number]
CMP             R2, R3
BCS             loc_1C776
LDR.W           R3, [R5,#configuration.Least_nonce_per_core]
MOV             R1, which_core
MOV             R0, R11 ; format
MOVW            R8, #:lower16:aD ; "%d  "
MOV.W           R10, #0
MOVT            R8, #:upper16:aD ; "%d  "
CMP             R2, R3
ITTT CC
LDRCC           R3, [SP,#0x1C+var_1C]
ADDCC           R3, #1
STRCC           R3, [SP,#0x1C+var_1C]
BLX             printf
LDR             R3, [R5,#configuration.pattern_number]
CBNZ            R3, loc_1C74A
B               loc_1C770

loc_1C740
which_pattern = R10     ; unsigned int
LDR             R3, [R5,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R3, which_pattern
BLS             loc_1C770

loc_1C74A
MLA             R3, R3, which_core, which_pattern
ADD.W           R3, R3, R3,LSL#4
ADD.W           R3, works, R3,LSL#2
ADD             R3, R6
LDR             R3, [R3,#4]
CMP             R3, #0
BNE             loc_1C740
MOV             R1, which_pattern
MOV             R0, R8  ; format
BLX             printf
LDR             R3, [R5,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R3, which_pattern
BHI             loc_1C74A

loc_1C770               ; c
MOVS            R0, #0xA
BLX             putchar

loc_1C776
ADDS            which_core, #1
CMP.W           which_core, #0x100
BNE             loc_1C70E
LDR.W           R2, [R5,#configuration.Invalid_Core_Num]
LDR             R3, [SP,#0x1C+var_1C]
CMP             R3, R2
BHI.W           loc_1C910

loc_1C78A               ; s
MOV             R0, #(aSCanTFindHashb+0x38) ; "\n"
BLX             puts
B               loc_1C6AC

loc_1C798
MOVS            R3, #7
STR             R3, [SP,#0x1C+ret]

loc_1C79C
LDR             R6, [SP,#0x1C+var_10]
MOV             R4, #gHw_Nonce_Num
MOVW            R0, #:lower16:aHwNumberDConfM ; "HW number = %d, Conf.Most_HW_Num = %d\n"...
LDR.W           R2, [R5,#configuration.Most_HW_Num]
MOVT            R0, #:upper16:aHwNumberDConfM ; "HW number = %d, Conf.Most_HW_Num = %d\n"...
LDR.W           R1, [R4,R6,LSL#2]
BLX             printf
LDR.W           R2, [R4,R6,LSL#2]
MOVW            R0, #:lower16:asc_29CA4 ; "\n-------------------------------------"...
LDR.W           R3, [R5,#configuration.Most_HW_Num]
MOVT            R0, #:upper16:asc_29CA4 ; "\n-------------------------------------"...
LDR             R1, [SP,#0x1C+ret]
CMP             R2, R3
IT HI
MOVHI           R1, #6
MOV             R7, R1
STR             R1, [SP,#0x1C+ret]
ret_0 = R1              ; unsigned int
BLX             puts
MOV             R3, #gSensor_OK
ADD.W           R1, R3, R6,LSL#2
LDRB.W          R0, [R3,R6,LSL#2]
MOVW            R6, #:lower16:gValid_Nonce_Num
LDRB            R2, [R1,#1]
MOVT            R6, #:upper16:gValid_Nonce_Num
LDRB            R3, [R1,#2]
LDRB            R1, [R1,#3]
ANDS            R2, R0
MOVW            R0, #:lower16:aChainDTotalVal_0 ; "Chain%d total valid nonce number: %d, l"...
ANDS            R3, R2
LDR.W           R2, [R5,#configuration.TargetTemp]
TST             R3, R1
LDR             R1, [SP,#0x1C+var_10]
IT EQ
MOVEQ           R3, ret_0
MOVT            R0, #:upper16:aChainDTotalVal_0 ; "Chain%d total valid nonce number: %d, l"...
ITT EQ
BICEQ.W         R3, R3, #2
STREQ           R3, [SP,#0x1C+ret]
MOV             R3, #gGlobalHighestTemp
LDR.W           R7, [R6,R1,LSL#2]
LDR             R3, [R3]
MOV             R8, R1
CMP             R2, R3
LDR             R2, [SP,#0x1C+var_8]
IT LT
LDRLT           R3, [SP,#0x1C+ret]
LDR             R2, [R2]
ITT LT
BICLT.W         R3, R3, #4
STRLT           R3, [SP,#0x1C+ret]
LDR             R3, [R5,#configuration.pattern_number]
MUL             R3, R2, R3
MOV             R2, R7
RSB.W           R3, R7, R3,LSL#8
BLX             printf
VLDR            S15, [R5,#configuration.pattern_number]
MOVW            R0, #:lower16:aNonceRateF ; "Nonce rate = %f \n\n"
LDR             R2, [SP,#0x1C+var_8]
MOVT            R0, #:upper16:aNonceRateF ; "Nonce rate = %f \n\n"
LDR.W           R3, [R6,R8,LSL#2]
VLDR            S11, =256.0
VLDR            S13, [R2]
VCVT.F32.U32    S15, S15
VMOV            S14, R3
VLDR            S12, =100.0
VCVT.F32.U32    S13, S13
VMUL.F32        S15, S15, S11
VCVT.F32.U32    S14, S14
VMUL.F32        S15, S15, S13
VMUL.F32        S14, S14, S12
VDIV.F32        S13, S14, S15
VCVT.F64.F32    D7, S13
VMOV            R2, R3, D7
BLX             printf
LDR             R3, [SP,#0x1C+ret]
LSLS            R1, R3, #0x1F
ITETE MI
MOVWMI          R0, #0x9D38
MOVWPL          R0, #0x9D44
MOVTMI          R0, #2
MOVTPL          R0, #2  ; s
BLX             puts
LDR             R3, [SP,#0x1C+ret]
LSLS            R2, R3, #0x1E
ITETE MI
MOVWMI          R0, #0xAB0C
MOVWPL          R0, #0xAB18
MOVTMI          R0, #2
MOVTPL          R0, #2  ; s
BLX             puts
LDR             R3, [SP,#0x1C+ret]
LSLS            R3, R3, #0x1D
ITETE MI
MOVWMI          R0, #0xBC2C
MOVWPL          R0, #0xBC3C
MOVTMI          R0, #2
MOVTPL          R0, #2  ; s
BLX             puts
LDR             R3, [SP,#0x1C+var_10]
MOV             R0, #aHwNumberD ; "HW number = %d\n\n"
LDR.W           R1, [R4,R3,LSL#2]
BLX             printf
MOVS            R0, #0x3E ; '>' ; address
BL              read_axi_fpga
MOV             R1, R0
MOV             R0, #aCrcErrorNumber ; "CRC error number = %d\n\n"
BLX             printf
LDR             R0, [SP,#0x1C+ret]
ADD             SP, SP, #0x1C
POP.W           {R4-R11,PC}

loc_1C910
which_core = R4         ; unsigned int
how_many_core_not_receive_all_nonce_per_asic = R3; unsigned int
works = R7              ; work *
MOVW            R0, #:lower16:aErrorAsicIsD ; "\n error asic is %d\n"
MOVS            how_many_core_not_receive_all_nonce_per_asic, #6
LDR             R1, [SP,#0x1C+which_asic]
MOVT            R0, #:upper16:aErrorAsicIsD ; "\n error asic is %d\n"
STR             R3, [SP,#0x1C+ret]
BLX             printf
B               loc_1C78A
; End of function BHB91601_get_result

off_1C924 DCD reg_mutex+0x14
flt_1C928 DCFS 256.0
flt_1C92C DCFS 100.0



; void __fastcall BHB91601_print_lcd(unsigned int result)
EXPORT BHB91601_print_lcd
BHB91601_print_lcd
result = R0             ; unsigned int
PUSH            {R4,LR}
MOV             R4, result
BL              display_level_result_on_lcd
LSLS            R2, result, #0x1F
BPL             loc_1C99A
MOVW            R1, #:lower16:aPatternOk_0 ; "   Pattern OK   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aPatternOk_0 ; "   Pattern OK   "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R3, #:lower16:pattern_test_time
MOVS            R2, #0
MOVT            R3, #:upper16:pattern_test_time
STRB            R2, [R3]

loc_1C958
LSLS            R3, result, #0x1E
MOV.W           R0, #2  ; line
ITETT MI
MOVWMI          R1, #0xBC64
MOVWPL          R1, #0xBC78
MOVMI           R2, #0x10
MOVTMI          R1, #2
ITT PL
MOVPL           R2, #0x10 ; size
MOVTPL          R1, #2  ; buf
BL              write_lcd_no_memset
MOV             R3, #gEEPROM_error
LDRB            R3, [R3]
CBNZ            R3, loc_1C9BA
MOVW            R1, #:lower16:aEepromOk ; "   EEPROM OK   "
MOVS            R2, #0x10
MOVT            R1, #:upper16:aEepromOk ; "   EEPROM OK   "
MOVS            R0, #3
POP.W           {result,LR}
B.W             write_lcd_no_memset

loc_1C99A
result = R4             ; unsigned int
MOVW            R1, #:lower16:aPatternNg_0 ; "   Pattern NG   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aPatternNg_0 ; "   Pattern NG   "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOV             R3, #pattern_test_time
LDRB            R2, [R3]
ADDS            R2, #1
STRB            R2, [R3]
B               loc_1C958

loc_1C9BA
MOVW            R1, #:lower16:aEepromNg ; "   EEPROM NG   "
MOVS            R2, #0x10
MOVT            R1, #:upper16:aEepromNg ; "   EEPROM NG   "
MOVS            R0, #3
POP.W           {result,LR}
B.W             write_lcd_no_memset
; End of function BHB91601_print_lcd

ALIGN 0x10



; int __fastcall BHB91601_check_nonce(unsigned __int8 which_chain, unsigned int *buf)
EXPORT BHB91601_check_nonce
BHB91601_check_nonce

var_14= -0x14
var_10= -0x10
mutex= -0xC
ret= -8

which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
PUSH.W          {R4-R11,LR}
MOVW            R3, #:lower16:gChain_Asic_Interval
LDR             R5, [buf,#4]
MOVT            R3, #:upper16:gChain_Asic_Interval
SUB             SP, SP, #0x14
MOV             R7, which_chain
LDR.W           R8, [buf]
data_0 = R8             ; unsigned int
data_1 = R5             ; unsigned int
LDR             buf, [R3]
LSRS            which_chain, data_1, #0x18
UXTB.W          R10, data_1
BL              __aeabi_uidiv
TST.W           data_0, #0x40
MOV             R6, R0
which_asic = R0         ; unsigned int
which_core = R10        ; unsigned int
UBFX.W          R4, data_0, #0x10, #0xF
which_pattern = R4      ; unsigned int
BNE             loc_1CACC

loc_1C9FE
which_asic = R6         ; unsigned int
MOV             R3, #BHB91601_ASIC_NUMBER
LDR             R3, [R3]
CMP             which_asic, R3
BCS.W           loc_1CB74
MOV             R1, #Conf
LDR             R3, [R1,#configuration.pattern_number]
CMP             which_pattern, R3
BCS.W           loc_1CB74
MOVW            R2, #:lower16:cgpu
ADD.W           R0, which_asic, #0x20000
MOVT            R2, #:upper16:cgpu
ADDS            R0, #0x2A ; '*'
MLA             R3, R3, which_core, which_pattern
ADD.W           R2, R2, R0,LSL#2
LDR             R2, [R2,#4]
ADD.W           R3, R3, R3,LSL#4
ADD.W           R3, R2, R3,LSL#2
work = R3               ; work *
LDR             R2, [work,#4]
CMP             data_1, R2
BEQ             loc_1CAE6
MOVW            R9, #:lower16:gHw_Nonce_Num
LDR.W           work, [R1,#configuration.Most_HW_Num]
match_nonce = R2        ; unsigned int
MOVT            R9, #:upper16:gHw_Nonce_Num
LDR.W           match_nonce, [R9,R7,LSL#2]
CMP             R2, R3
BLS             loc_1CA60

loc_1CA58
data_1 = R5             ; unsigned int
MOVS            R0, #0

loc_1CA5A
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}

loc_1CA60
which_pattern = R4      ; unsigned int
data_0 = R8             ; unsigned int
data_1 = R5             ; unsigned int
MOVW            R3, #:lower16:HW_check_mutex
ADD.W           R11, R7, R7,LSL#1
MOVT            R3, #:upper16:HW_check_mutex
ADD.W           R3, R3, R11,LSL#3
data_1 = R5             ; unsigned int
MOV             R8, #gWork_Num_For_Hw_Check
MOV             R0, R3  ; mutex
STR             R3, [SP,#0x14+mutex]
BLX             pthread_mutex_lock
LDRB.W          which_pattern, [R8]
CMP             R4, #0
BEQ             loc_1CB7E
MOVW            R3, #:lower16:gWorks_For_Hw_Check
ADD.W           R4, R7, R7,LSL#4
MOVT            R3, #:upper16:gWorks_For_Hw_Check
ADD.W           R4, R3, R4,LSL#9
MOV.W           R11, #0
B               loc_1CAA6

loc_1CA9E
i = R11                 ; int
LDRB.W          R1, [R8]
CMP             R1, i
BLE             loc_1CB42

loc_1CAA6               ; work
MOV             R0, R4
MOVS            R2, #0  ; print
MOV             R1, data_1 ; nonce
ADD.W           i, i, #1
ADDS            R4, #0x44 ; 'D'
BL              check_hw
i = R11                 ; int
CMP             R0, #0
BNE             loc_1CA9E
STR             R0, [SP,#0x14+ret]
LDR             R0, [SP,#0x14+mutex] ; mutex
BLX             pthread_mutex_unlock
LDR             R2, [SP,#0x14+ret]
MOV             R0, R2
ADD             SP, SP, #0x14
POP.W           {R4-i,PC}

loc_1CACC
which_asic = R0         ; unsigned int
which_pattern = R4      ; unsigned int
data_0 = R8             ; unsigned int
data_1 = R5             ; unsigned int
MOVW            which_asic, #:lower16:aSNonceCrcError ; "\n!!! %s: nonce crc error! nonce = 0x%0"...
which_asic = R6         ; unsigned int
STR             which_pattern, [SP,#0x14+var_10]
STR.W           which_core, [SP,#0x14+var_14]
MOV             R3, which_asic
MOV             R2, data_1
LDR             R1, =__FUNCTION__.8302 ; "BHB91601_check_nonce"
MOVT            R0, #:upper16:aSNonceCrcError ; "\n!!! %s: nonce crc error! nonce = 0x%0"...
BLX             printf
B               loc_1C9FE

loc_1CAE6
match_nonce = R2        ; unsigned int
work = R3               ; work *
ADD.W           work, work, R7,LSL#2
LDR             R0, [R3,#0x34]
CBZ             R0, loc_1CB0C
MOVW            match_nonce, #:lower16:gRepeated_Nonce_Id
ADDS            R0, #1
MOVT            R2, #:upper16:gRepeated_Nonce_Id
STR             R0, [R3,#0x34]
LDR.W           R3, [R2,R7,LSL#2]
MOVS            R0, #0
ADDS            R3, #1
STR.W           R3, [R2,R7,LSL#2]
ADD             SP, SP, #0x14
POP.W           {which_pattern-R11,PC}

loc_1CB0C
match_nonce = R2        ; unsigned int
data_0 = R8             ; unsigned int
data_1 = R5             ; unsigned int
ADD.W           which_asic, which_asic, R7,LSL#7
MOVW            match_nonce, #:lower16:gAsic_Core_Nonce_Num
MOVW            R1, #:lower16:gValid_Nonce_Num
ADD.W           which_core, which_core, R6,LSL#10
MOVT            R2, #:upper16:gAsic_Core_Nonce_Num
MOVT            R1, #:upper16:gValid_Nonce_Num
MOVS            which_pattern, #1
STR             R4, [R3,#0x34]
LDR.W           R4, [R1,R7,LSL#2]
LDR.W           R3, [R2,R10,LSL#2]
ADDS            R4, #1
ADDS            R3, #1
STR.W           R4, [R1,R7,LSL#2]
STR.W           R3, [R2,R10,LSL#2]
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}

loc_1CB42
which_asic = R6         ; unsigned int
which_core = R10        ; unsigned int
data_1 = R5             ; unsigned int
i = R11                 ; int
STR             R0, [SP,#0x14+ret]
ret_0 = R0              ; int
LDR             ret_0, [SP,#0x14+mutex] ; mutex
BLX             pthread_mutex_unlock
LDR             R2, [SP,#0x14+ret]
CMP             R2, #1
BNE             loc_1CA58
LDR.W           R1, [R9,R7,LSL#2]
MOVW            R0, #:lower16:aSFindAHwChainD ; "%s: Find a HW. Chain%d ASIC%d Core%d : "...
STR             data_1, [SP,#0x14+var_10]
MOV             R3, which_asic
STR.W           which_core, [SP,#0x14+var_14]
MOV             R2, R7
ADDS            R4, R1, #1
MOVT            R0, #:upper16:aSFindAHwChainD ; "%s: Find a HW. Chain%d ASIC%d Core%d : "...
LDR             R1, =__FUNCTION__.8302 ; "BHB91601_check_nonce"
STR.W           R4, [R9,R7,LSL#2]
BLX             printf
B               loc_1CA58

loc_1CB74
which_pattern = R4      ; unsigned int
data_0 = R8             ; unsigned int
data_1 = R5             ; unsigned int
MOV.W           R0, #0xFFFFFFFF
ADD             SP, SP, #0x14
POP.W           {which_pattern-R11,PC}

loc_1CB7E               ; mutex
data_1 = R5             ; unsigned int
LDR             R0, [SP,#0x14+mutex]
BLX             pthread_mutex_unlock
MOV             R0, R4
B               loc_1CA5A
; End of function BHB91601_check_nonce

off_1CB88 DCD __FUNCTION__.8302 ; "BHB91601_check_nonce"



; int __fastcall BHB91601_check_register_value(unsigned __int8 which_chain, unsigned int *buf)
EXPORT BHB91601_check_register_value
BHB91601_check_register_value
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
PUSH            {R3-R7,LR}
MOV             R5, #reg_value_buf
LDR             R4, [buf]
LDR             R2, [R5]
LDR             R7, [buf,#4]
data_0 = R4             ; unsigned int
data_1 = R7             ; unsigned int
LDR             R2, [R2,#8]
CMP.W           R2, #0x1FE
BHI             loc_1CC14
LSLS            R3, data_0, #0x19
BMI             loc_1CC28
ANDS.W          R6, data_0, #0x20000000
BNE             loc_1CBFC
MOV             R0, #reg_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R2, [R5]
LSRS            R3, data_0, #8
LSRS            R5, data_0, #0x10
UBFX.W          LR, data_0, #0x18, #5
AND.W           data_0, data_0, #0xF
data_1 = R7             ; unsigned int
LDR             R1, [R2]
ADD.W           R0, R2, R1,LSL#3
ADDS            R1, #1
CMP.W           R1, #0x200
STR             data_1, [R0,#0x10]
STRB.W          LR, [R0,#0x16]
STRB            R5, [R0,#0x14]
STRB            R4, [R0,#0x17]
STRB            R3, [R0,#0x15]
MOVW            R0, #:lower16:reg_mutex
LDR             R3, [R2,#8]
MOVT            R0, #:upper16:reg_mutex ; mutex
STR             R1, [R2]
IT CS
STRCS           R6, [R2]
ADDS            R3, #1
STR             R3, [R2,#8]
BLX             pthread_mutex_unlock
MOVS            R0, #0
POP             {R3-data_1,PC}

loc_1CBFC
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
data_0 = R4             ; unsigned int
data_1 = R7             ; unsigned int
MOVW            which_chain, #:lower16:aSRegTypeErrorD ; "%s: REG_TYPE error. data[0] = 0x%08x, r"...
MOV             R3, data_1
MOV             R2, data_0
LDR             buf, =__FUNCTION__.8311 ; "BHB91601_check_register_value"
MOVT            R0, #:upper16:aSRegTypeErrorD ; "%s: REG_TYPE error. data[0] = 0x%08x, r"...
BLX             printf
MOV.W           R0, #0xFFFFFFFF
POP             {R3-data_1,PC}

loc_1CC14
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
data_0 = R4             ; unsigned int
data_1 = R7             ; unsigned int
MOVW            which_chain, #:lower16:aSRegValueBufBu ; "%s: reg_value_buf buffer is full!\n"
LDR             buf, =__FUNCTION__.8311 ; "BHB91601_check_register_value"
MOVT            R0, #:upper16:aSRegValueBufBu ; "%s: reg_value_buf buffer is full!\n"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
POP             {R3-data_1,PC}

loc_1CC28
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
data_0 = R4             ; unsigned int
data_1 = R7             ; unsigned int
MOVW            which_chain, #:lower16:aSRegCrcErrorDa ; "%s: reg crc error. data[0] = 0x%08x, re"...
MOV             R3, data_1
MOV             R2, data_0
LDR             buf, =__FUNCTION__.8311 ; "BHB91601_check_register_value"
MOVT            R0, #:upper16:aSRegCrcErrorDa ; "%s: reg crc error. data[0] = 0x%08x, re"...
BLX             printf
MOV.W           R0, #0xFFFFFFFF
POP             {R3-data_1,PC}
; End of function BHB91601_check_register_value

off_1CC40 DCD __FUNCTION__.8311 ; "BHB91601_check_register_value"



; void *__fastcall BHB91601_receive_func(void *arg)
EXPORT BHB91601_receive_func
BHB91601_receive_func

sp= -0xC
buf= -8

arg = R0                ; void *
which_chain = R8        ; unsigned __int8
PUSH.W          {R4-which_chain,LR}
MOV             R2, arg
chain_info = R0         ; chain_info *
SUB             SP, SP, #0x10
MOVS            R3, #0
MOVS            chain_info, #1 ; algorithm
chain_info = R2         ; chain_info *
LDRB.W          which_chain, [chain_info]
LDRB            R5, [chain_info,#1]
which_i2c = R5          ; unsigned __int8
STR             R3, [SP,#0x10+buf]
STR             R3, [SP,#0x10+buf+4]
STR             R3, [SP,#0x10+sp]
BLX             sched_get_priority_max
MOV             R4, R0
priority = R0           ; const int
STR             priority, [SP,#0x10+sp]
BLX             pthread_self
ADD             R2, SP, #0x10+sp ; param
MOVS            R1, #1  ; policy
MOV             R6, R0
BLX             pthread_setschedparam
CMP             R0, #0
BEQ             loc_1CCF6

loc_1CC76
MOVW            R0, #:lower16:aSWhichChainDWh_1 ; "\n--- %s: which_chain = %d, which_i2c ="...
MOVW            R6, #:lower16:start_receive
MOVW            R7, #:lower16:gBegin_Get_Nonce
MOV             R3, which_i2c
MOV             R2, which_chain
LDR             R1, =__FUNCTION__.8375 ; "BHB91601_receive_func"
MOVT            R0, #:upper16:aSWhichChainDWh_1 ; "\n--- %s: which_chain = %d, which_i2c ="...
MOVT            R6, #:upper16:start_receive
MOVT            R7, #:upper16:gBegin_Get_Nonce
BLX             printf
B               loc_1CCAE

loc_1CC9A               ; useconds
MOV.W           R0, #0x3E8
BLX             usleep
MOVS            R0, #6  ; address
BL              read_axi_fpga
UBFX.W          R4, R0, #0, #9
nonce_number = R4       ; unsigned int
CBNZ            nonce_number, loc_1CCBA

loc_1CCAE
LDRB            R0, [R6]
CMP             R0, #0
BNE             loc_1CC9A
ADD             SP, SP, #0x10
POP.W           {R4-which_chain,PC}

loc_1CCBA
nonce_number = R4       ; unsigned int
MOVS            R5, #0
B               loc_1CCC8

loc_1CCBE
i = R5                  ; unsigned int
LDRB            R3, [R7]
CBNZ            R3, loc_1CCE2

loc_1CCC2
ADDS            i, #1
CMP             nonce_number, i
BLS             loc_1CCAE

loc_1CCC8               ; buf
ADD             R0, SP, #0x10+buf
BL              get_return_nonce
LDR             R0, [SP,#0x10+buf] ; data
BL              BM1391_is_nonce_or_reg_value
CMP             R0, #0
BNE             loc_1CCBE
ADD             R1, SP, #0x10+buf ; buf
MOV             R0, which_chain ; which_chain
BL              BHB91601_check_register_value
B               loc_1CCC2

loc_1CCE2               ; data
LDR             R0, [SP,#0x10+buf]
BL              BM1391_check_nonce_flag
CMP             R0, #0
BEQ             loc_1CCC2
ADD             R1, SP, #0x10+buf ; buf
MOV             R0, which_chain ; which_chain
BL              BHB91601_check_nonce
B               loc_1CCC2

loc_1CCF6
which_i2c = R5          ; unsigned __int8
priority = R4           ; const int
MOVW            R0, #:lower16:aSIoThreadLxUsi ; "\n--- %s: IO Thread #%lx using %d prior"...
MOV             R3, priority
MOV             R2, R6
LDR             R1, =__FUNCTION__.8375 ; "BHB91601_receive_func"
MOVT            R0, #:upper16:aSIoThreadLxUsi ; "\n--- %s: IO Thread #%lx using %d prior"...
BLX             printf
B               loc_1CC76
; End of function BHB91601_receive_func

ALIGN 4
off_1CD0C DCD __FUNCTION__.8375 ; "BHB91601_receive_func"



; void singleBoardTest_BHB91601_BM1391()
EXPORT singleBoardTest_BHB91601_BM1391
singleBoardTest_BHB91601_BM1391

thread_ret= -0x20
line= -0x1C
var_18= -0x18
lcd_display_buf= -0x14

PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x24
LDR             R5, =dword_2D134
ADD             R4, SP, #0x24+lcd_display_buf
MOV             R6, #lcd_fd
LDR             R2, [R5,#(dword_2D13C - 0x2D134)]
LDR             R3, [R5,#(dword_2D140 - 0x2D134)]
LDR             R0, [R5]
LDR             R1, [R5,#(dword_2D138 - 0x2D134)]
STM             R4!, {R0-R3}
MOVW            R0, #:lower16:aBeginSTest ; "\nBegin %s test\n"
ADD.W           R1, R5, #0x10
MOVT            R0, #:upper16:aBeginSTest ; "\nBegin %s test\n"
BLX             printf
MOV             R0, #aDate ; "date"
BLX             system
MOVS            R0, #0xA ; c
BLX             putchar
MOVW            R0, #:lower16:lcd_output
MOVS            R2, #0x40 ; '@' ; n
MOVT            R0, #:upper16:lcd_output ; s
MOVS            R1, #0x20 ; ' ' ; c
BLX             memset
LDR             R0, [R6] ; fd
CMP             R0, #0
BLE             loc_1CD7C
MOVS            R2, #0  ; whence
MOV             R1, R2  ; offset
BLX             lseek
MOVW            R1, #:lower16:lcd_output
LDR             R0, [R6] ; fd
MOVT            R1, #:upper16:lcd_output ; buf
MOVS            R2, #0x40 ; '@' ; n
BLX             write

loc_1CD7C
BL              init_fpga
MOVS            R0, #0x1A ; asic_baud
MOVW            R4, #:lower16:gChain
BL              set_fpga_baud
MOVS            R1, #0  ; data
MOVS            R0, #0x3E ; '>' ; address
BL              write_axi_fpga
MOVS            R0, #0  ; address
MOVT            R4, #:upper16:gChain
BL              read_axi_fpga
ORR.W           R1, R0, #0x40000000 ; data
MOVS            R0, #0  ; address
BL              write_axi_fpga
BL              reset_BHB91601_global_arg
BL              check_chain
LDRB            R3, [R4]
CMP             R3, #0xFF
BEQ.W           loc_1CF1C
LDR             R6, =cgpu.show_id
MOV             R5, #chain_info_0
MOVW            R2, #:lower16:(BHB91601_show_status_func+1)
ADD.W           R3, R5, R3,LSL#1 ; arg
MOVT            R2, #:upper16:(BHB91601_show_status_func+1) ; start_routine
MOV             R0, R6  ; newthread
MOVS            R1, #0  ; attr
BLX             pthread_create
thread_ret_0 = R0       ; unsigned int
MOV             R3, thread_ret_0
CBZ             thread_ret_0, loc_1CE22
LDR             thread_ret_0, [R6] ; th
thread_ret_0 = R3       ; unsigned int
BLX             pthread_cancel
MOVW            R1, #:lower16:aCreatShow ; "   Creat show   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCreatShow ; "   Creat show   "
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreateSingleB ; "\n!!!%s: create single_BM1391_show_stat"...
LDR             R1, =__FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
MOVT            R0, #:upper16:aSCreateSingleB ; "\n!!!%s: create single_BM1391_show_stat"...
BLX             printf

loc_1CE1C
ADD             SP, SP, #0x24 ; '$'
POP.W           {R4-R11,PC}

loc_1CE22
thread_ret_0 = R0       ; unsigned int
MOVW            R7, #:lower16:gEEPROM_error
MOVW            thread_ret_0, #:lower16:i2c_mutex
thread_ret_0 = R3       ; unsigned int
MOV             R1, thread_ret_0 ; mutexattr
MOVT            R7, #:upper16:gEEPROM_error
MOVT            R0, #:upper16:i2c_mutex ; mutex
SUB.W           R8, R6, #0x80008
STRB            thread_ret_0, [R7]
BLX             pthread_mutex_init
ADD.W           R3, R8, #0x100000
LDR.W           R3, [R3,#(cgpu.repair_mode - 0x330FC4)]
CMP             R3, #0
BNE             loc_1CF3E
BL              Test_EEPROM
CMP             R0, #0
BEQ.W           loc_1D06E
MOVW            R0, #:lower16:aSTestEepromChe ; "\n!!! %s: Test_EEPROM: Check EEPROM err"...
LDR             R1, =__FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
MOVT            R0, #:upper16:aSTestEepromChe ; "\n!!! %s: Test_EEPROM: Check EEPROM err"...
BLX             printf
MOVS            R3, #1
STRB            R3, [R7]

loc_1CE66               ; data
MOVW            R1, #0xFFFF
MOVS            R0, #0xD ; address
BL              write_axi_fpga
MOVW            R11, #:lower16:gI2c
MOVW            R0, #:lower16:(gAsic_Core_Nonce_Num+0x1859C)
MOVT            R11, #:upper16:gI2c
MOVT            R0, #:upper16:(gAsic_Core_Nonce_Num+0x1859C) ; useconds
BLX             usleep
LDRB.W          R1, [R11] ; which_i2c
LDRB            R0, [R4] ; which_chain
BL              reset_dsPIC33EP16GS202_pic
LDRB.W          R1, [R11] ; which_i2c
LDRB            R0, [R4] ; which_chain
BL              jump_from_loader_to_app_dsPIC33EP16GS202
LDRB            R3, [R4]
MOV             R2, #(pic_heart_beat_func+1) ; start_routine
MOVS            R1, #0  ; attr
LDR             R0, =cgpu.pic_heart_beat_id ; newthread
ADD.W           R3, R5, R3,LSL#1 ; arg
BLX             pthread_create
thread_ret_0 = R0       ; unsigned int
CMP             thread_ret_0, #0
BEQ             loc_1CF5C
LDR             thread_ret_0, [R6] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R3, =cgpu.send_id
LDR             R0, [R3,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOVW            R1, #:lower16:aCreatHeartBeat ; "Creat heart beat"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCreatHeartBeat ; "Creat heart beat"
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreatePicHear ; "\n!!!%s: create pic_heart_beat_func fai"...
LDR             R1, =__FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
MOVT            R0, #:upper16:aSCreatePicHear ; "\n!!!%s: create pic_heart_beat_func fai"...
BLX             printf
ADD             SP, SP, #0x24 ; '$'
POP.W           {R4-R11,PC}

loc_1CF1C
MOVW            R1, #:lower16:aNoHashBoard_0 ; " no hash board  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aNoHashBoard_0 ; " no hash board  "
MOVS            R0, #1  ; line
BL              write_lcd
MOV             R0, #aNoHashBoardPle ; "\nNo hash board, please plug in it"
BLX             puts
ADD             SP, SP, #0x24 ; '$'
POP.W           {R4-R11,PC}

loc_1CF3E
BL              Test_EEPROM_part_area
CMP             R0, #0
BEQ.W           loc_1D07E
MOVW            R0, #:lower16:aSTestEepromPar ; "\n!!! %s: Test_EEPROM_part_area: Check "...
LDR             R1, =__FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
MOVT            R0, #:upper16:aSTestEepromPar ; "\n!!! %s: Test_EEPROM_part_area: Check "...
BLX             printf
MOVS            R3, #1
STRB            R3, [R7]
B               loc_1CE66

loc_1CF5C               ; useconds
MOV             R0, #(gAsic_Core_Nonce_Num+0x1859C)
BLX             usleep
LDRB.W          R1, [R11] ; which_iic
LDRB            R0, [R4] ; which_chain
BL              set_pre_open_core_voltage
ret = R0                ; int
MOV             R9, ret
CMP             ret, #0
BNE.W           loc_1CE1C
MOV             R2, ret ; enable
LDRB.W          R1, [R11] ; which_i2c
LDRB            ret, [R4] ; which_chain
ret = R2                ; int
MOV.W           R10, #1
BL              enable_dsPIC33EP16GS202_clamping_voltage
MOV             R1, ret ; data
MOVS            R0, #0xD ; address
BL              write_axi_fpga
MOV             R0, #(gAsic_Core_Nonce_Num+0x1859C) ; useconds
BLX             usleep
MOVW            R3, #:lower16:start_receive
MOVW            R0, #0x2710 ; useconds
MOVT            R3, #:upper16:start_receive
STRB.W          R10, [R3]
BLX             usleep
LDRB            R3, [R4]
MOV             R2, #(BHB91601_receive_func+1) ; start_routine
MOV             R1, ret ; attr
LDR             R0, =cgpu.receive_id ; newthread
ADD.W           R3, R5, R3,LSL#1 ; arg
BLX             pthread_create
thread_ret_0 = R0       ; unsigned int
STR             thread_ret_0, [SP,#0x24+thread_ret]
CMP             thread_ret_0, #0
BNE             loc_1D0A8
MOVS            thread_ret_0, #0x40 ; '@' ; address
MOVW            R10, #:lower16:Conf
BL              read_axi_fpga
BIC.W           R1, R0, #0x8100
MOVS            R0, #0x40 ; '@' ; address
BIC.W           R1, R1, #0xE0
MOVT            R10, #:upper16:Conf
ORR.W           R1, R1, #0x8100 ; data
BL              write_axi_fpga
MOVW            R0, #:lower16:aSConfOpencoren ; "\n---%s: Conf.OpenCoreNum1 = %d, Conf.O"...
LDR.W           R3, [R10,#configuration.OpenCoreNum2]
LDR.W           R2, [R10,#configuration.OpenCoreNum1]
MOVT            R0, #:upper16:aSConfOpencoren ; "\n---%s: Conf.OpenCoreNum1 = %d, Conf.O"...
LDR             R1, =__FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
BLX             printf
LDR.W           R3, [R10,#configuration.OpenCoreNum1]
CMP             R3, #0
BEQ.W           loc_1D11E
LDR.W           ret, [SP,#0x24+thread_ret]
MOVW            R3, #:lower16:gHashBoard_BHB91601P
MOVW            R2, #:lower16:gHashBoard_BHB91601S
MOVW            R1, #:lower16:(gAsic_Core_Nonce_Num+0x492DC)
MOVT            R3, #:upper16:gHashBoard_BHB91601P
MOVT            R2, #:upper16:gHashBoard_BHB91601S
MOVT            R1, #:upper16:(gAsic_Core_Nonce_Num+0x492DC)
STR.W           R11, [SP,#0x24+thread_ret]
STR             R5, [SP,#0x24+line]
MOV             R11, R10
STR             R7, [SP,#0x24+var_18]
MOV             R10, R9
MOV             R5, R3
MOV             R9, R2
MOV             R7, R1
B               loc_1D060

loc_1D03E
i = R10                 ; unsigned int
LDRB.W          R3, [R9]
CMP             R3, #0
BEQ.W           loc_1D224
LDRB            R0, [R4] ; which_chain
BL              BHB91601_S_pre_open_core
MOV             R0, R7  ; useconds
BLX             usleep

loc_1D054
LDR.W           R3, [R11,#configuration.OpenCoreNum1]
ADD.W           i, i, #1
CMP             R3, i
BLS             loc_1D114

loc_1D060
LDRB            R3, [R5]
CMP             R3, #0
BEQ             loc_1D03E
LDRB            R0, [R4] ; which_chain
BL              BHB91601_P_pre_open_core
B               loc_1D054

loc_1D06E
MOVW            R0, #:lower16:aSTestEepromChe_0 ; "\n--- %s: Test_EEPROM: Check EEPROM ok!"...
LDR             R1, =__FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
MOVT            R0, #:upper16:aSTestEepromChe_0 ; "\n--- %s: Test_EEPROM: Check EEPROM ok!"...
BLX             printf
B               loc_1CE66

loc_1D07E
MOVW            R0, #:lower16:aSTestEepromPar_0 ; "\n--- %s: Test_EEPROM_part_area: Check "...
LDR             R1, =__FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
MOVT            R0, #:upper16:aSTestEepromPar_0 ; "\n--- %s: Test_EEPROM_part_area: Check "...
BLX             printf
B               loc_1CE66
ALIGN 0x10
off_1D090 DCD dword_2D134
off_1D094 DCD cgpu.show_id
off_1D098 DCD __FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
off_1D09C DCD cgpu.pic_heart_beat_id
off_1D0A0 DCD cgpu.send_id
off_1D0A4 DCD cgpu.receive_id

loc_1D0A8
thread_ret_0 = R0       ; unsigned int
ret = R9                ; int
LDR             R4, =cgpu.send_id
LDR             thread_ret_0, [R6] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R4,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDR             R0, [R4,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOVW            R1, #:lower16:aCreatReceive ; "  Creat receive "
MOV             R0, ret ; line
MOVT            R1, #:upper16:aCreatReceive ; "  Creat receive "
MOVS            R2, #0x10 ; size
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOV             R0, R10 ; line
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreateBhb9160_1 ; "\n!!!%s: create BHB91601_receive_func f"...
LDR             R1, =__FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
MOVT            R0, #:upper16:aSCreateBhb9160_1 ; "\n!!!%s: create BHB91601_receive_func f"...
BLX             printf
B               loc_1CE1C

loc_1D114
i = R10                 ; unsigned int
MOV             i, R11
LDR             R5, [SP,#0x24+line]
LDR.W           R11, [SP,#0x24+thread_ret]
LDR             R7, [SP,#0x24+var_18]

loc_1D11E
MOVW            R0, #:lower16:aBhb91601CheckA ; "\n--- BHB91601 check asic number"
MOVW            R9, #:lower16:BHB91601_ASIC_NUMBER
MOVT            R0, #:upper16:aBhb91601CheckA ; "\n--- BHB91601 check asic number"
MOVT            R9, #:upper16:BHB91601_ASIC_NUMBER
BLX             puts
MOVS            R2, #0  ; reg
MOVS            R3, #1  ; mode
MOV             R1, R2  ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              check_BM1391_asic_reg
LDRB            R1, [R4]
MOV             R0, #aCheckChainJDHa ; "\n--- check chain: J%d has asicNum = %d"...
ADD.W           R3, R8, R1
ADDS            R1, #1
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             printf
LDRB            R0, [R4] ; which_chain
LDR.W           R2, [R9]
ADD.W           R3, R8, R0
ADD.W           R3, R3, #0x100000
LDRB.W          R3, [R3,#0x30C]
CMP             R3, R2
BEQ.W           loc_1D2AA
LDR             R5, =cgpu.send_id
LDR             R0, [R5,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R5,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDRB            R3, [R4]
MOV             R1, #(aT1DT2D+0xC) ; format
ADD.W           R0, SP, #0x24+lcd_display_buf+7 ; s
ADD             R3, R8
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             sprintf
MOVW            R1, #:lower16:aOnlyHave ; "   Only have    "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aOnlyHave ; "   Only have    "
MOVS            R0, #0  ; line
BL              write_lcd
ADD             R1, SP, #0x24+lcd_display_buf ; buf
MOVS            R2, #0x10 ; size
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aAsic ; "      ASIC      "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aAsic ; "      ASIC      "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
LDRB            R3, [R4]
MOVW            R0, #:lower16:aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
LDR             R1, =__FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
MOVT            R0, #:upper16:aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
ADD             R3, R8
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             printf
MOV             R0, #asc_29F80 ; "----------------------------\n\n"
BLX             puts
LDR.W           R0, [R10,#configuration.close_power_delay] ; seconds
BLX             sleep

loc_1D212               ; which_i2c
LDRB.W          R1, [R11]
MOVS            R2, #0  ; enable
LDRB            R0, [R4] ; which_chain
BL              enable_dsPIC33EP16GS202_dc_dc
BL              power_off
B               loc_1CE1C

loc_1D224
i = R10                 ; unsigned int
LDR             R5, =cgpu.send_id
LDR             R0, [R6] ; th
STR             R3, [SP,#0x24+line]
LDR.W           R11, [SP,#0x24+thread_ret]
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R5,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDR             R0, [R5,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R3, [SP,#0x24+line]
MOVW            R1, #:lower16:aConfig ; "     Config     "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aConfig ; "     Config     "
MOV             R0, R3  ; line
STR             R3, [SP,#0x24+thread_ret]
BL              write_lcd
MOVW            R1, #:lower16:aHashboardType ; " Hashboard Type "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aHashboardType ; " Hashboard Type "
MOVS            R0, #1  ; line

loc_1D276
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aInConfigIni ; " in Config.ini  "
MOVS            R0, #2  ; line
MOVT            R1, #:upper16:aInConfigIni ; " in Config.ini  "
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCanTFindHashb ; "\n!!!%s: Can't find Hashboard type when"...
LDR             R1, =__FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
MOVT            R0, #:upper16:aSCanTFindHashb ; "\n!!!%s: Can't find Hashboard type when"...
BLX             printf

loc_1D298               ; enable
MOVS            R2, #0
LDRB.W          R1, [R11] ; which_i2c
LDRB            R0, [R4] ; which_chain
BL              enable_dsPIC33EP16GS202_dc_dc
BL              power_off
B               loc_1CE1C

loc_1D2AA               ; baud
MOVS            R1, #0
BL              BHB91601_set_baud
LDRB            R0, [R4]
BL              reset_hash_board
MOVS            R0, #0x1A ; asic_baud
BL              set_fpga_baud
LDRB            R3, [R4]
MOVW            R0, #:lower16:aDoubleCheckAsi ; "\n--- double check asic number"
MOV.W           R2, #0
MOVT            R0, #:upper16:aDoubleCheckAsi ; "\n--- double check asic number"
ADD             R3, R8
ADD.W           R3, R3, #0x100000
STRB.W          R2, [R3,#0x30C]
BLX             puts
MOVS            R2, #0  ; reg
MOVS            R3, #1  ; mode
MOV             R1, R2  ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              check_BM1391_asic_reg
LDRB            R1, [R4]
MOV             R0, #aCheckChainJDHa ; "\n--- check chain: J%d has asicNum = %d"...
ADD.W           R3, R8, R1
ADDS            R1, #1
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             printf
LDRB            R3, [R4]
LDR.W           R2, [R9]
ADD             R3, R8
ADD.W           R3, R3, #0x100000
LDRB.W          R3, [R3,#0x30C]
CMP             R3, R2
BEQ             loc_1D3B6
LDR             R5, =cgpu.send_id
LDR             R0, [R5,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R5,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDRB            R3, [R4]
MOV             R1, #(aT1DT2D+0xC) ; format
ADD.W           R0, SP, #0x24+lcd_display_buf+7 ; s
ADD             R3, R8
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             sprintf
MOVW            R1, #:lower16:aOnlyHave ; "   Only have    "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aOnlyHave ; "   Only have    "
MOVS            R0, #0  ; line
BL              write_lcd
ADD             R1, SP, #0x24+lcd_display_buf ; buf
MOVS            R2, #0x10 ; size
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aAsic ; "      ASIC      "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aAsic ; "      ASIC      "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
LDRB            R3, [R4]
MOV             R0, #aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
LDR             R1, =__FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
ADD             R3, R8
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             printf
MOV             R0, #asc_29F80 ; "----------------------------\n\n"
BLX             puts

loc_1D3AC               ; seconds
LDR.W           R0, [R10,#configuration.close_power_delay]
BLX             sleep
B               loc_1D298

loc_1D3B6
LDR             R3, =(cgpu.subid+0x7FD54)
LDRB.W          R8, [R3,#(cgpu.Only_find_ASIC - 0x330FC4)]
CMP.W           R8, #0
BEQ             loc_1D434
SUB.W           R8, R3, #0x80000
LDR.W           R0, [R8,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR.W           R0, [R8,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOVW            R1, #:lower16:aFindAllAsic ; " find all ASIC  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aFindAllAsic ; " find all ASIC  "
MOVS            R0, #1  ; line
BL              write_lcd
MOVW            R1, #:lower16:aOk ; "       OK       "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aOk ; "       OK       "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aFindDAsicOk ; "\nFind %d ASIC, OK\n"
LDR.W           R1, [R9]
MOVT            R0, #:upper16:aFindDAsicOk ; "\nFind %d ASIC, OK\n"
BLX             printf
B               loc_1D3AC
ALIGN 4
off_1D428 DCD cgpu.send_id
off_1D42C DCD __FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
off_1D430 DCD cgpu.subid+0x7FD54

loc_1D434
BL              BHB91601_calculate_timeout_and_baud
MOV             R1, R8  ; chip_addr
LDR.W           R2, [R10,#configuration.Freq] ; freq
MOVS            R3, #1  ; mode
LDRB            R0, [R4] ; which_chain
BL              set_BM1391_freq
MOVW            R3, #:lower16:gSensor_OK
LDRB            R0, [R4] ; which_chain
STR             R3, [SP,#0x24+thread_ret]
MOV             R9, R8
BL              BHB91601_set_address
LDR             R2, =(cgpu.subid+0x7FD54)
LDR             R3, [SP,#0x24+thread_ret]
LDRB            R0, [R4] ; which_chain
LDRB.W          R1, [R2,#(cgpu.baud - 0x330FC4)] ; baud
MOVT            R3, #:upper16:gSensor_OK
STR             R3, [SP,#0x24+thread_ret]
BL              BHB91601_set_baud
MOVS            R2, #0x3F ; '?' ; tm
MOVS            R3, #1  ; mode
MOV             R1, R8  ; asic_addr
LDRB            R0, [R4] ; which_chain
BL              BM1391_set_TM
LDR.W           R1, [R10,#configuration.timeout]
MOVS            R0, #0x22 ; '"' ; address
MOV             R8, #aSCheckSensorDT ; "\n---%s: check sensor %d time\n"
ORR.W           R1, R1, #0x80000000 ; data
BL              write_axi_fpga
MOVW            R0, #0x2710 ; useconds
BLX             usleep
LDRB            R0, [R4] ; which_chain
BL              BM1391_soft_reset_sensor
LDRB            R0, [R4] ; which_chain
BL              BM1391_enable_extended_mode_of_temperature_sensor
STR             R5, [SP,#0x24+line]
MOV             R2, R7
LDR             R5, [SP,#0x24+thread_ret]
MOV             R7, R9
MOV             R9, R2

loc_1D4A8
i = R7                  ; unsigned int
LDRB.W          LR, [R4]
MOV             R2, i
LDR             R1, =__FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
MOV             R0, R8  ; format
ADDS            i, #1
i = R2                  ; unsigned int
LDRB.W          R3, [R5,LR,LSL#2]
ADD.W           LR, R5, LR,LSL#2
CBZ             R3, loc_1D4D4
LDRB.W          R3, [LR,#1]
CBZ             R3, loc_1D4D4
LDRB.W          R3, [LR,#2]
CBZ             R3, loc_1D4D4
LDRB.W          R3, [LR,#3]
CMP             R3, #0
BNE.W           loc_1D794

loc_1D4D4
BLX             printf
LDRB            R0, [R4] ; which_chain
BL              BM1391_read_asic_temperature_local
i = R7                  ; unsigned int
CMP             i, #3
BNE             loc_1D4A8
LDR             R5, [SP,#0x24+line]
MOV             i, R9

loc_1D4E6
MOVW            R2, #:lower16:gHashBoard_BHB91601P
MOVW            R3, #:lower16:gIsReadTemp
MOVT            R2, #:upper16:gHashBoard_BHB91601P
MOVT            R3, #:upper16:gIsReadTemp
LDRB            R2, [R2]
MOV.W           R8, #1
STRB.W          R8, [R3]
CMP             R2, #0
BNE.W           loc_1D6D2
MOV             R3, #gHashBoard_BHB91601S
LDRB.W          R9, [R3]
CMP.W           R9, #0
BEQ             loc_1D5FE
LDRB            R0, [R4] ; which_chain
BL              BHB91601_S_open_core

loc_1D51E               ; which_iic
LDRB.W          R1, [R11]
MOVW            R9, #:lower16:gStartTest
LDRB            R0, [R4] ; which_chain
MOVT            R9, #:upper16:gStartTest
BL              adjust_voltage
MOV             R0, #aBeginSendTestP ; "\nBegin send test pattern"
BLX             puts
LDRB.W          R3, [R9]
CBNZ            R3, loc_1D574
MOVW            R8, #:lower16:time_counter
LDR.W           R3, [R10,#configuration.HeatingUpTime]
MOVT            R8, #:upper16:time_counter
LDR.W           R2, [R8]
CMP             R2, R3
BCC             loc_1D564
B               loc_1D648

loc_1D558
LDR.W           R2, [R10,#configuration.HeatingUpTime]
LDR.W           R3, [R8]
CMP             R2, R3
BLS             loc_1D648

loc_1D564               ; useconds
MOVW            R0, #0x2710
BLX             usleep
LDRB.W          R3, [R9]
CMP             R3, #0
BEQ             loc_1D558

loc_1D574
LDRB            R3, [R4]
MOVW            R2, #:lower16:(BHB91601_send_func+1)
LDR             R6, =cgpu.send_id
MOVT            R2, #:upper16:(BHB91601_send_func+1) ; start_routine
MOVS            R1, #0  ; attr
ADD.W           R3, R5, R3,LSL#1 ; arg
MOV             R0, R6  ; newthread
BLX             pthread_create
thread_ret_0 = R0       ; unsigned int
MOV             R5, thread_ret_0
CMP             thread_ret_0, #0
BEQ.W           loc_1D6DA
LDR             thread_ret_0, [R6,#(cgpu.show_id - 0x2B0FC4)] ; th
thread_ret_0 = R5       ; unsigned int
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R6,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDR             R0, [R6,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOVW            R1, #:lower16:aCreatSend ; "   Creat send   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCreatSend ; "   Creat send   "
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreateBhb9160_2 ; "\n!!!%s: create BHB91601_send_func fail"...
LDR             R1, =__FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
MOVT            R0, #:upper16:aSCreateBhb9160_2 ; "\n!!!%s: create BHB91601_send_func fail"...
BLX             printf
B               loc_1D212

loc_1D5FE
LDR             R5, =cgpu.send_id
LDR             R0, [R6] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R5,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDR             R0, [R5,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOVW            R1, #:lower16:aConfig ; "     Config     "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aConfig ; "     Config     "
MOV             R0, R9  ; line
BL              write_lcd
MOVW            R1, #:lower16:aHashboardType ; " Hashboard Type "
MOV             R0, R8
MOVT            R1, #:upper16:aHashboardType ; " Hashboard Type "
MOVS            R2, #0x10
B               loc_1D276

loc_1D648
LDR             R5, =cgpu.send_id
LDR             R0, [R5,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R5,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #aCanTOpenCoreCh ; "Can't open core, change to next voltage"...
BLX             puts
MOVW            R1, #:lower16:aCanTOpenCore ; "Can't open core "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCanTOpenCore ; "Can't open core "
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aChangeToNext ; "change  to  next"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aChangeToNext ; "change  to  next"
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:(aCanTOpenCoreCh+0x20) ; "voltage and freq"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:(aCanTOpenCoreCh+0x20) ; buf
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R3, #:lower16:pattern_test_time
LDRB            R0, [R4] ; which_chain
MOVT            R3, #:upper16:pattern_test_time
LDRB.W          R1, [R11] ; which_i2c
LDRB            R4, [R3]
MOVS            R2, #0  ; enable
ADDS            R4, #1
STRB            R4, [R3]
BL              enable_dsPIC33EP16GS202_dc_dc
BL              power_off
B.W             loc_1CE1C

loc_1D6D2               ; which_chain
LDRB            R0, [R4]
BL              BHB91601_P_open_core
B               loc_1D51E

loc_1D6DA               ; thread_return
thread_ret_0 = R0       ; unsigned int
MOV             R1, thread_ret_0
LDR             thread_ret_0, [R6] ; th
thread_ret_0 = R5       ; unsigned int
BLX             pthread_join
MOV             R1, R5  ; thread_return
LDR             R0, [R6,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_join
LDR             R0, [R6,#(cgpu.show_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDRB            R0, [R4] ; which_chain
BL              BHB91601_get_result
LSLS            R3, R0, #0x1F
MOV             R5, R0
result = R0             ; unsigned int
BPL             loc_1D76E
LDRB            R3, [R7]
CMP             R3, #0
BNE             loc_1D7C2
LDRB            R1, [R4] ; which_chain
LDRB.W          result, [R11] ; which_iic
result = R5             ; unsigned int
BL              BHB91601_AT24C02_write_total_data
CMP             R0, #0
BEQ             loc_1D7B4
MOV             R0, #aEepromOk_0 ; "\nEEPROM OK\n"
BLX             puts

loc_1D71C               ; result
MOV             R0, result
BL              BHB91601_print_lcd
LDR.W           R0, [R10,#configuration.close_power_delay] ; seconds
BLX             sleep

loc_1D72A               ; which_i2c
LDRB.W          R1, [R11]
MOVS            R2, #0  ; enable
LDRB            R0, [R4] ; which_chain
BL              enable_dsPIC33EP16GS202_dc_dc
BL              power_off

loc_1D73A               ; mutex
MOV             R0, #i2c_mutex
BLX             pthread_mutex_lock
LDR             R0, [R6,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOVS            R0, #0  ; speed
BL              set_fan_speed
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
B.W             loc_1CE1C

loc_1D76E
result = R0             ; unsigned int
BL              BHB91601_print_lcd
LDR.W           R0, [R10,#configuration.close_power_delay] ; seconds
BLX             sleep
MOVW            R2, #:lower16:pattern_test_time
MOVW            R3, #:lower16:gHowManyVoltageLevel
MOVT            R2, #:upper16:pattern_test_time
MOVT            R3, #:upper16:gHowManyVoltageLevel
LDRB            R2, [R2]
LDRB            R3, [R3]
CMP             R2, R3
BCS             loc_1D72A
B               loc_1D73A

loc_1D794
i = R2                  ; unsigned int
MOVW            R0, #:lower16:aSCheckSensorOk ; "\n---%s: check sensor ok\n"
LDR             R5, [SP,#0x24+line]
MOVT            R0, #:upper16:aSCheckSensorOk ; "\n---%s: check sensor ok\n"
MOV             R7, R9
BLX             printf
B               loc_1D4E6
ALIGN 4
off_1D7A8 DCD cgpu.subid+0x7FD54
off_1D7AC DCD __FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
off_1D7B0 DCD cgpu.send_id

loc_1D7B4
result = R5             ; unsigned int
MOV             R0, #aEepromNg_0 ; "\nEEPROM NG\n"
BLX             puts
B               loc_1D71C

loc_1D7C2
result = R0             ; unsigned int
MOVW            result, #:lower16:aSDonTSaveDataI ; "\n!!!%s: Don't save data into EEPROM, b"...
result = R5             ; unsigned int
LDR             R1, =__FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"
MOVT            R0, #:upper16:aSDonTSaveDataI ; "\n!!!%s: Don't save data into EEPROM, b"...
BLX             printf
B               loc_1D71C
; End of function singleBoardTest_BHB91601_BM1391

ALIGN 4
off_1D7D4 DCD __FUNCTION__.8389 ; "singleBoardTest_BHB91601_BM1391"



; int open_key()
EXPORT open_key
open_key
MOVW            R0, #:lower16:aSysClassGpioGp_0 ; "/sys/class/gpio/gpio943/value"
PUSH            {R4,LR}
MOV.W           R1, #0x800 ; oflag
MOVT            R0, #:upper16:aSysClassGpioGp_0 ; "/sys/class/gpio/gpio943/value"
MOVW            R4, #:lower16:key_fd
BLX             open
CMP             R0, #0
MOVT            R4, #:upper16:key_fd
STR             R0, [R4]
BLT             loc_1D7FA
POP             {R4,PC}

loc_1D7FA
MOV             R0, #aOpenKeyFailed ; "open key failed!!!"
BLX             puts
LDR             R0, [R4]
POP             {R4,PC}
; End of function open_key

ALIGN 4



; void close_key()
EXPORT close_key
close_key
PUSH            {R3,LR}
MOV             R3, #key_fd
LDR             R0, [R3] ; fd
BLX             close
MOVW            R0, #:lower16:aKeyClosed ; "key closed!!!"
POP.W           {R3,LR}
MOVT            R0, #:upper16:aKeyClosed ; "key closed!!!"
B.W             j_puts
; End of function close_key




; ssize_t __fastcall read_key(char *value)
EXPORT read_key
read_key
value = R0              ; char *
PUSH            {R3-R5,LR}
MOVW            R4, #:lower16:key_fd
MOVS            R2, #0  ; whence
MOVT            R4, #:upper16:key_fd
MOV             R1, R2  ; offset
MOV             R5, value
LDR             value, [R4] ; fd
value = R5              ; char *
BLX             lseek
LDR             R0, [R4] ; fd
MOV             R1, value ; buf
MOVS            R2, #1  ; nbytes
BLX             read
ret_len = R0            ; ssize_t
CMP             ret_len, #1
BNE             loc_1D852

locret_1D850
POP             {R3-value,PC}

loc_1D852
ret_len = R0            ; ssize_t
MOVW            R1, #:lower16:__FUNCTION__.5378 ; "read_key"
MOVW            ret_len, #:lower16:aSCanTReadOutKe ; "%s: can't read out key value\n"
MOVT            R1, #:upper16:__FUNCTION__.5378 ; "read_key"
MOVT            R0, #:upper16:aSCanTReadOutKe ; "%s: can't read out key value\n"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               locret_1D850
; End of function read_key




; void __fastcall sha2_starts(sha2_context *ctx)
EXPORT sha2_starts
sha2_starts
ctx = R0                ; sha2_context *
MOVW            R2, #0xE667
MOVW            R3, #0xAE85
MOVT            R2, #0x6A09
PUSH            {R4-R7}
MOVT            R3, #0xBB67
MOVW            R7, #0xF372
MOVW            R6, #0xF53A
MOVW            R5, #0x527F
MOVW            R4, #0x688C
MOVW            R1, #0xD9AB
STR             R2, [ctx,#8]
MOVW            R2, #0xCD19
MOVT            R7, #0x3C6E
MOVT            R6, #0xA54F
MOVT            R5, #0x510E
MOVT            R4, #0x9B05
MOVT            R1, #0x1F83
STR             R3, [ctx,#0xC]
MOVT            R2, #0x5BE0
MOVS            R3, #0
STR             R7, [ctx,#0x10]
STR             R6, [ctx,#0x14]
STR             R5, [ctx,#0x18]
STR             R4, [ctx,#0x1C]
STR             R1, [ctx,#0x20]
STR             R2, [ctx,#0x24]
STR             R3, [ctx]
STR             R3, [ctx,#4]
POP             {R4-R7}
BX              LR
; End of function sha2_starts




; void __fastcall sha2_process(sha2_context *ctx, const unsigned __int8 *data)
EXPORT sha2_process
sha2_process

F= -0x80
G= -0x7C
var_78= -0x78
W_0= -0x74
W_1= -0x70
W_2= -0x6C
W_3= -0x68
var_64= -0x64
B= -0x60
H= -0x5C
E= -0x58
var_54= -0x54
var_50= -0x50
var_4C= -0x4C
var_48= -0x48
var_44= -0x44
var_40= -0x40
W_7= -0x3C
D= -0x38
var_34= -0x34
var_30= -0x30
var_2C= -0x2C
var_28= -0x28
var_24= -0x24
ctx= -0x20
var_1C= -0x1C
var_18= -0x18
var_14= -0x14
var_10= -0x10
var_C= -0xC
var_8= -8

ctx_0 = R0              ; sha2_context *
data = R1               ; const unsigned __int8 *
PUSH.W          {R4-R11,LR}
MOVW            R2, #0x2F98
LDRB.W          R12, [data,#1]
SUB             SP, SP, #0x84
MOVT            R2, #0x428A
MOVW            R7, #0xFBCF
LDRB.W          R9, [data]
MOV             R3, R7
STR             R2, [SP,#0x84+F]
MOVT            R3, #0xB5C0
LDRB            R2, [data,#5]
MOV.W           R12, R12,LSL#16
STR             ctx_0, [SP,#0x84+ctx]
MOVW            R6, #0x4491
LDRB            ctx_0, [data,#4]
ORR.W           R12, R12, R9,LSL#24
LDRB            R5, [data,#3]
MOVT            R6, #0x7137
LDRB            R4, [data,#2]
LSLS            R2, R2, #0x10
LDRB.W          R9, [data,#9]
MOVW            R7, #0xDBA5
LDRB.W          R8, [data,#0xD]
ORR.W           R12, R12, R5
LDRB.W          R10, [data,#7]
ORR.W           R2, R2, R0,LSL#24
STR             R3, [SP,#0x84+D]
ORR.W           R4, R12, R4,LSL#8
LDRB            R3, [data,#6]
MOV.W           R9, R9,LSL#16
LDRB.W          LR, [data,#0xC]
ORR.W           R2, R2, R10
STR             R6, [SP,#0x84+var_40]
MOV.W           R8, R8,LSL#16
LDRB            R6, [data,#8]
MOVT            R7, #0xE9B5
LDRB            R5, [data,#0xB]
ORR.W           R10, R2, R3,LSL#8
LDRB            R0, [data,#0xE]
ORR.W           R8, R8, LR,LSL#24
STR             R4, [SP,#0x84+W_0]
LDRB.W          R12, [data,#0xF]
ORR.W           R9, R9, R6,LSL#24
LDRB            R4, [data,#0xA]
LDRB            R3, [data,#0x11]
ORR.W           R9, R9, R5
STR             R7, [SP,#0x84+var_1C]
ORR.W           R12, R8, R12
LDRB            R7, [data,#0x10]
ORR.W           R12, R12, R0,LSL#8
ORR.W           R9, R9, R4,LSL#8
LDRB            R2, [data,#0x12]
LSLS            R3, R3, #0x10
LDRB            R6, [data,#0x13]
LDRB            R5, [data,#0x14]
MOVW            R8, #0xC25B
LDRB.W          LR, [data,#0x17]
ORR.W           R3, R3, R7,LSL#24
STR.W           R9, [SP,#0x84+W_2]
MOVT            R8, #0x3956
LDRB            R4, [data,#0x15]
ORRS            R6, R3
STR.W           R10, [SP,#0x84+W_1]
LDRB.W          R10, [data,#0x16]
STR.W           R12, [SP,#0x84+W_3]
LDRB.W          R12, [data,#0x1C]
LSLS            R4, R4, #0x10
LDRB            R0, [data,#0x19]
LDRB.W          R11, [data,#0x18]
ORR.W           R4, R4, R5,LSL#24
STR.W           R12, [SP,#0x84+G]
ORR.W           R12, R6, R2,LSL#8
W_4 = R12               ; uint32_t
LDRB            R6, [data,#0x1F]
ORR.W           R4, R4, LR
LDRB            R2, [data,#0x1D]
LSLS            R0, R0, #0x10
LDRB            R7, [data,#0x1B]
ADD             R8, W_4
STR             R6, [SP,#0x84+var_78]
ORR.W           R0, R0, R11,LSL#24
LDR             R6, [SP,#0x84+G]
ORR.W           R10, R4, R10,LSL#8
LDRB.W          R9, [data,#0x1A]
LSLS            R2, R2, #0x10
STR.W           W_4, [SP,#0x84+var_64]
ORRS            R0, R7
LDRB.W          W_4, [data,#0x1E]
LDRB.W          R3, [data,#0x21]
ORR.W           R2, R2, R6,LSL#24
LDR             R6, [SP,#0x84+var_78]
ORR.W           R9, R0, R9,LSL#8
STR.W           R12, [SP,#0x84+E]
LDRB.W          R12, [data,#0x20]
STR.W           R9, [SP,#0x84+H]
ORRS            R2, R6
LDRB.W          R9, [data,#0x26]
LSLS            R3, R3, #0x10
LDRB.W          R6, [data,#0x2C]
LDRB.W          R5, [data,#0x23]
ORR.W           R3, R3, R12,LSL#24
LDRB.W          LR, [data,#0x24]
LDRB.W          R7, [data,#0x28]
LDRB.W          R11, [data,#0x22]
ORRS            R3, R5
STR.W           R10, [SP,#0x84+B]
LDRB.W          R4, [data,#0x25]
LDRB.W          R10, [data,#0x27]
STR.W           R9, [SP,#0x84+var_50]
ORR.W           R11, R3, R11,LSL#8
LDRB.W          R9, [data,#0x2B]
LDRB.W          R0, [data,#0x29]
LSLS            R4, R4, #0x10
LDRB.W          R12, [data,#0x2A]
STR             R6, [SP,#0x84+G]
ORR.W           R4, R4, LR,LSL#24
LDR             R6, [SP,#0x84+E]
ORR.W           R4, R4, R10
LDRB.W          R3, [data,#0x31]
LDRB.W          R5, [data,#0x30]
LSLS            R0, R0, #0x10
STR.W           R11, [SP,#0x84+var_54]
ORR.W           R2, R2, R6,LSL#8
LDRB.W          R6, [data,#0x2F]
LDRB.W          R11, [data,#0x2E]
LSLS            R3, R3, #0x10
STR             R2, [SP,#0x84+W_7]
ORR.W           R0, R0, R7,LSL#24
STR             R6, [SP,#0x84+var_78]
ORR.W           R3, R3, R5,LSL#24
LDR             R6, [SP,#0x84+var_50]
ORR.W           R0, R0, R9
LDRB.W          R2, [data,#0x2D]
ORR.W           R12, R0, R12,LSL#8
STR.W           R11, [SP,#0x84+E]
LDRB.W          R5, [data,#0x3A]
ORR.W           R10, R4, R6,LSL#8
LDR             R6, [SP,#0x84+G]
LSLS            R2, R2, #0x10
LDRB.W          R11, [data,#0x33]
STR             R5, [SP,#0x84+var_34]
LDRB.W          R5, [data,#0x3C]
ORR.W           R2, R2, R6,LSL#24
LDRB.W          R6, [data,#0x3B]
LDRB.W          R7, [data,#0x32]
ORR.W           R3, R3, R11
LDRB.W          LR, [data,#0x34]
STR             R6, [SP,#0x84+G]
LDR             R6, [SP,#0x84+var_78]
LDRB.W          R9, [data,#0x36]
STR.W           R10, [SP,#0x84+var_50]
ORRS            R2, R6
LDR             R6, [SP,#0x84+E]
LDRB.W          R4, [data,#0x35]
LDRB.W          R10, [data,#0x37]
STR.W           R12, [SP,#0x84+var_4C]
ORR.W           R2, R2, R6,LSL#8
LDRB.W          R12, [data,#0x38]
LDRB.W          R0, [data,#0x39]
LSLS            R4, R4, #0x10
STR             R5, [SP,#0x84+var_78]
STR             R2, [SP,#0x84+var_48]
ORR.W           R4, R4, LR,LSL#24
LDRB.W          R2, [data,#0x3D]
LDRB.W          R11, [data,#0x3F]
LSLS            R0, R0, #0x10
ORR.W           R10, R4, R10
ORR.W           R12, R0, R12,LSL#24
STR.W           R11, [SP,#0x84+var_30]
ORR.W           R11, R3, R7,LSL#8
LSLS            R2, R2, #0x10
STR.W           R11, [SP,#0x84+var_44]
LDRB.W          R11, [data,#0x3E]
LDR             data, [SP,#0x84+ctx]
LDR             R3, [R1,#8]
MOV             R7, R3
MOV             R3, R1
LDR             R6, [R3,#0x20]
LDR             R0, [R3,#0xC]
LDR             R1, [R1,#0x18]
MOV             R5, R6
STR             R5, [SP,#0x84+var_10]
STR             R1, [SP,#0x84+E]
STR             R0, [SP,#0x84+var_28]
MOV             R0, R5
LDR             R1, [R3,#0x1C]
LDR             R5, [SP,#0x84+var_40]
LDR             R4, [SP,#0x84+E]
STR             R1, [SP,#0x84+var_24]
ADD             R0, R5
LDR             R1, [R3,#0x24]
MOV             R5, R0
MOV             R0, R3
LDR             R3, [R3,#0x10]
MOV.W           R6, R4,ROR#11
STR             R1, [SP,#0x84+var_8]
MOV.W           R1, R7,ROR#13
EOR.W           R6, R6, R4,ROR#6
LDR             R4, [SP,#0x84+F]
STR             R3, [SP,#0x84+var_14]
EOR.W           R1, R1, R7,ROR#2
LDR             R3, [SP,#0x84+var_8]
LDR             R0, [R0,#0x14]
EOR.W           R1, R1, R7,ROR#22
ADD             R3, R4
LDR             R4, [SP,#0x84+E]
STR             R3, [SP,#0x84+F]
LDR             R3, [SP,#0x84+var_24]
STR             R0, [SP,#0x84+var_C]
MOV             R0, R7
EOR.W           R6, R6, R4,ROR#25
MOV             LR, R3
LDR             R3, [SP,#0x84+var_10]
EOR.W           R3, LR, R3
ORR.W           LR, R10, R9,LSL#8
ANDS            R3, R4
LDR             R4, [SP,#0x84+F]
STR.W           LR, [SP,#0x84+var_40]
MOV             LR, R7
LDR             R7, [SP,#0x84+var_28]
ADD             R6, R4
LDR             R4, [SP,#0x84+var_10]
MOV             R9, R7
EORS            R3, R4
ORR.W           R4, R0, R7
ADD             R6, R3
LDR             R3, [SP,#0x84+var_14]
LDR             R7, [SP,#0x84+W_0]
STR             R0, [SP,#0x84+var_2C]
AND.W           R0, LR, R9
ANDS            R4, R3
ADDS            R3, R6, R7
LDR             R7, [SP,#0x84+W_1]
LDR             R6, [SP,#0x84+var_24]
ORRS            R0, R4
ADD             R1, R0
LDR             R0, [SP,#0x84+W_2]
ADDS            R7, R5, R7
LDR             R5, [SP,#0x84+D]
ADD             R1, R3
MOV             R10, R6
MOV.W           R4, R1,ROR#13
ADDS            R5, R6, R5
MOV             LR, R5
EOR.W           R4, R4, R1,ROR#2
ADD             LR, R0
LDR             R0, [SP,#0x84+var_C]
EOR.W           R4, R4, R1,ROR#22
ADDS            R5, R3, R0
LDR             R3, [SP,#0x84+var_78]
MOV.W           R0, R5,ROR#11
STR             R5, [SP,#0x84+D]
EOR.W           R0, R0, R5,ROR#6
ORR.W           R2, R2, R3,LSL#24
LDR             R3, [SP,#0x84+E]
EOR.W           R0, R0, R5,ROR#25
LDR             R5, [SP,#0x84+var_1C]
STR             R2, [SP,#0x84+F]
EOR.W           R9, R3, R6
LDR             R6, [SP,#0x84+W_3]
ADDS            R5, R3, R5
MOV             R2, R5
LDR             R5, [SP,#0x84+D]
ADDS            R6, R2, R6
LDR             R2, [SP,#0x84+D]
STR             R6, [SP,#0x84+var_1C]
MOV             R6, R10
AND.W           R5, R9, R5
EORS            R5, R6
ADD             R8, R2
ADD             R5, R7
LDR             R2, [SP,#0x84+var_2C]
ADD             R0, R5
LDR             R5, [SP,#0x84+G]
LDR             R6, [SP,#0x84+var_28]
ORR.W           R10, R2, R1
AND.W           R9, R2, R1
ORR.W           R12, R12, R5
LDR             R5, [SP,#0x84+var_34]
AND.W           R10, R10, R6
LDR             R6, [SP,#0x84+W_1]
LDR             R2, [SP,#0x84+F]
ORR.W           R9, R10, R9
ADD             R4, R9
STR.W           R8, [SP,#0x84+var_18]
ORR.W           R12, R12, R5,LSL#8
LDR             R5, [SP,#0x84+var_30]
ADD             R4, R0
MOV             R7, R12
MOV.W           R12, R6,ROR#18
STR             R7, [SP,#0x84+G]
ORRS            R2, R5
EOR.W           R12, R12, R6,ROR#7
LDR             R5, [SP,#0x84+G]
MOV.W           R9, R7,ROR#19
temp1 = R0              ; uint32_t
E_0 = R3                ; uint32_t
H_0 = R1                ; uint32_t
LDR             R7, [SP,#0x84+var_14]
EOR.W           R12, R12, R6,LSR#3
LDR             R6, [SP,#0x84+D]
ORR.W           R8, R2, R11,LSL#8
ADD             temp1, R7
C_0 = R0                ; uint32_t
G_0 = R4                ; uint32_t
EOR.W           R9, R9, R5,ROR#17
EOR.W           R2, E_0, R6
LDR             R6, [SP,#0x84+W_0]
STR.W           R8, [SP,#0x84+var_78]
ANDS            R2, C_0
EORS            R2, E_0
MOV.W           R7, G_0,ROR#13
MOV             R8, R6
LDR             R6, [SP,#0x84+var_50]
MOV.W           R10, C_0,ROR#11
EOR.W           R5, R9, R5,LSR#10
EOR.W           R7, R7, G_0,ROR#2
ADD             LR, R2
LDR             R2, [SP,#0x84+var_2C]
ADD.W           R9, R8, R6
EOR.W           R10, R10, C_0,ROR#6
ADD             R9, R5
EOR.W           R7, R7, G_0,ROR#22
ORR.W           R5, H_0, G_0
EOR.W           R10, R10, C_0,ROR#25
ANDS            R5, R2
LDR             R6, [SP,#0x84+W_2]
AND.W           R2, H_0, G_0
ADD             LR, R10
temp1 = R14             ; uint32_t
ORRS            R5, R2
LDR             R2, [SP,#0x84+var_78]
ADD             R7, R5
ADD             R12, R9
ADD             R7, LR
MOV.W           R5, R6,ROR#18
STR             R7, [SP,#0x84+F]
LDR             E_0, [SP,#0x84+F]
EOR.W           R5, R5, R6,ROR#7
STR.W           R12, [SP,#0x84+W_0]
MOV.W           R8, R2,ROR#19
LDR             R7, [SP,#0x84+var_28]
EOR.W           R5, R5, R6,LSR#3
LDR             R6, [SP,#0x84+F]
EOR.W           R8, R8, R2,ROR#17
MOV.W           R12, R3,ROR#13
ADD             LR, R7
B_0 = R14               ; uint32_t
F_0 = R3                ; uint32_t
LDR             R7, [SP,#0x84+W_1]
EOR.W           R12, R12, F_0,ROR#2
LDR             F_0, [SP,#0x84+D]
F_0 = R6                ; uint32_t
MOV.W           R9, LR,ROR#11
EOR.W           R8, R8, R2,LSR#10
EOR.W           R12, R12, F_0,ROR#22
LDR             F_0, [SP,#0x84+var_4C]
EOR.W           R2, R3, C_0
EOR.W           R9, R9, LR,ROR#6
MOV             R10, R7
LDR             R7, [SP,#0x84+var_1C]
AND.W           R2, R2, LR
ADD             R10, R6
LDR             R6, [SP,#0x84+F]
EOR.W           R9, R9, LR,ROR#25
EORS            R3, R2
ADD             R3, R7
ADD             R8, R10
ADD             R9, R3
temp1 = R9              ; uint32_t
ORR.W           R11, G_0, R6
LDR             R3, [SP,#0x84+var_2C]
ANDS            R6, G_0
AND.W           R11, R11, H_0
ADD             R8, R5
ORR.W           R11, R11, R6
LDR             R5, [SP,#0x84+var_18]
MOV             R10, R3
ADD             R12, R11
ADD             R12, temp1
ADD             R10, temp1
A_0 = R10               ; uint32_t
E_0 = R12               ; uint32_t
LDR             R3, [SP,#0x84+F]
EOR.W           R6, C_0, LR
MOV.W           R11, A_0,ROR#11
MOV.W           R2, E_0,ROR#13
LDR             R7, [SP,#0x84+W_3]
AND.W           R6, R6, A_0
EOR.W           R11, R11, A_0,ROR#6
EOR.W           R2, R2, E_0,ROR#2
EORS            R6, C_0
ADD             R6, R5
EOR.W           R11, R11, A_0,ROR#25
ORR.W           R5, R3, E_0
EOR.W           R2, R2, E_0,ROR#22
ANDS            R5, G_0
STR.W           R8, [SP,#0x84+W_1]
AND.W           R3, R3, E_0
ADD             R11, R6
temp1 = R11             ; uint32_t
ORRS            R3, R5
ADD             H_0, temp1
ADD             R3, R2
MOV.W           R8, R7,ROR#18
ADD             temp1, R3
D_0 = R11               ; uint32_t
LDR             R3, [SP,#0x84+W_0]
EOR.W           R8, R8, R7,ROR#7
MOV.W           R6, H_0,ROR#11
MOV.W           R2, D_0,ROR#13
EOR.W           R8, R8, R7,LSR#3
LDR             R7, [SP,#0x84+B]
MOV.W           R5, R3,ROR#19
EOR.W           R6, R6, H_0,ROR#6
EOR.W           R2, R2, D_0,ROR#2
EOR.W           R5, R5, R3,ROR#17
MOV             R3, #0x59F111F1
EOR.W           R2, R2, D_0,ROR#22
ADD             R3, R7
LDR             R7, [SP,#0x84+W_2]
ADD             C_0, R3
LDR             R3, [SP,#0x84+W_0]
EOR.W           R6, R6, H_0,ROR#25
MOV             R9, R7
LDR             R7, [SP,#0x84+var_48]
EOR.W           R5, R5, R3,LSR#10
EOR.W           R3, LR, A_0
ANDS            R3, H_0
ADD             R9, R7
LDR             R7, [SP,#0x84+F]
EOR.W           R3, R3, LR
ADD             R9, R8
ADD             R3, R0
ORR.W           R0, E_0, D_0
ANDS            R0, R7
AND.W           R8, E_0, D_0
ORR.W           R8, R0, R8
ADD             R6, R3
temp1 = R6              ; uint32_t
ADD             R8, R2
ADD             G_0, temp1
ADD             temp1, R8
C_0 = R6                ; uint32_t
LDR             R7, [SP,#0x84+var_64]
MOV.W           R0, C_0,ROR#13
ADD             R9, R5
STR.W           R9, [SP,#0x84+W_2]
MOV.W           R5, G_0,ROR#11
EOR.W           R9, R0, C_0,ROR#2
LDR             R0, [SP,#0x84+H]
MOVW            R3, #0x82A4
MOV.W           R2, R7,ROR#18
MOVT            R3, #0x923F
EOR.W           R5, R5, G_0,ROR#6
ADD             R3, R0
EOR.W           R2, R2, R7,ROR#7
EOR.W           R8, A_0, H_0
EOR.W           R0, R9, C_0,ROR#22
ADD             LR, R3
LDR             R7, [SP,#0x84+F]
ORR.W           R3, D_0, C_0
AND.W           R8, R8, G_0
EOR.W           R8, R8, A_0
AND.W           R3, R3, E_0
AND.W           R9, D_0, C_0
EOR.W           R5, R5, G_0,ROR#25
ADD             LR, R8
ORR.W           R9, R3, R9
ADD             R5, LR
temp1 = R5              ; uint32_t
ADD             R0, R9
ADD             R7, temp1
F_0 = R7                ; uint32_t
LDR             R3, [SP,#0x84+var_64]
ADD             temp1, R0
B_0 = R5                ; uint32_t
MOV.W           R0, B_0,ROR#13
EOR.W           LR, H_0, G_0
MOV.W           R8, F_0,ROR#11
AND.W           LR, LR, F_0
EOR.W           R9, R0, B_0,ROR#2
LDR             R0, [SP,#0x84+W_7]
EOR.W           R2, R2, R3,LSR#3
MOV             R3, #0xAB1C5ED5
EOR.W           R8, R8, F_0,ROR#6
ADD             R3, R0
EOR.W           R0, R9, B_0,ROR#22
ADD             A_0, R3
LDR             R3, [SP,#0x84+W_3]
EOR.W           LR, LR, H_0
EOR.W           R8, R8, F_0,ROR#25
ADD             LR, R10
MOV             R9, R3
LDR             R3, [SP,#0x84+var_44]
ORR.W           R10, C_0, B_0
ADD             R8, LR
temp1 = R8              ; uint32_t
AND.W           R10, R10, D_0
ADD             E_0, temp1
ADD             R9, R3
AND.W           R3, C_0, B_0
ORR.W           R3, R10, R3
ADD             R2, R9
ADD             R0, R3
MOVW            R3, #0xAA98
ADD             temp1, R0
A_0 = R8                ; uint32_t
LDR             R0, [SP,#0x84+W_1]
MOVT            R3, #0xD807
EOR.W           R10, G_0, F_0
MOV.W           R9, E_0,ROR#11
AND.W           R10, R10, E_0
EOR.W           R10, R10, G_0
MOV.W           LR, R0,ROR#19
MOV.W           R0, A_0,ROR#13
EOR.W           R9, R9, E_0,ROR#6
EOR.W           R0, R0, A_0,ROR#2
EOR.W           R9, R9, E_0,ROR#25
STR             R0, [SP,#0x84+F]
LDR             R0, [SP,#0x84+var_54]
ADD             R3, R0
ADD             H_0, R3
LDR             R3, [SP,#0x84+F]
ADD             R1, R10
ORR.W           R10, B_0, A_0
AND.W           R10, R10, C_0
ADD             R9, R1
temp1 = R9              ; uint32_t
ADD             D_0, temp1
LDR             R1, [SP,#0x84+W_1]
EOR.W           R0, R3, A_0,ROR#22
LDR             R3, [SP,#0x84+W_1]
EOR.W           LR, LR, R3,ROR#17
AND.W           R3, B_0, A_0
ORR.W           R3, R10, R3
ADD             R0, R3
EOR.W           LR, LR, R1,LSR#10
ADD             temp1, R0
H_0 = R9                ; uint32_t
MOV.W           R1, D_0,ROR#11
MOV.W           R0, H_0,ROR#13
MOVW            R3, #0x5B01
EOR.W           R10, F_0, E_0
EOR.W           R1, R1, D_0,ROR#6
EOR.W           R0, R0, H_0,ROR#2
MOVT            R3, #0x1283
AND.W           R10, R10, D_0
EOR.W           R1, R1, D_0,ROR#25
STR             R0, [SP,#0x84+F]
EOR.W           R10, R10, F_0
LDR             R0, [SP,#0x84+var_50]
ADD             LR, R2
ORR.W           R2, A_0, H_0
STR.W           LR, [SP,#0x84+W_3]
ANDS            R2, B_0
ADD             R3, R0
ADD             G_0, R3
LDR             R3, [SP,#0x84+F]
ADD             R4, R10
ADD             R1, R4
temp1 = R1              ; uint32_t
AND.W           R4, A_0, H_0
ADD             C_0, temp1
ORRS            R4, R2
EOR.W           R0, R3, H_0,ROR#22
LDR             R2, [SP,#0x84+var_64]
MOV             R3, R6
C_0 = R3                ; uint32_t
LDR             R6, [SP,#0x84+var_40]
ADD             R4, R0
MOV.W           R0, C_0,ROR#11
ADD             R4, temp1
G_0 = R4                ; uint32_t
LDR             temp1, [SP,#0x84+B]
ADD             R2, R6
MOV             R6, C_0
STR             R6, [SP,#0x84+F]
EOR.W           R0, R0, R6,ROR#6
LDR             R6, [SP,#0x84+var_4C]
MOV             R3, #0x243185BE
MOV.W           LR, R1,ROR#18
MOV.W           R1, G_0,ROR#13
ORR.W           R10, H_0, G_0
ADD             R3, R6
LDR             R6, [SP,#0x84+F]
ADD             F_0, R3
EOR.W           R3, E_0, D_0
EOR.W           R1, R1, G_0,ROR#2
AND.W           R10, R10, A_0
ANDS            R3, R6
EOR.W           R0, R0, R6,ROR#25
LDR             R6, [SP,#0x84+B]
EOR.W           R3, R3, E_0
EOR.W           R1, R1, G_0,ROR#22
ADD             R7, R3
ADD             R7, R0
temp1 = R7              ; uint32_t
AND.W           R3, H_0, G_0
EOR.W           LR, LR, R6,ROR#7
ADDS            R6, B_0, temp1
B_0 = R6                ; uint32_t
MOV.W           R0, B_0,ROR#11
LDR             R5, [SP,#0x84+B]
ORR.W           R10, R10, R3
STR             B_0, [SP,#0x84+B]
EOR.W           R0, R0, B_0,ROR#6
LDR             B_0, [SP,#0x84+var_48]
ADD             R10, R1
MOVW            R1, #0x7DC3
ADD             temp1, R10
F_0 = R7                ; uint32_t
MOVT            R1, #0x550C
EOR.W           LR, LR, R5,LSR#3
ADD             R1, R6
LDR             R6, [SP,#0x84+B]
ADD             E_0, R1
LDR             R1, [SP,#0x84+F]
MOV.W           R3, F_0,ROR#13
ADD             R2, LR
ORR.W           LR, G_0, F_0
EOR.W           R1, D_0, R1
EOR.W           R3, R3, F_0,ROR#2
ANDS            R1, R6
EOR.W           R0, R0, R6,ROR#25
EOR.W           R1, R1, D_0
LDR             R6, [SP,#0x84+W_2]
ADD             R12, R1
AND.W           LR, LR, H_0
AND.W           R1, G_0, F_0
MOV             R10, R5
LDR             R5, [SP,#0x84+var_44]
ORR.W           LR, LR, R1
MOVW            R1, #0x5D74
EOR.W           R3, R3, F_0,ROR#22
MOVT            R1, #0x72BE
ADD             R1, R5
ADD             R12, R0
temp1 = R12             ; uint32_t
LDR             R5, [SP,#0x84+B]
ADD             R3, LR
ADD             D_0, R1
LDR             R1, [SP,#0x84+F]
ADD             A_0, temp1
LDR             R0, [SP,#0x84+G]
ADD             temp1, R3
E_0 = R12               ; uint32_t
MOV.W           R3, R6,ROR#19
MOV.W           LR, A_0,ROR#11
EORS            R1, R5
EOR.W           R3, R3, R6,ROR#17
MOV             R5, R6
LDR             R6, [SP,#0x84+F]
ADD             R10, R0
EOR.W           LR, LR, A_0,ROR#6
MOV.W           R0, E_0,ROR#13
EOR.W           R3, R3, R5,LSR#10
LDR             R5, [SP,#0x84+var_40]
AND.W           R1, R1, A_0
EOR.W           R0, R0, E_0,ROR#2
EOR.W           LR, LR, A_0,ROR#25
EORS            R1, R6
ADD             R1, R11
EOR.W           R0, R0, E_0,ROR#22
ORR.W           R11, F_0, E_0
LDR             R6, [SP,#0x84+F]
AND.W           R11, R11, G_0
ADD             LR, R1
temp1 = R14             ; uint32_t
AND.W           R1, F_0, E_0
ADD             H_0, LR
ORR.W           R1, R11, R1
MOV.W           R11, H_0,ROR#11
ADD             R0, R1
MOVW            R1, #0xB1FE
EOR.W           R11, R11, H_0,ROR#6
MOVT            R1, #0x80DE
ADD             R1, R5
LDR             R5, [SP,#0x84+B]
ADD             R6, R1
ADD             LR, R0
D_0 = R14               ; uint32_t
EOR.W           R11, R11, H_0,ROR#25
ADD             R2, R3
EOR.W           R1, R5, A_0
MOV.W           R0, LR,ROR#13
AND.W           R1, R1, H_0
STR             R2, [SP,#0x84+var_64]
EORS            R1, R5
ORR.W           R2, E_0, LR
ADD             R6, R1
ANDS            R2, F_0
ADD.W           R3, R6, R11
temp1 = R3              ; uint32_t
AND.W           R1, E_0, LR
ADD             G_0, temp1
EOR.W           R0, R0, LR,ROR#2
ORRS            R1, R2
MOV.W           R2, G_0,ROR#11
EOR.W           R0, R0, LR,ROR#22
LDR             R5, [SP,#0x84+H]
EOR.W           R2, R2, G_0,ROR#6
ADD             R0, R1
ADD             temp1, R0
C_0 = R3                ; uint32_t
EOR.W           R0, R2, G_0,ROR#25
LDR             R2, [SP,#0x84+G]
MOV             R1, #0x9BDC06A7
MOV.W           R11, R5,ROR#18
MOV.W           R6, C_0,ROR#13
ADD             R1, R2
LDR             R2, [SP,#0x84+B]
EOR.W           R6, R6, C_0,ROR#2
ADD             R2, R1
EOR.W           R1, A_0, H_0
MOV             R5, R2
LDR             R2, [SP,#0x84+H]
ANDS            R1, G_0
EOR.W           R6, R6, C_0,ROR#22
EOR.W           R11, R11, R2,ROR#7
EOR.W           R11, R11, R2,LSR#3
EOR.W           R2, R1, A_0
ADD             R5, R2
ORR.W           R1, LR, C_0
ADDS            R2, R5, R0
temp1 = R2              ; uint32_t
ADDS            R5, F_0, temp1
F_0 = R5                ; uint32_t
AND.W           R0, LR, C_0
AND.W           R1, R1, E_0
ADD             R10, R11
ORRS            R1, R0
MOV.W           R11, F_0,ROR#11
ADD             R1, R6
LDR             R7, [SP,#0x84+W_3]
MOV             R6, F_0
ADD             temp1, R1
B_0 = R2                ; uint32_t
STR             R6, [SP,#0x84+F]
EOR.W           R11, R11, R6,ROR#6
LDR             R6, [SP,#0x84+var_78]
MOV             R1, #0xC19BF174
MOV.W           F_0, R7,ROR#19
MOV.W           R0, B_0,ROR#13
ADD             R1, R6
LDR             R6, [SP,#0x84+F]
ADD             A_0, R1
EOR.W           R1, H_0, G_0
EOR.W           R5, R5, R7,ROR#17
EOR.W           R0, R0, B_0,ROR#2
ANDS            R1, R6
EOR.W           R5, R5, R7,LSR#10
EOR.W           R1, R1, H_0
LDR             R7, [SP,#0x84+W_0]
ADD             R8, R1
ORR.W           R1, C_0, B_0
AND.W           R1, R1, LR
EOR.W           R11, R11, R6,ROR#25
AND.W           R6, C_0, B_0
EOR.W           R0, R0, B_0,ROR#22
ORRS            R6, R1
MOVW            R1, #0x69C1
ADD             R11, R8
temp1 = R11             ; uint32_t
MOVT            R1, #0xE49B
ADD             E_0, temp1
ADD             R1, R7
LDR             R7, [SP,#0x84+F]
ADD             R6, R0
MOV.W           R0, E_0,ROR#11
ADD             R6, temp1
A_0 = R6                ; uint32_t
MOV.W           R8, A_0,ROR#13
EOR.W           R0, R0, E_0,ROR#6
ADD             H_0, R1
EOR.W           R1, G_0, R7
AND.W           R1, R1, E_0
EOR.W           R0, R0, E_0,ROR#25
EORS            R1, G_0
EOR.W           R8, R8, A_0,ROR#2
ADD             R10, R5
LDR             R7, [SP,#0x84+H]
STR.W           R10, [SP,#0x84+B]
ADD             R9, R1
ORR.W           R10, B_0, A_0
ADD.W           R5, R9, R0
temp1 = R5              ; uint32_t
AND.W           R1, B_0, A_0
LDR             R0, [SP,#0x84+var_78]
EOR.W           R8, R8, A_0,ROR#22
AND.W           R10, R10, C_0
ORR.W           R10, R10, R1
ADD             R8, R10
ADDS            R0, R7, R0
ADD.W           R7, temp1, R8
ADD             LR, temp1
STR             R7, [SP,#0x84+H]
MOVW            R1, #0x4786
LDR             R7, [SP,#0x84+H]
MOVT            R1, #0xEFBE
LDR             temp1, [SP,#0x84+W_7]
MOV.W           R9, LR,ROR#11
EOR.W           R9, R9, LR,ROR#6
MOV.W           R8, R7,ROR#13
MOV.W           R10, R5,ROR#18
EOR.W           R11, R9, LR,ROR#25
EOR.W           R8, R8, R7,ROR#2
LDR             R7, [SP,#0x84+W_1]
EOR.W           R10, R10, R5,ROR#7
ADD             R1, R7
LDR             R7, [SP,#0x84+H]
ADD             G_0, R1
LDR             R1, [SP,#0x84+F]
EOR.W           R8, R8, R7,ROR#22
MOV             R7, R5
LDR             R5, [SP,#0x84+F]
EOR.W           R1, R1, E_0
AND.W           R1, R1, LR
EOR.W           R10, R10, R7,LSR#3
LDR             R7, [SP,#0x84+W_2]
EOR.W           R9, R1, R5
LDR             R5, [SP,#0x84+H]
ADD             R9, R4
ADD             R0, R10
ADD             R9, R11
temp1 = R9              ; uint32_t
ORR.W           R1, A_0, R5
AND.W           R11, A_0, R5
ANDS            R1, B_0
ADD.W           R4, C_0, temp1
C_0 = R4                ; uint32_t
ORR.W           R1, R1, R11
LDR             R3, [SP,#0x84+F]
ADD             R1, R8
MOV.W           R8, C_0,ROR#11
ADD             temp1, R1
G_0 = R9                ; uint32_t
MOVW            R1, #0x9DC6
MOV.W           R11, G_0,ROR#13
MOVT            R1, #0xFC1
EOR.W           R8, R8, C_0,ROR#6
ADD             R1, R7
EOR.W           R11, R11, G_0,ROR#2
ADD             R3, R1
EOR.W           R8, R8, C_0,ROR#25
EOR.W           R1, E_0, LR
EOR.W           R11, R11, G_0,ROR#22
ANDS            R1, C_0
EOR.W           R1, R1, E_0
ORR.W           R7, R5, G_0
ADDS            R3, R1, R3
AND.W           R1, R5, G_0
LDR             R5, [SP,#0x84+var_64]
ANDS            R7, A_0
ORRS            R7, R1
ADD             R3, R8
temp1 = R3              ; uint32_t
ADD             R11, R7
ADD.W           R10, B_0, temp1
B_0 = R10               ; uint32_t
MOVW            R2, #0xA1CC
ADD             temp1, R11
F_0 = R3                ; uint32_t
MOV.W           R7, R5,ROR#19
LDR             R5, [SP,#0x84+W_3]
MOVT            R2, #0x240C
MOV.W           R8, B_0,ROR#11
MOV.W           R1, F_0,ROR#13
ADD             R2, R5
LDR             R5, [SP,#0x84+var_64]
EOR.W           R8, R8, B_0,ROR#6
ADD             E_0, R2
EOR.W           R2, LR, C_0
EOR.W           R1, R1, F_0,ROR#2
AND.W           R2, R2, B_0
EOR.W           R11, R8, B_0,ROR#25
EOR.W           R7, R7, R5,ROR#17
EOR.W           R8, R2, LR
ORR.W           R2, G_0, F_0
EOR.W           R1, R1, F_0,ROR#22
EOR.W           R7, R7, R5,LSR#10
LDR             R5, [SP,#0x84+H]
ADD             R8, R12
AND.W           R12, G_0, F_0
ADD             R8, R11
temp1 = R8              ; uint32_t
ANDS            R2, R5
ADD.W           R11, A_0, temp1
A_0 = R11               ; uint32_t
ORR.W           R2, R2, R12
ADD             R0, R7
ADD             R2, R1
MOVW            R7, #0x2C6F
ADD             temp1, R2
E_0 = R8                ; uint32_t
LDR             R2, [SP,#0x84+var_64]
STR             R0, [SP,#0x84+D]
MOVT            R7, #0x2DE9
MOV.W           R0, A_0,ROR#11
LDR             R6, [SP,#0x84+var_54]
ADD             R7, R2
MOV.W           R12, E_0,ROR#13
EOR.W           R0, R0, A_0,ROR#6
ADD             LR, R7
EOR.W           R7, C_0, B_0
EOR.W           R12, R12, E_0,ROR#2
AND.W           R7, R7, A_0
EOR.W           R2, R0, A_0,ROR#25
EOR.W           R0, R7, C_0
MOV.W           R1, R6,ROR#18
ADD             LR, R0
EOR.W           R12, R12, E_0,ROR#22
ADD.W           R0, LR, R2
temp1 = R0              ; uint32_t
EOR.W           R1, R1, R6,ROR#7
MOV             R2, R5
ADD             R2, temp1
ORR.W           R7, F_0, E_0
MOV             R5, R2
H_0 = R2                ; uint32_t
LDR             H_0, [SP,#0x84+var_54]
H_0 = R5                ; uint32_t
AND.W           R7, R7, G_0
AND.W           R6, F_0, E_0
ORRS            R6, R7
MOVW            R7, #0x84AA
ADD             R6, R12
MOVT            R7, #0x4A74
ADD             temp1, R6
D_0 = R0                ; uint32_t
EOR.W           R1, R1, R2,LSR#3
LDR             R6, [SP,#0x84+B]
MOV.W           R2, H_0,ROR#11
MOV.W           LR, D_0,ROR#13
ORR.W           R12, E_0, D_0
EOR.W           R2, R2, H_0,ROR#6
AND.W           R12, R12, F_0
ADD             R7, R6
EOR.W           LR, LR, D_0,ROR#2
EOR.W           R6, R2, H_0,ROR#25
ADD             C_0, R7
LDR             R2, [SP,#0x84+W_7]
EOR.W           R7, B_0, A_0
ANDS            R7, H_0
EOR.W           LR, LR, D_0,ROR#22
EOR.W           R7, R7, B_0
ADD             R1, R2
ADDS            R2, R7, R4
LDR             R7, [SP,#0x84+W_0]
ADD             R2, R6
temp1 = R2              ; uint32_t
AND.W           R4, E_0, D_0
ADD             G_0, temp1
ORR.W           R12, R12, R4
LDR             R4, [SP,#0x84+D]
ADDS            R6, R1, R7
ADD             R12, LR
STR             R6, [SP,#0x84+F]
ADD             temp1, R12
C_0 = R2                ; uint32_t
LDR             R6, [SP,#0x84+B]
MOV             R12, #0x5CB0A9DC
MOV.W           LR, G_0,ROR#11
MOV.W           R7, C_0,ROR#13
ADD             R12, R4
EOR.W           R4, A_0, H_0
EOR.W           LR, LR, G_0,ROR#6
MOV.W           R1, R6,ROR#19
AND.W           R4, R4, G_0
EOR.W           R4, R4, A_0
EOR.W           R7, R7, C_0,ROR#2
EOR.W           R1, R1, R6,ROR#17
ADD             R12, B_0
ADD.W           B_0, R4, R12
EOR.W           R7, R7, C_0,ROR#22
ORR.W           R12, D_0, C_0
EOR.W           R1, R1, R6,LSR#10
LDR             R6, [SP,#0x84+F]
AND.W           R12, R12, E_0
AND.W           R4, D_0, C_0
EOR.W           LR, LR, G_0,ROR#25
ORR.W           R4, R12, R4
ADD             LR, R10
temp1 = R14             ; uint32_t
ADD             R4, R7
ADD             R6, R1
ADD             F_0, LR
MOV             R1, R6
ADD             LR, R4
B_0 = R14               ; uint32_t
MOVW            R6, #0x88DA
LDR             R4, [SP,#0x84+var_50]
MOVT            R6, #0x76F9
STR             R1, [SP,#0x84+H]
ADD             R6, R1
LDR             R1, [SP,#0x84+var_50]
MOV.W           R12, F_0,ROR#11
EOR.W           R10, H_0, G_0
MOV.W           R4, R4,ROR#18
MOV.W           R7, LR,ROR#13
EOR.W           R12, R12, F_0,ROR#6
EOR.W           R4, R4, R1,ROR#7
AND.W           R10, R10, F_0
EOR.W           R12, R12, F_0,ROR#25
ADD             R6, A_0
EOR.W           R7, R7, LR,ROR#2
EOR.W           R10, R10, H_0
EOR.W           R4, R4, R1,LSR#3
LDR             R1, [SP,#0x84+D]
ORR.W           A_0, C_0, LR
EOR.W           R7, R7, LR,ROR#22
ADD             R10, R6
ADD             R10, R12
temp1 = R10             ; uint32_t
AND.W           R6, R11, D_0
AND.W           R12, C_0, LR
MOV.W           R11, R1,ROR#19
ORR.W           R6, R6, R12
ADD             R7, R6
ADD             E_0, temp1
ADD             temp1, R7
A_0 = R10               ; uint32_t
LDR             R7, [SP,#0x84+var_54]
EOR.W           R11, R11, R1,ROR#17
MOV.W           R12, E_0,ROR#11
MOV.W           R6, A_0,ROR#13
EOR.W           R11, R11, R1,LSR#10
ADD             R4, R7
LDR             R1, [SP,#0x84+var_4C]
EOR.W           R12, R12, E_0,ROR#6
LDR             R7, [SP,#0x84+W_1]
EOR.W           R6, R6, A_0,ROR#2
EOR.W           R12, R12, E_0,ROR#25
EOR.W           R6, R6, A_0,ROR#22
ADD             R4, R7
ADD             R11, R4
MOVW            R7, #0x5152
MOV.W           R4, R1,ROR#18
MOVT            R7, #0x983E
ADD             R7, R11
EOR.W           R4, R4, R1,ROR#7
ADD             H_0, R7
EOR.W           R7, G_0, F_0
AND.W           R7, R7, E_0
EOR.W           R4, R4, R1,LSR#3
LDR             R1, [SP,#0x84+H]
EOR.W           R7, R7, G_0
ADD             R7, R5
ORR.W           R5, LR, A_0
ADD             R7, R12
temp1 = R7              ; uint32_t
ANDS            R5, C_0
AND.W           R12, LR, A_0
ORR.W           R5, R5, R12
MOV.W           R12, R1,ROR#19
ADD             R5, R6
EOR.W           R12, R12, R1,ROR#17
MOV             R6, R1
ADDS            R1, D_0, temp1
D_0 = R1                ; uint32_t
STR             D_0, [SP,#0x84+var_54]
MOV.W           R0, D_0,ROR#11
LDR             D_0, [SP,#0x84+var_50]
EOR.W           R12, R12, R6,LSR#10
LDR             R6, [SP,#0x84+W_2]
ADD             temp1, R5
H_0 = R7                ; uint32_t
MOV.W           R5, H_0,ROR#13
ADD             R4, R1
ADD             R4, R6
LDR             R6, [SP,#0x84+var_48]
ADD             R12, R4
LDR             R4, [SP,#0x84+var_54]
MOV             R1, R12
MOV             R12, #0xA831C66D
STR             R1, [SP,#0x84+var_50]
ADD             R12, R1
LDR             R1, [SP,#0x84+var_54]
EOR.W           R0, R0, R4,ROR#6
MOV.W           R4, R6,ROR#18
EOR.W           R5, R5, H_0,ROR#2
EOR.W           R4, R4, R6,ROR#7
ADD             G_0, R12
EOR.W           R0, R0, R1,ROR#25
MOV             R1, R6
LDR             R6, [SP,#0x84+var_54]
EOR.W           R12, F_0, E_0
EOR.W           R5, R5, H_0,ROR#22
EOR.W           R4, R4, R1,LSR#3
LDR             R1, [SP,#0x84+var_44]
AND.W           R12, R12, R6
LDR             R6, [SP,#0x84+W_3]
EOR.W           R12, R12, F_0
ADD             R12, R9
ORR.W           R9, A_0, H_0
ADD             R0, R12
temp1 = R0              ; uint32_t
AND.W           R9, R9, LR
AND.W           R12, A_0, H_0
ADD             C_0, temp1
ORR.W           R12, R9, R12
MOV.W           R9, R11,ROR#19
ADD             R12, R5
ADD             R12, temp1
G_0 = R12               ; uint32_t
LDR             temp1, [SP,#0x84+var_4C]
EOR.W           R5, R9, R11,ROR#17
MOV.W           R9, C_0,ROR#11
EOR.W           R5, R5, R11,LSR#10
ADDS            R0, R4, R0
ADD             R0, R6
MOV.W           R4, G_0,ROR#13
ADD             R0, R5
EOR.W           R9, R9, C_0,ROR#6
MOVW            R5, #0x27C8
EOR.W           R4, R4, G_0,ROR#2
MOV             R6, R0
EOR.W           R9, R9, C_0,ROR#25
MOVT            R5, #0xB003
STR             R6, [SP,#0x84+var_4C]
ADD             R5, R6
LDR             R6, [SP,#0x84+var_50]
ADD             F_0, R5
LDR             R5, [SP,#0x84+var_54]
MOV.W           R0, R1,ROR#18
EOR.W           R4, R4, G_0,ROR#22
EOR.W           R5, E_0, R5
EOR.W           R0, R0, R1,ROR#7
ANDS            R5, C_0
EOR.W           R5, R5, E_0
EOR.W           R0, R0, R1,LSR#3
ADD             R5, R3
ORR.W           R3, H_0, G_0
ADD             R5, R9
temp1 = R5              ; uint32_t
AND.W           R3, R3, A_0
AND.W           R9, H_0, G_0
ORR.W           R3, R3, R9
MOV.W           R9, R6,ROR#19
ADD             R4, R3
ADDS            R4, temp1, R4
EOR.W           R9, R9, R6,ROR#17
MOV             R1, R4
LDR             R4, [SP,#0x84+var_48]
EOR.W           R9, R9, R6,LSR#10
LDR             R6, [SP,#0x84+var_64]
STR             R1, [SP,#0x84+F]
ADD             LR, temp1
F_0 = R1                ; uint32_t
ADDS            R4, R0, R4
MOV.W           R0, F_0,ROR#13
ADD             R4, R6
LDR             R6, [SP,#0x84+F]
ADD             R9, R4
MOVW            R4, #0x7FC7
MOV             F_0, R9
F_0 = R6                ; uint32_t
MOVT            R4, #0xBF59
ADD             R4, R1
MOV.W           R3, LR,ROR#11
ADD             E_0, R4
EOR.W           R0, R0, F_0,ROR#2
LDR             F_0, [SP,#0x84+var_40]
EOR.W           R3, R3, LR,ROR#6
LDR             R4, [SP,#0x84+F]
LDR             temp1, [SP,#0x84+var_54]
EOR.W           R3, R3, LR,ROR#25
STR             R1, [SP,#0x84+var_1C]
MOV.W           R9, R6,ROR#18
EOR.W           R0, R0, R4,ROR#22
LDR             R4, [SP,#0x84+var_54]
EOR.W           R9, R9, R6,ROR#7
EORS            R4, C_0
EOR.W           R9, R9, R6,LSR#3
AND.W           R4, R4, LR
LDR             R6, [SP,#0x84+F]
EORS            R4, R5
LDR             R5, [SP,#0x84+var_4C]
ADD             R4, R8
ORR.W           R8, G_0, R6
ADD             R4, R3
temp1 = R4              ; uint32_t
AND.W           R8, R8, H_0
AND.W           R3, G_0, R6
ORR.W           R8, R8, R3
MOV.W           R3, R5,ROR#19
ADD             R8, R0
EOR.W           R0, R3, R5,ROR#17
ADD             A_0, temp1
MOV.W           R3, A_0,ROR#11
ADD             temp1, R8
E_0 = R4                ; uint32_t
EOR.W           R0, R0, R5,LSR#10
LDR             R5, [SP,#0x84+var_44]
EOR.W           R3, R3, A_0,ROR#6
MOV.W           R8, E_0,ROR#13
ADD             R9, R5
LDR             R5, [SP,#0x84+B]
EOR.W           R3, R3, A_0,ROR#25
EOR.W           R8, R8, E_0,ROR#2
ADD             R9, R5
LDR             R5, [SP,#0x84+G]
ADD             R9, R0
MOVW            R0, #0xBF3
MOV             R6, R9
MOVT            R0, #0xC6E0
ADD             R0, R6
STR             R6, [SP,#0x84+var_48]
MOV.W           R9, R5,ROR#18
LDR             R5, [SP,#0x84+var_54]
EOR.W           R6, C_0, LR
EOR.W           R8, R8, E_0,ROR#22
AND.W           R6, R6, A_0
ADD             R0, R5
LDR             R5, [SP,#0x84+G]
EORS            R6, C_0
ADD             R6, R0
ADD             R6, R3
temp1 = R6              ; uint32_t
EOR.W           R9, R9, R5,ROR#7
ADD             H_0, temp1
EOR.W           R9, R9, R5,LSR#3
LDR             R5, [SP,#0x84+F]
H_0 = R7                ; uint32_t
MOV             R0, R5
MOV             R3, R5
ORRS            R0, E_0
ANDS            R3, E_0
AND.W           R0, R0, G_0
LDR             R5, [SP,#0x84+var_78]
ORRS            R3, R0
MOV.W           R0, R1,ROR#19
ADD             R3, R8
EOR.W           R8, R0, R1,ROR#17
LDR             R0, [SP,#0x84+var_40]
ADD             temp1, R3
D_0 = R6                ; uint32_t
MOV.W           R3, H_0,ROR#11
EOR.W           R8, R8, R1,LSR#10
LDR             R1, [SP,#0x84+D]
ADD             R9, R0
EOR.W           R3, R3, H_0,ROR#6
MOV.W           R0, D_0,ROR#13
ADD             R9, R1
EOR.W           R3, R3, H_0,ROR#25
ADD             R8, R9
MOV.W           R9, R5,ROR#18
MOV             R1, R8
EOR.W           R0, R0, D_0,ROR#2
MOVW            R8, #0x9147
STR             R1, [SP,#0x84+var_54]
MOVT            R8, #0xD5A7
EOR.W           R9, R9, R5,ROR#7
ADD             R8, R1
LDR             R1, [SP,#0x84+F]
ADD             C_0, R8
EOR.W           R8, LR, A_0
AND.W           R8, R8, H_0
EOR.W           R9, R9, R5,LSR#3
EOR.W           R8, R8, LR
LDR             R5, [SP,#0x84+G]
ADD             R8, R2
ORR.W           R2, E_0, D_0
ANDS            R2, R1
LDR             R1, [SP,#0x84+var_48]
ADD             R3, R8
temp1 = R3              ; uint32_t
AND.W           R8, E_0, D_0
ORR.W           R8, R2, R8
ADD             R9, R5
LDR             R5, [SP,#0x84+H]
EOR.W           R0, R0, D_0,ROR#22
MOV.W           R2, R1,ROR#19
ADD             R8, R0
EOR.W           R2, R2, R1,ROR#17
ADD             R9, R5
LDR             R5, [SP,#0x84+W_0]
ADD.W           R0, G_0, temp1
G_0 = R0                ; uint32_t
EOR.W           R2, R2, R1,LSR#10
ADD             R8, temp1
C_0 = R8                ; uint32_t
MOV.W           temp1, G_0,ROR#11
MOV.W           R12, C_0,ROR#13
ADD             R9, R2
MOV.W           R2, R5,ROR#18
MOV             R1, R9
EOR.W           R3, R3, G_0,ROR#6
MOVW            R9, #0x6351
EOR.W           R2, R2, R5,ROR#7
MOVT            R9, #0x6CA
EOR.W           R3, R3, G_0,ROR#25
ADD             R9, R1
EOR.W           R2, R2, R5,LSR#3
ADD             LR, R9
LDR             R5, [SP,#0x84+var_54]
EOR.W           R9, A_0, H_0
STR             R1, [SP,#0x84+var_44]
AND.W           R9, R9, G_0
LDR             R1, [SP,#0x84+F]
EOR.W           R9, R9, A_0
EOR.W           R12, R12, C_0,ROR#2
ADD             R9, LR
ORR.W           LR, D_0, C_0
ADD             R9, R3
temp1 = R9              ; uint32_t
AND.W           LR, LR, E_0
AND.W           R3, D_0, C_0
ORR.W           LR, LR, R3
MOV.W           R3, R5,ROR#19
EOR.W           R12, R12, C_0,ROR#22
ADD             R1, temp1
F_0 = R1                ; uint32_t
EOR.W           R3, R3, R5,ROR#17
STR             F_0, [SP,#0x84+G]
ADD             R12, LR
EOR.W           R3, R3, R5,LSR#10
LDR             R5, [SP,#0x84+var_78]
ADD             temp1, R12
B_0 = R9                ; uint32_t
MOV.W           R12, F_0,ROR#11
MOV.W           LR, B_0,ROR#13
ADD             R2, R5
LDR             R5, [SP,#0x84+W_1]
ADD             R2, R11
EOR.W           LR, LR, B_0,ROR#2
ADD             R2, R3
LDR             R3, [SP,#0x84+G]
MOV             F_0, R2
F_0 = R3                ; uint32_t
MOV             R2, #0x14292967
STR             R1, [SP,#0x84+var_40]
ADD             R2, R1
LDR             R1, [SP,#0x84+G]
EOR.W           R12, R12, F_0,ROR#6
MOV.W           F_0, R5,ROR#18
F_0 = R1                ; uint32_t
EOR.W           LR, LR, B_0,ROR#22
EOR.W           R3, R3, R5,ROR#7
ADD             A_0, R2
EOR.W           R12, R12, F_0,ROR#25
MOV             F_0, R5
LDR             R5, [SP,#0x84+G]
EOR.W           R2, H_0, G_0
EOR.W           R3, R3, R1,LSR#3
LDR             R1, [SP,#0x84+var_50]
ANDS            R2, R5
LDR             R5, [SP,#0x84+var_44]
EORS            R2, H_0
ADD             R2, R10
ORR.W           R10, C_0, B_0
ADD             R2, R12
temp1 = R2              ; uint32_t
AND.W           R10, R10, D_0
AND.W           R12, C_0, B_0
ADD             E_0, temp1
ORR.W           R12, R10, R12
MOV.W           R10, R5,ROR#19
ADD             LR, R12
MOV.W           R12, E_0,ROR#11
EOR.W           R10, R10, R5,ROR#17
ADD             temp1, LR
STR             R2, [SP,#0x84+F]
A_0 = R2                ; uint32_t
EOR.W           R12, R12, E_0,ROR#6
EOR.W           R10, R10, R5,LSR#10
LDR             R5, [SP,#0x84+W_0]
EOR.W           R12, R12, E_0,ROR#25
ADD.W           LR, R3, R5
LDR             R5, [SP,#0x84+W_2]
ADD             LR, R1
MOV.W           R3, A_0,ROR#13
ADD             LR, R10
MOV             R1, LR
MOV             LR, #0x27B70A85
STR             R1, [SP,#0x84+W_7]
ADD             LR, R1
EOR.W           R3, R3, A_0,ROR#2
LDR             R1, [SP,#0x84+W_2]
MOV.W           R10, R5,ROR#18
EOR.W           R3, R3, A_0,ROR#22
LDR             A_0, [SP,#0x84+G]
ADD             H_0, LR
LDR             R5, [SP,#0x84+W_1]
EOR.W           R10, R10, R1,ROR#7
EOR.W           LR, G_0, R2
LDR             R2, [SP,#0x84+F]
AND.W           LR, LR, E_0
EOR.W           R10, R10, R1,LSR#3
LDR             R1, [SP,#0x84+var_40]
EOR.W           LR, LR, G_0
ADD             LR, R7
ORR.W           R7, B_0, R2
ADD             R12, LR
temp1 = R12             ; uint32_t
AND.W           R7, R7, C_0
AND.W           LR, B_0, R2
ADD.W           R2, D_0, temp1
D_0 = R2                ; uint32_t
ORR.W           LR, R7, LR
MOV.W           R7, R1,ROR#19
LDR             R6, [SP,#0x84+var_4C]
ADD             LR, R3
EOR.W           R7, R7, R1,ROR#17
ADD             LR, temp1
H_0 = R14               ; uint32_t
ADD.W           temp1, R10, R5
LDR             R5, [SP,#0x84+W_3]
EOR.W           R7, R7, R1,LSR#10
ADD             R12, R6
MOV.W           R3, D_0,ROR#11
MOV.W           R10, LR,ROR#13
STR             D_0, [SP,#0x84+var_78]
ADD             R12, R7
MOV.W           R7, R5,ROR#18
MOV             R1, R12
EOR.W           R3, R3, D_0,ROR#6
MOVW            R12, #0x2138
EOR.W           R7, R7, R5,ROR#7
MOVT            R12, #0x2E1B
EOR.W           R3, R3, D_0,ROR#25
ADD             R12, R1
EOR.W           R10, R10, LR,ROR#2
ADD             R12, G_0
LDR             G_0, [SP,#0x84+G]
MOV             R6, R5
LDR             R5, [SP,#0x84+G]
EOR.W           R10, R10, LR,ROR#22
EOR.W           R7, R7, R6,LSR#3
LDR             R6, [SP,#0x84+var_64]
EORS            R0, E_0
STR             R1, [SP,#0x84+var_18]
ANDS            R0, D_0
EORS            R0, R5
LDR             R5, [SP,#0x84+F]
ADD             R0, R12
ADD             R3, R0
temp1 = R3              ; uint32_t
ORR.W           R12, R5, LR
AND.W           R0, R5, LR
LDR             R5, [SP,#0x84+W_7]
AND.W           R12, R12, B_0
ORR.W           R0, R12, R0
ADD             C_0, temp1
ADD             R0, R10
ADD             R0, temp1
G_0 = R0                ; uint32_t
MOV.W           temp1, C_0,ROR#11
MOV.W           R12, R5,ROR#19
EOR.W           R3, R3, C_0,ROR#6
EOR.W           R12, R12, R5,ROR#17
EOR.W           R3, R3, C_0,ROR#25
EOR.W           R12, R12, R5,LSR#10
LDR             R5, [SP,#0x84+W_2]
ADD.W           R10, R7, R5
LDR             R5, [SP,#0x84+var_1C]
MOV.W           R7, G_0,ROR#13
ADD             R10, R5
EOR.W           R7, R7, G_0,ROR#2
ADD             R12, R10
STR.W           R12, [SP,#0x84+W_1]
MOVW            R10, #0x6DFC
LDR             R5, [SP,#0x84+W_1]
MOVT            R10, #0x4D2C
MOV.W           R12, R6,ROR#18
EOR.W           R7, R7, G_0,ROR#22
ADD             R10, R5
LDR             R5, [SP,#0x84+G]
EOR.W           R12, R12, R6,ROR#7
ADD             R5, R10
EOR.W           R10, E_0, D_0
AND.W           R10, R10, C_0
LDR             D_0, [SP,#0x84+F]
EOR.W           R10, R10, E_0
EOR.W           R12, R12, R6,LSR#3
ADD             R10, R5
LDR             R6, [SP,#0x84+var_48]
ORR.W           R5, LR, G_0
ADD             R10, R3
temp1 = R10             ; uint32_t
ANDS            R5, R2
AND.W           R3, LR, G_0
ORRS            R5, R3
MOV.W           R3, R1,ROR#19
ADD             R7, R5
LDR             R5, [SP,#0x84+W_3]
EOR.W           R3, R3, R1,ROR#17
ADD             B_0, temp1
ADD             temp1, R7
F_0 = R10               ; uint32_t
MOV.W           R7, B_0,ROR#11
EOR.W           R3, R3, R1,LSR#10
ADD             R5, R12
ADD             R5, R6
LDR             R6, [SP,#0x84+B]
ADDS            R3, R5, R3
LDR             R2, [SP,#0x84+var_78]
MOV             R1, R3
EOR.W           R3, R7, B_0,ROR#6
MOVW            R7, #0xD13
MOV.W           R12, F_0,ROR#13
MOVT            R7, #0x5338
MOV.W           R5, R6,ROR#18
ADD             R7, R1
STR             R1, [SP,#0x84+W_3]
ADD             E_0, R7
EOR.W           R7, R2, C_0
EOR.W           R5, R5, R6,ROR#7
AND.W           R7, R7, B_0
EOR.W           R3, R3, B_0,ROR#25
MOV             R1, R6
EOR.W           R12, R12, F_0,ROR#2
EORS            R7, R2
EOR.W           R5, R5, R1,LSR#3
ADD             R7, R4
LDR             R1, [SP,#0x84+W_1]
ORR.W           R4, G_0, F_0
ADD             R7, R3
temp1 = R7              ; uint32_t
EOR.W           R12, R12, F_0,ROR#22
AND.W           R3, G_0, F_0
LDR             R2, [SP,#0x84+F]
AND.W           R4, R4, LR
LDR             R6, [SP,#0x84+var_64]
ORRS            R4, R3
MOV.W           R3, R1,ROR#19
ADD             R12, R4
ADD.W           R4, temp1, R12
ADD             R2, temp1
A_0 = R2                ; uint32_t
MOV             temp1, R4
E_0 = R4                ; uint32_t
EOR.W           R3, R3, R1,ROR#17
ADD             R5, R6
MOV.W           E_0, R7,ROR#13
E_0 = R7                ; uint32_t
MOV             R6, E_0
LDR             E_0, [SP,#0x84+var_54]
E_0 = R6                ; uint32_t
EOR.W           R3, R3, R1,LSR#10
MOV.W           R12, A_0,ROR#11
EOR.W           R4, R4, E_0,ROR#2
STR             E_0, [SP,#0x84+F]
ADD             R5, R7
EOR.W           R12, R12, A_0,ROR#6
ADDS            R7, R5, R3
EOR.W           R4, R4, E_0,ROR#22
MOVW            R3, #0x7354
STR             R7, [SP,#0x84+var_64]
MOVT            R3, #0x650A
EOR.W           E_0, C_0, B_0
ADD             R3, R7
LDR             R7, [SP,#0x84+var_78]
ANDS            R6, A_0
EOR.W           R12, R12, A_0,ROR#25
EOR.W           R6, R6, C_0
LDR             R1, [SP,#0x84+D]
ADD             R3, R7
LDR             R7, [SP,#0x84+F]
ADD             R6, R3
ADD             R6, R12
temp1 = R6              ; uint32_t
ORR.W           R3, F_0, R7
AND.W           R12, F_0, R7
LDR             R7, [SP,#0x84+W_3]
ANDS            R3, G_0
ORR.W           R12, R3, R12
MOV.W           R5, R1,ROR#18
ADD             LR, temp1
EOR.W           R5, R5, R1,ROR#7
ADD             R4, R12
MOV.W           R3, R7,ROR#19
ADD             temp1, R4
D_0 = R6                ; uint32_t
EOR.W           R5, R5, R1,LSR#3
MOV.W           R4, LR,ROR#11
EOR.W           R3, R3, R7,ROR#17
MOV.W           R12, D_0,ROR#13
EOR.W           R4, R4, LR,ROR#6
EOR.W           R3, R3, R7,LSR#10
LDR             R7, [SP,#0x84+B]
EOR.W           R4, R4, LR,ROR#25
EOR.W           R12, R12, D_0,ROR#2
ADD             R5, R7
LDR             R7, [SP,#0x84+var_44]
EOR.W           R12, R12, D_0,ROR#22
ADD             R5, R7
ADD             R5, R3
MOVW            R3, #0xABB
MOV             R7, R5
LDR             R5, [SP,#0x84+H]
MOVT            R3, #0x766A
STR             R7, [SP,#0x84+var_34]
ADD             R3, R7
LDR             R7, [SP,#0x84+H]
ADD             R3, C_0
EOR.W           C_0, B_0, A_0
MOV.W           R5, R5,ROR#18
AND.W           R8, R8, LR
EOR.W           R8, R8, B_0
EOR.W           R5, R5, R7,ROR#7
ADD             R8, R3
ADD             R4, R8
temp1 = R4              ; uint32_t
EOR.W           R5, R5, R7,LSR#3
LDR             R7, [SP,#0x84+F]
ADD             G_0, temp1
STR             G_0, [SP,#0x84+G]
ADD             R5, R1
AND.W           R8, R7, D_0
MOV             R3, R7
LDR             R7, [SP,#0x84+var_64]
ORRS            R3, D_0
AND.W           R3, R3, F_0
ORR.W           R8, R3, R8
ADD             R8, R12
MOV.W           R3, R7,ROR#19
ADD             R8, temp1
C_0 = R8                ; uint32_t
MOV.W           temp1, G_0,ROR#11
LDR             G_0, [SP,#0x84+H]
EOR.W           R3, R3, R7,ROR#17
MOV.W           R12, C_0,ROR#13
EOR.W           R3, R3, R7,LSR#10
LDR             R7, [SP,#0x84+var_40]
EOR.W           R12, R12, C_0,ROR#2
ADD             R5, R7
LDR             R7, [SP,#0x84+G]
ADD             R5, R3
MOVW            R3, #0xC92E
MOV             R1, R5
MOVT            R3, #0x81C2
ADD             R3, R1
STR             R1, [SP,#0x84+B]
EOR.W           R4, R4, R7,ROR#6
ADD             R3, B_0
EOR.W           B_0, A_0, LR
LDR             R1, [SP,#0x84+F]
MOV.W           R5, R11,ROR#18
EOR.W           R4, R4, R7,ROR#25
EOR.W           R12, R12, C_0,ROR#22
AND.W           R9, R9, R7
LDR             R7, [SP,#0x84+var_34]
EOR.W           R9, R9, A_0
EOR.W           R5, R5, R11,ROR#7
ADD             R9, R3
ORR.W           R3, D_0, C_0
ADD             R4, R9
temp1 = R4              ; uint32_t
ANDS            R3, R1
AND.W           R9, D_0, C_0
EOR.W           R5, R5, R11,LSR#3
ORR.W           R9, R3, R9
MOV.W           R3, R7,ROR#19
ADD             F_0, temp1
ADD             R0, R5
LDR             R5, [SP,#0x84+W_7]
EOR.W           R3, R3, R7,ROR#17
MOV             R1, R0
ADD             R9, R12
MOV.W           R12, F_0,ROR#11
EOR.W           R3, R3, R7,LSR#10
LDR             R7, [SP,#0x84+var_50]
ADD             R1, R5
ADDS            R5, R1, R3
LDR             R1, [SP,#0x84+G]
ADD             R9, temp1
B_0 = R9                ; uint32_t
MOV             R0, R5
MOV.W           R3, R7,ROR#18
EOR.W           R5, R12, F_0,ROR#6
MOV.W           temp1, B_0,ROR#13
MOVW            R12, #0x2C85
EOR.W           R3, R3, R7,ROR#7
EOR.W           R1, LR, R1
EOR.W           R5, R5, F_0,ROR#25
MOVT            R12, #0x9272
EOR.W           R4, R4, B_0,ROR#2
ADD             R12, R0
EOR.W           R3, R3, R7,LSR#3
AND.W           R1, R1, F_0
LDR             R7, [SP,#0x84+B]
ADD             A_0, R12
EOR.W           R1, R1, LR
ORR.W           R12, C_0, B_0
ADD             R1, R2
ADD             R1, R5
temp1 = R1              ; uint32_t
AND.W           R2, R12, D_0
AND.W           R5, C_0, B_0
EOR.W           R4, R4, B_0,ROR#22
ORRS            R2, R5
MOV.W           R5, R7,ROR#19
ADD             R4, R2
LDR             R2, [SP,#0x84+F]
EOR.W           R5, R5, R7,ROR#17
ADD             R11, R3
MOV             R7, R2
LDR             R2, [SP,#0x84+var_18]
ADD             R7, temp1
E_0 = R7                ; uint32_t
ADD             temp1, R4
A_0 = R1                ; uint32_t
LDR             R4, [SP,#0x84+B]
MOV.W           R12, E_0,ROR#11
ADD             R11, R2
EOR.W           R12, R12, E_0,ROR#6
EOR.W           R4, R5, R4,LSR#10
MOV.W           R5, A_0,ROR#13
EOR.W           R12, R12, E_0,ROR#25
ADD             R11, R4
EOR.W           R5, R5, A_0,ROR#2
STR.W           R11, [SP,#0x84+D]
MOVW            R11, #0xE8A1
LDR             R3, [SP,#0x84+var_4C]
MOVT            R11, #0xA2BF
LDR             R2, [SP,#0x84+D]
EOR.W           R5, R5, A_0,ROR#22
STR             R0, [SP,#0x84+H]
ADD             R11, R2
MOV.W           R4, R3,ROR#18
LDR             R2, [SP,#0x84+G]
ADD             LR, R11
EOR.W           R4, R4, R3,ROR#7
MOV             R11, R3
LDR             R3, [SP,#0x84+G]
EOR.W           R2, R2, F_0
EOR.W           R4, R4, R11,LSR#3
ANDS            R2, E_0
ORR.W           R11, B_0, A_0
EORS            R2, R3
ADD             R2, LR
AND.W           R3, R11, C_0
AND.W           LR, B_0, A_0
ADD             R2, R12
temp1 = R2              ; uint32_t
ORR.W           R3, R3, LR
MOV.W           LR, R0,ROR#19
ADD             R5, R3
EOR.W           LR, LR, R0,ROR#17
MOV             R3, R0
ADDS            R0, temp1, R5
LDR             R5, [SP,#0x84+var_50]
EOR.W           LR, LR, R3,LSR#10
LDR             R3, [SP,#0x84+var_1C]
ADD             D_0, temp1
ADD             R4, R5
LDR             R5, [SP,#0x84+W_1]
MOV             temp1, R0
H_0 = R0                ; uint32_t
MOV.W           R11, D_0,ROR#11
MOV.W           R12, R2,ROR#13
STR             R2, [SP,#0x84+var_78]
ADD             R4, R5
EOR.W           R11, R11, D_0,ROR#6
ADD             LR, R4
MOV.W           R4, R3,ROR#18
MOV             H_0, LR
H_0 = R2                ; uint32_t
EOR.W           R12, R12, H_0,ROR#2
EOR.W           R4, R4, R3,ROR#7
MOV             LR, #0xA81A664B
STR             R0, [SP,#0x84+var_50]
ADD             LR, R0
EOR.W           R4, R4, R3,LSR#3
LDR             R0, [SP,#0x84+G]
EOR.W           R12, R12, H_0,ROR#22
LDR             R3, [SP,#0x84+var_78]
EOR.W           R5, F_0, E_0
LDR             H_0, [SP,#0x84+D]
H_0 = R3                ; uint32_t
ANDS            R5, D_0
ADD             R0, LR
EOR.W           R5, R5, F_0
ORR.W           LR, A_0, H_0
ADD             R5, R0
AND.W           R0, A_0, H_0
AND.W           H_0, LR, B_0
MOV.W           LR, R2,ROR#19
ORRS            R3, R0
LDR             R0, [SP,#0x84+var_4C]
EOR.W           R11, R11, D_0,ROR#25
EOR.W           LR, LR, R2,ROR#17
ADD             R12, R3
ADD             R5, R11
temp1 = R5              ; uint32_t
EOR.W           LR, LR, R2,LSR#10
LDR             R2, [SP,#0x84+W_3]
ADDS            R0, R4, R0
ADD             C_0, temp1
ADD             temp1, R12
G_0 = R5                ; uint32_t
ADD.W           R12, R0, R2
LDR             R2, [SP,#0x84+var_48]
MOV.W           R3, C_0,ROR#11
ADD             LR, R12
STR.W           LR, [SP,#0x84+var_30]
MOVW            R12, #0x8B70
EOR.W           LR, R3, C_0,ROR#6
LDR             R0, [SP,#0x84+var_30]
MOV.W           R3, R2,ROR#18
MOVT            R12, #0xC24B
MOV.W           R4, G_0,ROR#13
EOR.W           LR, LR, C_0,ROR#25
EOR.W           R3, R3, R2,ROR#7
ADD             R12, R0
EOR.W           R4, R4, G_0,ROR#2
EOR.W           R0, E_0, D_0
EOR.W           R3, R3, R2,LSR#3
LDR             R2, [SP,#0x84+var_78]
AND.W           R0, R0, C_0
ADD             F_0, R12
EORS            R0, E_0
ADD             R0, R10
EOR.W           R4, R4, G_0,ROR#22
ORR.W           R12, R2, G_0
AND.W           R10, R2, G_0
LDR             R2, [SP,#0x84+var_50]
ADD             R0, LR
temp1 = R0              ; uint32_t
AND.W           LR, R12, A_0
ORR.W           LR, LR, R10
ADD             B_0, temp1
ADD             R4, LR
MOV.W           LR, B_0,ROR#11
MOV.W           R12, R2,ROR#19
ADD             temp1, R4
F_0 = R0                ; uint32_t
LDR             R4, [SP,#0x84+var_1C]
EOR.W           LR, LR, B_0,ROR#6
EOR.W           R12, R12, R2,ROR#17
EOR.W           LR, LR, B_0,ROR#25
EOR.W           R12, R12, R2,LSR#10
LDR             R2, [SP,#0x84+var_64]
ADD             R3, R4
MOV.W           R4, F_0,ROR#13
ADD             R3, R2
LDR             R2, [SP,#0x84+var_54]
ADD             R12, R3
EOR.W           R11, R4, F_0,ROR#2
STR.W           R12, [SP,#0x84+F]
MOVW            R12, #0x51A3
LDR             R4, [SP,#0x84+F]
MOVT            R12, #0xC76C
MOV.W           R3, R2,ROR#18
ADD             R12, R4
EOR.W           R4, R11, F_0,ROR#22
EOR.W           R11, D_0, C_0
EOR.W           R3, R3, R2,ROR#7
AND.W           R11, R11, B_0
ADD             E_0, R12
EOR.W           R11, R11, D_0
EOR.W           R3, R3, R2,LSR#3
ADD             R11, R7
LDR             R2, [SP,#0x84+var_30]
ORR.W           R12, G_0, F_0
LDR             R7, [SP,#0x84+var_78]
ADD             R11, LR
temp1 = R11             ; uint32_t
AND.W           LR, G_0, F_0
ADD             A_0, temp1
AND.W           R7, R12, R7
EOR.W           R12, C_0, B_0
ORR.W           R7, R7, LR
MOV.W           LR, R2,ROR#19
ADD             R4, R7
MOV.W           R7, A_0,ROR#11
EOR.W           LR, LR, R2,ROR#17
ADD             temp1, R4
E_0 = R11               ; uint32_t
EOR.W           R10, R7, A_0,ROR#6
MOV.W           R4, E_0,ROR#13
EOR.W           LR, LR, R2,LSR#10
LDR             R2, [SP,#0x84+var_48]
AND.W           R12, R12, A_0
EOR.W           R4, R4, E_0,ROR#2
EOR.W           R12, R12, C_0
ADD             R3, R2
LDR             R2, [SP,#0x84+var_34]
EOR.W           R4, R4, E_0,ROR#22
ADD             R3, R2
LDR             R2, [SP,#0x84+var_44]
ADD             LR, R3
STR.W           LR, [SP,#0x84+G]
MOVW            LR, #0xE819
LDR             R7, [SP,#0x84+G]
MOVT            LR, #0xD192
MOV.W           R3, R2,ROR#18
EOR.W           R3, R3, R2,ROR#7
ADD             LR, R7
ADD             D_0, LR
EOR.W           R7, R10, A_0,ROR#25
EOR.W           R3, R3, R2,LSR#3
LDR             R2, [SP,#0x84+F]
ORR.W           LR, F_0, E_0
ADD             R12, R6
AND.W           R6, LR, G_0
ADD             R12, R7
temp1 = R12             ; uint32_t
AND.W           R7, F_0, E_0
ORRS            R6, R7
MOV.W           R7, R2,ROR#19
ADD             R4, R6
EOR.W           R7, R7, R2,ROR#17
MOV             R6, R2
LDR             R2, [SP,#0x84+var_78]
EOR.W           R10, B_0, A_0
ADD             R2, temp1
H_0 = R2                ; uint32_t
ADD             temp1, R4
D_0 = R12               ; uint32_t
EOR.W           R4, R7, R6,LSR#10
LDR             R6, [SP,#0x84+var_54]
MOV.W           R7, D_0,ROR#13
MOV.W           LR, H_0,ROR#11
ADD             R3, R6
LDR             R6, [SP,#0x84+B]
EOR.W           R7, R7, D_0,ROR#2
AND.W           R10, R10, H_0
EOR.W           LR, LR, H_0,ROR#6
EOR.W           R10, R10, B_0
ADD             R3, R6
STR             R7, [SP,#0x84+W_0]
ADDS            R4, R3, R4
LDR             R3, [SP,#0x84+var_40]
STR             R4, [SP,#0x84+var_78]
MOVW            R4, #0x624
LDR             R7, [SP,#0x84+var_78]
MOVT            R4, #0xD699
EOR.W           LR, LR, H_0,ROR#25
MOV.W           R6, R3,ROR#18
ADD             R4, R7
LDR             R7, [SP,#0x84+W_0]
EOR.W           R6, R6, R3,ROR#7
ADD             R4, C_0
ORR.W           C_0, E_0, D_0
EOR.W           R6, R6, R3,LSR#3
ADD             R10, R4
AND.W           R3, R8, F_0
EOR.W           R7, R7, D_0,ROR#22
AND.W           R4, E_0, D_0
ORRS            R3, R4
LDR             R4, [SP,#0x84+G]
ADD             R10, LR
temp1 = R10             ; uint32_t
ADD             R7, R3
ADD             G_0, temp1
ADD             temp1, R7
C_0 = R10               ; uint32_t
LDR             R7, [SP,#0x84+var_44]
MOV.W           R8, G_0,ROR#11
MOV.W           LR, R4,ROR#19
EOR.W           R8, R8, G_0,ROR#6
EOR.W           LR, LR, R4,ROR#17
ADD             R6, R7
LDR             R7, [SP,#0x84+H]
EOR.W           R8, R8, G_0,ROR#25
EOR.W           R3, LR, R4,LSR#10
MOV.W           LR, C_0,ROR#13
ADD             R6, R7
EOR.W           LR, LR, C_0,ROR#2
ADDS            R4, R6, R3
LDR             R3, [SP,#0x84+W_7]
STR             R4, [SP,#0x84+W_2]
MOVW            R4, #0x3585
LDR             R7, [SP,#0x84+W_2]
MOVT            R4, #0xF40E
EOR.W           LR, LR, C_0,ROR#22
MOV.W           R6, R3,ROR#18
ADD             R4, R7
EOR.W           R7, A_0, H_0
EOR.W           R6, R6, R3,ROR#7
ANDS            R7, G_0
ADD             R4, B_0
EORS            R7, A_0
ORR.W           B_0, D_0, C_0
EOR.W           R6, R6, R3,LSR#3
ADD             R7, R4
AND.W           R3, R9, E_0
AND.W           R4, D_0, C_0
ORRS            R3, R4
LDR             R4, [SP,#0x84+var_78]
ADD             LR, R3
LDR             R3, [SP,#0x84+var_78]
ADD             R7, R8
temp1 = R7              ; uint32_t
MOVW            R9, #0xA070
ADD             F_0, temp1
ADD             temp1, LR
MOV.W           R4, R4,ROR#19
STR             R7, [SP,#0x84+W_0]
LDR             R7, [SP,#0x84+W_0]
MOVT            R9, #0x106A
EOR.W           R4, R4, R3,ROR#17
EOR.W           LR, H_0, G_0
AND.W           LR, LR, F_0
MOV.W           R8, F_0,ROR#11
EOR.W           R4, R4, R3,LSR#10
LDR             R3, [SP,#0x84+var_40]
EOR.W           LR, LR, H_0
EOR.W           R8, R8, F_0,ROR#6
ADDS            R3, R6, R3
MOV.W           R6, R7,ROR#13
LDR             R7, [SP,#0x84+D]
EOR.W           R8, R8, F_0,ROR#25
ADD             R3, R7
ADDS            R4, R3, R4
LDR             R3, [SP,#0x84+var_18]
MOV             R7, R4
LDR             R4, [SP,#0x84+W_0]
STR             R7, [SP,#0x84+var_54]
ADD             R9, R7
LDR             R7, [SP,#0x84+W_0]
ADD             A_0, R9
ADD             LR, R1
LDR             R1, [SP,#0x84+W_0]
EOR.W           R6, R6, R4,ROR#2
MOV.W           R4, R3,ROR#18
EOR.W           R6, R6, R7,ROR#22
LDR             R7, [SP,#0x84+W_2]
EOR.W           R4, R4, R3,ROR#7
ORR.W           R9, C_0, R1
AND.W           R1, C_0, R1
EOR.W           R4, R4, R3,LSR#3
AND.W           R3, R9, D_0
MOV.W           R9, R7,ROR#19
ORRS            R3, R1
LDR             R1, [SP,#0x84+W_7]
ADD             LR, R8
temp1 = R14             ; uint32_t
EOR.W           R9, R9, R7,ROR#17
ADD             R6, R3
MOVW            R3, #0xC116
EOR.W           R9, R9, R7,LSR#10
LDR             R7, [SP,#0x84+var_50]
ADD             R4, R1
MOVT            R3, #0x19A4
ADD             E_0, LR
ADD             R4, R7
LDR             R7, [SP,#0x84+W_1]
ADD.W           R8, R4, R9
LDR             R4, [SP,#0x84+W_1]
STR.W           R8, [SP,#0x84+var_4C]
ADD             R3, R8
EOR.W           R8, G_0, F_0
ADD             LR, R6
A_0 = R14               ; uint32_t
AND.W           R8, R8, E_0
MOV.W           R6, E_0,ROR#11
MOV.W           R4, R4,ROR#18
ADD             R3, H_0
EOR.W           R8, R8, G_0
EOR.W           R6, R6, E_0,ROR#6
EOR.W           R4, R4, R7,ROR#7
ADD             R8, R3
LDR             R3, [SP,#0x84+W_0]
MOV.W           R1, LR,ROR#13
EOR.W           R4, R4, R7,LSR#3
LDR             R7, [SP,#0x84+var_54]
EOR.W           R6, R6, E_0,ROR#25
EOR.W           R1, R1, LR,ROR#2
ORR.W           H_0, R3, LR
ADD             R8, R6
temp1 = R8              ; uint32_t
AND.W           R6, R3, LR
AND.W           R3, R2, C_0
MOV.W           R2, R7,ROR#19
EOR.W           R1, R1, LR,ROR#22
ORRS            R3, R6
EOR.W           R2, R2, R7,ROR#17
LDR             R6, [SP,#0x84+var_18]
ADD             R1, R3
ADD             D_0, temp1
EOR.W           R2, R2, R7,LSR#10
ADD             temp1, R1
H_0 = R8                ; uint32_t
LDR             R7, [SP,#0x84+W_3]
LDR             R1, [SP,#0x84+var_30]
ADD             R4, R6
MOVW            R3, #0x6C08
MOV.W           R9, D_0,ROR#11
MOVT            R3, #0x1E37
MOV.W           R6, H_0,ROR#13
ADD             R4, R1
EOR.W           R9, R9, D_0,ROR#6
ADD             R2, R4
MOV.W           R4, R7,ROR#18
ADD             R3, R2
EOR.W           R6, R6, H_0,ROR#2
EOR.W           R4, R4, R7,ROR#7
ADD             R3, G_0
EOR.W           R1, F_0, E_0
EOR.W           R9, R9, D_0,ROR#25
EOR.W           R4, R4, R7,LSR#3
LDR             R7, [SP,#0x84+W_0]
ORR.W           G_0, LR, H_0
EOR.W           R6, R6, H_0,ROR#22
AND.W           R1, R1, D_0
ANDS            R5, R7
LDR             R7, [SP,#0x84+var_4C]
EORS            R1, F_0
ADD             R1, R3
AND.W           R3, LR, H_0
ORRS            R5, R3
ADD             R1, R9
temp1 = R1              ; uint32_t
MOV.W           R3, R7,ROR#19
ADD             R5, R6
ADD             C_0, temp1
ADD             temp1, R5
G_0 = R1                ; uint32_t
LDR             R5, [SP,#0x84+W_1]
EOR.W           R6, R3, R7,ROR#17
LDR             R3, [SP,#0x84+F]
MOV.W           R9, C_0,ROR#11
EOR.W           R6, R6, R7,LSR#10
ADD             R4, R5
ADDS            R3, R4, R3
MOV.W           R5, G_0,ROR#13
ADDS            R3, R6, R3
LDR             R6, [SP,#0x84+var_64]
MOVW            R4, #0x774C
MOV             R7, R3
MOVT            R4, #0x2748
EOR.W           R9, R9, C_0,ROR#6
ADD             R4, R7
EOR.W           R5, R5, G_0,ROR#2
MOV.W           R3, R6,ROR#18
ADD             F_0, R4
EOR.W           R4, E_0, D_0
EOR.W           R9, R9, C_0,ROR#25
EOR.W           R3, R3, R6,ROR#7
AND.W           R4, R4, C_0
EOR.W           R4, R4, E_0
EOR.W           R5, R5, G_0,ROR#22
EOR.W           R3, R3, R6,LSR#3
ADD             R4, R0
LDR             R6, [SP,#0x84+W_0]
ORR.W           R0, H_0, G_0
ADD             R4, R9
temp1 = R4              ; uint32_t
AND.W           R0, R0, LR
AND.W           R9, H_0, G_0
STR             R7, [SP,#0x84+var_44]
ORR.W           R9, R0, R9
MOV.W           R0, R2,ROR#19
ADD             R5, R9
MOV             R9, R6
LDR             R6, [SP,#0x84+W_3]
EOR.W           R0, R0, R2,ROR#17
ADD             R9, temp1
ADD             temp1, R5
ADD             R3, R6
LDR             R6, [SP,#0x84+G]
EOR.W           R0, R0, R2,LSR#10
STR             R4, [SP,#0x84+W_0]
MOV             R7, R9
B_0 = R7                ; uint32_t
F_0 = R4                ; uint32_t
MOV.W           R9, F_0,ROR#13
ADD             R3, R6
LDR             R6, [SP,#0x84+var_34]
ADDS            R0, R3, R0
LDR             R3, [SP,#0x84+W_0]
MOV             F_0, R0
F_0 = R3                ; uint32_t
MOV             R0, #0x34B0BCB5
MOV.W           R5, B_0,ROR#11
ADD             R0, R4
STR             R4, [SP,#0x84+var_40]
ADD             E_0, R0
LDR             R0, [SP,#0x84+W_0]
EOR.W           R9, R9, F_0,ROR#2
MOV.W           F_0, R6,ROR#18
F_0 = R0                ; uint32_t
EOR.W           R5, R5, B_0,ROR#6
LDR             R4, [SP,#0x84+var_44]
EOR.W           R3, R3, R6,ROR#7
EOR.W           R9, R9, F_0,ROR#22
EOR.W           F_0, D_0, C_0
ANDS            R0, B_0
EOR.W           R3, R3, R6,LSR#3
LDR             R6, [SP,#0x84+W_0]
EOR.W           R5, R5, B_0,ROR#25
EOR.W           R0, R0, D_0
ADD             R0, R11
ADD             R0, R5
temp1 = R0              ; uint32_t
ORR.W           R11, G_0, R6
AND.W           R5, G_0, R6
LDR             R6, [SP,#0x84+var_64]
AND.W           R11, R11, H_0
ADD             LR, temp1
ORR.W           R11, R11, R5
MOV.W           R5, R4,ROR#19
ADD             R3, R6
LDR             R6, [SP,#0x84+var_78]
ADD             R11, R9
EOR.W           R9, R5, R4,ROR#17
MOV.W           R5, LR,ROR#11
ADD             temp1, R11
E_0 = R0                ; uint32_t
ADD             R3, R6
EOR.W           R9, R9, R4,LSR#10
LDR             R6, [SP,#0x84+B]
EOR.W           R5, R5, LR,ROR#6
ADD             R9, R3
MOV.W           R11, E_0,ROR#13
MOV             R4, R9
EOR.W           R5, R5, LR,ROR#25
MOVW            R9, #0xCB3
STR             R4, [SP,#0x84+W_7]
MOV.W           R3, R6,ROR#18
MOVT            R9, #0x391C
ADD             R9, R4
LDR             R4, [SP,#0x84+W_0]
ADD             D_0, R9
EOR.W           R3, R3, R6,ROR#7
EOR.W           R9, C_0, B_0
EOR.W           R11, R11, E_0,ROR#2
AND.W           R9, R9, LR
EOR.W           R3, R3, R6,LSR#3
EOR.W           R9, R9, C_0
LDR             R6, [SP,#0x84+var_40]
ADD             R9, R12
ORR.W           R12, R4, E_0
ADD             R9, R5
temp1 = R9              ; uint32_t
MOV             R5, R4
AND.W           R12, R12, G_0
ANDS            R5, E_0
ORR.W           R5, R12, R5
MOV.W           R12, R6,ROR#19
EOR.W           R11, R11, E_0,ROR#22
ADD             H_0, temp1
EOR.W           R12, R12, R6,ROR#17
ADD             R11, R5
EOR.W           R12, R12, R6,LSR#10
LDR             R6, [SP,#0x84+var_34]
ADD             temp1, R11
D_0 = R9                ; uint32_t
MOV.W           R11, H_0,ROR#11
MOV.W           R5, D_0,ROR#13
ADD             R3, R6
LDR             R6, [SP,#0x84+W_2]
EOR.W           R11, R11, H_0,ROR#6
EOR.W           R5, R5, D_0,ROR#2
ADD             R3, R6
LDR             R6, [SP,#0x84+H]
ADD             R12, R3
MOVW            R3, #0xAA4A
MOV             R4, R12
MOVT            R3, #0x4ED8
ADD             R3, R4
STR             R4, [SP,#0x84+var_34]
ADD             R3, C_0
EOR.W           C_0, B_0, LR
LDR             R4, [SP,#0x84+W_0]
AND.W           R10, R10, H_0
EOR.W           R10, R10, B_0
MOV.W           R12, R6,ROR#18
ADD             R10, R3
EOR.W           R11, R11, H_0,ROR#25
ORR.W           R3, E_0, D_0
EOR.W           R12, R12, R6,ROR#7
ANDS            R3, R4
LDR             R4, [SP,#0x84+W_7]
ADD             R11, R10
temp1 = R11             ; uint32_t
AND.W           R10, E_0, D_0
ORR.W           R10, R3, R10
EOR.W           R12, R12, R6,LSR#3
LDR             R6, [SP,#0x84+B]
EOR.W           R5, R5, D_0,ROR#22
MOV.W           R3, R4,ROR#19
ADD             R10, R5
EOR.W           R3, R3, R4,ROR#17
ADD.W           R5, G_0, temp1
G_0 = R5                ; uint32_t
ADD             R10, temp1
C_0 = R10               ; uint32_t
MOV.W           temp1, G_0,ROR#11
EOR.W           R1, R3, R4,LSR#10
ADD.W           R3, R12, R6
LDR             R6, [SP,#0x84+var_54]
EOR.W           R11, R11, G_0,ROR#6
MOV.W           R12, C_0,ROR#13
EOR.W           R11, R11, G_0,ROR#25
ADD             R3, R6
LDR             R6, [SP,#0x84+D]
ADDS            R1, R3, R1
MOVW            R3, #0xCA4F
MOV             R4, R1
MOVT            R3, #0x5B9C
ADD             R3, R4
EOR.W           R12, R12, C_0,ROR#2
MOV.W           R1, R6,ROR#18
ADD             R3, B_0
EOR.W           B_0, LR, H_0
EOR.W           R12, R12, C_0,ROR#22
EOR.W           R1, R1, R6,ROR#7
ANDS            R7, G_0
EOR.W           R7, R7, LR
STR             R4, [SP,#0x84+B]
EOR.W           R1, R1, R6,LSR#3
LDR             R6, [SP,#0x84+var_34]
ADD             R7, R3
LDR             R4, [SP,#0x84+W_0]
ORR.W           R3, D_0, C_0
ADD             R11, R7
temp1 = R11             ; uint32_t
ANDS            R3, E_0
AND.W           R7, D_0, C_0
ORRS            R7, R3
MOV.W           R3, R6,ROR#19
ADD             R7, R12
EOR.W           R3, R3, R6,ROR#17
ADD             R7, temp1
STR             R7, [SP,#0x84+W_0]
F_0 = R4                ; uint32_t
ADD             F_0, temp1
B_0 = R7                ; uint32_t
EOR.W           R3, R3, R6,LSR#10
LDR             R6, [SP,#0x84+H]
LDR             B_0, [SP,#0x84+var_4C]
MOV.W           temp1, F_0,ROR#11
ADD             R1, R6
LDR             R6, [SP,#0x84+W_0]
ADD             R1, R7
EOR.W           R11, R11, F_0,ROR#6
ADD             R1, R3
MOVW            R3, #0x6FF3
MOV             R7, R1
MOV.W           R12, R6,ROR#13
MOVT            R3, #0x682E
STR             R7, [SP,#0x84+H]
ADD             R3, R7
EOR.W           R12, R12, R6,ROR#2
LDR             R7, [SP,#0x84+W_0]
LDR             R6, [SP,#0x84+var_50]
ADD             R3, LR
EOR.W           LR, H_0, G_0
EOR.W           R11, R11, F_0,ROR#25
AND.W           LR, LR, F_0
EOR.W           R12, R12, R7,ROR#22
LDR             R7, [SP,#0x84+W_0]
MOV.W           R1, R6,ROR#18
EOR.W           LR, LR, H_0
ADD             R3, LR
EOR.W           R1, R1, R6,ROR#7
ADD             R11, R3
temp1 = R11             ; uint32_t
ORR.W           LR, C_0, R7
AND.W           R3, C_0, R7
LDR             R7, [SP,#0x84+B]
EOR.W           R1, R1, R6,LSR#3
LDR             R6, [SP,#0x84+D]
AND.W           LR, LR, D_0
ORR.W           LR, LR, R3
ADD             E_0, temp1
MOV.W           R3, R7,ROR#19
ADD             R1, R6
LDR             R6, [SP,#0x84+B]
ADD             R12, LR
EOR.W           R3, R3, R7,ROR#17
ADD.W           LR, R12, temp1
ADD             R1, R2
MOV.W           temp1, E_0,ROR#11
MOV             R7, LR
A_0 = R7                ; uint32_t
EOR.W           R3, R3, R6,LSR#10
MOV.W           R12, A_0,ROR#13
EOR.W           R2, R11, E_0,ROR#6
ADDS            R3, R1, R3
EOR.W           R12, R12, A_0,ROR#2
STR             R3, [SP,#0x84+var_64]
MOV             R6, A_0
LDR             R1, [SP,#0x84+var_64]
MOVW            LR, #0x82EE
LDR             A_0, [SP,#0x84+var_30]
A_0 = R6                ; uint32_t
MOVT            LR, #0x748F
EOR.W           R11, G_0, F_0
EOR.W           R2, R2, E_0,ROR#25
ADD             LR, R1
LDR             R1, [SP,#0x84+H]
ADD             H_0, LR
AND.W           R11, R11, E_0
MOV.W           R3, R7,ROR#18
EOR.W           R11, R11, G_0
ADD             R11, R8
EOR.W           R12, R12, A_0,ROR#22
EOR.W           LR, R3, R7,ROR#7
MOV.W           R3, R1,ROR#19
LDR             R1, [SP,#0x84+H]
ADD             R2, R11
temp1 = R2              ; uint32_t
STR             A_0, [SP,#0x84+var_48]
MOV             R11, A_0
EOR.W           LR, LR, R7,LSR#3
ADD             R9, temp1
EOR.W           R3, R3, R1,ROR#17
LDR             R1, [SP,#0x84+W_0]
STR.W           R9, [SP,#0x84+W_1]
ORR.W           R8, R1, A_0
LDR             A_0, [SP,#0x84+W_0]
A_0 = R11               ; uint32_t
AND.W           R8, R8, C_0
AND.W           R1, R6, A_0
LDR             R6, [SP,#0x84+var_50]
ORR.W           R1, R8, R1
ADD             R1, R12
ADD             LR, R6
LDR             R6, [SP,#0x84+H]
EOR.W           R3, R3, R6,LSR#10
ADDS            R6, temp1, R1
H_0 = R6                ; uint32_t
STR             H_0, [SP,#0x84+W_3]
MOV.W           R8, H_0,ROR#13
LDR             H_0, [SP,#0x84+var_44]
MOV             temp1, R9
MOV.W           R1, R2,ROR#11
MOV             R12, R6
EOR.W           R1, R1, R9,ROR#6
ADD             R12, LR
MOV             R6, R12
EOR.W           R9, F_0, E_0
ADD             R3, R6
LDR             R6, [SP,#0x84+W_3]
MOV             R12, #0x78A5636F
ADD             R12, R3
EOR.W           R8, R8, R6,ROR#2
LDR             R6, [SP,#0x84+F]
LDR             R2, [SP,#0x84+var_64]
MOV.W           LR, R6,ROR#18
LDR             R6, [SP,#0x84+W_1]
AND.W           R9, R9, R6
EOR.W           A_0, R1, R6,ROR#25
LDR             R6, [SP,#0x84+F]
LDR             R1, [SP,#0x84+W_3]
EOR.W           R9, R9, F_0
EOR.W           LR, LR, R6,ROR#7
EOR.W           R8, R8, R1,ROR#22
ADD.W           R1, R12, G_0
EOR.W           LR, LR, R6,LSR#3
MOV.W           G_0, R2,ROR#19
LDR             R6, [SP,#0x84+var_48]
ADD             LR, R7
LDR             R7, [SP,#0x84+var_64]
EOR.W           R5, R5, R2,ROR#17
LDR             R2, [SP,#0x84+W_3]
ADD             R9, R1
LDR             R1, [SP,#0x84+W_0]
ORR.W           R12, R6, R2
EOR.W           R5, R5, R7,LSR#10
MOV             R2, R6
LDR             R7, [SP,#0x84+var_40]
LDR             R6, [SP,#0x84+W_3]
AND.W           R12, R12, R1
ADD.W           R1, R9, R11
temp1 = R1              ; uint32_t
MOVW            R11, #0x7814
ADD             LR, R7
ADD.W           R9, C_0, temp1
C_0 = R9                ; uint32_t
ANDS            R6, R2
LDR             R7, [SP,#0x84+W_1]
ORR.W           R6, R12, R6
ADD.W           R12, LR, R5
LDR             R5, [SP,#0x84+G]
MOV             R2, C_0
MOV.W           C_0, C_0,ROR#11
C_0 = R2                ; uint32_t
ADD             R6, R8
ADD             temp1, R6
G_0 = R1                ; uint32_t
LDR             R6, [SP,#0x84+W_3]
EOR.W           R9, R9, C_0,ROR#6
EOR.W           R10, E_0, R7
MOV.W           R8, G_0,ROR#13
MOV.W           LR, R5,ROR#18
STR             C_0, [SP,#0x84+var_50]
EOR.W           R9, R9, C_0,ROR#25
AND.W           R10, R10, C_0
LDR             C_0, [SP,#0x84+var_48]
MOV             R7, R5
EOR.W           R8, R8, G_0,ROR#2
EOR.W           LR, LR, R5,ROR#7
MOVT            R11, #0x84C8
MOV             R5, R6
EOR.W           R8, R8, G_0,ROR#22
ADD             R11, R12
EOR.W           LR, LR, R7,LSR#3
ORRS            R5, G_0
LDR             R7, [SP,#0x84+W_0]
EOR.W           R10, R10, E_0
ANDS            R5, R2
ADD             F_0, R11
ANDS            R6, G_0
MOV.W           R11, R3,ROR#19
ADD             R4, R10
ORRS            R6, R5
ADD             R4, R9
temp1 = R4              ; uint32_t
ADD.W           R5, R8, R6
EOR.W           R11, R11, R3,ROR#17
ADD.W           R10, R5, temp1
LDR             R5, [SP,#0x84+F]
ADD             R7, temp1
B_0 = R7                ; uint32_t
F_0 = R10               ; uint32_t
EOR.W           R11, R11, R3,LSR#10
LDR             R3, [SP,#0x84+W_7]
MOV.W           R8, B_0,ROR#11
MOV             R2, B_0
ADD             R5, LR
LDR             R6, [SP,#0x84+var_78]
ADD             R5, R3
LDR             R3, [SP,#0x84+W_1]
ADD             R11, R5
LDR             R5, [SP,#0x84+var_50]
EOR.W           R8, R8, B_0,ROR#6
STR             R2, [SP,#0x84+W_0]
MOV.W           B_0, #0x208
B_0 = R2                ; uint32_t
LDR             temp1, [SP,#0x84+var_78]
EOR.W           R9, R3, R5
EOR.W           R8, R8, B_0,ROR#25
AND.W           R9, R9, B_0
LDR             B_0, [SP,#0x84+W_2]
MOVT            R7, #0x8CC7
MOV.W           R6, R6,ROR#18
ADD             R7, R11
MOV.W           R5, R12,ROR#19
ADD             E_0, R7
EOR.W           R6, R6, R4,ROR#7
MOV.W           R7, R2,ROR#18
EOR.W           R9, R9, R3
EOR.W           R6, R6, R4,LSR#3
ORR.W           R4, G_0, F_0
EOR.W           R7, R7, R2,ROR#7
LDR             R2, [SP,#0x84+W_3]
MOV.W           LR, F_0,ROR#13
EOR.W           R5, R5, R12,ROR#17
ANDS            R4, R2
LDR             R2, [SP,#0x84+W_2]
ADD             R0, R9
EOR.W           LR, LR, F_0,ROR#2
EOR.W           R5, R5, R12,LSR#10
MOV.W           R12, R11,ROR#19
EOR.W           LR, LR, F_0,ROR#22
EOR.W           R9, R7, R2,LSR#3
LDR             R2, [SP,#0x84+var_54]
AND.W           R3, G_0, F_0
EOR.W           R12, R12, R11,ROR#17
ORRS            R4, R3
STR.W           R9, [SP,#0x84+F]
ADD.W           R3, LR, R4
EOR.W           LR, R12, R11,LSR#10
MOV.W           R7, R2,ROR#18
LDR             R4, [SP,#0x84+var_48]
STR.W           LR, [SP,#0x84+var_44]
ADD             R0, R8
temp1 = R0              ; uint32_t
EOR.W           R11, R7, R2,ROR#7
LDR             R7, [SP,#0x84+G]
ADD             R3, temp1
ADD             R4, temp1
A_0 = R4                ; uint32_t
E_0 = R3                ; uint32_t
MOVW            R9, #0xFFFA
ADD             R6, R7
LDR             R7, [SP,#0x84+var_34]
LDR             temp1, [SP,#0x84+W_0]
MOV             R2, A_0
MOV.W           A_0, A_0,ROR#11
A_0 = R2                ; uint32_t
MOV.W           R12, E_0,ROR#13
STR             A_0, [SP,#0x84+G]
ADDS            R7, R6, R7
LDR             R6, [SP,#0x84+var_50]
ADD             R5, R7
EOR.W           R4, R4, A_0,ROR#6
MOV.W           R7, R5,ROR#19
MOVT            R9, #0x90BE
EOR.W           R8, R6, R0
LDR             R6, [SP,#0x84+var_54]
LDR             R0, [SP,#0x84+W_1]
EOR.W           R7, R7, R5,ROR#17
EOR.W           R4, R4, A_0,ROR#25
ADD             R9, R5
AND.W           R8, R8, A_0
LDR             A_0, [SP,#0x84+var_4C]
EOR.W           LR, R11, R6,LSR#3
ORR.W           R6, F_0, E_0
EOR.W           R11, R7, R5,LSR#10
EOR.W           R12, R12, E_0,ROR#2
STR.W           LR, [SP,#0x84+var_48]
AND.W           R5, F_0, E_0
ADD             R9, R0
ANDS            R6, G_0
LDR             R0, [SP,#0x84+var_50]
ORRS            R6, R5
LDR             R5, [SP,#0x84+F]
EOR.W           R12, R12, E_0,ROR#22
MOV.W           LR, R2,ROR#18
STR.W           R11, [SP,#0x84+W_1]
EOR.W           R8, R8, R0
ADD             R6, R12
ADD             R9, R8
MOV             R12, R5
LDR             R5, [SP,#0x84+var_78]
ADD             R9, R4
temp1 = R9              ; uint32_t
EOR.W           LR, LR, R2,ROR#7
LDR             R4, [SP,#0x84+B]
ADD.W           R0, R6, temp1
MOV             R7, R2
LDR             R2, [SP,#0x84+W_3]
ADD.W           R11, R12, R5
MOV.W           R6, R0,ROR#13
EOR.W           LR, LR, R7,LSR#3
ADD             R11, R4
LDR             R4, [SP,#0x84+var_44]
ADD             R2, temp1
D_0 = R0                ; uint32_t
H_0 = R2                ; uint32_t
LDR             R7, [SP,#0x84+W_0]
MOV.W           R5, H_0,ROR#11
STR.W           LR, [SP,#0x84+var_78]
EOR.W           LR, R6, D_0,ROR#2
LDR             R6, [SP,#0x84+G]
ADD.W           R12, R11, R4
MOVW            temp1, #0x6CEB
LDR             R4, [SP,#0x84+var_50]
EOR.W           R5, R5, H_0,ROR#6
MOVT            R9, #0xA450
EORS            R6, R7
EOR.W           LR, LR, D_0,ROR#22
ADD             R9, R12
EOR.W           R5, R5, H_0,ROR#25
ANDS            R6, H_0
MOV.W           R11, R12,ROR#19
EORS            R6, R7
ADD             R9, R4
ORR.W           R8, E_0, D_0
ADD             R9, R6
AND.W           R7, E_0, D_0
ADD             R9, R5
temp1 = R9              ; uint32_t
AND.W           R8, R8, F_0
LDR             R5, [SP,#0x84+W_2]
ORR.W           R8, R8, R7
MOVW            R7, #0xA3F7
ADD.W           R6, G_0, temp1
G_0 = R6                ; uint32_t
MOVT            R7, #0xBEF9
STR             G_0, [SP,#0x84+F]
ADD             R7, R5
MOV.W           R5, G_0,ROR#11
LDR             G_0, [SP,#0x84+var_48]
ADD             R8, LR
LDR             R1, [SP,#0x84+H]
ADD.W           R4, R8, temp1
C_0 = R4                ; uint32_t
MOV.W           temp1, C_0,ROR#13
EOR.W           R11, R11, R12,ROR#17
ADD             R7, R6
LDR             R6, [SP,#0x84+G]
ADD             R7, R1
LDR             R1, [SP,#0x84+W_1]
EOR.W           R9, R9, C_0,ROR#2
EOR.W           R11, R11, R12,LSR#10
EOR.W           LR, R6, H_0
LDR             R6, [SP,#0x84+F]
ADD             R7, R1
LDR             R1, [SP,#0x84+F]
AND.W           R8, D_0, C_0
EOR.W           R9, R9, C_0,ROR#22
EOR.W           R5, R5, R6,ROR#6
AND.W           LR, LR, R1
ORR.W           R6, D_0, C_0
EOR.W           R5, R5, R1,ROR#25
LDR             R1, [SP,#0x84+W_0]
ANDS            R6, E_0
ORR.W           R6, R6, R8
ADD             R7, R1
LDR             R1, [SP,#0x84+G]
ADD             R6, R9
EOR.W           LR, LR, R1
LDR             R1, [SP,#0x84+var_78]
ADD             LR, R7
LDR             R7, [SP,#0x84+var_54]
ADD             R5, LR
temp1 = R5              ; uint32_t
MOV             LR, #0xC67178F2
ADD             R6, temp1
ADD             LR, R7
MOV.W           R9, R6,ROR#13
ADD             LR, R1
LDR             R1, [SP,#0x84+F]
EOR.W           R9, R9, R6,ROR#2
ADD             temp1, F_0
B_0 = R6                ; uint32_t
F_0 = R5                ; uint32_t
ORR.W           R10, C_0, B_0
MOV.W           R7, F_0,ROR#11
EOR.W           R12, H_0, R1
LDR             R1, [SP,#0x84+var_64]
EOR.W           R9, R9, B_0,ROR#22
AND.W           R10, R10, D_0
AND.W           R8, C_0, B_0
EOR.W           R7, R7, F_0,ROR#6
ADD             LR, R1
LDR             R1, [SP,#0x84+G]
ADD             LR, R11
ORR.W           R8, R10, R8
ADD             R8, R9
AND.W           R12, R12, F_0
ADD             LR, R1
LDR             R1, [SP,#0x84+E]
EOR.W           R12, R12, H_0
EOR.W           R7, R7, F_0,ROR#25
ADD             LR, R12
ADD             E_0, R1
LDR             R1, [SP,#0x84+var_2C]
ADD             LR, R7
temp1 = R14             ; uint32_t
LDR             R7, [SP,#0x84+var_28]
ADD             R3, LR
ADD             R8, R1
LDR             R1, [SP,#0x84+var_8]
ADD             B_0, R7
ADD.W           R7, R8, LR
MOV             R12, R1
LDR             R1, [SP,#0x84+var_C]
ADD             R12, H_0
LDR             H_0, [SP,#0x84+F]
ADD             D_0, R1
LDR             R1, [SP,#0x84+var_10]
ADD             R2, R1
MOV             R1, R2
LDR             R2, [SP,#0x84+var_14]
ADD             C_0, R2
LDR             R2, [SP,#0x84+var_24]
ADD             F_0, R2
LDR             R2, [SP,#0x84+ctx]
STR.W           R12, [R2,#0x24]
STR             R0, [R2,#0x14]
STR             R1, [R2,#0x20]
STR             R4, [R2,#0x10]
STR             R6, [R2,#0xC]
STR             R5, [R2,#0x1C]
STR             R7, [R2,#8]
STR             R3, [R2,#0x18]
ADD             SP, SP, #0x84
POP.W           {R4-R11,PC}
; End of function sha2_process

ALIGN 0x10



; void __fastcall sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen)
EXPORT sha2_update
sha2_update
ctx = R0                ; sha2_context *
input = R1              ; const unsigned __int8 *
ilen = R2               ; int
PUSH.W          {R4-R8,LR}
SUBS            R4, ilen, #0
BLE             locret_1F7BE
LDR             R3, [ctx]
MOV             R6, ctx
MOV             R5, input
AND.W           R7, R3, #0x3F ; '?'
left = R7               ; uint32_t
ADD             R3, R4
CMP             R4, R3
STR             R3, [ctx]
IT HI
LDRHI           R3, [ctx,#4]
RSB.W           LR, left, #0x40 ; '@'
fill = R14              ; int
ITT HI
ADDHI           R3, #1
STRHI           R3, [ctx,#4]
MOVS            R3, left
IT NE
MOVNE           R3, #1
CMP             R4, LR
IT LT
MOVLT           R3, #0
CBNZ            R3, loc_1F7C2
CMP             R4, #0x3F ; '?'
BLE             loc_1F7AC

loc_1F798               ; data
ctx = R6                ; sha2_context *
input = R5              ; const unsigned __int8 *
ilen = R4               ; int
MOV             R1, input
SUBS            ilen, #0x40 ; '@'
MOV             R0, ctx ; ctx
ADDS            input, #0x40 ; '@'
input = R1              ; const unsigned __int8 *
BL              sha2_process
input = R5              ; const unsigned __int8 *
ilen = R4               ; int
CMP             ilen, #0x3F ; '?'
BGT             loc_1F798

loc_1F7A8
CMP             ilen, #0
BLE             locret_1F7BE

loc_1F7AC
ADD.W           R0, ctx, #0x28 ; '('
MOV             R2, ilen ; n
ADD             R0, R7  ; dest
MOV             R1, input ; src
POP.W           {ilen-R8,LR}
input = R1              ; const unsigned __int8 *
ilen = R2               ; int
B.W             j_memcpy

locret_1F7BE
ilen = R4               ; int
POP.W           {ilen-R8,PC}

loc_1F7C2
ctx = R0                ; sha2_context *
input = R1              ; const unsigned __int8 *
ilen = R2               ; int
fill = R14              ; int
left = R7               ; uint32_t
ADD.W           R8, ctx, #0x28 ; '('
MOV             ilen, LR ; n
ilen = R4               ; int
ADD.W           ctx, R8, left ; dest
ctx = R6                ; sha2_context *
SUBS            ilen, ilen, R2
ADD             R5, LR
MOVS            left, #0
BLX             memcpy
MOV             R1, R8  ; data
MOV             R0, ctx ; ctx
BL              sha2_process
input = R5              ; const unsigned __int8 *
ilen = R4               ; int
CMP             ilen, #0x3F ; '?'
BGT             loc_1F798
B               loc_1F7A8
; End of function sha2_update




; void __fastcall sha2_finish(sha2_context *ctx, unsigned __int8 *output)
EXPORT sha2_finish
sha2_finish

msglen= -0xC

ctx = R0                ; sha2_context *
output = R1             ; unsigned __int8 *
LDR             R3, [ctx]
PUSH            {R4-R7,LR}
MOV             R4, ctx
LDR             ctx, [ctx,#4]
ctx = R4                ; sha2_context *
MOV             R5, output
SUB             SP, SP, #0xC
AND.W           R2, R3, #0x3F ; '?'
LSRS            output, R3, #0x1D
output = R5             ; unsigned __int8 *
LSLS            R3, R3, #3
ORR.W           R1, R1, R0,LSL#3
last = R2               ; uint32_t
high = R1               ; uint32_t
low = R3                ; uint32_t
LSRS            R0, low, #0x10
LSRS            R6, low, #0x18
STRB.W          low, [SP,#0xC+msglen+7]
MOV.W           LR, high,LSR#24
STRB.W          high, [SP,#0xC+msglen+3]
LSRS            R7, high, #0x10
LSRS            high, high, #8
LSRS            low, low, #8
STRB.W          R0, [SP,#0xC+msglen+5]
CMP             last, #0x37 ; '7'
STRB.W          R1, [SP,#0xC+msglen+2]
MOVW            R1, #:lower16:sha2_padding
ITE LS
RSBLS.W         last, last, #0x38 ; '8'
RSBHI.W         R2, R2, #0x78 ; 'x' ; ilen
padn = R2               ; uint32_t
MOV             R0, ctx ; ctx
MOVT            R1, #:upper16:sha2_padding ; input
STRB.W          R3, [SP,#0xC+msglen+6]
STRB.W          LR, [SP,#0xC+msglen]
STRB.W          R7, [SP,#0xC+msglen+1]
STRB.W          R6, [SP,#0xC+msglen+4]
BL              sha2_update
MOVS            R2, #8  ; ilen
MOV             R1, SP  ; input
MOV             R0, ctx ; ctx
BL              sha2_update
LDRB            R3, [ctx,#0xB]
STRB            R3, [output]
LDRH            R3, [ctx,#0xA]
STRB            R3, [output,#1]
LDR             R3, [ctx,#8]
LSRS            R3, R3, #8
STRB            R3, [output,#2]
LDR             R3, [ctx,#8]
STRB            R3, [output,#3]
LDRB            R3, [ctx,#0xF]
STRB            R3, [output,#4]
LDRH            R3, [ctx,#0xE]
STRB            R3, [output,#5]
LDR             R3, [ctx,#0xC]
LSRS            R3, R3, #8
STRB            R3, [output,#6]
LDR             R3, [ctx,#0xC]
STRB            R3, [output,#7]
LDRB            R3, [ctx,#0x13]
STRB            R3, [output,#8]
LDRH            R3, [ctx,#0x12]
STRB            R3, [output,#9]
LDR             R3, [ctx,#0x10]
LSRS            R3, R3, #8
STRB            R3, [output,#0xA]
LDR             R3, [ctx,#0x10]
STRB            R3, [output,#0xB]
LDRB            R3, [ctx,#0x17]
STRB            R3, [output,#0xC]
LDRH            R3, [ctx,#0x16]
STRB            R3, [output,#0xD]
LDR             R3, [ctx,#0x14]
LSRS            R3, R3, #8
STRB            R3, [output,#0xE]
LDR             R3, [ctx,#0x14]
STRB            R3, [output,#0xF]
LDRB            R3, [ctx,#0x1B]
STRB            R3, [output,#0x10]
LDRH            R3, [ctx,#0x1A]
STRB            R3, [output,#0x11]
LDR             R3, [ctx,#0x18]
LSRS            R3, R3, #8
STRB            R3, [output,#0x12]
LDR             R3, [ctx,#0x18]
STRB            R3, [output,#0x13]
LDRB            R3, [ctx,#0x1F]
STRB            R3, [output,#0x14]
LDRH            R3, [ctx,#0x1E]
STRB            R3, [output,#0x15]
LDR             R3, [ctx,#0x1C]
LSRS            R3, R3, #8
STRB            R3, [output,#0x16]
LDR             R3, [ctx,#0x1C]
STRB            R3, [output,#0x17]
LDRB.W          R3, [ctx,#0x23]
STRB            R3, [output,#0x18]
LDRH            R3, [ctx,#0x22]
STRB            R3, [output,#0x19]
LDR             R3, [ctx,#0x20]
LSRS            R3, R3, #8
STRB            R3, [output,#0x1A]
LDR             R3, [ctx,#0x20]
STRB            R3, [output,#0x1B]
LDRB.W          R3, [ctx,#0x27]
STRB            R3, [output,#0x1C]
LDRH            R3, [ctx,#0x26]
STRB            R3, [output,#0x1D]
LDR             R3, [ctx,#0x24]
LSRS            R3, R3, #8
STRB            R3, [output,#0x1E]
LDR             R3, [ctx,#0x24]
STRB            R3, [output,#0x1F]
ADD             SP, SP, #0xC
POP             {ctx-R7,PC}
; End of function sha2_finish

ALIGN 4



; void __fastcall sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output)
EXPORT sha2
sha2

ctx= -0xE8

input = R0              ; const unsigned __int8 *
ilen = R1               ; int
output = R2             ; unsigned __int8 *
MOVW            R3, #0xE667
PUSH.W          {R4-R8,LR}
MOVT            R3, #0x6A09
SUB             SP, SP, #0xE8
MOVW            R5, #0xAE85
MOVW            R4, #0xF372
STR             R3, [SP,#0xE8+ctx.state]
MOVT            R5, #0xBB67
MOVT            R4, #0x3C6E
MOVW            R3, #0x688C
STR             R5, [SP,#0xE8+ctx.state+4]
MOVT            R3, #0x9B05
STR             R4, [SP,#0xE8+ctx.state+8]
MOVW            R7, #0xF53A
MOVW            R6, #0x527F
MOVW            R5, #0xD9AB
MOVW            R4, #0xCD19
MOV             R8, output
STR             R3, [SP,#0xE8+ctx.state+0x14]
MOV             output, ilen ; ilen
output = R8             ; unsigned __int8 *
MOVS            R3, #0
MOV             ilen, input ; input
ilen = R2               ; int
MOVT            R7, #0xA54F
MOV             input, SP ; ctx
input = R1              ; const unsigned __int8 *
MOVT            R6, #0x510E
MOVT            R5, #0x1F83
MOVT            R4, #0x5BE0
STR             R3, [SP,#0xE8+ctx]
STR             R3, [SP,#0xE8+ctx.total+4]
STR             R7, [SP,#0xE8+ctx.state+0xC]
STR             R6, [SP,#0xE8+ctx.state+0x10]
STR             R5, [SP,#0xE8+ctx.state+0x18]
STR             R4, [SP,#0xE8+ctx.state+0x1C]
BL              sha2_update
MOV             R1, output ; output
MOV             R0, SP  ; ctx
BL              sha2_finish
ADD             SP, SP, #0xE8
POP.W           {R4-output,PC}
; End of function sha2

ALIGN 0x10



; uint32_t __fastcall swab32(uint32_t v)
EXPORT swab32
swab32
v = R0                  ; uint32_t
REV             v, v
BX              LR
; End of function swab32




; void __fastcall flip_swab(void *dest_p, const void *src_p, unsigned int length)
EXPORT flip_swab
flip_swab
length = R2             ; unsigned int
dest = R0               ; uint32_t *
src = R1                ; const uint32_t *
LSRS            length, length, #2
BEQ             locret_1F97C
ADD.W           R2, src, R2,LSL#2
SUBS            dest, #4

loc_1F96E
LDR.W           R3, [R1],#4
CMP             R1, R2
REV             R3, R3
STR.W           R3, [R0,#4]!
BNE             loc_1F96E

locret_1F97C
BX              LR
; End of function flip_swab

ALIGN 0x10



; void __fastcall flip32(void *dest_p, const void *src_p)
EXPORT flip32
flip32
dest = R0               ; uint32_t *
src = R1                ; const uint32_t *
SUBS            R2, src, #4
SUBS            dest, #4
ADDS            src, #0x1C

loc_1F986
LDR.W           R3, [R2,#4]!
CMP             R2, R1
REV             R3, R3
STR.W           R3, [R0,#4]!
BNE             loc_1F986
BX              LR
; End of function flip32

ALIGN 4



; void *__fastcall BHB07601_send_func(void *arg)
EXPORT BHB07601_send_func
BHB07601_send_func

var_9C= -0x9C
var_90= -0x90
which_core= -0x8C
works= -0x88
var_84= -0x84
var_80= -0x80
var_7C= -0x7C
which_asic= -0x78
var_74= -0x74
var_70= -0x70
work_vil_1397= -0x6C
buf_vil= -0x38
var_4= -4

arg = R0                ; void *
work = R9               ; work *
MOV             R3, arg
chain_info = R0         ; chain_info *
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x9C
LDRB            R6, [chain_info]
which_chain = R6        ; unsigned __int8
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
LDRB            R5, [R3,#1]
which_i2c = R5          ; unsigned __int8
ADD             chain_info, SP, #0x9C+buf_vil ; s
chain_info = R3         ; chain_info *
BLX             memset
MOVW            R4, #:lower16:gBegin_Get_Nonce
MOVW            R1, #:lower16:__FUNCTION__.8427 ; "BHB07601_send_func"
MOVW            R0, #:lower16:aSWhichChainDWh_0 ; "\n--- %s: which_chain = %d, which_i2c ="...
MOV             R3, which_i2c
MOV             R2, which_chain
MOVT            R1, #:upper16:__FUNCTION__.8427 ; "BHB07601_send_func"
MOVT            R0, #:upper16:aSWhichChainDWh_0 ; "\n--- %s: which_chain = %d, which_i2c ="...
MOVT            R4, #:upper16:gBegin_Get_Nonce
BLX             printf
LDRB            R3, [R4]
CBNZ            R3, loc_1F9E6
MOVS            R0, #7  ; address
BL              read_axi_fpga
ORR.W           R1, R0, #0x10000 ; data
MOVS            R0, #7  ; address
BL              write_axi_fpga
MOVS            R3, #1
STRB            R3, [R4]

loc_1F9E6
MOV             R3, #BHB07601_ASIC_NUMBER
STR             R3, [SP,#0x9C+var_70]
LDR             R3, [R3]
CMP             R3, #0
BEQ.W           loc_1FC16
MOVW            R3, #:lower16:Conf
MOVW            R8, #:lower16:gReadingTemp
MOV             R1, R3
ORR.W           R3, which_chain, #0x80
MOV             R2, R3
STR             R3, [SP,#0x9C+var_84]
MOV             R3, R1
LSLS            R2, R2, #0x10
MOVT            R3, #:upper16:Conf
MOV             R1, R3
STR             R3, [SP,#0x9C+var_90]
ADD.W           R3, which_chain, which_chain,LSL#4
LDR.W           work, [R1,#configuration.pattern_number]
MOVW            R7, #:lower16:gSend_Work_Num
LDR             R1, =(cgpu.workdataFilePrefix+0x3C)
LSLS            R3, R3, #9
MOVT            R8, #:upper16:gReadingTemp
MOVT            R7, #:upper16:gSend_Work_Num
STR             R3, [SP,#0x9C+var_7C]
MOVS            R4, #0
ORR.W           R3, R2, #0x1000000
STR             R1, [SP,#0x9C+var_74]
STR             R3, [SP,#0x9C+var_80]
STR             R4, [SP,#0x9C+which_asic]

loc_1FA3C
work_id = R4            ; unsigned int
LDR             R3, [SP,#0x9C+var_74]
MOV             R2, R3
LDR.W           R3, [R2,#4]!
STR             R3, [SP,#0x9C+works]
MOVS            R3, #0
STR             R2, [SP,#0x9C+var_74]
STR             R3, [SP,#0x9C+which_core]

loc_1FA4C
MOVS            R5, #0
which_pattern = R5      ; unsigned int
CMP             which_pattern, work
BCS.W           loc_1FB90

loc_1FA54
LDRB.W          R3, [R8]
CMP             R3, #0
BNE.W           loc_1FC0C

loc_1FA5E               ; address
MOVS            R0, #3
MOV.W           R10, #1
BL              read_axi_fpga
work_fifo_ready = R0    ; unsigned int
MOV             R3, #gChain
LDRB            R3, [R3]
LSL.W           R3, R10, R3
TST             R3, work_fifo_ready
BEQ.W           loc_1FC02
LDR             R3, [SP,#0x9C+which_core]
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             work_fifo_ready, SP, #0x9C+buf_vil ; s
MLA             work, work, R3, which_pattern
LDR             R3, [SP,#0x9C+works]
ADD.W           work, work, work,LSL#4
ADD.W           work, R3, work,LSL#2
BLX             memset
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             R0, SP, #0x9C+work_vil_1397 ; s
BLX             memset
AND.W           R2, work_id, #0x7F
LDRB.W          LR, [SP,#0x9C+var_84]
ORR.W           R2, R2, which_pattern,LSL#7
ADD.W           R3, work, #7
ADD.W           R1, work, #0x13
STRB.W          R10, [SP,#0x9C+work_vil_1397]
ADD.W           R0, SP, #0x9C+work_vil_1397.work_count+3
STRB.W          LR, [SP,#0x9C+work_vil_1397.chain_id]
STR             R2, [SP,#0x9C+work_vil_1397.work_count]

loc_1FAC2
LDRB.W          LR, [R3,#1]!
CMP             R1, R3
STRB.W          LR, [R0,#1]!
BNE             loc_1FAC2
ADD.W           R3, SP, #0x9C+work_vil_1397.data+0xB
ADD.W           LR, SP, #0x9C+work_vil_1397.midstate+0x1F

loc_1FAD6
LDRB.W          R0, [R1,#1]!
STRB.W          R0, [R3,#1]!
CMP             R3, LR
BNE             loc_1FAD6
ADD             R3, SP, #0x9C+work_vil_1397
LDR             R1, [SP,#0x9C+var_80]
ADD.W           R11, SP, #0x9C+work_vil_1397.data+4
MOV             R12, R3
ADD.W           R10, SP, #0x9C+var_4
STR             R1, [SP,#0x9C+buf_vil]
STR.W           R2, [R10,#-0x30]!

loc_1FAF6
LDRB.W          R1, [R12,#9]
ADD.W           R12, R12, #4
LDRB.W          LR, [R12,#4]
LDRB.W          R2, [R12,#7]
LDRB.W          R0, [R12,#6]
CMP             R12, R11
MOV.W           R1, R1,LSL#16
ORR.W           R1, R1, LR,LSL#24
ORR.W           R2, R2, R1
ORR.W           R2, R2, R0,LSL#8
STR.W           R2, [R10,#4]!
BNE             loc_1FAF6
ADD.W           R12, SP, #0x9C+buf_vil+0x10
ADD.W           R10, SP, #0x9C+work_vil_1397.midstate+0xC

loc_1FB2A
LDRB            R1, [R3,#0x15]
ADDS            R3, #4
LDRB.W          LR, [R3,#0x10]
LDRB            R2, [R3,#0x13]
LDRB            R0, [R3,#0x12]
CMP             R10, R3
MOV.W           R1, R1,LSL#16
ORR.W           R1, R1, LR,LSL#24
ORR.W           R2, R2, R1
ORR.W           R2, R2, R0,LSL#8
STR.W           R2, [R12,#4]!
BNE             loc_1FB2A
ADD             R0, SP, #0x9C+buf_vil ; value
ADDS            which_pattern, #1
BL              set_TW_write_command
LDR             R2, [SP,#0x9C+var_7C]
ADD.W           R3, work_id, work_id,LSL#4
MOV             R0, #gWorks_For_Hw_Check
MOV             R1, work ; src
ADDS            work_id, #1
ADD.W           R3, R2, R3,LSL#2
MOVS            R2, #0x44 ; 'D' ; n
ADD             R0, R3  ; dest
BLX             memcpy
which_pattern = R5      ; unsigned int
work_id = R4            ; unsigned int
LDR.W           R3, [R7,which_chain,LSL#2]
CMP             work_id, #0x80
IT CS
MOVCS           work_id, #0
ADDS            R3, #1
STR.W           R3, [R7,which_chain,LSL#2]

loc_1FB84
LDR             R3, [SP,#0x9C+var_90]
LDR.W           work, [R3,#configuration.pattern_number]
work_id = R4            ; unsigned int
CMP             which_pattern, work
BCC.W           loc_1FA54

loc_1FB90
LDR             R3, [SP,#0x9C+which_core]
ADDS            R3, #1
CMP.W           R3, #0x2A0
STR             R3, [SP,#0x9C+which_core]
which_core_0 = R3       ; unsigned int
BNE.W           loc_1FA4C
LDR             which_core_0, [SP,#0x9C+var_70]
LDR             R2, [R3]
LDR             R3, [SP,#0x9C+which_asic]
ADDS            R3, #1
CMP             R2, R3
STR             R3, [SP,#0x9C+which_asic]
which_asic_0 = R3       ; unsigned int
BHI.W           loc_1FA3C
MUL             R2, work, R2
LDR             R1, [SP,#0x9C+which_core]
LDR.W           which_asic_0, [R7,which_chain,LSL#2]
MUL             R2, R1, R2
CMP             R2, R3
BLS             loc_1FC2A
LDR.W           work, [SP,#0x9C+which_core]
MOVW            which_pattern, #:lower16:__FUNCTION__.8427 ; "BHB07601_send_func"
LDR.W           R10, [SP,#0x9C+var_90]
MOVW            work_id, #:lower16:aSChainDSendWor ; "\n\n---%s: Chain%d send work num : %d, "...
LDR.W           R11, [SP,#0x9C+var_70]
MOVT            R5, #:upper16:__FUNCTION__.8427 ; "BHB07601_send_func"
MOVT            R4, #:upper16:aSChainDSendWor ; "\n\n---%s: Chain%d send work num : %d, "...

loc_1FBDC
STR             R2, [SP,#0x9C+var_9C]
MOV             R1, R5
MOV             R2, which_chain
MOV             R0, R4  ; format
BLX             printf
LDR.W           R1, [R10,#configuration.pattern_number]
LDR.W           R2, [R11]
LDR.W           R3, [R7,which_chain,LSL#2]
MUL             R2, R2, R1
MUL             R2, work, R2
CMP             R3, R2
BCC             loc_1FBDC
B               loc_1FC2A

loc_1FC02               ; useconds
which_pattern = R5      ; unsigned int
work_id = R4            ; unsigned int
work_fifo_ready = R0    ; unsigned int
MOV.W           work_fifo_ready, #0x3E8
BLX             usleep
B               loc_1FB84

loc_1FC0C               ; useconds
MOVW            R0, #0x2710
BLX             usleep
B               loc_1FA5E

loc_1FC16
which_i2c = R5          ; unsigned __int8
MOVW            R3, #:lower16:gSend_Work_Num
MOVW            R8, #:lower16:gReadingTemp
MOVT            R3, #:upper16:gSend_Work_Num
MOVT            R8, #:upper16:gReadingTemp
LDR.W           R3, [R3,which_chain,LSL#2]

loc_1FC2A
MOVW            R1, #:lower16:__FUNCTION__.8427 ; "BHB07601_send_func"
MOVW            R0, #:lower16:aSChainDSendWor_0 ; "\n\n---%s: Chain%d send work num : %d\n"
MOVT            R1, #:upper16:__FUNCTION__.8427 ; "BHB07601_send_func"
MOV             R2, which_chain
MOVT            R0, #:upper16:aSChainDSendWor_0 ; "\n\n---%s: Chain%d send work num : %d\n"
MOVW            R4, #:lower16:gValid_Nonce_Num
BLX             printf
MOVW            R0, #:lower16:aSendTestPatter ; "\nsend test pattern done"
MOVT            R4, #:upper16:gValid_Nonce_Num
MOVT            R0, #:upper16:aSendTestPatter ; "\nsend test pattern done"
MOVW            work, #:lower16:(gAsic_Core_Nonce_Num+0xC33FC)
BLX             puts
MOVW            R0, #:lower16:aDate ; "date"
MOVT            work, #:upper16:(gAsic_Core_Nonce_Num+0xC33FC)
MOVT            R0, #:upper16:aDate ; "date"
MOVS            R5, #0
BLX             system
MOVS            R0, #0xA ; c
BLX             putchar
LDR.W           R10, [R4,which_chain,LSL#2]
received_data = R10     ; unsigned int
MOV             R7, received_data

loc_1FC76
CMP             R10, R7
ADD.W           R5, R5, #1
count = R5              ; unsigned int
MOV             R0, work ; useconds
BNE             loc_1FC9E
CMP             count, #2
BHI             loc_1FC8E
BLX             usleep

loc_1FC88
LDR.W           R7, [R4,which_chain,LSL#2]
B               loc_1FC76

loc_1FC8E
count = R5              ; unsigned int
LDRB.W          R3, [R8]
CBZ             R3, loc_1FCA8
MOVW            R0, #0x2710 ; useconds
BLX             usleep
B               loc_1FC8E

loc_1FC9E
BLX             usleep
MOV             R10, R7
MOVS            count, #0
B               loc_1FC88

loc_1FCA8
count = R5              ; unsigned int
MOVW            R3, #:lower16:start_receive
MOVW            R0, #:lower16:aToStopReceive ; "to stop receive"
MOVT            R3, #:upper16:start_receive
MOVS            R4, #0
MOVT            R0, #:upper16:aToStopReceive ; "to stop receive"
STRB            R4, [R3]
BLX             puts
MOV             R0, R4
ADD             SP, SP, #0x9C
POP.W           {R4-R11,PC}
; End of function BHB07601_send_func

off_1FCC8 DCD cgpu.workdataFilePrefix+0x3C



; void reset_BHB07601_global_arg()
EXPORT reset_BHB07601_global_arg
reset_BHB07601_global_arg

var_10= -0x10
var_C= -0xC
var_8= -8

MOVW            R3, #:lower16:gBM1397_MISC_CONTROL_reg
PUSH.W          {R4-R11,LR}
MOVW            R2, #0x3A01
SUB             SP, SP, #0x14
MOVT            R3, #:upper16:gBM1397_MISC_CONTROL_reg
MOVW            R9, #:lower16:gRepeated_Nonce_Id
STR             R2, [R3]
MOVW            R8, #:lower16:gValid_Nonce_Num
BL              reset_global_arg
MOVW            R3, #:lower16:Conf
MOVW            R2, #:lower16:BHB07601_ASIC_NUMBER
MOVT            R3, #:upper16:Conf
MOVT            R2, #:upper16:BHB07601_ASIC_NUMBER
LDR             R5, [R3,#configuration.pattern_number]
MOVW            R3, #:lower16:cgpu
LDR             R2, [R2]
MOVT            R3, #:upper16:cgpu
LDR             R1, =0x3312CF
MOVW            R12, #:lower16:gSend_Work_Num
LDR.W           R10, =(gAsic_Core_Nonce_Num+0xA7C)
MOVW            R7, #:lower16:gSensor_OK
ADD.W           R6, R5, R5,LSL#4
STR             R2, [SP,#0x14+var_C]
ADD.W           R2, R2, #0x20000
STR             R1, [SP,#0x14+var_10]
ADDS            R2, #0x2A ; '*'
MOV.W           LR, #0
LSLS            R6, R6, #2
ADD.W           R3, R3, R2,LSL#2
MOVT            R9, #:upper16:gRepeated_Nonce_Id
MOVT            R8, #:upper16:gValid_Nonce_Num
MOVT            R12, #:upper16:gSend_Work_Num
MOVT            R7, #:upper16:gSensor_OK
MOV             R1, LR
STR             R3, [SP,#0x14+var_8]

loc_1FD42
LDR             R3, [SP,#0x14+var_10]
MOV             R4, R10
STR.W           R1, [R9],#4
STR.W           R1, [R8],#4
STRB.W          R1, [R3,#1]!
STR             R3, [SP,#0x14+var_10]
LDR             R3, [SP,#0x14+var_C]
STR.W           R1, [R12],#4
LDR.W           R11, =(cgpu.workdataFilePrefix+0x3C)
CBZ             R3, loc_1FD8A

loc_1FD60
LDR.W           R3, [R11,#4]!
SUB.W           R0, R4, #0xA80
ADD             R3, LR

loc_1FD6A
STR.W           R1, [R0,#4]!
ADDS            R2, R3, R6
CBZ             R5, loc_1FD7A

loc_1FD72
STR             R1, [R3,#0x34]
ADDS            R3, #0x44 ; 'D'
CMP             R3, R2
BNE             loc_1FD72

loc_1FD7A
CMP             R0, R4
MOV             R3, R2
BNE             loc_1FD6A
LDR             R3, [SP,#0x14+var_8]
ADD.W           R4, R4, #0x1000
CMP             R11, R3
BNE             loc_1FD60

loc_1FD8A
ADD.W           LR, LR, #4
STRB            R1, [R7]
CMP.W           LR, #0x10
STRB            R1, [R7,#1]
STRB            R1, [R7,#2]
ADD.W           R10, R10, #0x80000
STRB            R1, [R7,#3]
ADD.W           R7, R7, #4
BNE             loc_1FD42
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}
; End of function reset_BHB07601_global_arg

ALIGN 4
dword_1FDAC DCD 0x3312CF
off_1FDB0 DCD gAsic_Core_Nonce_Num+0xA7C
off_1FDB4 DCD cgpu.workdataFilePrefix+0x3C



; void __cdecl dump_eeprom_info(eeprom_layout_t eeprom)
EXPORT dump_eeprom_info
dump_eeprom_info

eeprom=  0x10

SUB             SP, SP, #0x10
PUSH            {R4-R6,LR}
ADD             R4, SP, #eeprom
STM.W           R4, {R0-R3}
MOV             R0, #aDumpEepromInfo ; "\n--- dump eeprom info:"
MOV             R5, #a02x_0 ; "%02x"
ADD.W           R4, SP, #eeprom.fixture_version+1
BLX             puts
MOVW            R0, #:lower16:aFixtureHeader0 ; "fixture_header:      0x%04x\n"
LDRH.W          R1, [SP,#eeprom]
MOVT            R0, #:upper16:aFixtureHeader0 ; "fixture_header:      0x%04x\n"
ADD.W           R6, SP, #eeprom.hash_board_sn+0x13
BLX             printf
MOVW            R0, #:lower16:aFixtureVersion ; "fixture_version:     0x%04x\n"
LDRH.W          R1, [SP,#eeprom.fixture_version]
MOVT            R0, #:upper16:aFixtureVersion ; "fixture_version:     0x%04x\n"
BLX             printf
MOV             R0, #aHashBoardSn0x ; "hash_board_sn:       0x"
BLX             printf

loc_1FE0A
LDRB.W          R1, [R4,#1]!
MOV             R0, R5  ; format
BLX             printf
CMP             R4, R6
BNE             loc_1FE0A
MOVS            R0, #0xA ; c
BLX             putchar
MOVW            R0, #:lower16:aPcbVersion0x04 ; "pcb_version:         0x%04x\n"
LDRH.W          R1, [SP,#eeprom.pcb_version]
MOVT            R0, #:upper16:aPcbVersion0x04 ; "pcb_version:         0x%04x\n"
BLX             printf
MOVW            R0, #:lower16:aBomVersion0x04 ; "bom_version:         0x%04x\n"
LDRH.W          R1, [SP,#eeprom.bom_version]
MOVT            R0, #:upper16:aBomVersion0x04 ; "bom_version:         0x%04x\n"
BLX             printf
MOVW            R0, #:lower16:aTempSensorType ; "temp_sensor_type:    0x%02x\n"
LDRB.W          R1, [SP,#eeprom.temp_sensor_type]
MOVT            R0, #:upper16:aTempSensorType ; "temp_sensor_type:    0x%02x\n"
BLX             printf
MOVW            R0, #:lower16:aProductId0x02x ; "product_id:          0x%02x\n"
LDRB.W          R1, [SP,#eeprom.product_id]
MOVT            R0, #:upper16:aProductId0x02x ; "product_id:          0x%02x\n"
BLX             printf
MOVW            R0, #:lower16:aCrcTestFixture ; "crc_test_fixture:    0x%04x\n"
LDRH.W          R1, [SP,#eeprom.crc_test_fixture]
MOVT            R0, #:upper16:aCrcTestFixture ; "crc_test_fixture:    0x%04x\n"
BLX             printf
POP.W           {R4-R6,LR}
ADD             SP, SP, #0x10
BX              LR
; End of function dump_eeprom_info

ALIGN 4



; bool __fastcall BHB07601_AT24C02_write_total_data(unsigned __int8 which_iic, unsigned __int8 which_chain)
EXPORT BHB07601_AT24C02_write_total_data
BHB07601_AT24C02_write_total_data

length= -0x2FC
var_20C= -0x20C
var_208= -0x208
eeprom= -0x204
eeprom_rb= -0x104

which_iic = R0          ; unsigned __int8
which_chain = R1        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB.W           SP, SP, #0x2FC
ADD             R5, SP, #0x2FC+eeprom
MOV             R8, which_iic
MOV             R9, which_chain
MOV             which_iic, R5 ; s
MOV.W           R2, #0x100 ; n
MOVS            which_chain, #0 ; c
BLX             memset
MOVS            R4, #0xFF
MOV.W           R2, #0x100 ; n
MOVS            R1, #0  ; c
ADD             R0, SP, #0x2FC+eeprom_rb ; s
STRH            R4, [R5]
MOVW            R6, #:lower16:Conf
BLX             memset
MOVW            R0, #:lower16:aS ; "\n--- %s\n"
MOVT            R6, #:upper16:Conf
LDR             R1, =__FUNCTION__.8242 ; "BHB07601_AT24C02_write_total_data"
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
STRH.W          R4, [SP,#0x2FC+eeprom_rb]
MOV.W           R11, #0
BLX             printf
LDR.W           R2, [R6,#configuration.HashBoard_Hardware_Version_1]
MOVW            R1, #0x1397
LDR.W           R3, [R6,#configuration.HashBoard_Hardware_Version_2]
MOVS            R4, #1
LDR.W           R7, [R6,#configuration.HashBoard_Bom_Version_2]
MOV             R0, R5  ; p_data
LDR.W           LR, [R6,#configuration.HashBoard_Bom_Version_1]
MOVW            R10, #:lower16:gEEPROM_error
STRH            R1, [R5]
MOVS            R1, #0x1E ; w_len
ORR.W           R3, R3, R2,LSL#8
LDR.W           R2, [R6,#configuration.sensor_model]
LDR.W           R6, [R6,#configuration.HashBoard_Product_ID]
MOVT            R10, #:upper16:gEEPROM_error
ORR.W           LR, R7, LR,LSL#8
STRH            R3, [R5,#0x18]
STRB            R2, [R5,#0x1C]
MOVW            R7, #:lower16:aSEeprom0xX0xX0 ; "!!! %s: eeprom[0x%x] 0x%x != 0x%x!\n"
STRB            R6, [R5,#0x1D]
MOVS            R6, #0x28 ; '('
STRH.W          LR, [R5,#0x1A]
MOVT            R7, #:upper16:aSEeprom0xX0xX0 ; "!!! %s: eeprom[0x%x] 0x%x != 0x%x!\n"
STRH            R4, [R5,#2]
STR.W           R11, [SP,#0x2FC+eeprom.hash_board_sn]
STR.W           R11, [SP,#0x2FC+eeprom.hash_board_sn+4]
STR.W           R11, [SP,#0x2FC+eeprom.hash_board_sn+8]
STR.W           R11, [SP,#0x2FC+eeprom.hash_board_sn+0xC]
STR.W           R11, [SP,#0x2FC+eeprom.hash_board_sn+0x10]
BL              CRC16
MOV             R3, R9  ; which_chain
STRH            R0, [R5,#0x1E]
MOV             R2, R8  ; which_iic
MOV             R1, R5  ; buf
MOV             R0, R11 ; address
STR             R6, [SP,#0x2FC+length] ; length
MOV.W           R6, #0x5A5A5A5A
STR.W           R9, [SP,#0x2FC+var_208]
STR.W           R8, [SP,#0x2FC+var_20C]
MOV             R9, R4
STR             R6, [SP,#0x2FC+eeprom.reserved_0]
STR             R6, [SP,#0x2FC+eeprom.reserved_0+4]
ADD.W           R6, SP, #0x2FC+var_208+3
BL              AT24C02_write_bytes
MOVS            R2, #0xF0 ; n
ADD             R1, SP, #0x2FC+eeprom.hash_board_sn+0xC ; src
MOV             R0, SP  ; dest
LDR.W           R8, =__FUNCTION__.8242 ; "BHB07601_AT24C02_write_total_data"
BLX             memcpy
LDM.W           R5, {R0-R3} ; eeprom
ADDW            R5, SP, #0x2FC+eeprom.reserved_1+0xD7
BL              dump_eeprom_info
MOV             R0, R4  ; seconds
MOV             R4, R11
BLX             sleep
MOVS            R1, #0x28 ; '('
LDR             R3, [SP,#0x2FC+var_208] ; which_chain
STR             R1, [SP,#0x2FC+length] ; length
MOV             R0, R11 ; address
LDR             R2, [SP,#0x2FC+var_20C] ; which_iic
ADD             R1, SP, #0x2FC+eeprom_rb ; buf
BL              AT24C02_read_bytes

loc_1FF7A
i = R4                  ; int
LDRB.W          LR, [R6,#1]!
MOV             R2, i
LDRB.W          R12, [R5,#1]!
ADDS            i, #1
i = R2                  ; int
MOV             R1, R8
MOV             R0, R7  ; format
MOV             R3, LR
CMP             LR, R12
BEQ             loc_1FFA2
STR.W           R12, [SP,#0x2FC+length]
MOV.W           R9, #0
BLX             printf
MOVS            R3, #1
STRB.W          R3, [R10]

loc_1FFA2
i = R4                  ; int
CMP             i, #0x28 ; '('
BNE             loc_1FF7A
CMP.W           R9, #0
BEQ             loc_1FFC4
MOVW            R0, #:lower16:aSSaveDataIntoE_0 ; "--- %s: save data into EEPROM success! "...
LDR             R1, =__FUNCTION__.8242 ; "BHB07601_AT24C02_write_total_data"
MOVT            R0, #:upper16:aSSaveDataIntoE_0 ; "--- %s: save data into EEPROM success! "...
BLX             printf
MOV             R0, R9
ADD.W           SP, SP, #0x2FC
POP.W           {i-R11,PC}

loc_1FFC4
MOVW            R0, #:lower16:aSSaveDataIntoE ; "!!! %s: save data into EEPROM fail! \n"
LDR             R1, =__FUNCTION__.8242 ; "BHB07601_AT24C02_write_total_data"
MOVT            R0, #:upper16:aSSaveDataIntoE ; "!!! %s: save data into EEPROM fail! \n"
BLX             printf
MOVW            R0, #:lower16:aSClearEepromDa ; "!!! %s: clear EEPROM data! \n"
LDR             R1, =__FUNCTION__.8242 ; "BHB07601_AT24C02_write_total_data"
MOVT            R0, #:upper16:aSClearEepromDa ; "!!! %s: clear EEPROM data! \n"
BLX             printf
MOV             R2, i   ; n
MOVS            R1, #0xFF ; c
ADD             R0, SP, #0x2FC+eeprom_rb ; s
BLX             memset
MOV             R0, R9  ; address
STR             i, [SP,#0x2FC+length] ; length
LDR             R3, [SP,#0x2FC+var_208] ; which_chain
ADD             R1, SP, #0x2FC+eeprom_rb ; buf
LDR             R2, [SP,#0x2FC+var_20C] ; which_iic
BL              AT24C02_write_bytes
MOV             R0, R9
ADD.W           SP, SP, #0x2FC
POP.W           {i-R11,PC}
; End of function BHB07601_AT24C02_write_total_data

ALIGN 4
off_20004 DCD __FUNCTION__.8242 ; "BHB07601_AT24C02_write_total_data"



; int __fastcall BHB07601_set_voltage(unsigned __int8 which_chain, unsigned __int8 which_i2c)
EXPORT BHB07601_set_voltage
BHB07601_set_voltage
which_chain = R0        ; unsigned __int8
which_i2c = R1          ; unsigned __int8
PUSH            {R3-R5,LR}
BL              Calibration_voltage
ret = R0                ; int
MOV             R4, ret
CBNZ            ret, loc_20016

loc_20012
ret = R4                ; int
MOV             R0, ret
POP             {R3-R5,PC}

loc_20016
ret = R0                ; int
LDR             R5, =cgpu.show_id
LDR.W           ret, [R5],#-8 ; th
ret = R4                ; int
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R5,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
ADDS            R1, ret, #1
BEQ             loc_20088
ADDS            R2, ret, #2
BNE             loc_200BA
MOVW            R1, #:lower16:aMaximumNValue ; " Maximum N value"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aMaximumNValue ; " Maximum N value"
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aCanNotMatch ; " can not match  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCanNotMatch ; " can not match  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aVoltage ; "    voltage     "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aVoltage ; "    voltage     "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSMaximumNValue ; "\n!!! %s: Maximum N value can't match v"...
LDR             R1, =__FUNCTION__.8252 ; "BHB07601_set_voltage"
MOVT            R0, #:upper16:aSMaximumNValue ; "\n!!! %s: Maximum N value can't match v"...
BLX             printf
MOV             R0, ret
POP             {R3-R5,PC}

loc_20088
MOVW            R1, #:lower16:aCanNotFind ; "  Can not find  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCanNotFind ; "  Can not find  "
MOVS            R0, #1  ; line
BL              write_lcd
MOVW            R1, #:lower16:aMatchVoltage ; "  match voltage "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aMatchVoltage ; "  match voltage "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCanTFindMatch ; "\n!!! %s: Can't find match voltage!\n"
LDR             R1, =__FUNCTION__.8252 ; "BHB07601_set_voltage"
MOVT            R0, #:upper16:aSCanTFindMatch ; "\n!!! %s: Can't find match voltage!\n"
BLX             printf
MOV             R0, ret
POP             {R3-R5,PC}

loc_200BA
ADDS            R3, ret, #3
BNE             loc_20012
MOVW            R1, #:lower16:aMinimumNValue ; " Minimum N value"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aMinimumNValue ; " Minimum N value"
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aCanNotMatch ; " can not match  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCanNotMatch ; " can not match  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aVoltage ; "    voltage     "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aVoltage ; "    voltage     "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSMinimumNValue ; "\n!!! %s: Minimum N value can't match v"...
LDR             R1, =__FUNCTION__.8252 ; "BHB07601_set_voltage"
MOVT            R0, #:upper16:aSMinimumNValue ; "\n!!! %s: Minimum N value can't match v"...
BLX             printf
MOV             R0, ret
POP             {R3-R5,PC}
; End of function BHB07601_set_voltage

off_20100 DCD cgpu.show_id
off_20104 DCD __FUNCTION__.8252 ; "BHB07601_set_voltage"



; void BHB07601_calculate_timeout_and_baud()
EXPORT BHB07601_calculate_timeout_and_baud
BHB07601_calculate_timeout_and_baud

var_C= -0xC
var_8= -8

PUSH            {R4-R7,LR}
MOV.W           R0, #0x2A0 ; actual_core_number
SUB             SP, SP, #0xC
MOVW            R4, #:lower16:Conf
BL              calculate_core_number
MOVW            R3, #:lower16:pattern_test_time
MOV             R6, R0
temp_corenum = R0       ; unsigned int
MOVT            R3, #:upper16:pattern_test_time
LDRB            R2, [R3]
CMP             R2, #8  ; switch 9 cases
BHI             def_20128 ; jumptable 00020128 default case
TBB.W           [PC,R2] ; switch jump
jpt_20128 DCB 0x34      ; jump table for switch statement
DCB 0x38
DCB 0x3C
DCB 0x40
DCB 0x44
DCB 0x48
DCB 0x4C
DCB 0x50
DCB 5
ALIGN 2

loc_20136               ; jumptable 00020128 case 8
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq9]

loc_2013C
temp_corenum = R6       ; unsigned int
temp_freq = R5          ; unsigned int
MOV             R1, temp_corenum
MOV.W           R0, #0x1000000
BL              __aeabi_uidiv
MOVW            R3, #:lower16:gChain_Asic_Interval
MOV             R1, temp_freq
MOVT            R3, #:upper16:gChain_Asic_Interval
LDR             R3, [R3]
MUL             R0, R3, R0
BL              __aeabi_uidiv
LDR             R1, =(cgpu.subid+0x7FD54)
MOVW            R3, #0x851F
STR             temp_freq, [SP,#0xC+var_8]
MOVT            R3, #0x51EB
STR             temp_freq, [R4,#configuration.Freq]
LDRB.W          temp_corenum, [R1,#(cgpu.timeout_percent - 0x330FC4)]
LDR.W           R2, [R4,#configuration.baud]
LDR             R1, =__FUNCTION__.8269_0 ; "BHB07601_calculate_timeout_and_baud"
MUL             R6, R6, R0
MOV             R0, #aSBaudDTimeout0 ; "\n--- %s: baud = %d, timeout = 0x%08x ="...
UMULL           R6, R7, R6, R3
LSRS            temp_freq, R7, #5
STR             R5, [SP,#0xC+var_C]
MOV             R3, R5
STR.W           R5, [R4,#configuration.timeout]
BLX             printf
ADD             SP, SP, #0xC
POP             {R4-R7,PC}

loc_20194               ; jumptable 00020128 case 0
temp_corenum = R0       ; unsigned int
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq1]
temp_freq = R5          ; unsigned int
B               loc_2013C

loc_2019C               ; jumptable 00020128 case 1
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq2]
temp_freq = R5          ; unsigned int
B               loc_2013C

loc_201A4               ; jumptable 00020128 case 2
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq3]
temp_freq = R5          ; unsigned int
B               loc_2013C

loc_201AC               ; jumptable 00020128 case 3
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq4]
temp_freq = R5          ; unsigned int
B               loc_2013C

loc_201B4               ; jumptable 00020128 case 4
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq5]
temp_freq = R5          ; unsigned int
B               loc_2013C

loc_201BC               ; jumptable 00020128 case 5
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq6]
temp_freq = R5          ; unsigned int
B               loc_2013C

loc_201C4               ; jumptable 00020128 case 6
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq7]
temp_freq = R5          ; unsigned int
B               loc_2013C

loc_201CC               ; jumptable 00020128 case 7
MOVT            R4, #:upper16:Conf
LDR             R5, [R4,#configuration.Freq8]
temp_freq = R5          ; unsigned int
B               loc_2013C

def_20128               ; jumptable 00020128 default case
MOVW            temp_corenum, #:lower16:aSPatternTestTi ; "%s: pattern_test_time = %d, error!!! \n"
temp_corenum = R6       ; unsigned int
LDR             R1, =__FUNCTION__.8269_0 ; "BHB07601_calculate_timeout_and_baud"
MOVT            R0, #:upper16:aSPatternTestTi ; "%s: pattern_test_time = %d, error!!! \n"
MOVT            R4, #:upper16:Conf
MOVS            R5, #0
BLX             printf
B               loc_2013C
; End of function BHB07601_calculate_timeout_and_baud

ALIGN 4
off_201EC DCD cgpu.subid+0x7FD54
off_201F0 DCD __FUNCTION__.8269_0 ; "BHB07601_calculate_timeout_and_baud"



; void __fastcall BHB07601_set_address(unsigned __int8 which_chain)
EXPORT BHB07601_set_address
BHB07601_set_address
which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R6, which_chain
MOVW            which_chain, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R2, R6
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
MOVW            R8, #:lower16:BHB07601_ASIC_NUMBER
LDR             R1, =__FUNCTION__.8275 ; "BHB07601_set_address"
MOVT            R8, #:upper16:BHB07601_ASIC_NUMBER
BLX             printf
MOV             R0, R6  ; which_chain
BL              BM1397_chain_inactive
LDR.W           R3, [R8]
CBZ             R3, locret_2024C
MOVS            R4, #0
MOVW            R7, #:lower16:gChain_Asic_Interval
MOV             R5, R4
MOVT            R7, #:upper16:gChain_Asic_Interval

loc_2022A               ; address
chip_addr = R5          ; unsigned __int8
which_asic = R4         ; unsigned __int8
MOV             R1, chip_addr
MOV             R0, R6  ; which_chain
BL              BM1397_set_address
LDR             R3, [R7]
MOVW            R0, #0x1388 ; useconds
ADDS            which_asic, #1
UXTB            R4, R4
ADD             chip_addr, R3
BLX             usleep
LDR.W           R3, [R8]
UXTB            R5, R5
chip_addr = R5          ; unsigned __int8
which_asic = R4         ; unsigned __int8
CMP             which_asic, R3
BCC             loc_2022A

locret_2024C
POP.W           {R4-R8,PC}
; End of function BHB07601_set_address

off_20250 DCD __FUNCTION__.8275 ; "BHB07601_set_address"



; void __fastcall BHB07601_set_baud(unsigned __int8 which_chain, unsigned __int8 baud)
EXPORT BHB07601_set_baud
BHB07601_set_baud
which_chain = R0        ; unsigned __int8
baud = R1               ; unsigned __int8
PUSH            {R3-R5,LR}
MOV             R4, which_chain
MOVW            which_chain, #:lower16:aSChainDBaudD ; "\n--- %s: Chain : %d, baud = %d\n"
MOV             R5, baud
MOV             R3, baud
MOV             R2, R4
LDR             baud, =__FUNCTION__.8283_0 ; "BHB07601_set_baud"
MOVT            R0, #:upper16:aSChainDBaudD ; "\n--- %s: Chain : %d, baud = %d\n"
BLX             printf
MOV             R1, R5  ; baud
MOV             R0, R4  ; which_chain
POP.W           {R3-R5,LR}
B.W             BM1397_set_baud
; End of function BHB07601_set_baud

off_20278 DCD __FUNCTION__.8283_0 ; "BHB07601_set_baud"



; void __fastcall BHB07601_open_core(unsigned __int8 which_chain)
EXPORT BHB07601_open_core
BHB07601_open_core

var_48= -0x48
var_44= -0x44
var_40= -0x40
buf_vil_tw= -0x38

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x4C
MOV             R5, which_chain
MOVW            R3, #:lower16:gIsOpenCoreEnd
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             which_chain, SP, #0x4C+buf_vil_tw ; s
MOV             R4, R3
BLX             memset
MOVW            R3, #:lower16:gIsOpeningCore
MOVW            R0, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R6, R3
LDR             R1, =__FUNCTION__.8293 ; "BHB07601_open_core"
MOV             R2, R5
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
BLX             printf
MOV             R3, R4
MOV             R2, R6
MOVT            R3, #:upper16:gIsOpenCoreEnd
MOVT            R2, #:upper16:gIsOpeningCore
MOVS            R4, #0
MOVS            R6, #1
MOVS            R0, #0x40 ; '@' ; address
STR             R3, [SP,#0x4C+var_44]
STRB            R4, [R3]
MOVW            R11, #:lower16:Conf
STRB            R6, [R2]
MOVW            R7, #:lower16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"
STR             R2, [SP,#0x4C+var_40]
LSLS            R6, R5
LDR.W           R8, =__FUNCTION__.8293 ; "BHB07601_open_core"
MOV             R9, R4
BL              read_axi_fpga
BIC.W           R1, R0, #0x20 ; ' ' ; data
MOVS            R0, #0x40 ; '@' ; address
BL              write_axi_fpga
MOV             R1, R4  ; data
MOVS            R0, #0x24 ; '$' ; address
BL              write_axi_fpga
MOV             R1, R4  ; c
ADD             R0, SP, #0x4C+buf_vil_tw ; s
MOVS            R2, #0x34 ; '4' ; n
MOVT            R11, #:upper16:Conf
BLX             memset
MOVS            R3, #0x80
MOVT            R7, #:upper16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"
MOVT            R3, #0x100
ORR.W           R3, R3, R5,LSL#16
STR             R3, [SP,#0x4C+var_48]

loc_20308
core_id = R9            ; unsigned int
ADD.W           R10, core_id, #0x150
MOV             R4, core_id

loc_2030E               ; useconds
core_index = R4         ; unsigned int
MOV.W           R0, #0x3E8
BLX             usleep
MOV             R2, core_index ; core_id
MOVS            R3, #1  ; mode
MOVS            R1, #0  ; which_asic
ADDS            core_index, #0x54 ; 'T'
core_index = R2         ; unsigned int
MOV             R0, R5  ; which_chain
BL              BM1397_enable_core_clock
CMP             R4, R10
BNE             loc_2030E
MOVW            R0, #0x1388 ; useconds
BLX             usleep
B               loc_2033E

loc_20332
work_fifo_ready = R3    ; unsigned int
BLX             printf
MOVW            R0, #0xBB8 ; useconds
BLX             usleep

loc_2033E               ; address
MOVS            R0, #3
BL              read_axi_fpga
MOV             R3, R0
work_fifo_ready = R0    ; unsigned int
MOV             R2, R5
TST             R6, R3
MOV             work_fifo_ready, R7 ; format
work_fifo_ready = R3    ; unsigned int
MOV             R1, R8
BEQ             loc_20332
LDR             work_fifo_ready, [SP,#0x4C+var_48]
ADD             R0, SP, #0x4C+buf_vil_tw ; value
ADD.W           core_id, core_id, #1
STR             R3, [SP,#0x4C+buf_vil_tw]
BL              set_TW_write_command
LDR.W           R0, [R11,#configuration.OpenCoreGap] ; useconds
BLX             usleep
core_id = R9            ; unsigned int
CMP.W           core_id, #0x54 ; 'T'
BNE             loc_20308
MOVS            R0, #0x30 ; '0' ; address
BL              read_axi_fpga
ORR.W           R1, R0, #0x400000 ; data
MOVS            R0, #0x30 ; '0' ; address
BL              write_axi_fpga
LDR             R1, [SP,#0x4C+var_40]
MOVS            R2, #0
MOVS            R3, #1
STRB            R2, [R1]
LDR             R2, [SP,#0x4C+var_44]
STRB            R3, [R2]
ADD             SP, SP, #0x4C ; 'L'
POP.W           {R4-R11,PC}
; End of function BHB07601_open_core

ALIGN 0x10
off_20390 DCD __FUNCTION__.8293 ; "BHB07601_open_core"



; void __fastcall BHB07601_pre_open_core(unsigned __int8 which_chain)
EXPORT BHB07601_pre_open_core
BHB07601_pre_open_core

var_40= -0x40
buf_vil_tw= -0x38

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x44
MOV             R5, which_chain
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             which_chain, SP, #0x44+buf_vil_tw ; s
BLX             memset
MOVW            R0, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R2, R5
LDR             R1, =__FUNCTION__.8311_0 ; "BHB07601_pre_open_core"
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
BLX             printf
MOVS            R0, #0x40 ; '@' ; address
MOVW            R11, #:lower16:Conf
BL              read_axi_fpga
BIC.W           R1, R0, #0x20 ; ' ' ; data
MOVS            R0, #0x40 ; '@' ; address
BL              write_axi_fpga
MOVS            R1, #0  ; data
MOVS            R0, #0x24 ; '$' ; address
BL              write_axi_fpga
MOVT            R11, #:upper16:Conf
ADD             R0, SP, #0x44+buf_vil_tw ; s
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
BLX             memset
LDR.W           R3, [R11,#configuration.OpenCoreNum2]
CMP             R3, #0
BEQ             loc_2046E
MOVS            R3, #0x80
MOVS            R7, #1
LDR.W           R8, =__FUNCTION__.8311_0 ; "BHB07601_pre_open_core"
MOVT            R3, #0x100
MOVW            R6, #:lower16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"
LSLS            R7, R5
ORR.W           R3, R3, R5,LSL#16
MOV.W           R9, #0
MOVT            R6, #:upper16:aSChainDWorkFif ; "%s: chain%d work fifo not ready: 0x%x\n"
STR             R3, [SP,#0x44+var_40]

loc_20408
core_id = R9            ; unsigned int
ADD.W           R10, core_id, #0x150
MOV             R4, core_id

loc_2040E               ; useconds
core_index = R4         ; unsigned int
MOV.W           R0, #0x3E8
BLX             usleep
MOV             R2, core_index ; core_id
MOVS            R3, #1  ; mode
MOVS            R1, #0  ; which_asic
ADDS            core_index, #0x54 ; 'T'
core_index = R2         ; unsigned int
MOV             R0, R5  ; which_chain
BL              BM1397_enable_core_clock
CMP             R10, R4
BNE             loc_2040E
MOVW            R0, #0x1388 ; useconds
BLX             usleep
B               loc_2043E

loc_20432
work_fifo_ready = R3    ; unsigned int
BLX             printf
MOVW            R0, #0xBB8 ; useconds
BLX             usleep

loc_2043E               ; address
MOVS            R0, #3
BL              read_axi_fpga
MOV             R3, R0
work_fifo_ready = R0    ; unsigned int
MOV             R2, R5
TST             R7, R3
MOV             work_fifo_ready, R6 ; format
work_fifo_ready = R3    ; unsigned int
MOV             R1, R8
BEQ             loc_20432
LDR             work_fifo_ready, [SP,#0x44+var_40]
ADD             R0, SP, #0x44+buf_vil_tw ; value
ADD.W           core_id, core_id, #1
STR             R3, [SP,#0x44+buf_vil_tw]
BL              set_TW_write_command
LDR.W           R0, [R11,#configuration.OpenCoreGap] ; useconds
BLX             usleep
core_id = R9            ; unsigned int
LDR.W           R3, [R11,#configuration.OpenCoreNum2]
CMP             R3, core_id
BHI             loc_20408

loc_2046E
ADD             SP, SP, #0x44 ; 'D'
POP.W           {R4-R11,PC}
; End of function BHB07601_pre_open_core

off_20474 DCD __FUNCTION__.8311_0 ; "BHB07601_pre_open_core"



; void __fastcall dump_core_lost_nonce(unsigned __int8 which_chain, unsigned __int8 which_asic)
EXPORT dump_core_lost_nonce
dump_core_lost_nonce
which_chain = R0        ; unsigned __int8
which_asic = R1         ; unsigned __int8
PUSH.W          {R3-R11,LR}
ADD.W           R2, which_asic, #0x20000
MOVW            R3, #:lower16:cgpu
LDR             R7, =(reg_mutex+0x14)
MOVT            R3, #:upper16:cgpu
ADDS            R2, #0x2A ; '*'
ADD.W           which_asic, which_asic, which_chain,LSL#7
ADD.W           R3, R3, R2,LSL#2
ADDS            which_chain, #0xC
MOVW            R5, #:lower16:Conf
MOVW            R9, #:lower16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
LDR.W           R10, [R3,#4]
works = R10             ; work *
LSLS            R6, R0, #2
ADD.W           R7, R7, R1,LSL#12
MOVT            R5, #:upper16:Conf
MOVT            R9, #:upper16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
MOVS            R4, #0
B               loc_204BC

loc_204B4
which_core = R4         ; unsigned int
ADDS            which_core, #1
CMP.W           which_core, #0x2A0
BEQ             locret_2051E

loc_204BC
LDR.W           R2, [R7,#4]!
LDR             R3, [R5,#configuration.pattern_number]
CMP             R2, R3
BCS             loc_204B4
MOV             R1, which_core
MOV             R0, R9  ; format
BLX             printf
LDR             R3, [R5,#configuration.pattern_number]
MOVW            R8, #:lower16:aD ; "%d  "
MOV.W           R11, #0
MOVT            R8, #:upper16:aD ; "%d  "
CBNZ            R3, loc_204EA
B               loc_20510

loc_204E0
which_pattern = R11     ; unsigned int
LDR             R3, [R5,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R3, which_pattern
BLS             loc_20510

loc_204EA
MLA             R3, R3, which_core, which_pattern
ADD.W           R3, R3, R3,LSL#4
ADD.W           R3, works, R3,LSL#2
ADD             R3, R6
LDR             R3, [R3,#4]
CMP             R3, #0
BNE             loc_204E0
MOV             R1, which_pattern
MOV             R0, R8  ; format
BLX             printf
LDR             R3, [R5,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R3, which_pattern
BHI             loc_204EA

loc_20510               ; c
MOVS            R0, #0xA
ADDS            which_core, #1
BLX             putchar
which_core = R4         ; unsigned int
CMP.W           which_core, #0x2A0
BNE             loc_204BC

locret_2051E
POP.W           {R3-R11,PC}
; End of function dump_core_lost_nonce

ALIGN 4
off_20524 DCD reg_mutex+0x14



; unsigned int __fastcall BHB07601_get_result(unsigned __int8 which_chain)
EXPORT BHB07601_get_result
BHB07601_get_result

ret= -0x10
format= -0xC
s= -8

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
MOV             R4, which_chain
MOVW            R5, #:lower16:Conf
MOVW            which_chain, #:lower16:asc_29AF4 ; "\n\n-----------------------------------"...
SUB             SP, SP, #0x14
MOVT            R5, #:upper16:Conf
MOVT            R0, #:upper16:asc_29AF4 ; "\n\n-----------------------------------"...
MOV.W           R7, #0x2A0
BLX             puts
LDR             R1, [R5,#configuration.pattern_number]
MOVW            R0, #:lower16:aEveryAsicRequi ; "every ASIC require nonce number: %u\n"
MOVS            R6, #0
MOVW            R8, #:lower16:BHB07601_ASIC_NUMBER
MOVW            R9, #:lower16:aIc02d10d ; "IC[%02d]=%-10d"
MOVT            R0, #:upper16:aEveryAsicRequi ; "every ASIC require nonce number: %u\n"
MOVT            R8, #:upper16:BHB07601_ASIC_NUMBER
MOVT            R9, #:upper16:aIc02d10d ; "IC[%02d]=%-10d"
MUL             R1, R7, R1
MOV             R11, R7
MOV             R10, R6
BLX             printf
MOVS            R3, #0xF
STR             R3, [SP,#0x14+ret]

loc_20574
which_asic = R10        ; unsigned int
how_many_asic_not_receive_all_nonce = R6; unsigned int
LDR.W           R3, [R8]
UXTB.W          R1, which_asic ; which_asic
MOV.W           R2, #0x2A0 ; core_number
MOV             R0, R4  ; which_chain
CMP             which_asic, R3
BCS             loc_205C2
BL              calculate_how_many_nonce_per_asic_get
LDR             R3, [R5,#configuration.pattern_number]
MOV             LR, R0
per_asic_received_nonce_number = R0; unsigned int
MOV             R1, which_asic
MOV             per_asic_received_nonce_number, R9 ; format
per_asic_received_nonce_number = R14; unsigned int
MOV             R2, LR
ADD.W           which_asic, which_asic, #1
which_asic = R1         ; unsigned int
MUL             R3, R11, R3
CMP             LR, R3
BCS             loc_205B0
LDR             R3, [SP,#0x14+ret]
ADDS            how_many_asic_not_receive_all_nonce, #1
LDR.W           R7, [R5,#configuration.Invalid_Asic_Num]
CMP             how_many_asic_not_receive_all_nonce, R7
IT HI
MOVHI           R3, #0xE
STR             R3, [SP,#0x14+ret]

loc_205B0
BLX             printf
TST.W           R10, #3
BNE             loc_20574
MOVS            R0, #0xA ; c
BLX             putchar
B               loc_20574

loc_205C2
CMP             R3, #0
BEQ             loc_20648
LDR             how_many_asic_not_receive_all_nonce, =(gAsic_Core_Nonce_Num+0xA7C)
MOVW            R3, #:lower16:aAsic02dD_0 ; "asic[%02d] = %d\n"
MOVW            R2, #:lower16:(aSCanTFindHashb+0x38) ; "\n"
MOV.W           R10, #0
MOV.W           R9, #0x2A0
MOVT            R3, #:upper16:aAsic02dD_0 ; "asic[%02d] = %d\n"
MOVT            R2, #:upper16:(aSCanTFindHashb+0x38) ; "\n"
STR             R3, [SP,#0x14+format]
ADD.W           R6, R6, R4,LSL#19
STR             R2, [SP,#0x14+s]

loc_205E8
which_asic = R10        ; unsigned int
UXTB.W          R7, which_asic
MOV.W           R2, #0x2A0 ; core_number
MOV             R0, R4  ; which_chain
MOV             R1, R7  ; which_asic
BL              calculate_how_many_nonce_per_asic_get
MOV             R11, R0
per_asic_received_nonce_number = R0; unsigned int
LDR             per_asic_received_nonce_number, [R5,#configuration.pattern_number]
per_asic_received_nonce_number = R11; unsigned int
MUL             R3, R9, R0
CMP             per_asic_received_nonce_number, R3
BCS             loc_20638
LDR.W           R2, [R5,#configuration.Least_nonce_per_core]
SUB.W           R3, R6, #0xA80
MOV.W           LR, #0

loc_20610
how_many_core_not_receive_all_nonce_per_asic = R14; unsigned int
LDR.W           R1, [R3,#4]!
CMP             R0, R1
BLS             loc_20620
CMP             R1, R2
IT CC
ADDCC.W         LR, LR, #1

loc_20620
CMP             R6, R3
BNE             loc_20610
LDR.W           R3, [R5,#configuration.Invalid_Core_Num]
CMP             LR, R3
BHI.W           loc_20954

loc_2062E
LDR.W           R3, [R5,#configuration.Dump_Lost_Nonce]
CMP             R3, #0
BNE.W           loc_2093A

loc_20638
LDR.W           R3, [R8]
ADD.W           which_asic, which_asic, #1
ADD.W           R6, R6, #0x1000
CMP             R3, which_asic
BHI             loc_205E8

loc_20648
MOVW            R2, #0xAAAB
LDR             R1, [R5,#configuration.pattern_number]
MOVT            R2, #0xAAAA
MOVS            R6, #0xA8
UMULL           R2, R3, R3, R2
MOV             R0, #aEveryDomainReq ; "\nevery Domain require nonce number: %u"...
MOV             R9, #aD02d10d ; "D[%02d]:%-10d "
MOVW            R10, #:lower16:aDBig02d10d ; "D_BIG[%02d]:%-10d\n"
MUL             R1, R6, R1
MOVT            R10, #:upper16:aDBig02d10d ; "D_BIG[%02d]:%-10d\n"
MOVS            R6, #1
LSRS            R3, R3, #3
MUL             R1, R3, R1
BLX             printf
MOVS            R1, #0  ; which_domain
MOV             R0, R4  ; which_chain
BL              calculate_how_many_nonce_per_domain_get
MOVS            R1, #0
MOV             R2, R0
MOV             R7, R0
total_big_domain_nonce_num = R0; unsigned int
MOV             total_big_domain_nonce_num, R9 ; format
total_big_domain_nonce_num = R2; unsigned int
BLX             printf
B               loc_206AA
ALIGN 4
off_20698 DCD gAsic_Core_Nonce_Num+0xA7C
flt_2069C DCFS 672.0
flt_206A0 DCFS 100.0

loc_206A4
which_domain = R11      ; unsigned int
MOV             R6, which_domain
CMP             R6, #0x30 ; '0'
BEQ             loc_206DC

loc_206AA               ; which_domain
which_domain = R6       ; unsigned int
UXTB            R1, which_domain
MOV             R0, R4  ; which_chain
ADD.W           R11, which_domain, #1
BL              calculate_how_many_nonce_per_domain_get
MOV             R3, R0
per_domain_received_nonce_number = R0; unsigned int
MOV             R1, which_domain
MOV             R2, R3
MOV             per_domain_received_nonce_number, R9 ; format
per_domain_received_nonce_number = R2; unsigned int
ADD             total_big_domain_nonce_num, R3
BLX             printf
ANDS.W          R3, R11, #3
BNE             loc_206A4
MOV             R2, total_big_domain_nonce_num
LSRS            R1, which_domain, #2
MOV             R0, R10 ; format
MOV             which_domain, R11
MOV             total_big_domain_nonce_num, R3
total_big_domain_nonce_num = R2; unsigned int
BLX             printf
which_domain = R6       ; unsigned int
total_big_domain_nonce_num = R7; unsigned int
CMP             which_domain, #0x30 ; '0'
BNE             loc_206AA

loc_206DC
MOVW            R3, #:lower16:gHw_Nonce_Num
MOVW            R0, #:lower16:aHwNumberDConfM_0 ; "\nHW number = %d, Conf.Most_HW_Num = %d"...
MOVT            R3, #:upper16:gHw_Nonce_Num
LDR.W           R2, [R5,#configuration.Most_HW_Num]
MOV             which_domain, R3
which_domain = R11      ; unsigned int
LDR.W           R1, [R3,R4,LSL#2]
MOVT            R0, #:upper16:aHwNumberDConfM_0 ; "\nHW number = %d, Conf.Most_HW_Num = %d"...
STR             R3, [SP,#0x14+s]
BLX             printf
LDR.W           R2, [R6,R4,LSL#2]
MOVW            R0, #:lower16:asc_29CA4 ; "\n-------------------------------------"...
LDR.W           R3, [R5,#configuration.Most_HW_Num]
MOVT            R0, #:upper16:asc_29CA4 ; "\n-------------------------------------"...
LDR             R1, [SP,#0x14+ret]
CMP             R2, R3
IT HI
MOVHI           R1, #0xE
MOV             R6, R1
STR             R1, [SP,#0x14+ret]
ret_0 = R1              ; unsigned int
BLX             puts
MOV             R3, #gSensor_OK
ADD.W           R1, R3, R4,LSL#2
LDRB.W          R0, [R3,R4,LSL#2]
LDRB            R2, [R1,#1]
LDRB            R3, [R1,#2]
LDRB            R1, [R1,#3]
ANDS            R2, R0
ANDS            R3, R2
MOVW            R2, #:lower16:gGlobalHighestTemp
TST             R3, R1
MOVT            R2, #:upper16:gGlobalHighestTemp
IT EQ
MOVEQ           R3, ret_0
LDR             R2, [R2]
IT EQ
BICEQ.W         R3, R3, #2
LDR.W           R1, [R5,#configuration.TargetTemp]
IT EQ
STREQ           R3, [SP,#0x14+ret]
MOV             R3, #gHigherThanAlarmTemp
LDRB            R3, [R3]
CMP             R1, R2
IT LT
ORRLT.W         R3, R3, #1
CBZ             R3, loc_20770
LDR             R3, [SP,#0x14+ret]
BIC.W           R3, R3, #4
STR             R3, [SP,#0x14+ret]

loc_20770
LDR             R3, [R5,#configuration.pattern_number]
MOV.W           R10, #0x2A0
LDR.W           R1, [R8]
MOV             R6, #gBad_Chip
MOVS            R2, #0
STR             R2, [R6,#bad_chip.idx]
MUL             R3, R10, R3
STR             R2, [R6,#bad_chip.idx+4]
STR             R2, [R6,#bad_chip.idx+8]
STR             R2, [R6,#bad_chip.idx+0xC]
STR             R3, [R6,#bad_chip.nonce_num]
STR             R3, [R6,#bad_chip.nonce_num+4]
STR             R3, [R6,#bad_chip.nonce_num+8]
STR             R3, [R6,#bad_chip.nonce_num+0xC]
CMP             R1, #0
BEQ.W           loc_20968
MOVW            which_domain, #0x851F
MOV             R9, R2
MOVT            R11, #0x51EB
MOVS            total_big_domain_nonce_num, #1

loc_207AA
how_many_bad_asic = R9  ; unsigned int
SUBS            R1, R7, #1
which_asic = R1         ; unsigned int
MOV.W           R2, #0x2A0 ; core_number
UXTB            which_asic, which_asic ; which_asic
MOV             R0, R4  ; which_chain
BL              calculate_how_many_nonce_per_asic_get
per_asic_received_nonce_number = R0; unsigned int
LDR             R3, [R5,#configuration.pattern_number]
ADDS            R1, R7, #1
LDR.W           R2, [R5,#configuration.bad_chip_nonce_rate]
MUL             R2, R3, R2
MUL             R2, R10, R2
UMULL           R2, R3, R2, R11
CMP.W           per_asic_received_nonce_number, R3,LSR#5
BCS             loc_207FA
LDR             R3, [R6,#bad_chip.nonce_num]
ADD.W           how_many_bad_asic, how_many_bad_asic, #1
CMP             per_asic_received_nonce_number, R3
BHI             loc_207FA
LDR             R2, [R6,#bad_chip.nonce_num+8]
STR             per_asic_received_nonce_number, [R6,#bad_chip.nonce_num]
LDR             per_asic_received_nonce_number, [R6,#bad_chip.idx+4]
STR             R2, [SP,#0x14+format]
LDR             R2, [R6,#bad_chip.idx+8]
STR             R0, [R6,#bad_chip.idx+8]
LDR             R0, [R6,#bad_chip.nonce_num+4]
STR             R2, [R6,#bad_chip.idx+0xC]
LDR             R2, [SP,#0x14+format]
STR             R0, [R6,#bad_chip.nonce_num+8]
STR             R3, [R6,#bad_chip.nonce_num+4]
STR             R2, [R6,#bad_chip.nonce_num+0xC]
LDR             R2, [R6,#bad_chip.idx]
STR             R7, [R6,#bad_chip.idx]
STR             R2, [R6,#bad_chip.idx+4]

loc_207FA
which_asic = R7         ; unsigned int
LDR.W           R3, [R8]
CMP             R3, which_asic
MOV             which_asic, R1
BHI             loc_207AA

loc_20804
LDR.W           R3, [R5,#configuration.bad_chip_num]
MOVW            R0, #:lower16:aChainDTotalBad ; "Chain%d total bad number: %d\n\n"
MOV             R2, R9
MOV             R1, R4
MOVT            R0, #:upper16:aChainDTotalBad ; "Chain%d total bad number: %d\n\n"
STR.W           R9, [R6]
CMP             R3, R9
MOVW            R6, #:lower16:gValid_Nonce_Num
IT LS
LDRLS           R3, [SP,#0x14+ret]
MOVT            R6, #:upper16:gValid_Nonce_Num
ITT LS
BICLS.W         R3, R3, #8
STRLS           R3, [SP,#0x14+ret]
BLX             printf
LDR.W           R2, [R8]
MOV.W           R3, #0x2A0
LDR             R7, [R5,#configuration.pattern_number]
MOVW            R0, #:lower16:aChainDTotalVal_0 ; "Chain%d total valid nonce number: %d, l"...
LDR.W           LR, [R6,R4,LSL#2]
MOV             R1, R4
MOVT            R0, #:upper16:aChainDTotalVal_0 ; "Chain%d total valid nonce number: %d, l"...
MUL             R7, R2, R7
MOV             R2, LR
MUL             R3, R3, R7
SUB.W           R3, R3, LR
BLX             printf
VLDR            S15, [R5,#configuration.pattern_number]
MOVW            R0, #:lower16:aNonceRateF_0 ; "Nonce rate = %f%% \n\n"
LDR.W           R3, [R6,R4,LSL#2]
MOVT            R0, #:upper16:aNonceRateF_0 ; "Nonce rate = %f%% \n\n"
VLDR            S11, =672.0
VLDR            S13, [R8]
VCVT.F32.U32    S15, S15
VMOV            S14, R3
VLDR            S12, =100.0
VCVT.F32.U32    S13, S13
VMUL.F32        S15, S15, S11
VCVT.F32.U32    S14, S14
VMUL.F32        S15, S15, S13
VMUL.F32        S14, S14, S12
VDIV.F32        S13, S14, S15
VCVT.F64.F32    D7, S13
VMOV            R2, R3, D7
BLX             printf
LDR             R3, [SP,#0x14+ret]
LSLS            R0, R3, #0x1F
ITETE MI
MOVWMI          R0, #0x9D38
MOVWPL          R0, #0x9D44
MOVTMI          R0, #2
MOVTPL          R0, #2  ; s
BLX             puts
LDR             R3, [SP,#0x14+ret]
LSLS            R1, R3, #0x1E
ITETE MI
MOVWMI          R0, #0xAB0C
MOVWPL          R0, #0xAB18
MOVTMI          R0, #2
MOVTPL          R0, #2  ; s
BLX             puts
LDR             R3, [SP,#0x14+ret]
LSLS            R2, R3, #0x1D
ITETE MI
MOVWMI          R0, #0xBC2C
MOVWPL          R0, #0xBC3C
MOVTMI          R0, #2
MOVTPL          R0, #2  ; s
BLX             puts
LDR             R3, [SP,#0x14+ret]
LSLS            R3, R3, #0x1C
ITETE MI
MOVWMI          R0, #0xD754
MOVWPL          R0, #0xD768
MOVTMI          R0, #2
MOVTPL          R0, #2  ; s
BLX             puts
LDR             R3, [SP,#0x14+s]
MOV             R0, #aHwNumberD ; "HW number = %d\n\n"
LDR.W           R1, [R3,R4,LSL#2]
BLX             printf
MOVS            R0, #0x3E ; '>' ; address
BL              read_axi_fpga
MOV             R1, R0
MOV             R0, #aCrcErrorNumber ; "CRC error number = %d\n\n"
BLX             printf
LDR             R0, [SP,#0x14+ret]
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}

loc_2093A
which_asic = R10        ; unsigned int
per_asic_received_nonce_number = R11; unsigned int
MOV             R2, per_asic_received_nonce_number
MOV             R1, which_asic
LDR             R0, [SP,#0x14+format] ; format
BLX             printf
MOV             R0, R4  ; which_chain
MOV             R1, R7  ; which_asic
BL              dump_core_lost_nonce
LDR             R0, [SP,#0x14+s] ; s
BLX             puts
B               loc_20638

loc_20954
how_many_core_not_receive_all_nonce_per_asic = R14; unsigned int
MOVW            R0, #:lower16:aErrorAsicIsD_0 ; "\nerror asic is %d\n"
MOVS            R3, #0xE
MOV             R1, which_asic
MOVT            R0, #:upper16:aErrorAsicIsD_0 ; "\nerror asic is %d\n"
STR             R3, [SP,#0x14+ret]
BLX             printf
B               loc_2062E

loc_20968
which_domain = R11      ; unsigned int
total_big_domain_nonce_num = R7; unsigned int
MOV             R9, R1
B               loc_20804
; End of function BHB07601_get_result




; void __fastcall BHB07601_print_lcd(unsigned int result)
EXPORT BHB07601_print_lcd
BHB07601_print_lcd

var_1C= -0x1C
var_18= -0x18
badchip_info= -0x14

result = R0             ; unsigned int
PUSH.W          {R4-R9,LR}
SUB             SP, SP, #0x1C
MOV             R6, result
ADD             R4, SP, #0x1C+badchip_info
BL              display_level_result_on_lcd
LDR             R3, =dword_2D488
ANDS.W          R5, result, #8
LDR             R0, [R3]
LDR             R1, [R3,#(dword_2D48C - 0x2D488)]
LDR             R2, [R3,#(dword_2D490 - 0x2D488)]
LDR             R3, [R3,#(dword_2D494 - 0x2D488)]
STM             R4!, {R0-R3}
BEQ             loc_20A02
MOV             R0, #aBadChipCheckOk ; "Bad Chip Check OK\n"
BLX             puts
LSLS            R2, result, #0x1F
BMI.W           loc_20AAE
MOVW            R1, #:lower16:aPatternNg_0 ; "   Pattern NG   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aPatternNg_0 ; "   Pattern NG   "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOV             R3, #pattern_test_time
LDRB            R2, [R3]
ADDS            R2, #1
STRB            R2, [R3]

loc_209BC
LSLS            R3, result, #0x1E
MOV.W           R0, #2  ; line
ITETT MI
MOVWMI          R1, #0xBC64
MOVWPL          R1, #0xBC78
MOVMI           R2, #0x10
MOVTMI          R1, #2
ITT PL
MOVPL           R2, #0x10 ; size
MOVTPL          R1, #2  ; buf
BL              write_lcd_no_memset
MOV             R3, #gEEPROM_error
LDRB            R3, [R3]
CMP             R3, #0
BEQ             loc_20ACC
MOVW            R1, #:lower16:aEepromNg ; "   EEPROM NG   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aEepromNg ; "   EEPROM NG   "
MOVS            R0, #3  ; line
BL              write_lcd_no_memset
ADD             SP, SP, #0x1C
POP.W           {R4-R9,PC}

loc_20A02
MOVW            R4, #:lower16:gBad_Chip
MOVW            R0, #:lower16:aBadchipNum2d ; "BadChip Num=%2d "
MOVT            R4, #:upper16:gBad_Chip
MOV.W           R3, #0x20202020
LDR             R1, [R4]
MOVT            R0, #:upper16:aBadchipNum2d ; "BadChip Num=%2d "
STR             R3, [SP,#0x1C+badchip_info]
MOVW            result, #:lower16:a2d4d2d4d ; "%2d-%4d  %2d-%4d\n"
STR             R3, [SP,#0x1C+badchip_info+4]
MOVW            R8, #:lower16:(a2d4d2d4d_0+8) ; "%2d-%4d "
STR             R3, [SP,#0x1C+badchip_info+8]
MOVW            R9, #:lower16:a2d4d2d4d_0 ; "%2d-%4d %2d-%4d "
STR             R3, [SP,#0x1C+badchip_info+0xC]
MOVT            R6, #:upper16:a2d4d2d4d ; "%2d-%4d  %2d-%4d\n"
BLX             printf
MOVW            R1, #:lower16:aBadchipNum2d ; "BadChip Num=%2d "
LDR             R2, [R4]
MOVT            R1, #:upper16:aBadchipNum2d ; "BadChip Num=%2d "
ADD             R0, SP, #0x1C+badchip_info ; s
BLX             sprintf
MOVS            R2, #0x10 ; size
ADD             R1, SP, #0x1C+badchip_info ; buf
MOVS            R0, #1  ; line
MOVT            R8, #:upper16:(a2d4d2d4d_0+8) ; "%2d-%4d "
MOVT            R9, #:upper16:a2d4d2d4d_0 ; "%2d-%4d %2d-%4d "
BL              write_lcd_no_memset

loc_20A56
i = R5                  ; int
LDR             R7, [R4,#0x18]
MOV             R0, R6  ; format
LDR             R3, [R4,#8]
LDR             R2, [R4,#0x14]
LDR             R1, [R4,#4]
STR             R7, [SP,#0x1C+var_1C]
BLX             printf
LDR             R7, [R4,#4]
MOV.W           R3, #0x20202020
STR             R3, [SP,#0x1C+badchip_info]
STR             R3, [SP,#0x1C+badchip_info+4]
STR             R3, [SP,#0x1C+badchip_info+8]
STR             R3, [SP,#0x1C+badchip_info+0xC]
CBZ             R7, loc_20A86
LDR             R3, [R4,#8]
MOV             R2, R7
MOV             R1, R8  ; format
ADD             R0, SP, #0x1C+badchip_info ; s
CBNZ            R3, loc_20AE2
LDR             R3, [R4,#0x14]
BLX             sprintf

loc_20A86
ASRS            R0, i, #1
MOVS            R2, #0x10 ; size
ADDS            i, #2
ADDS            R0, #2  ; line
ADD             R1, SP, #0x1C+badchip_info ; buf
BL              write_lcd_no_memset
i = R5                  ; int
CMP             i, #4
ADD.W           R4, R4, #8
BNE             loc_20A56
MOVW            R3, #:lower16:pattern_test_time
MOVS            R2, #0
MOVT            R3, #:upper16:pattern_test_time
STRB            R2, [R3]
ADD             SP, SP, #0x1C
POP.W           {R4-R9,PC}

loc_20AAE
result = R6             ; unsigned int
MOVW            R1, #:lower16:aPatternOk_0 ; "   Pattern OK   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aPatternOk_0 ; "   Pattern OK   "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R3, #:lower16:pattern_test_time
MOVS            R2, #0
MOVT            R3, #:upper16:pattern_test_time
STRB            R2, [R3]
B               loc_209BC

loc_20ACC
MOVW            R1, #:lower16:aEepromOk ; "   EEPROM OK   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aEepromOk ; "   EEPROM OK   "
MOVS            R0, #3  ; line
BL              write_lcd_no_memset
ADD             SP, SP, #0x1C
POP.W           {R4-R9,PC}

loc_20AE2
i = R5                  ; int
LDR             R7, [R4,#0x18]
MOV             R1, R9  ; format
STR             R3, [SP,#0x1C+var_1C]
LDR             R3, [R4,#0x14]
STR             R7, [SP,#0x1C+var_18]
BLX             sprintf
B               loc_20A86
; End of function BHB07601_print_lcd

ALIGN 4
off_20AF4 DCD dword_2D488



; void kill_hashboard()
EXPORT kill_hashboard
kill_hashboard
MOVW            R0, #:lower16:aPowerOffHashbo ; "\npower off hashboard"
PUSH            {R3,LR}
MOVT            R0, #:upper16:aPowerOffHashbo ; "\npower off hashboard"
BLX             puts
MOVW            R2, #:lower16:gI2c
MOV             R3, #gChain
MOVT            R2, #:upper16:gI2c
LDRB            R1, [R2] ; which_i2c
MOVS            R2, #0  ; enable
LDRB            R0, [R3] ; which_chain
BL              enable_dsPIC33EP16GS202_dc_dc
BL              power_off
MOVS            R0, #0x40 ; '@' ; address
BL              read_axi_fpga
POP.W           {R3,LR}
BIC.W           R1, R0, #0x40 ; '@' ; data
MOVS            R0, #0x40 ; '@' ; address
B.W             write_axi_fpga
; End of function kill_hashboard



; Attributes: noreturn

; void *__fastcall __noreturn BHB07601_show_status_func(void *arg)
EXPORT BHB07601_show_status_func
BHB07601_show_status_func

var_28= -0x28
var_24= -0x24
var_20= -0x20
var_1C= -0x1C
var_18= -0x18
var_14= -0x14
var_10= -0x10
var_C= -0xC
var_8= -8

arg = R0                ; void *
which_chain = R8        ; unsigned __int8
MOVW            R2, #:lower16:gIsReadTemp
PUSH.W          {R4-R11,LR}
MOV             R4, R2
MOVW            R2, #:lower16:gIsOpenCoreEnd
MOV             R5, R2
SUB             SP, SP, #0x2C
MOV             LR, R4
MOVT            R5, #:upper16:gIsOpenCoreEnd
MOVW            R4, #:lower16:gReadingTemp
STR             R5, [SP,#0x2C+var_1C]
MOV             R5, R4
MOVW            R4, #:lower16:Sensor2_temp
MOVT            R5, #:upper16:gReadingTemp
LDRB.W          which_chain, [arg]
STR             R5, [SP,#0x2C+var_10]
MOV             R5, R4
MOVT            R5, #:upper16:Sensor2_temp
MOVW            R4, #:lower16:Sensor1_temp
STR             R5, [SP,#0x2C+var_14]
MOV             R5, R4
MOVT            R5, #:upper16:Sensor1_temp
MOVW            R4, #:lower16:Sensor4_temp
STR             R5, [SP,#0x2C+var_20]
MOV             R5, R4
MOVW            R4, #:lower16:Sensor3_temp
MOV             R3, arg
chain_info = R0         ; chain_info *
MOVT            R4, #:upper16:Sensor3_temp
LDR             R7, =(lcd_output+0x20)
STR             R4, [SP,#0x2C+var_C]
MOV             R4, #gStartTest
MOVW            chain_info, #:lower16:aSWhichChainDWh_0 ; "\n--- %s: which_chain = %d, which_i2c ="...
chain_info = R3         ; chain_info *
STR             R4, [SP,#0x2C+var_28]
MOV             R4, #0xCCCCCCCD
LDRB            chain_info, [chain_info,#1]
which_i2c = R3          ; unsigned __int8
MOVT            LR, #:upper16:gIsReadTemp
MOVT            R5, #:upper16:Sensor4_temp
STR             R4, [SP,#0x2C+var_18]
MOV             R2, which_chain
MOVT            R0, #:upper16:aSWhichChainDWh_0 ; "\n--- %s: which_chain = %d, which_i2c ="...
LDR             R1, =__FUNCTION__.8385_0 ; "BHB07601_show_status_func"
MOVW            R4, #:lower16:time_counter
STR             R5, [SP,#0x2C+var_8]
MOVW            R6, #:lower16:Conf
MOVW            R9, #:lower16:gValid_Nonce_Num
MOVW            R10, #:lower16:lcd_fd
MOVW            R11, #:lower16:gHigherThanAlarmTemp
STR.W           LR, [SP,#0x2C+var_24]
MOVT            R4, #:upper16:time_counter
BLX             printf
MOVS            R3, #0
MOVT            R6, #:upper16:Conf
MOVT            R9, #:upper16:gValid_Nonce_Num
MOVT            R10, #:upper16:lcd_fd
MOVT            R11, #:upper16:gHigherThanAlarmTemp
SUB.W           R5, R7, #0x20 ; ' '
STR             R3, [R4]
B               loc_20C3E

loc_20BF4
MOV             LR, #aTempSettingErr ; "temp setting err!"
LDM.W           LR!, {R0-R3} ; "temp setting err!"
LDRH.W          LR, [LR] ; "!"
STR             R0, [R7]
STR             R1, [R7,#(lcd_output+0x24 - 0x309AC)]
STRH.W          LR, [R7,#(lcd_output+0x30 - 0x309AC)]
STR             R2, [R7,#(lcd_output+0x28 - 0x309AC)]
STR             R3, [R7,#(lcd_output+0x2C - 0x309AC)]

loc_20C10
LDR             R3, [R4]
MOVS            R2, #0x40 ; '@' ; n
MOV             R1, R5  ; buf
LDR.W           R0, [R10] ; fd
ADDS            R3, #1
STR             R3, [R4]
BLX             write
LDR             R3, [SP,#0x2C+var_28]
LDRB            R3, [R3]
CMP             R3, #0
BNE             loc_20CEC

loc_20C2A               ; useconds
MOV             R0, #(gAsic_Core_Nonce_Num+0xC33FC)
BLX             usleep
LDRB.W          R3, [R11]
CMP             R3, #0
BNE             loc_20D24

loc_20C3E               ; n
MOVS            R2, #0x40 ; '@'
MOVS            R1, #0x20 ; ' ' ; c
MOV             R0, R5  ; s
BLX             memset
LDR             R3, =(cgpu.subid+0x7FD54)
LDRB.W          R0, [R3,#(cgpu.fan_speed - 0x330FC4)] ; level
BL              fan_control
LDR             R3, [SP,#0x2C+var_24]
LDR             R2, [R4]
LDRB            R3, [R3]
CBZ             R3, loc_20C72
LDR             R3, [SP,#0x2C+var_1C]
LDRB            R3, [R3]
CBZ             R3, loc_20C72
LDR             R3, [SP,#0x2C+var_18]
UMULL           R0, R1, R2, R3
LSRS            R3, R1, #3
ADD.W           R3, R3, R3,LSL#2
CMP.W           R2, R3,LSL#1
BEQ             loc_20D3A

loc_20C72
MOVW            R1, #:lower16:aTimeDs ; "   time %ds"
MOV             R0, R5  ; s
MOVT            R1, #:upper16:aTimeDs ; "   time %ds"
BLX             sprintf
MOVW            R1, #:lower16:aNonceD ; "   nonce=%d"
LDR.W           R2, [R9,which_chain,LSL#2]
MOVT            R1, #:upper16:aNonceD ; "   nonce=%d"
LDR             R0, =(lcd_output+0x10) ; s
BLX             sprintf
LDR.W           R3, [R6,#configuration.TempSensor1]
CMP             R3, #0
BEQ             loc_20BF4
LDR.W           R3, [R6,#configuration.TempSensor2]
CBZ             R3, loc_20CD8
LDR.W           R3, [R6,#configuration.TempSensor3]
CBZ             R3, loc_20CFE
LDR.W           R3, [R6,#configuration.TempSensor4]
MOVW            R1, #:lower16:aT1DT2D ; " T1:%d   T2:%d"
CMP             R3, #0
BNE             loc_20D7C
LDR             R3, [SP,#0x2C+var_14]
MOVT            R1, #:upper16:aT1DT2D ; " T1:%d   T2:%d"
LDR             R2, [SP,#0x2C+var_20]
LDR             R0, =(lcd_output+0x20) ; s
LDR             R3, [R3]
LDR             R2, [R2]
BLX             sprintf
LDR             R3, [SP,#0x2C+var_C]
MOV             R1, #aT3D ; " T3:%d"
LDR             R0, =(lcd_output+0x30) ; s
LDR             R2, [R3]
BLX             sprintf
B               loc_20C10

loc_20CD8
LDR             R3, [SP,#0x2C+var_20]
MOV             R1, #aT1DC ; "   T1 %d `C"
LDR             R0, =(lcd_output+0x20) ; s
LDR             R2, [R3]
BLX             sprintf
B               loc_20C10

loc_20CEC
MOVW            R0, #:lower16:aGvalidNonceNum ; "\ngValid_Nonce_Num = %d\n"
LDR.W           R1, [R9,which_chain,LSL#2]
MOVT            R0, #:upper16:aGvalidNonceNum ; "\ngValid_Nonce_Num = %d\n"
BLX             printf
B               loc_20C2A

loc_20CFE
LDR             R3, [SP,#0x2C+var_20]
MOV             R1, #aT1DC ; "   T1 %d `C"
LDR             R0, =(lcd_output+0x20) ; s
LDR             R2, [R3]
BLX             sprintf
LDR             R3, [SP,#0x2C+var_14]
MOV             R1, #aT2DC ; "   T2 %d `C"
LDR             R0, =(lcd_output+0x30) ; s
LDR             R2, [R3]
BLX             sprintf
B               loc_20C10

loc_20D24
MOVW            R0, #:lower16:aTempIsHigerTha ; "Temp is higer than AlarmTemp %d\n"
LDR.W           R1, [R6,#configuration.AlarmTemp]
MOVT            R0, #:upper16:aTempIsHigerTha ; "Temp is higer than AlarmTemp %d\n"
BLX             printf
BL              kill_hashboard
B               loc_20C3E

loc_20D3A
LDR.W           R0, [R6,#configuration.timeout]
MOVS            R3, #1
LDR             R2, [SP,#0x2C+var_10]
RSB.W           R0, R0, R0,LSL#4 ; useconds
STRB            R3, [R2]
BLX             usleep
LDR.W           R3, [R6,#configuration.sensor_model]
SUBS            R2, R3, #1
CMP             R2, #1
BLS             loc_20DA6
SUBS            R3, #3
CMP             R3, #5
BLS             loc_20D74
MOVW            R0, #:lower16:aSPleaseConfigS ; "\n%s: please config sensor_model in Con"...
LDR             R1, =__FUNCTION__.8385_0 ; "BHB07601_show_status_func"
MOVT            R0, #:upper16:aSPleaseConfigS ; "\n%s: please config sensor_model in Con"...
BLX             printf

loc_20D6A
LDR             R1, [SP,#0x2C+var_10]
MOVS            R3, #0
LDR             R2, [R4]
STRB            R3, [R1]
B               loc_20C72

loc_20D74               ; which_chain
MOV             R0, which_chain
BL              BM1397_read_asic_temperature_local
B               loc_20D6A

loc_20D7C
LDR             R3, [SP,#0x2C+var_14]
MOVT            R1, #:upper16:aT1DT2D ; " T1:%d   T2:%d"
LDR             R2, [SP,#0x2C+var_20]
LDR             R0, =(lcd_output+0x20) ; s
LDR             R3, [R3]
LDR             R2, [R2]
BLX             sprintf
LDR             R3, [SP,#0x2C+var_8]
MOVW            R1, #:lower16:aT3DT4D ; " T3:%d   T4:%d"
LDR             R2, [SP,#0x2C+var_C]
MOVT            R1, #:upper16:aT3DT4D ; " T3:%d   T4:%d"
LDR             R0, =(lcd_output+0x30) ; s
LDR             R3, [R3]
LDR             R2, [R2]
BLX             sprintf
B               loc_20C10

loc_20DA6               ; which_chain
MOV             R0, which_chain
BL              BM1397_read_asic_temperature_local_remote
B               loc_20D6A
; End of function BHB07601_show_status_func

ALIGN 0x10
off_20DB0 DCD lcd_output+0x20
off_20DB4 DCD __FUNCTION__.8385_0 ; "BHB07601_show_status_func"
off_20DB8 DCD cgpu.subid+0x7FD54
off_20DBC DCD lcd_output+0x10
off_20DC0 DCD lcd_output+0x30



; int __fastcall BHB07601_check_nonce(unsigned __int8 which_chain, unsigned int *buf)
EXPORT BHB07601_check_nonce
BHB07601_check_nonce

var_C= -0xC
var_8= -8

which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
PUSH.W          {R4-R11,LR}
MOVW            R3, #:lower16:gChain_Asic_Interval
LDR.W           R9, [buf,#4]
MOV             R4, buf
MOVT            R3, #:upper16:gChain_Asic_Interval
SUB             SP, SP, #0xC
LDR             buf, [R3]
buf = R4                ; unsigned int *
MOV             R8, which_chain
LDR.W           R11, [buf]
data_0 = R11            ; unsigned int
data_1 = R9             ; unsigned int
UBFX.W          which_chain, data_1, #0xE, #8
BL              __aeabi_uidiv
MOV             R5, R0
which_asic = R0         ; unsigned int
MOV             which_asic, data_1 ; nonce
which_asic = R5         ; unsigned int
BL              BM1397_get_core_id
LDR             R6, [buf]
TST.W           data_0, #0x40
MOV             R7, R0
which_core = R0         ; unsigned int
UBFX.W          R10, R6, #0x17, #8
which_pattern = R10     ; unsigned int
BNE             loc_20EA6

loc_20DFE
which_core = R7         ; unsigned int
MOV             R3, #BHB07601_ASIC_NUMBER
LDR             buf, [R3]
CMP.W           which_core, #0x2A0
IT CC
CMPCC           which_asic, R4
ITE CS
MOVCS           R4, #1
MOVCC           R4, #0
BCS.W           loc_20F22
MOV             R3, #Conf
LDR             R3, [R3,#configuration.pattern_number]
CMP             which_pattern, R3
BCS             loc_20F22
MOVW            R2, #:lower16:cgpu
ADD.W           R1, which_asic, #0x20000
MOVT            R2, #:upper16:cgpu
ADDS            R1, #0x2A ; '*'
MLA             R3, R3, which_core, which_pattern
ADD.W           R2, R2, R1,LSL#2
LDR             R2, [R2,#4]
ADD.W           R3, R3, R3,LSL#4
ADD.W           R3, R2, R3,LSL#2
work = R3               ; work *
LDR             R2, [work,#4]
CMP             data_1, R2
BEQ             loc_20E80
ADD.W           work, R8, R8,LSL#4
match_nonce = R2        ; unsigned int
UBFX.W          R6, R6, #0x10, #7
ADD.W           R6, R6, R6,LSL#4
MOVW            R0, #:lower16:gWorks_For_Hw_Check
LSLS            R3, R3, #9
MOVT            R0, #:upper16:gWorks_For_Hw_Check
MOV             match_nonce, R4 ; print
ADD.W           R6, R3, R6,LSL#2
MOV             R1, data_1 ; nonce
ADD             R0, R6  ; work
BL              check_hw
ret = R0                ; int
CMP             ret, #1
IT NE
MOVNE           ret, R4
BEQ             loc_20EF4

loc_20E7A
ADD             SP, SP, #0xC
POP.W           {R4-data_0,PC}

loc_20E80
match_nonce = R2        ; unsigned int
data_0 = R11            ; unsigned int
data_1 = R9             ; unsigned int
work = R3               ; work *
ADD.W           work, work, R8,LSL#2
LDR             R0, [R3,#0x34]
CBZ             R0, loc_20EBE
MOVW            match_nonce, #:lower16:gRepeated_Nonce_Id
ADDS            R0, #1
MOVT            R2, #:upper16:gRepeated_Nonce_Id
STR             R0, [R3,#0x34]
LDR.W           R3, [R2,R8,LSL#2]
MOV             R0, R4
ADDS            R3, #1
STR.W           R3, [R2,R8,LSL#2]
ADD             SP, SP, #0xC
POP.W           {R4-data_0,PC}

loc_20EA6
buf = R4                ; unsigned int *
which_core = R0         ; unsigned int
data_0 = R11            ; unsigned int
data_1 = R9             ; unsigned int
MOVW            which_core, #:lower16:aSNonceCrcError ; "\n!!! %s: nonce crc error! nonce = 0x%0"...
which_core = R7         ; unsigned int
STMEA.W         SP, {which_core,which_pattern}
MOV             R3, which_asic
MOV             R2, data_1
LDR             R1, =__FUNCTION__.8401 ; "BHB07601_check_nonce"
MOVT            R0, #:upper16:aSNonceCrcError ; "\n!!! %s: nonce crc error! nonce = 0x%0"...
BLX             printf
B               loc_20DFE

loc_20EBE
match_nonce = R2        ; unsigned int
ADD.W           which_asic, which_asic, R8,LSL#7
MOVS            R4, #1
MOVW            match_nonce, #:lower16:gAsic_Core_Nonce_Num
STR             R4, [R3,#0x34]
ADD.W           which_core, which_core, R5,LSL#10
MOVW            R1, #:lower16:gValid_Nonce_Num
MOVT            R2, #:upper16:gAsic_Core_Nonce_Num
MOVT            R1, #:upper16:gValid_Nonce_Num
LDR.W           R3, [R2,R7,LSL#2]
LDR.W           R4, [R1,R8,LSL#2]
ADDS            R3, #1
ADDS            R4, #1
STR.W           R3, [R2,R7,LSL#2]
STR.W           R4, [R1,R8,LSL#2]
ADD             SP, SP, #0xC
POP.W           {R4-data_0,PC}

loc_20EF4
which_asic = R5         ; unsigned int
which_core = R7         ; unsigned int
data_0 = R11            ; unsigned int
data_1 = R9             ; unsigned int
MOVW            LR, #:lower16:gHw_Nonce_Num
STR.W           data_1, [SP,#0xC+var_8]
MOVT            LR, #:upper16:gHw_Nonce_Num
MOVW            R0, #:lower16:aSFindAHwChainD ; "%s: Find a HW. Chain%d ASIC%d Core%d : "...
LDR.W           R6, [LR,R8,LSL#2]
MOV             R3, which_asic
STR             which_core, [SP,#0xC+var_C]
MOV             R2, R8
MOVT            R0, #:upper16:aSFindAHwChainD ; "%s: Find a HW. Chain%d ASIC%d Core%d : "...
LDR             R1, =__FUNCTION__.8401 ; "BHB07601_check_nonce"
ADDS            R6, #1
STR.W           R6, [LR,R8,LSL#2]
BLX             printf
MOV             R0, R4
B               loc_20E7A

loc_20F22
MOV.W           R0, #0xFFFFFFFF
B               loc_20E7A
; End of function BHB07601_check_nonce

off_20F28 DCD __FUNCTION__.8401 ; "BHB07601_check_nonce"



; int __fastcall BHB07601_check_register_value(unsigned __int8 which_chain, unsigned int *buf)
EXPORT BHB07601_check_register_value
BHB07601_check_register_value
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
PUSH            {R3-R7,LR}
MOV             R5, #reg_value_buf
LDR             R4, [buf]
LDR             R2, [R5]
LDR             R7, [buf,#4]
data_0 = R4             ; unsigned int
data_1 = R7             ; unsigned int
LDR             R2, [R2,#8]
CMP.W           R2, #0x1FE
BHI             loc_20FB4
LSLS            R3, data_0, #0x19
BMI             loc_20FC8
ANDS.W          R6, data_0, #0x20000000
BNE             loc_20F9C
MOV             R0, #reg_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R2, [R5]
LSRS            R3, data_0, #8
LSRS            R5, data_0, #0x10
UBFX.W          LR, data_0, #0x18, #5
AND.W           data_0, data_0, #0xF
data_1 = R7             ; unsigned int
LDR             R1, [R2]
ADD.W           R0, R2, R1,LSL#3
ADDS            R1, #1
CMP.W           R1, #0x200
STR             data_1, [R0,#0x10]
STRB.W          LR, [R0,#0x16]
STRB            R5, [R0,#0x14]
STRB            R4, [R0,#0x17]
STRB            R3, [R0,#0x15]
MOVW            R0, #:lower16:reg_mutex
LDR             R3, [R2,#8]
MOVT            R0, #:upper16:reg_mutex ; mutex
STR             R1, [R2]
IT CS
STRCS           R6, [R2]
ADDS            R3, #1
STR             R3, [R2,#8]
BLX             pthread_mutex_unlock
MOVS            R0, #0
POP             {R3-data_1,PC}

loc_20F9C
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
data_0 = R4             ; unsigned int
data_1 = R7             ; unsigned int
MOVW            which_chain, #:lower16:aSRegTypeErrorD ; "%s: REG_TYPE error. data[0] = 0x%08x, r"...
MOV             R3, data_1
MOV             R2, data_0
LDR             buf, =__FUNCTION__.8407 ; "BHB07601_check_register_value"
MOVT            R0, #:upper16:aSRegTypeErrorD ; "%s: REG_TYPE error. data[0] = 0x%08x, r"...
BLX             printf
MOV.W           R0, #0xFFFFFFFF
POP             {R3-data_1,PC}

loc_20FB4
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
data_0 = R4             ; unsigned int
data_1 = R7             ; unsigned int
MOVW            which_chain, #:lower16:aSRegValueBufBu ; "%s: reg_value_buf buffer is full!\n"
LDR             buf, =__FUNCTION__.8407 ; "BHB07601_check_register_value"
MOVT            R0, #:upper16:aSRegValueBufBu ; "%s: reg_value_buf buffer is full!\n"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
POP             {R3-data_1,PC}

loc_20FC8
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
data_0 = R4             ; unsigned int
data_1 = R7             ; unsigned int
MOVW            which_chain, #:lower16:aSRegCrcErrorDa ; "%s: reg crc error. data[0] = 0x%08x, re"...
MOV             R3, data_1
MOV             R2, data_0
LDR             buf, =__FUNCTION__.8407 ; "BHB07601_check_register_value"
MOVT            R0, #:upper16:aSRegCrcErrorDa ; "%s: reg crc error. data[0] = 0x%08x, re"...
BLX             printf
MOV.W           R0, #0xFFFFFFFF
POP             {R3-data_1,PC}
; End of function BHB07601_check_register_value

off_20FE0 DCD __FUNCTION__.8407 ; "BHB07601_check_register_value"



; void *__fastcall BHB07601_receive_func(void *arg)
EXPORT BHB07601_receive_func
BHB07601_receive_func

sp= -0xC
buf= -8

arg = R0                ; void *
which_chain = R8        ; unsigned __int8
PUSH.W          {R4-which_chain,LR}
MOV             R2, arg
chain_info = R0         ; chain_info *
SUB             SP, SP, #0x10
MOVS            R3, #0
MOVS            chain_info, #1 ; algorithm
chain_info = R2         ; chain_info *
LDRB.W          which_chain, [chain_info]
LDRB            R5, [chain_info,#1]
which_i2c = R5          ; unsigned __int8
STR             R3, [SP,#0x10+buf]
STR             R3, [SP,#0x10+buf+4]
STR             R3, [SP,#0x10+sp]
BLX             sched_get_priority_max
MOV             R4, R0
priority = R0           ; const int
STR             priority, [SP,#0x10+sp]
BLX             pthread_self
ADD             R2, SP, #0x10+sp ; param
MOVS            R1, #1  ; policy
MOV             R6, R0
BLX             pthread_setschedparam
CMP             R0, #0
BEQ             loc_21096

loc_21016
MOVW            R0, #:lower16:aSWhichChainDWh_1 ; "\n--- %s: which_chain = %d, which_i2c ="...
MOVW            R6, #:lower16:start_receive
MOVW            R7, #:lower16:gBegin_Get_Nonce
MOV             R3, which_i2c
MOV             R2, which_chain
LDR             R1, =__FUNCTION__.8469 ; "BHB07601_receive_func"
MOVT            R0, #:upper16:aSWhichChainDWh_1 ; "\n--- %s: which_chain = %d, which_i2c ="...
MOVT            R6, #:upper16:start_receive
MOVT            R7, #:upper16:gBegin_Get_Nonce
BLX             printf
B               loc_2104E

loc_2103A               ; useconds
MOV.W           R0, #0x3E8
BLX             usleep
MOVS            R0, #6  ; address
BL              read_axi_fpga
UBFX.W          R4, R0, #0, #9
nonce_number = R4       ; unsigned int
CBNZ            nonce_number, loc_2105A

loc_2104E
LDRB            R0, [R6]
CMP             R0, #0
BNE             loc_2103A
ADD             SP, SP, #0x10
POP.W           {R4-which_chain,PC}

loc_2105A
nonce_number = R4       ; unsigned int
MOVS            R5, #0
B               loc_21068

loc_2105E
i = R5                  ; unsigned int
LDRB            R3, [R7]
CBNZ            R3, loc_21082

loc_21062
ADDS            i, #1
CMP             nonce_number, i
BLS             loc_2104E

loc_21068               ; buf
ADD             R0, SP, #0x10+buf
BL              get_return_nonce
LDR             R0, [SP,#0x10+buf] ; data
BL              BM1397_is_nonce_or_reg_value
CMP             R0, #0
BNE             loc_2105E
ADD             R1, SP, #0x10+buf ; buf
MOV             R0, which_chain ; which_chain
BL              BHB07601_check_register_value
B               loc_21062

loc_21082               ; data
LDR             R0, [SP,#0x10+buf]
BL              BM1397_check_nonce_flag
CMP             R0, #0
BEQ             loc_21062
ADD             R1, SP, #0x10+buf ; buf
MOV             R0, which_chain ; which_chain
BL              BHB07601_check_nonce
B               loc_21062

loc_21096
which_i2c = R5          ; unsigned __int8
priority = R4           ; const int
MOVW            R0, #:lower16:aSIoThreadLxUsi ; "\n--- %s: IO Thread #%lx using %d prior"...
MOV             R3, priority
MOV             R2, R6
LDR             R1, =__FUNCTION__.8469 ; "BHB07601_receive_func"
MOVT            R0, #:upper16:aSIoThreadLxUsi ; "\n--- %s: IO Thread #%lx using %d prior"...
BLX             printf
B               loc_21016
; End of function BHB07601_receive_func

ALIGN 4
off_210AC DCD __FUNCTION__.8469 ; "BHB07601_receive_func"



; void singleBoardTest_BHB07601_BM1397()
EXPORT singleBoardTest_BHB07601_BM1397
singleBoardTest_BHB07601_BM1397

chip_addr= -0x1C
format= -0x18
lcd_display_buf= -0x14

MOVW            R0, #:lower16:aBeginSTest ; "\nBegin %s test\n"
PUSH.W          {R4-R11,LR}
MOV.W           R3, #0x20202020
SUB             SP, SP, #0x1C
MOVT            R0, #:upper16:aBeginSTest ; "\nBegin %s test\n"
MOVW            R4, #:lower16:lcd_fd
LDR             R1, =__FUNCTION__.8483 ; "singleBoardTest_BHB07601_BM1397"
MOVT            R4, #:upper16:lcd_fd
STR             R3, [SP,#0x1C+lcd_display_buf+4]
STR             R3, [SP,#0x1C+lcd_display_buf]
STR             R3, [SP,#0x1C+lcd_display_buf+8]
STR             R3, [SP,#0x1C+lcd_display_buf+0xC]
BLX             printf
MOV             R0, #aDate ; "date"
BLX             system
MOVS            R0, #0xA ; c
BLX             putchar
MOVW            R0, #:lower16:lcd_output
MOVS            R2, #0x40 ; '@' ; n
MOVT            R0, #:upper16:lcd_output ; s
MOVS            R1, #0x20 ; ' ' ; c
BLX             memset
LDR             R0, [R4] ; fd
CMP             R0, #0
BLE             loc_21118
MOVS            R2, #0  ; whence
MOV             R1, R2  ; offset
BLX             lseek
MOVW            R1, #:lower16:lcd_output
LDR             R0, [R4] ; fd
MOVT            R1, #:upper16:lcd_output ; buf
MOVS            R2, #0x40 ; '@' ; n
BLX             write

loc_21118
BL              init_fpga
MOVS            R0, #0x1A ; asic_baud
MOVW            R4, #:lower16:gChain
BL              set_fpga_baud
MOVS            R1, #0  ; data
MOVS            R0, #0x3E ; '>' ; address
BL              write_axi_fpga
MOVS            R0, #0  ; address
MOVT            R4, #:upper16:gChain
BL              read_axi_fpga
UXTH            R1, R0
MOV             R0, #aFpgaVersion0x0 ; "FPGA version 0x%04x\n"
BLX             printf
MOVS            R0, #0  ; address
BL              read_axi_fpga
ORR.W           R1, R0, #0x40000000 ; data
MOVS            R0, #0  ; address
BL              write_axi_fpga
BL              reset_BHB07601_global_arg
BL              check_chain
LDRB            R3, [R4]
CMP             R3, #0xFF
BEQ.W           loc_212CC
LDR             R6, =cgpu.show_id
MOV             R5, #chain_info_0
MOVW            R2, #:lower16:(BHB07601_show_status_func+1)
ADD.W           R3, R5, R3,LSL#1 ; arg
MOVT            R2, #:upper16:(BHB07601_show_status_func+1) ; start_routine
MOV             R0, R6  ; newthread
MOVS            R1, #0  ; attr
BLX             pthread_create
thread_ret = R0         ; unsigned int
MOV             R3, thread_ret
CBZ             thread_ret, loc_211D2
LDR             thread_ret, [R6] ; th
thread_ret = R3         ; unsigned int
BLX             pthread_cancel
MOVW            R1, #:lower16:aCreatShow ; "   Creat show   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCreatShow ; "   Creat show   "
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreateSingleB_2 ; "\n!!!%s: create single_BM1397_show_stat"...
LDR             R1, =__FUNCTION__.8483 ; "singleBoardTest_BHB07601_BM1397"
MOVT            R0, #:upper16:aSCreateSingleB_2 ; "\n!!!%s: create single_BM1397_show_stat"...
BLX             printf

loc_211CC
ADD             SP, SP, #0x1C
POP.W           {R4-R11,PC}

loc_211D2
thread_ret = R0         ; unsigned int
MOVW            R8, #:lower16:gEEPROM_error
MOVW            thread_ret, #:lower16:i2c_mutex
thread_ret = R3         ; unsigned int
MOV             R1, thread_ret ; mutexattr
MOVT            R8, #:upper16:gEEPROM_error
MOVT            R0, #:upper16:i2c_mutex ; mutex
SUB.W           R9, R6, #0x80008
STRB.W          thread_ret, [R8]
BLX             pthread_mutex_init
ADD.W           R3, R9, #0x100000
LDR.W           R3, [R3,#(cgpu.repair_mode - 0x330FC4)]
CMP             R3, #0
BNE             loc_212EE
BL              Test_EEPROM
CMP             R0, #0
BEQ.W           loc_2149C
MOVW            R0, #:lower16:aSTestEepromChe ; "\n!!! %s: Test_EEPROM: Check EEPROM err"...
LDR             R1, =__FUNCTION__.8483 ; "singleBoardTest_BHB07601_BM1397"
MOVT            R0, #:upper16:aSTestEepromChe ; "\n!!! %s: Test_EEPROM: Check EEPROM err"...
BLX             printf
MOVS            R3, #1
STRB.W          R3, [R8]

loc_2121A               ; data
MOVW            R1, #0xFFFF
MOVS            R0, #0xD ; address
BL              write_axi_fpga
MOVW            R7, #:lower16:gI2c
MOVW            R0, #:lower16:(gAsic_Core_Nonce_Num+0x1859C)
MOVT            R7, #:upper16:gI2c
MOVT            R0, #:upper16:(gAsic_Core_Nonce_Num+0x1859C) ; useconds
BLX             usleep
LDRB            R1, [R7] ; which_i2c
LDRB            R0, [R4] ; which_chain
BL              reset_dsPIC33EP16GS202_pic
LDRB            R1, [R7] ; which_i2c
LDRB            R0, [R4] ; which_chain
BL              jump_from_loader_to_app_dsPIC33EP16GS202
LDRB            R3, [R4]
MOV             R2, #(pic_heart_beat_func+1) ; start_routine
MOVS            R1, #0  ; attr
LDR             R0, =cgpu.pic_heart_beat_id ; newthread
ADD.W           R3, R5, R3,LSL#1 ; arg
BLX             pthread_create
thread_ret = R0         ; unsigned int
CMP             thread_ret, #0
BEQ             loc_21320
LDR             thread_ret, [R6] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R3, =cgpu.send_id
LDR             R0, [R3,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOVW            R1, #:lower16:aCreatHeartBeat ; "Creat heart beat"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCreatHeartBeat ; "Creat heart beat"
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreatePicHear ; "\n!!!%s: create pic_heart_beat_func fai"...
LDR             R1, =__FUNCTION__.8483 ; "singleBoardTest_BHB07601_BM1397"
MOVT            R0, #:upper16:aSCreatePicHear ; "\n!!!%s: create pic_heart_beat_func fai"...
BLX             printf
ADD             SP, SP, #0x1C
POP.W           {R4-R11,PC}

loc_212CC
MOVW            R1, #:lower16:aNoHashBoard_0 ; " no hash board  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aNoHashBoard_0 ; " no hash board  "
MOVS            R0, #1  ; line
BL              write_lcd
MOV             R0, #aNoHashBoardPle ; "\nNo hash board, please plug in it"
BLX             puts
ADD             SP, SP, #0x1C
POP.W           {R4-R11,PC}

loc_212EE
BL              Test_EEPROM_part_area
CMP             R0, #0
BEQ.W           loc_214AC
MOVW            R0, #:lower16:aSTestEepromPar ; "\n!!! %s: Test_EEPROM_part_area: Check "...
LDR             R1, =__FUNCTION__.8483 ; "singleBoardTest_BHB07601_BM1397"
MOVT            R0, #:upper16:aSTestEepromPar ; "\n!!! %s: Test_EEPROM_part_area: Check "...
BLX             printf
MOVS            R3, #1
STRB.W          R3, [R8]
B               loc_2121A
ALIGN 0x10
off_21310 DCD __FUNCTION__.8483 ; "singleBoardTest_BHB07601_BM1397"
off_21314 DCD cgpu.show_id
off_21318 DCD cgpu.pic_heart_beat_id
off_2131C DCD cgpu.send_id

loc_21320               ; useconds
MOV             R0, #(gAsic_Core_Nonce_Num+0x1859C)
BLX             usleep
LDRB            R1, [R7] ; which_iic
LDRB            R0, [R4] ; which_chain
BL              set_pre_open_core_voltage
ret = R0                ; int
MOV             R10, ret
CMP             ret, #0
BNE.W           loc_211CC
MOVW            R3, #:lower16:start_receive
MOV.W           R2, #1
MOVT            R3, #:upper16:start_receive
MOVW            ret, #0x2710 ; useconds
ret = R10               ; int
STRB            R2, [R3]
BLX             usleep
LDRB            R3, [R4]
MOV             R2, #(BHB07601_receive_func+1) ; start_routine
MOV             R1, ret ; attr
LDR             R0, =cgpu.receive_id ; newthread
ADD.W           R3, R5, R3,LSL#1 ; arg
BLX             pthread_create
thread_ret = R0         ; unsigned int
MOV             R11, thread_ret
CMP             thread_ret, #0
BNE.W           loc_214BC
MOVS            thread_ret, #0x40 ; '@' ; address
thread_ret = R11        ; unsigned int
MOVW            ret, #:lower16:BHB07601_ASIC_NUMBER
BL              read_axi_fpga
BIC.W           R1, R0, #0x8100
MOVS            R0, #0x40 ; '@' ; address
BIC.W           R1, R1, #0xE0
MOVT            R10, #:upper16:BHB07601_ASIC_NUMBER
ORR.W           R1, R1, #0x8100 ; data
BL              write_axi_fpga
MOVS            R2, #1  ; mode
MOV             R1, thread_ret ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              BM1397_set_clock_order
MOV             R0, #aBhb07601CheckA ; "\n--- BHB07601 check asic number"
BLX             puts
MOVS            R3, #1  ; mode
MOV             R2, thread_ret ; reg
MOV             R1, thread_ret ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              check_BM1397_asic_reg
LDRB            R1, [R4]
MOV             R0, #aCheckChainJDHa ; "\n--- check chain: J%d has asicNum = %d"...
ADD.W           R3, R9, R1
ADDS            R1, #1
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             printf
LDRB            R3, [R4]
LDR.W           R2, [R10]
ADD             R3, R9
ADD.W           R3, R3, #0x100000
LDRB.W          R3, [R3,#0x30C]
CMP             R3, R2
BEQ.W           loc_21528
LDR             R5, =cgpu.send_id
LDR             R0, [R5,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R5,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDRB            R3, [R4]
MOV             R1, #(aT1DT2D+0xC) ; format
ADD.W           R0, SP, #0x1C+lcd_display_buf+7 ; s
ADD             R3, R9
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             sprintf
MOVW            R1, #:lower16:aOnlyHave ; "   Only have    "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aOnlyHave ; "   Only have    "
MOV             R0, thread_ret ; line
BL              write_lcd
ADD             R1, SP, #0x1C+lcd_display_buf ; buf
MOVS            R0, #1  ; line
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aAsic ; "      ASIC      "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aAsic ; "      ASIC      "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
LDRB            R3, [R4]
MOVW            R0, #:lower16:aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
LDR             R1, =__FUNCTION__.8483 ; "singleBoardTest_BHB07601_BM1397"
MOVT            R0, #:upper16:aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
ADD             R9, R3
ADD.W           R9, R9, #0x100000
LDRB.W          R2, [R9,#0x30C]

loc_2146C
BLX             printf
MOV             R0, #asc_29F80 ; "----------------------------\n\n"
BLX             puts

loc_2147C
MOV             R3, #Conf
LDR.W           R0, [R3,#configuration.close_power_delay] ; seconds
BLX             sleep
MOV             R2, thread_ret ; enable
LDRB            R1, [R7] ; which_i2c
LDRB            R0, [R4] ; which_chain
BL              enable_dsPIC33EP16GS202_dc_dc
BL              power_off
B               loc_211CC

loc_2149C
MOVW            R0, #:lower16:aSTestEepromChe_0 ; "\n--- %s: Test_EEPROM: Check EEPROM ok!"...
LDR             R1, =__FUNCTION__.8483 ; "singleBoardTest_BHB07601_BM1397"
MOVT            R0, #:upper16:aSTestEepromChe_0 ; "\n--- %s: Test_EEPROM: Check EEPROM ok!"...
BLX             printf
B               loc_2121A

loc_214AC
MOVW            R0, #:lower16:aSTestEepromPar_0 ; "\n--- %s: Test_EEPROM_part_area: Check "...
LDR             R1, =__FUNCTION__.8483 ; "singleBoardTest_BHB07601_BM1397"
MOVT            R0, #:upper16:aSTestEepromPar_0 ; "\n--- %s: Test_EEPROM_part_area: Check "...
BLX             printf
B               loc_2121A

loc_214BC
thread_ret = R0         ; unsigned int
ret = R10               ; int
LDR             R4, =cgpu.send_id
LDR             thread_ret, [R6] ; th
thread_ret = R11        ; unsigned int
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R4,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDR             R0, [R4,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOVW            R1, #:lower16:aCreatReceive ; "  Creat receive "
MOV             R0, ret ; line
MOVT            R1, #:upper16:aCreatReceive ; "  Creat receive "
MOVS            R2, #0x10 ; size
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOVS            R0, #1  ; line
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreateBhb0760 ; "\n!!!%s: create BHB07601_receive_func f"...
LDR             R1, =__FUNCTION__.8483 ; "singleBoardTest_BHB07601_BM1397"
MOVT            R0, #:upper16:aSCreateBhb0760 ; "\n!!!%s: create BHB07601_receive_func f"...
BLX             printf
B               loc_211CC

loc_21528               ; asic_baud
MOVS            R0, #0x1A
BL              set_fpga_baud
LDRB            R3, [R4]
MOV             R0, #aDoubleCheckAsi ; "\n--- double check asic number"
ADD             R3, R9
ADD.W           R3, R3, #0x100000
STRB.W          thread_ret, [R3,#0x30C]
BLX             puts
MOVS            R3, #1  ; mode
MOV             R2, thread_ret ; reg
MOV             R1, thread_ret ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              check_BM1397_asic_reg
LDRB            R1, [R4]
MOV             R0, #aCheckChainJDHa ; "\n--- check chain: J%d has asicNum = %d"...
ADD.W           R3, R9, R1
ADDS            R1, #1
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             printf
LDRB            R3, [R4]
LDR.W           R2, [R10]
ADD             R3, R9
ADD.W           R3, R3, #0x100000
LDRB.W          R3, [R3,#0x30C]
CMP             R3, R2
BEQ             loc_2160C
LDR             R5, =cgpu.send_id
LDR             R0, [R5,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R5,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDRB            R3, [R4]
MOV             R1, #(aT1DT2D+0xC) ; format
ADD.W           R0, SP, #0x1C+lcd_display_buf+7 ; s
ADD             R3, R9
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             sprintf
MOVW            R1, #:lower16:aOnlyHave ; "   Only have    "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aOnlyHave ; "   Only have    "
MOV             R0, thread_ret ; line
BL              write_lcd
ADD             R1, SP, #0x1C+lcd_display_buf ; buf
MOVS            R0, #1  ; line
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aAsic ; "      ASIC      "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aAsic ; "      ASIC      "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
LDRB            R3, [R4]
MOV             R0, #aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
LDR             R1, =__FUNCTION__.8483 ; "singleBoardTest_BHB07601_BM1397"
ADD             R3, R9
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
B               loc_2146C

loc_2160C
LDR.W           R9, =(cgpu.subid+0x7FD54)
LDRB.W          R3, [R9,#(cgpu.Only_find_ASIC - 0x330FC4)]
STR             R3, [SP,#0x1C+chip_addr]
CBZ             R3, loc_2168C
SUB.W           R9, R9, #0x80000
LDR.W           R0, [R9,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR.W           R0, [R9,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOVW            R1, #:lower16:aFindAllAsic ; " find all ASIC  "
MOVS            R0, #1  ; line
MOVT            R1, #:upper16:aFindAllAsic ; " find all ASIC  "
MOVS            R2, #0x10 ; size
BL              write_lcd
MOVW            R1, #:lower16:aOk ; "       OK       "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aOk ; "       OK       "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aFindDAsicOk ; "\nFind %d ASIC, OK\n"
LDR.W           R1, [R10]
MOVT            R0, #:upper16:aFindDAsicOk ; "\nFind %d ASIC, OK\n"
BLX             printf
B               loc_2147C
off_2167C DCD cgpu.receive_id
off_21680 DCD cgpu.send_id
off_21684 DCD __FUNCTION__.8483 ; "singleBoardTest_BHB07601_BM1397"
off_21688 DCD cgpu.subid+0x7FD54

loc_2168C
MOVW            R10, #:lower16:Conf
MOVW            thread_ret, #:lower16:gSensor_OK
MOVT            R10, #:upper16:Conf
MOVT            R11, #:upper16:gSensor_OK
BL              BHB07601_calculate_timeout_and_baud
LDR.W           R2, [R10,#configuration.Freq] ; freq
MOVS            R3, #1  ; mode
LDR             R1, [SP,#0x1C+chip_addr] ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              set_BM1397_freq_slowly
LDRB            R0, [R4] ; which_chain
BL              BHB07601_set_address
LDRB.W          R1, [R9,#(cgpu.baud - 0x330FC4)] ; baud
LDRB            R0, [R4] ; which_chain
BL              BHB07601_set_baud
LDR.W           R9, [SP,#0x1C+chip_addr]
MOVS            R2, #0x3F ; '?' ; tm
MOVS            R3, #1  ; mode
LDRB            R0, [R4] ; which_chain
MOV             R1, R9  ; asic_addr
BL              BM1397_set_TM
LDR.W           R1, [R10,#configuration.timeout]
MOV             R3, #aSCheckSensorDT ; "\n---%s: check sensor %d time\n"
MOVS            R0, #0x22 ; '"' ; address
STR             R3, [SP,#0x1C+format]
ORR.W           R1, R1, #0x80000000 ; data
STR.W           R9, [SP,#0x1C+chip_addr]
BL              write_axi_fpga
MOVW            R0, #0x2710 ; useconds
BLX             usleep
MOVS            R3, #1  ; mode
LDRB.W          R2, [R10,#configuration.CoreClockDelay] ; reg_data
LDR             R1, [SP,#0x1C+chip_addr] ; which_asic
LDRB            R0, [R4] ; which_chain
BL              BM1397_set_core_clock_delay_all
LDRB            R0, [R4] ; which_chain
BL              BM1397_soft_reset_sensor
LDRB            R0, [R4] ; which_chain
BL              BM1397_enable_extended_mode_of_temperature_sensor
STR             R7, [SP,#0x1C+chip_addr]
MOV             R7, R11
MOV             R11, R5
LDR             R5, [SP,#0x1C+format]

loc_21714
i = R9                  ; unsigned int
LDRB.W          LR, [R4]
MOV             R2, i
LDR             R1, =__FUNCTION__.8483 ; "singleBoardTest_BHB07601_BM1397"
MOV             R0, R5  ; format
ADD.W           i, i, #1
i = R2                  ; unsigned int
LDRB.W          R3, [R7,LR,LSL#2]
ADD.W           LR, R7, LR,LSL#2
CBZ             R3, loc_21742
LDRB.W          R3, [LR,#1]
CBZ             R3, loc_21742
LDRB.W          R3, [LR,#2]
CBZ             R3, loc_21742
LDRB.W          R3, [LR,#3]
CMP             R3, #0
BNE.W           loc_2197E

loc_21742
BLX             printf
LDRB            R0, [R4] ; which_chain
BL              BM1397_read_asic_temperature_local
i = R9                  ; unsigned int
CMP.W           i, #3
BNE             loc_21714
LDR             R7, [SP,#0x1C+chip_addr]
MOV             R5, R11

loc_21756
MOVW            R3, #:lower16:gIsReadTemp
MOVS            R2, #1
MOVT            R3, #:upper16:gIsReadTemp
LDRB            R0, [R4] ; which_chain
STRB            R2, [R3]
MOVW            R9, #:lower16:gStartTest
BL              BHB07601_open_core
LDRB            R1, [R7] ; which_iic
MOVT            R9, #:upper16:gStartTest
LDRB            R0, [R4] ; which_chain
BL              adjust_voltage
MOV             R0, #aBeginSendTestP ; "\nBegin send test pattern"
BLX             puts
LDRB.W          R3, [R9]
CBNZ            R3, loc_217BC
MOVW            R11, #:lower16:time_counter
LDR.W           R3, [R10,#configuration.HeatingUpTime]
MOVT            R11, #:upper16:time_counter
LDR.W           R2, [R11]
CMP             R2, R3
BCC             loc_217AC
B               loc_21852

loc_217A0
LDR.W           R2, [R10,#configuration.HeatingUpTime]
LDR.W           R3, [R11]
CMP             R2, R3
BLS             loc_21852

loc_217AC               ; useconds
MOVW            R0, #0x2710
BLX             usleep
LDRB.W          R3, [R9]
CMP             R3, #0
BEQ             loc_217A0

loc_217BC
LDRB            R3, [R4]
MOVW            R2, #:lower16:(BHB07601_send_func+1)
LDR             R6, =cgpu.send_id
MOVT            R2, #:upper16:(BHB07601_send_func+1) ; start_routine
MOVS            R1, #0  ; attr
ADD.W           R3, R5, R3,LSL#1 ; arg
MOV             R0, R6  ; newthread
BLX             pthread_create
thread_ret = R0         ; unsigned int
MOV             R5, thread_ret
CMP             thread_ret, #0
BEQ             loc_218D8
LDR             thread_ret, [R6,#(cgpu.show_id - 0x2B0FC4)] ; th
thread_ret = R5         ; unsigned int
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R6,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDR             R0, [R6,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOVW            R1, #:lower16:aCreatSend ; "   Creat send   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCreatSend ; "   Creat send   "
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreateBhb0760_0 ; "\n!!!%s: create BHB07601_send_func fail"...
LDR             R1, =__FUNCTION__.8483 ; "singleBoardTest_BHB07601_BM1397"
MOVT            R0, #:upper16:aSCreateBhb0760_0 ; "\n!!!%s: create BHB07601_send_func fail"...
BLX             printf
LDRB            R1, [R7] ; which_i2c
MOVS            R2, #0  ; enable
LDRB            R0, [R4] ; which_chain
BL              enable_dsPIC33EP16GS202_dc_dc
BL              power_off
B               loc_211CC

loc_21852
LDR             R5, =cgpu.send_id
LDR             R0, [R5,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R5,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #aCanTOpenCoreCh ; "Can't open core, change to next voltage"...
BLX             puts
MOVW            R1, #:lower16:aCanTOpenCore ; "Can't open core "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCanTOpenCore ; "Can't open core "
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aChangeToNext ; "change  to  next"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aChangeToNext ; "change  to  next"
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:(aCanTOpenCoreCh+0x20) ; "voltage and freq"
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:(aCanTOpenCoreCh+0x20) ; buf
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R3, #:lower16:pattern_test_time
LDRB            R0, [R4] ; which_chain
MOVT            R3, #:upper16:pattern_test_time
LDRB            R1, [R7] ; which_i2c
LDRB            R4, [R3]
MOVS            R2, #0  ; enable
ADDS            R4, #1
STRB            R4, [R3]
BL              enable_dsPIC33EP16GS202_dc_dc
BL              power_off
B               loc_211CC

loc_218D8               ; thread_return
thread_ret = R0         ; unsigned int
MOV             R1, thread_ret
LDR             thread_ret, [R6] ; th
thread_ret = R5         ; unsigned int
BLX             pthread_join
MOV             R1, R5  ; thread_return
LDR             R0, [R6,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_join
LDR             R0, [R6,#(cgpu.show_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDRB            R0, [R4] ; which_chain
BL              BHB07601_get_result
LSLS            R3, R0, #0x1F
MOV             R5, R0
result = R0             ; unsigned int
BPL             loc_21916
LDRB.W          R3, [R8]
CBNZ            R3, loc_2196E
LDRB            R1, [R4] ; which_chain
LDRB            result, [R7] ; which_iic
result = R5             ; unsigned int
BL              BHB07601_AT24C02_write_total_data
CBZ             R0, loc_21960
MOV             R0, #aEepromOk_0 ; "\nEEPROM OK\n"
BLX             puts

loc_21916               ; result
MOV             R0, result
BL              BHB07601_print_lcd
LDR.W           R0, [R10,#configuration.close_power_delay] ; seconds
BLX             sleep
BL              power_off
MOVS            R0, #0x1E ; seconds
BLX             sleep
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R0, [R6,#(cgpu.pic_heart_beat_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOVS            R0, #0  ; speed
BL              set_fan_speed
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
B               loc_211CC

loc_21960
MOV             R0, #aEepromNg_0 ; "\nEEPROM NG\n"
BLX             puts
B               loc_21916

loc_2196E
result = R0             ; unsigned int
MOVW            result, #:lower16:aSDonTSaveDataI ; "\n!!!%s: Don't save data into EEPROM, b"...
result = R5             ; unsigned int
LDR             R1, =__FUNCTION__.8483 ; "singleBoardTest_BHB07601_BM1397"
MOVT            R0, #:upper16:aSDonTSaveDataI ; "\n!!!%s: Don't save data into EEPROM, b"...
BLX             printf
B               loc_21916

loc_2197E
i = R2                  ; unsigned int
MOVW            R0, #:lower16:aSCheckSensorOk ; "\n---%s: check sensor ok\n"
LDR             R7, [SP,#0x1C+chip_addr]
MOVT            R0, #:upper16:aSCheckSensorOk ; "\n---%s: check sensor ok\n"
MOV             R5, R11
BLX             printf
B               loc_21756
; End of function singleBoardTest_BHB07601_BM1397

off_21990 DCD __FUNCTION__.8483 ; "singleBoardTest_BHB07601_BM1397"
off_21994 DCD cgpu.send_id



; int cgpu_init()
EXPORT cgpu_init
cgpu_init
MOVW            R1, #:lower16:__FUNCTION__.8274 ; "cgpu_init"
MOVW            R0, #:lower16:aS ; "\n--- %s\n"
PUSH            {R3,LR}
MOVT            R1, #:upper16:__FUNCTION__.8274 ; "cgpu_init"
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
BLX             printf
MOV.W           R2, #:lower16:(gAsic_Core_Nonce_Num+0xCF4EC)
MOVW            R0, #:lower16:cgpu
MOVT            R2, #:upper16:(gAsic_Core_Nonce_Num+0xCF4EC) ; n
MOVS            R1, #0  ; c
MOVT            R0, #:upper16:cgpu ; s
BLX             memset
MOVW            R0, #:lower16:Conf
MOV.W           R2, #0x17C ; n
MOVS            R1, #0  ; c
MOVT            R0, #:upper16:Conf ; s
BLX             memset
BL              open_lcd
ret = R0                ; int
CMP             ret, #0
BLE             loc_21A32
MOVW            ret, #:lower16:lcd_output
MOVS            R2, #0x40 ; '@' ; n
MOVS            R1, #0x20 ; ' ' ; c
MOVT            R0, #:upper16:lcd_output ; s
BLX             memset
MOVW            R3, #:lower16:lcd_fd
MOVW            R1, #:lower16:lcd_output
MOVT            R3, #:upper16:lcd_fd
MOVT            R1, #:upper16:lcd_output ; buf
LDR             R0, [R3] ; fd
MOVS            R2, #0x40 ; '@' ; n
BLX             write
BL              open_key
ret = R0                ; int
CMP             ret, #0
BLE             loc_21A50
BL              open_red_led
ret = R0                ; int
CMP             ret, #0
BLE             loc_21A6A
BL              open_green_led
ret = R0                ; int
CMP             ret, #0
BLE             loc_21A84
BL              bitmain_axi_init
ret = R0                ; int
CMP             ret, #0
BLT             AXI_ERR
BL              open_power_control
ret = R0                ; int
CMP             ret, #0
BLE             loc_21AA8
MOVS            ret, #0
POP             {R3,PC}

loc_21A32
ret = R0                ; int
MOVW            R1, #:lower16:__FUNCTION__.8274 ; "cgpu_init"
MOVW            ret, #:lower16:aSOpenLcdDriver ; "!!! %s: open lcd driver error\n"
MOVT            R1, #:upper16:__FUNCTION__.8274 ; "cgpu_init"
MOVT            R0, #:upper16:aSOpenLcdDriver ; "!!! %s: open lcd driver error\n"
BLX             printf

LCD_ERR
BL              close_lcd
MOV.W           R0, #0xFFFFFFFF
POP             {R3,PC}

loc_21A50
ret = R0                ; int
MOVW            R1, #:lower16:__FUNCTION__.8274 ; "cgpu_init"
MOVW            ret, #:lower16:aSOpenStartKeyE ; "!!! %s: open start key error\n"
MOVT            R1, #:upper16:__FUNCTION__.8274 ; "cgpu_init"
MOVT            R0, #:upper16:aSOpenStartKeyE ; "!!! %s: open start key error\n"
BLX             printf

START_KEY_ERR
BL              close_key
B               LCD_ERR

loc_21A6A
ret = R0                ; int
MOVW            R1, #:lower16:__FUNCTION__.8274 ; "cgpu_init"
MOVW            ret, #:lower16:aSOpenRedLedErr ; "!!! %s: open red led error\n"
MOVT            R1, #:upper16:__FUNCTION__.8274 ; "cgpu_init"
MOVT            R0, #:upper16:aSOpenRedLedErr ; "!!! %s: open red led error\n"
BLX             printf

RED_LED_ERR
BL              close_red_led
B               START_KEY_ERR

loc_21A84
ret = R0                ; int
MOVW            R1, #:lower16:__FUNCTION__.8274 ; "cgpu_init"
MOVW            ret, #:lower16:aSOpenGreenLedE ; "!!! %s: open green led error\n"
MOVT            R1, #:upper16:__FUNCTION__.8274 ; "cgpu_init"
MOVT            R0, #:upper16:aSOpenGreenLedE ; "!!! %s: open green led error\n"
BLX             printf

GREEN_LED_ERR
BL              close_green_led
B               RED_LED_ERR

AXI_ERR
ret = R0                ; int
BL              bitmain_axi_close

POWER_CONTROL_ERR
BL              close_power_control
B               GREEN_LED_ERR

loc_21AA8
ret = R0                ; int
MOVW            R1, #:lower16:__FUNCTION__.8274 ; "cgpu_init"
MOVW            ret, #:lower16:aSOpenPowerCont ; "!!! %s: open power control gpio error\n"
MOVT            R1, #:upper16:__FUNCTION__.8274 ; "cgpu_init"
MOVT            R0, #:upper16:aSOpenPowerCont ; "!!! %s: open power control gpio error\n"
BLX             printf
B               POWER_CONTROL_ERR
; End of function cgpu_init

ALIGN 0x10



; void Hardware_close()
EXPORT Hardware_close
Hardware_close
BX              LR
; End of function Hardware_close

ALIGN 4



; void malloc_register_buf()
EXPORT malloc_register_buf
malloc_register_buf
PUSH            {R3,LR}
MOVS            R1, #1  ; size
MOVW            R0, #0x1008 ; nmemb
BLX             calloc
MOV             R3, #reg_value_buf
STR             R0, [R3]
CBZ             R0, loc_21ADE
POP             {R3,PC}

loc_21ADE
MOVW            R0, #:lower16:aSMallocRegValu ; "%s: malloc reg_value_buf failed\n"
LDR             R1, =__FUNCTION__.8287_0 ; "malloc_register_buf"
MOVT            R0, #:upper16:aSMallocRegValu ; "%s: malloc reg_value_buf failed\n"
POP.W           {R3,LR}
B.W             j_printf
; End of function malloc_register_buf

off_21AF0 DCD __FUNCTION__.8287_0 ; "malloc_register_buf"



; int get_works()
EXPORT get_works
get_works

t0= -0x14
t1= -0xC

PUSH            {LR}
SUB             SP, SP, #0x14
MOVS            R1, #0  ; tz
MOV             R0, SP  ; tv
BLX             gettimeofday
MOVW            R3, #:lower16:Conf
MOVW            R2, #0x1397
MOVT            R3, #:upper16:Conf
LDR             R3, [R3,#configuration.AsicType]
CMP             R3, R2
BEQ             loc_21B66
BL              get_works_v1

loc_21B16
ret = R0                ; int
CMP             ret, #0
BLT             loc_21B6C
MOVS            R1, #0  ; tz
ADD             ret, SP, #0x14+t1 ; tv
BLX             gettimeofday
LDR             R1, [SP,#0x14+t0.tv_usec]
MOVW            R0, #:lower16:aGetWorksTook3f ; "get_works took %.3fs\n"
LDR             R2, [SP,#0x14+t1.tv_usec]
MOVT            R0, #:upper16:aGetWorksTook3f ; "get_works took %.3fs\n"
VLDR            S12, =1000000.0
LDR             R3, [SP,#0x14+t1]
SUBS            R2, R2, R1
LDR             R1, [SP,#0x14+t0]
VMOV            S15, R2
VCVT.F32.S32    S14, S15
SUBS            R3, R3, R1
VMOV            S15, R3
VDIV.F32        S13, S14, S12
VCVT.F32.S32    S15, S15
VADD.F32        S15, S13, S15
VCVT.F64.F32    D7, S15
VMOV            R2, R3, D7
BLX             printf
MOVS            R0, #0

loc_21B60
ADD             SP, SP, #0x14
POP.W           {PC}

loc_21B66
BL              get_works_v2
ret = R0                ; int
B               loc_21B16

loc_21B6C
MOV             ret, #0xFFFFFFF2
B               loc_21B60
; End of function get_works

ALIGN 4
flt_21B74 DCFS 1000000.0



; int configMiner()
EXPORT configMiner
configMiner

ret= -8

PUSH            {LR}
SUB             SP, SP, #0xC
BL              read_config
BL              get_works
ret_0 = R0              ; int
CBNZ            ret_0, loc_21B8E
STR             ret_0, [SP,#0xC+ret]
BL              malloc_register_buf
LDR             R0, [SP,#0xC+ret]

loc_21B8E
ADD             SP, SP, #0xC
POP.W           {PC}
; End of function configMiner




; void display_arguments()
EXPORT display_arguments
display_arguments

output= -0x40

PUSH            {R4-R6,LR}
MOVS            R6, #0x40 ; '@'
SUB             SP, SP, #0x40
MOV             R2, R6  ; n
MOV             R0, SP  ; s
MOVS            R1, #0  ; c
MOVW            R5, #:lower16:lcd_fd
MOVW            R4, #:lower16:Conf
BLX             memset
MOVT            R5, #:upper16:lcd_fd
MOVS            R2, #0  ; whence
MOV             R1, R2  ; offset
LDR             R0, [R5] ; fd
BLX             lseek
MOV             R2, R6  ; n
MOV             R0, SP  ; s
MOVS            R1, #0x20 ; ' ' ; c
MOVT            R4, #:upper16:Conf
BLX             memset
MOVW            R3, #:lower16:gName_len
MOV             R1, R4  ; src
MOVT            R3, #:upper16:gName_len
MOV             R0, SP  ; dest
LDR             R2, [R3] ; n
BLX             memcpy
MOVW            R1, #:lower16:aIc2dP2d ; "IC:%2d P:%2d"
LDR             R3, [R4,#configuration.pattern_number]
LDR             R2, [R4,#configuration.AsicNum]
MOVT            R1, #:upper16:aIc2dP2d ; "IC:%2d P:%2d"
ADD             R0, SP, #0x40+output+0x10 ; s
BLX             sprintf
MOVW            R1, #:lower16:aFreqD ; "FREQ: %d"
LDR             R2, [R4,#configuration.Freq1]
MOVT            R1, #:upper16:aFreqD ; "FREQ: %d"
ADD             R0, SP, #0x40+output+0x20 ; s
BLX             sprintf
MOVW            R1, #:lower16:aVoltageD ; "Voltage: %d"
LDR.W           R2, [R4,#configuration.Voltage1]
MOVT            R1, #:upper16:aVoltageD ; "Voltage: %d"
ADD             R0, SP, #0x40+output+0x30 ; s
BLX             sprintf
MOV             R2, R6  ; n
MOV             R1, SP  ; buf
LDR             R0, [R5] ; fd
BLX             write
ADD             SP, SP, #0x40 ; '@'
POP             {R4-R6,PC}
; End of function display_arguments




; void clear_register_value_buf()
EXPORT clear_register_value_buf
clear_register_value_buf
PUSH            {R4-R6,LR}
MOVW            R5, #:lower16:reg_value_buf
LDR             R6, =reg_mutex
MOVT            R5, #:upper16:reg_value_buf
MOVS            R4, #0
MOV             R0, R6  ; mutex
BLX             pthread_mutex_lock
LDR             R3, [R5]
MOV             R0, R6  ; mutex
STR             R4, [R3]
STR             R4, [R3,#4]
STR             R4, [R3,#8]
STR             R4, [R3,#0xC]
BLX             pthread_mutex_unlock
LDR             R0, [R5]
MOV             R1, R4  ; c
MOVW            R2, #0xFF8 ; n
POP.W           {R4-R6,LR}
ADDS            R0, #0x10 ; s
B.W             j_memset
; End of function clear_register_value_buf

ALIGN 4
off_21C54 DCD reg_mutex



; int __fastcall calculate_core_number(unsigned int actual_core_number)
EXPORT calculate_core_number
calculate_core_number
actual_core_number = R0 ; unsigned int
CBZ             actual_core_number, loc_21C6C
CMP             actual_core_number, #1
IT HI
MOVHI           R3, #1
BLS             loc_21C86

loc_21C62
core_number = R3        ; int
LSLS            core_number, core_number, #1
CMP             actual_core_number, core_number
BHI             loc_21C62
MOV             actual_core_number, core_number
BX              LR

loc_21C6C
actual_core_number = R0 ; unsigned int
PUSH            {R4,LR}
MOV             R4, actual_core_number
MOVW            actual_core_number, #:lower16:aSLineDNoteActu ; "%s line %d: Note actual_core_num is 0!"...
actual_core_number = R4 ; unsigned int
MOV.W           R2, #0x13A
MOVT            R0, #:upper16:aSLineDNoteActu ; "%s line %d: Note actual_core_num is 0!"...
LDR             R1, =__FUNCTION__.8309 ; "calculate_core_number"
BLX             printf
MOV             R0, actual_core_number
POP             {actual_core_number,PC}

loc_21C86
actual_core_number = R0 ; unsigned int
MOVS            actual_core_number, #1
BX              LR
; End of function calculate_core_number

ALIGN 4
off_21C8C DCD __FUNCTION__.8309 ; "calculate_core_number"



; unsigned int __fastcall calculate_how_many_nonce_per_asic_get(unsigned __int8 which_chain, unsigned __int8 which_asic, unsigned int core_number)
EXPORT calculate_how_many_nonce_per_asic_get
calculate_how_many_nonce_per_asic_get
which_chain = R0        ; unsigned __int8
which_asic = R1         ; unsigned __int8
core_number = R2        ; unsigned int
CBZ             core_number, loc_21CC0
ADD.W           R3, which_asic, which_chain,LSL#7
PUSH            {R4}
ADD.W           core_number, core_number, #0x40000000
LDR             R4, =gAsic_Core_Nonce_Num
SUBS            R2, #1
MOVS            which_chain, #0
ADD.W           R2, R2, R3,LSL#10
LSLS            R3, R3, #0xC
ADD.W           which_asic, R4, R2,LSL#2
SUBS            R3, #4
ADD             R3, R4

loc_21CB0
ret = R0                ; unsigned int
LDR.W           R2, [R3,#4]!
CMP             R3, R1
ADD             ret, R2
BNE             loc_21CB0
POP.W           {R4}
BX              LR

loc_21CC0
which_chain = R0        ; unsigned __int8
which_asic = R1         ; unsigned __int8
core_number = R2        ; unsigned int
MOV             which_chain, core_number
BX              LR
; End of function calculate_how_many_nonce_per_asic_get

off_21CC4 DCD gAsic_Core_Nonce_Num



; unsigned int __fastcall calculate_how_many_nonce_per_domain_get(unsigned __int8 which_chain, unsigned __int8 which_domain)
EXPORT calculate_how_many_nonce_per_domain_get
calculate_how_many_nonce_per_domain_get
which_chain = R0        ; unsigned __int8
core_id_start = R1      ; unsigned int
PUSH            {R3-R7,LR}
MOV             R3, #BHB07601_ASIC_NUMBER
MOV             R4, #0xAAAAAAAB
MOV             R5, core_id_start
LDR             R2, [R3]
MOV             R6, which_chain
MOV             which_chain, core_id_start
UMULL           R2, R3, R2, R4
LSRS            R4, R3, #3
MOV             core_id_start, R4
BL              __aeabi_uidiv
MOV             core_id_start, R4
LSLS            R4, R0, #2
asic_id_start = R4      ; unsigned int
MOV             R0, R5
BL              __aeabi_uidivmod
MOVS            R3, #0xA8
ADDS            R2, asic_id_start, #4
MUL             core_id_start, R3, core_id_start
CMP             asic_id_start, R2
ADD.W           R7, core_id_start, R3
core_id_end = R7        ; unsigned int
BCS             loc_21D38
ADD.W           R3, asic_id_start, R6,LSL#7
LDR             R5, =(reg_mutex+0x14)
MOVS            R6, #4
ADD.W           R3, core_id_start, R3,LSL#10
MOVS            R0, #0
ADD.W           R5, R5, R3,LSL#2

loc_21D1A
ret = R0                ; unsigned int
CMP             core_id_start, core_id_end
BCS             loc_21D2E
ADD.W           R4, R5, #0x2A0
MOV             R3, R5

loc_21D24
LDR.W           R2, [R3,#4]!
CMP             R3, R4
ADD             ret, R2
BNE             loc_21D24

loc_21D2E
SUBS            R6, #1
ADD.W           R5, R5, #0x1000
BNE             loc_21D1A
POP             {R3-core_id_end,PC}

loc_21D38
asic_id_start = R4      ; unsigned int
MOVS            R0, #0
POP             {R3-core_id_end,PC}
; End of function calculate_how_many_nonce_per_domain_get

off_21D3C DCD reg_mutex+0x14



; void display_level_result_on_lcd()
EXPORT display_level_result_on_lcd
display_level_result_on_lcd

Voltage_char= -0xC

MOVW            R3, #:lower16:__FUNCTION__.8274 ; "cgpu_init"
PUSH            {R4-R7,LR}
MOVT            R3, #:upper16:__FUNCTION__.8274 ; "cgpu_init"
MOV             R4, #(gAsic_Core_Nonce_Num+0x1FF2D4)
SUB             SP, SP, #0xC
LDR.W           R0, [R3,#(off_2D918 - 0x2D8E0)]!
MOVW            R1, #:lower16:a2d ; "%2d"
LDRB.W          R2, [R4,#(pattern_test_time - 0x230118)]
MOVT            R1, #:upper16:a2d ; "%2d"
LDRB            R3, [R3,#(byte_2D91C - 0x2D918)]
STR             R0, [SP,#0xC+Voltage_char]
ADDS            R2, #1
MOV             R0, SP  ; s
STRB.W          R3, [SP,#0xC+Voltage_char+4]
BLX             sprintf
LDRB.W          R7, [SP,#0xC+Voltage_char]
MOVW            R3, #:lower16:lcd_buffer
LDRB.W          R6, [SP,#0xC+Voltage_char+1]
MOVT            R3, #:upper16:lcd_buffer
LDRB.W          R5, [SP,#0xC+Voltage_char+2]
MOV             R1, R3  ; buf
MOVS            R2, #0x10 ; size
MOVS            R0, #0  ; line
STRB            R7, [R3,#(lcd_buffer+0xA - 0x309DC)]
STRB            R6, [R3,#(lcd_buffer+0xB - 0x309DC)]
STRB            R5, [R3,#(lcd_buffer+0xC - 0x309DC)]
BL              write_lcd
LDRB.W          R1, [R4,#(pattern_test_time - 0x230118)]
MOV             R0, #aLevelD ; "Level: %d\n\n"
ADDS            R1, #1
BLX             printf
ADD             SP, SP, #0xC
POP             {R4-R7,PC}
; End of function display_level_result_on_lcd

ALIGN 0x10



; void reset_global_arg()
EXPORT reset_global_arg
reset_global_arg
MOVW            R0, #:lower16:aS ; "\n--- %s\n"
PUSH.W          {R4-R10,LR}
LDR             R1, =__FUNCTION__.8353 ; "reset_global_arg"
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
MOVW            R5, #:lower16:(gAsic_Core_Nonce_Num+0x1FF2D4)
MOVW            R6, #:lower16:gChain
BLX             printf
MOVW            R2, #:lower16:reg_value_buf
MOVS            R4, #0
MOVT            R5, #:upper16:(gAsic_Core_Nonce_Num+0x1FF2D4)
MOVT            R6, #:upper16:gChain
MOV.W           R8, #1
MOVS            R7, #0xFF
MOVT            R2, #:upper16:reg_value_buf
STRB            R7, [R6]
STR.W           R4, [R5,#(time_counter - 0x230118)]
MOV             R1, R4  ; c
STR.W           R4, [R5,#(gHighest_Temp - 0x230118)]
MOVW            R10, #:lower16:uart_send_mutex
STRB.W          R4, [R5,#(gWork_Num_For_Hw_Check - 0x230118)]
MOVW            R9, #:lower16:uart_receive_mutex
STR.W           R4, [R5,#(Sensor1_temp - 0x230118)]
ADDS            R6, #8
STR.W           R4, [R5,#(Sensor2_temp - 0x230118)]
MOVT            R10, #:upper16:uart_send_mutex
STR.W           R4, [R5,#(Sensor3_temp - 0x230118)]
MOVT            R9, #:upper16:uart_receive_mutex
STR.W           R4, [R5,#(Sensor4_temp - 0x230118)]
STR.W           R4, [R5,#(last_Sensor1_temp - 0x230118)]
STR.W           R4, [R5,#(last_Sensor2_temp - 0x230118)]
STR.W           R4, [R5,#(last_Sensor3_temp - 0x230118)]
STR.W           R4, [R5,#(last_Sensor4_temp - 0x230118)]
STR.W           R4, [R5,#(highest_temp - 0x230118)]
STR.W           R4, [R5,#(lowest_temp - 0x230118)]
STR.W           R4, [R5,#(gGlobalHighestTemp - 0x230118)]
STR.W           R4, [R5,#(temp_change - 0x230118)]
STRB.W          R4, [R5,#(gNotReadOutTemp - 0x230118)]
STRB.W          R4, [R5,#(gIsOpenCoreEnd - 0x230118)]
STRB.W          R4, [R5,#(gT1_offset_value - 0x230118)]
STRB.W          R4, [R5,#(gT2_offset_value - 0x230118)]
STRB.W          R4, [R5,#(gT3_offset_value - 0x230118)]
STRB.W          R4, [R5,#(gT4_offset_value - 0x230118)]
STRB.W          R4, [R5,#(gHigherThanMaxTempGap - 0x230118)]
STR.W           R4, [R5,#(gMaxTempGap_value - 0x230118)]
STRB.W          R4, [R5,#(gIsReadTemp - 0x230118)]
STRB.W          R4, [R5,#(gReadingTemp - 0x230118)]
STRB.W          R4, [R5,#(gEEPROM_error - 0x230118)]
STRB.W          R4, [R5,#(gStartTest - 0x230118)]
STRB.W          R8, [R6,#(Sensor1_OK - 0x30B2C)]
STRB.W          R8, [R6,#(Sensor2_OK - 0x30B2C)]
STRB.W          R8, [R6,#(Sensor3_OK - 0x30B2C)]
STRB.W          R8, [R6,#(Sensor4_OK - 0x30B2C)]
STRB.W          R4, [R5,#(gBegin_Get_Nonce - 0x230118)]
LDR             R0, [R2] ; s
MOVW            R2, #0x1008 ; n
STR.W           R4, [R5,#(gValid_Nonce_Num - 0x230118)]
STR.W           R4, [R5,#(gHw_Nonce_Num - 0x230118)]
STR.W           R4, [R5,#(gRepeated_Nonce_Id - 0x230118)]
STR.W           R4, [R5,#(gValid_Nonce_Num+4 - 0x230118)]
STR.W           R4, [R5,#(gValid_Nonce_Num+8 - 0x230118)]
STR.W           R4, [R5,#(gValid_Nonce_Num+0xC - 0x230118)]
STR.W           R4, [R5,#(gHw_Nonce_Num+4 - 0x230118)]
STR.W           R4, [R5,#(gHw_Nonce_Num+8 - 0x230118)]
STR.W           R4, [R5,#(gHw_Nonce_Num+0xC - 0x230118)]
STR.W           R4, [R5,#(gRepeated_Nonce_Id+4 - 0x230118)]
STR.W           R4, [R5,#(gRepeated_Nonce_Id+8 - 0x230118)]
STR.W           R4, [R5,#(gRepeated_Nonce_Id+0xC - 0x230118)]
STRB.W          R4, [R5,#(start_receive - 0x230118)]
BLX             memset
MOVW            R0, #:lower16:gWorks_For_Hw_Check
MOV             R1, R4  ; c
MOV.W           R2, #0x2200 ; n
MOVT            R0, #:upper16:gWorks_For_Hw_Check ; s
BLX             memset
MOVW            R0, #:lower16:gAT24C02_data_map
MOV             R1, R7  ; c
MOV.W           R2, #0x100 ; n
MOVT            R0, #:upper16:gAT24C02_data_map ; s
BLX             memset
ADD.W           R0, R5, #0xDB0 ; s
MOV             R1, R4  ; c
MOVS            R2, #0x40 ; '@' ; n
ADD.W           R5, R5, #0xDF0
BLX             memset
MOVW            R0, #:lower16:lcd_output
MOVS            R2, #0x40 ; '@' ; n
MOVS            R1, #0x20 ; ' ' ; c
MOVT            R0, #:upper16:lcd_output ; s
BLX             memset
MOVW            R3, #:lower16:lcd_fd
MOVW            R1, #:lower16:lcd_output
MOVT            R3, #:upper16:lcd_fd
MOVT            R1, #:upper16:lcd_output ; buf
LDR             R0, [R3] ; fd
MOVS            R2, #0x40 ; '@' ; n
BLX             write
MOV             R1, R4  ; mutexattr
LDR             R0, =reg_mutex ; mutex
MOV             R7, R4
BLX             pthread_mutex_init

loc_21F1C               ; mutexattr
MOVS            R1, #0
ADD.W           R0, R10, R7 ; mutex
BLX             pthread_mutex_init
MOVS            R1, #0  ; mutexattr
ADD.W           R0, R9, R7 ; mutex
BLX             pthread_mutex_init
ADDS            R0, R5, R7 ; mutex
MOVS            R1, #0  ; mutexattr
ADDS            R7, #0x18
ADDS            R6, #4
BLX             pthread_mutex_init
CMP             R7, #0x60 ; '`'
STRB.W          R8, [R6,#-4]
STRB.W          R8, [R6,#-3]
STRB.W          R8, [R6,#-2]
STRB.W          R8, [R6,#-1]
BNE             loc_21F1C
POP.W           {R4-R10,LR}
B.W             clear_register_value_buf
; End of function reset_global_arg

off_21F58 DCD __FUNCTION__.8353 ; "reset_global_arg"
off_21F5C DCD reg_mutex



; void __fastcall rev(unsigned __int8 *s, unsigned __int8 l)
EXPORT rev
rev
s = R0                  ; unsigned __int8 *
l = R1                  ; unsigned __int8
SUBS            l, #1
j = R1                  ; unsigned __int8
ANDS.W          j, j, #0xFF
BEQ             locret_21F82
MOVS            R3, #0
PUSH            {R4-R6}

loc_21F6C
i = R3                  ; unsigned __int8
j = R1                  ; unsigned __int8
LDRB            R4, [s,i]
t = R4                  ; unsigned __int8
ADDS            R5, i, #1
SUBS            R2, j, #1
LDRB            R6, [s,j]
STRB            R6, [s,i]
UXTB            i, R5
STRB            t, [s,j]
UXTB            j, R2
CMP             i, j
BCC             loc_21F6C
POP             {t-R6}

locret_21F82
BX              LR
; End of function rev




; int __fastcall check_hw(work *work, unsigned int nonce, bool print)
EXPORT check_hw
check_hw

var_129= -0x129
hash1= -0x128
hash2= -0x108
ctx= -0xE8

work = R0               ; work *
nonce = R1              ; unsigned int
print = R2              ; bool
PUSH.W          {R4-R10,LR}
SUB             SP, SP, #0x128
MOV             R7, work
MOV             R8, nonce
MOV             R9, print
MOVS            nonce, #0 ; c
nonce = R8              ; unsigned int
MOVS            print, #0x20 ; ' ' ; n
MOV             work, SP ; s
work = R7               ; work *
MOV             R10, work
REV.W           R6, nonce
BLX             memset
MOVS            R2, #0x20 ; ' ' ; n
MOVS            R1, #0  ; c
ADD             R0, SP, #0x128+hash2 ; s
ADD.W           R5, SP, #0x128+ctx.state+0x1F
BLX             memset
hash2_32 = R13          ; uint32_t *
LDR.W           R0, [R10,#0x14]!
ADD.W           R12, SP, #0x128+ctx.state
MOV             R4, R12
ADD.W           LR, SP, #0x128+ctx.state+0x10
LDR.W           R1, [R10,#4]
LDR.W           R2, [R10,#8]
LDR.W           R3, [R10,#0xC]
STM.W           R12!, {R0-R3}
LDR.W           R0, [R10,#0x10]
LDR.W           R1, [R10,#0x14]
LDR.W           R2, [R10,#0x18]
LDR.W           R3, [R10,#0x1C]
STM.W           R12!, {R0-R3}

loc_21FE0
LDRB            R2, [R5]
LDRB            R3, [R4]
STRB.W          R2, [R4],#1
CMP             LR, R4
STRB.W          R3, [R5],#-1
BNE             loc_21FE0
MOV             R2, work
MOV             LR, SP
LDR.W           R0, [R2,#8]!
MOV             R3, SP
ADD.W           R4, SP, #0x128+hash1+0xB
ADD.W           R5, SP, #0x128+hash1+6
MOV.W           R12, #0x50 ; 'P'
LDR             R1, [R2,#4]
LDR             R2, [R2,#8]
STR.W           R12, [SP,#0x128+ctx]
STM.W           LR!, {R0-R2}
MOVS            R2, #0
STR             R2, [SP,#0x128+ctx.total+4]

loc_22016
LDRB            R1, [R4]
LDRB            R2, [R3]
STRB.W          R1, [R3],#1
CMP             R5, R3
STRB.W          R2, [R4],#-1
BNE             loc_22016
MOVS            R2, #0xC ; length
MOV             R1, SP  ; src_p
ADD             R0, SP, #0x128+ctx.buffer ; dest_p
BL              flip_swab
LSRS            R1, R6, #0x18
UBFX.W          R0, R6, #8, #8
UBFX.W          R3, R6, #0x10, #8
STRB.W          R0, [SP,#0x128+hash1+2]
MOVS            R2, #4  ; length
STRB.W          R1, [SP,#0x128+hash1]
ADD             R0, SP, #0x128+ctx.buffer+0xC ; dest_p
MOV             R1, SP  ; src_p
STRB.W          R3, [SP,#0x128+hash1+1]
STRB.W          R6, [SP,#0x128+hash1+3]
BL              flip_swab
MOV             R1, SP  ; output
ADD             R0, SP, #0x128+ctx ; ctx
BL              sha2_finish
MOVS            R2, #0xE8 ; n
MOVS            R1, #0  ; c
ADD             R0, SP, #0x128+ctx ; s
BLX             memset
ADD             R2, SP, #0x128+hash2 ; output
MOVS            R1, #0x20 ; ' ' ; ilen
MOV             R0, SP  ; input
BL              sha2
MOV             R0, SP  ; dest_p
ADD             R1, SP, #0x128+hash2 ; src_p
BL              flip32
LDR             R0, [SP,#0x128+hash1+0x1C]
CBZ             R0, loc_22084
MOVS            R0, #1
CMP.W           R9, #0
BNE             loc_2208A

loc_22084
ADD             SP, SP, #0x128
POP.W           {R4-R10,PC}

loc_2208A
hash2_32 = R13          ; uint32_t *
MOVW            R0, #:lower16:aSGotAHw ; "\n%s: Got a HW!\n"
LDR             R1, =__FUNCTION__.8381 ; "check_hw"
MOVT            R0, #:upper16:aSGotAHw ; "\n%s: Got a HW!\n"
MOVW            R5, #:lower16:a02x_0 ; "%02x"
BLX             printf
MOVW            R0, #:lower16:aHash10x ; "hash1=0x"
MOVT            R5, #:upper16:a02x_0 ; "%02x"
MOVT            R0, #:upper16:aHash10x ; "hash1=0x"
ADD.W           R4, SP, #0x128+var_129
ADD.W           R6, SP, #0x128+hash1+0x1F
BLX             printf

loc_220B4
LDRB.W          R1, [R4,#1]!
MOV             R0, R5  ; format
BLX             printf
CMP             R4, R6
BNE             loc_220B4
MOVS            R0, #0xA ; c
ADD.W           R9, work, #0x13
BLX             putchar
MOVW            R0, #:lower16:aMidstate0x ; "midstate=0x"
MOVW            R5, #:lower16:a02x_0 ; "%02x"
MOVT            R0, #:upper16:aMidstate0x ; "midstate=0x"
MOV             R4, R9
MOVT            R5, #:upper16:a02x_0 ; "%02x"
ADD.W           R6, work, #0x33 ; '3'
BLX             printf

loc_220E6
LDRB.W          R1, [R4,#1]!
MOV             R0, R5  ; format
BLX             printf
CMP             R6, R4
BNE             loc_220E6
MOVW            R0, #:lower16:aData20x ; "\tdata2=0x"
MOVW            R5, #:lower16:a02x_0 ; "%02x"
MOVT            R0, #:upper16:aData20x ; "\tdata2=0x"
MOVT            R5, #:upper16:a02x_0 ; "%02x"
ADDS            R4, work, #7
BLX             printf

loc_2210A
LDRB.W          R1, [R4,#1]!
MOV             R0, R5  ; format
BLX             printf
CMP             R9, R4
BNE             loc_2210A
MOVW            R0, #:lower16:aReturnNonce0x0 ; "\treturn nonce=0x%08x, but it should be"...
LDR             R2, [work,#4]
MOV             R1, nonce
MOVT            R0, #:upper16:aReturnNonce0x0 ; "\treturn nonce=0x%08x, but it should be"...
BLX             printf
MOVS            R0, #1
ADD             SP, SP, #0x128
POP.W           {R4-R10,PC}
; End of function check_hw

off_22130 DCD __FUNCTION__.8381 ; "check_hw"



; int open_red_led()
EXPORT open_red_led
open_red_led
MOVW            R0, #:lower16:aSysClassGpioGp_1 ; "/sys/class/gpio/gpio941/value"
PUSH            {R4,LR}
MOVW            R1, #0x801 ; oflag
MOVT            R0, #:upper16:aSysClassGpioGp_1 ; "/sys/class/gpio/gpio941/value"
MOVW            R4, #:lower16:red_led_fd
BLX             open
CMP             R0, #0
MOVT            R4, #:upper16:red_led_fd
STR             R0, [R4]
BLT             loc_22156
POP             {R4,PC}

loc_22156
MOV             R0, #aOpenRedLedFail ; "open red led failed!!!"
BLX             puts
LDR             R0, [R4]
POP             {R4,PC}
; End of function open_red_led

ALIGN 4



; void close_red_led()
EXPORT close_red_led
close_red_led
PUSH            {R3,LR}
MOV             R3, #red_led_fd
LDR             R0, [R3] ; fd
BLX             close
MOVW            R0, #:lower16:aRedLedClosed ; "red led closed!!!"
POP.W           {R3,LR}
MOVT            R0, #:upper16:aRedLedClosed ; "red led closed!!!"
B.W             j_puts
; End of function close_red_led




; void red_led_on()
EXPORT red_led_on
red_led_on
MOVW            R3, #:lower16:red_led_fd
MOVW            R1, #:lower16:a1 ; "1"
MOVT            R3, #:upper16:red_led_fd
MOVT            R1, #:upper16:a1 ; "1"
LDR             R0, [R3] ; fd
MOVS            R2, #1  ; n
B.W             j_write
; End of function red_led_on




; void red_led_off()
EXPORT red_led_off
red_led_off
MOVW            R3, #:lower16:red_led_fd
MOVW            R1, #:lower16:a0 ; "0"
MOVT            R3, #:upper16:red_led_fd
MOVT            R1, #:upper16:a0 ; "0"
LDR             R0, [R3] ; fd
MOVS            R2, #1  ; n
B.W             j_write
; End of function red_led_off




; int open_green_led()
EXPORT open_green_led
open_green_led
MOVW            R0, #:lower16:aSysClassGpioGp_2 ; "/sys/class/gpio/gpio942/value"
PUSH            {R4,LR}
MOVW            R1, #0x801 ; oflag
MOVT            R0, #:upper16:aSysClassGpioGp_2 ; "/sys/class/gpio/gpio942/value"
MOVW            R4, #:lower16:red_led_fd
BLX             open
CMP             R0, #0
MOVT            R4, #:upper16:red_led_fd
STR             R0, [R4,#(green_led_fd - 0x230F9C)]
BLT             loc_221DA
POP             {R4,PC}

loc_221DA
MOV             R0, #aOpenGreenLedFa ; "open green led failed!!!"
BLX             puts
LDR             R0, [R4,#(green_led_fd - 0x230F9C)]
POP             {R4,PC}
; End of function open_green_led

ALIGN 4



; void close_green_led()
EXPORT close_green_led
close_green_led
PUSH            {R3,LR}
MOV             R3, #red_led_fd
LDR             R0, [R3,#(green_led_fd - 0x230F9C)] ; fd
BLX             close
MOVW            R0, #:lower16:aGreenLedClosed ; "green led closed!!!"
POP.W           {R3,LR}
MOVT            R0, #:upper16:aGreenLedClosed ; "green led closed!!!"
B.W             j_puts
; End of function close_green_led




; void green_led_on()
EXPORT green_led_on
green_led_on
MOVW            R3, #:lower16:red_led_fd
MOVW            R1, #:lower16:a1 ; "1"
MOVT            R3, #:upper16:red_led_fd
MOVT            R1, #:upper16:a1 ; "1"
LDR             R0, [R3,#(green_led_fd - 0x230F9C)] ; fd
MOVS            R2, #1  ; n
B.W             j_write
; End of function green_led_on




; void green_led_off()
EXPORT green_led_off
green_led_off
MOVW            R3, #:lower16:red_led_fd
MOVW            R1, #:lower16:a0 ; "0"
MOVT            R3, #:upper16:red_led_fd
MOVT            R1, #:upper16:a0 ; "0"
LDR             R0, [R3,#(green_led_fd - 0x230F9C)] ; fd
MOVS            R2, #1  ; n
B.W             j_write
; End of function green_led_off




; void __fastcall write_pic1704(unsigned __int8 which_i2c, unsigned __int8 which_chain, unsigned __int8 data)
EXPORT write_pic1704
write_pic1704
which_i2c = R0          ; unsigned __int8
which_chain = R1        ; unsigned __int8
data = R2               ; unsigned __int8
ORR.W           data, data, #0xA00000
ORR.W           which_chain, R2, which_chain,LSL#16
ORR.W           which_i2c, R1, which_i2c,LSL#26
B.W             i2c_write
; End of function write_pic1704




; unsigned __int8 __fastcall read_pic1704(unsigned __int8 which_i2c, unsigned __int8 which_chain)
EXPORT read_pic1704
read_pic1704
which_i2c = R0          ; unsigned __int8
which_chain = R1        ; unsigned __int8
LSLS            which_chain, which_chain, #0x10
ORR.W           R1, R1, #0xA00000
ORR.W           which_i2c, R1, which_i2c,LSL#26
B.W             i2c_read
; End of function read_pic1704

ALIGN 4



; void __fastcall write_dspic33ep16gs202(unsigned __int8 which_i2c, unsigned __int8 which_chain, unsigned __int8 data)
EXPORT write_dspic33ep16gs202
write_dspic33ep16gs202
which_i2c = R0          ; unsigned __int8
which_chain = R1        ; unsigned __int8
data = R2               ; unsigned __int8
ORR.W           data, data, #0x400000
ORR.W           which_chain, R2, which_chain,LSL#16
ORR.W           which_i2c, R1, which_i2c,LSL#26
B.W             i2c_write
; End of function write_dspic33ep16gs202




; unsigned __int8 __fastcall read_dspic33ep16gs202(unsigned __int8 which_i2c, unsigned __int8 which_chain)
EXPORT read_dspic33ep16gs202
read_dspic33ep16gs202
which_i2c = R0          ; unsigned __int8
which_chain = R1        ; unsigned __int8
LSLS            which_chain, which_chain, #0x10
ORR.W           R1, R1, #0x400000
ORR.W           which_i2c, R1, which_i2c,LSL#26
B.W             i2c_read
; End of function read_dspic33ep16gs202

ALIGN 4


; Attributes: bp-based frame

; int __fastcall set_PIC16F1704_flash_pointer(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 flash_addr_h, unsigned __int8 flash_addr_l)
EXPORT set_PIC16F1704_flash_pointer
set_PIC16F1704_flash_pointer

var_8= -8
var_7= -7
var_6= -6
var_5= -5
flash_addr_h= -4
flash_addr_l= -3
var_2= -2
var_1= -1

which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
flash_addr_h_0 = R2     ; unsigned __int8
flash_addr_l_0 = R3     ; unsigned __int8
PUSH.W          {R4-R8,LR}
ADDS            R4, flash_addr_h_0, flash_addr_l_0
ADDS            R4, #7
MOV             R6, which_chain
SUB             SP, SP, #8
MOV.W           LR, R4,LSR#8
MOV             R8, which_i2c
crc = R4                ; unsigned __int16
LSLS            R6, R6, #0x10
MOVW            which_i2c, #:lower16:i2c_mutex
which_i2c = R8          ; unsigned int
STRB.W          flash_addr_h_0, [SP,#8+flash_addr_h]
MOVS            R5, #0x55 ; 'U'
STRB.W          flash_addr_l_0, [SP,#8+flash_addr_l]
MOVS            which_chain, #0xAA
MOVS            flash_addr_h_0, #6
MOVS            flash_addr_l_0, #1
MOVT            R0, #:upper16:i2c_mutex ; mutex
ADD             R7, SP, #8
STRB.W          R5, [SP,#8+var_8]
STRB.W          crc, [R7,#var_1]!
MOV             crc, SP
STRB.W          LR, [SP,#8+var_2]
STRB.W          R1, [SP,#8+var_7]
STRB.W          R2, [SP,#8+var_6]
STRB.W          R3, [SP,#8+var_5]
BLX             pthread_mutex_lock
MOV             R0, R5
ORR.W           R5, R6, #0xA00000
ORR.W           R5, R5, which_i2c,LSL#26
B               loc_222D8

loc_222D4
LDRB.W          R0, [R4,#1]!

loc_222D8               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R4
BNE             loc_222D4
MOV             R0, #0x186A0 ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R6, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
CMP             R6, #1
MOVW            R1, #:lower16:__FUNCTION__.8002 ; "set_PIC16F1704_flash_pointer"
BNE             loc_22316
CMP             R4, #1
BEQ             loc_22332

loc_22316
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
MOVT            R1, #:upper16:__FUNCTION__.8002 ; "set_PIC16F1704_flash_pointer"
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #8
POP.W           {R4-which_i2c,PC}

loc_22332
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
MOVT            R1, #:upper16:__FUNCTION__.8002 ; "set_PIC16F1704_flash_pointer"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, R4
ADD             SP, SP, #8
POP.W           {R4-which_i2c,PC}
; End of function set_PIC16F1704_flash_pointer

ALIGN 4



; int __fastcall send_data_to_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf)
EXPORT send_data_to_PIC16F1704
send_data_to_PIC16F1704

var_1D= -0x1D
send_data= -0x1C
var_4= -4

which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
buf = R2                ; unsigned __int8 *
PUSH            {R4-R7,LR}
SUBS            R4, buf, #1
MOV             R6, which_i2c
ADDS            buf, #0xF
MOV             which_i2c, R4
which_i2c = R6          ; unsigned int
MOVS            R3, #0x16
SUB             SP, SP, #0x1C
MOV             R7, which_chain
MOVS            which_chain, #0
STR             R1, [SP,#0x1C+send_data+4]
STR             R1, [SP,#0x1C+send_data+8]
STR             R1, [SP,#0x1C+send_data+0xC]
STR             R1, [SP,#0x1C+send_data+0x10]

loc_22366
crc = R3                ; unsigned __int16
LDRB.W          R5, [R0,#1]!
CMP             R0, R2
ADD             crc, R5
UXTH            R3, R3
crc = R3                ; unsigned __int16
BNE             loc_22366
MOVS            R2, #0x55 ; 'U'
LSRS            R5, crc, #8
UXTB            crc, crc
crc_data_0 = R5         ; unsigned __int8
crc_data_1 = R3         ; unsigned __int8
MOVS            R0, #0xAA
STRB.W          R2, [SP,#0x1C+send_data]
ADD.W           R1, SP, #0x1C+send_data+0x13
MOVS            R2, #0x14
STRB.W          R0, [SP,#0x1C+send_data+1]
STRB.W          R2, [SP,#0x1C+send_data+2]
MOVS            R0, #2
ADD             R2, SP, #0x1C+var_4
STRB.W          R0, [R2,#-0x15]!

loc_22394
LDRB.W          R0, [R4,#1]!
STRB.W          R0, [R2,#1]!
CMP             R2, R1
BNE             loc_22394
STRB.W          crc_data_0, [SP,#0x1C+send_data+0x14]
LSLS            crc_data_0, R7, #0x10
crc_data_1 = R3         ; unsigned __int8
MOVW            R0, #:lower16:i2c_mutex
STRB.W          crc_data_1, [SP,#0x1C+send_data+0x15]
ORR.W           R5, R5, #0xA00000
ADD.W           R4, SP, #0x1C+var_1D
ORR.W           R5, R5, which_i2c,LSL#26
ADD.W           R7, SP, #0x1C+send_data+0x15
MOVT            R0, #:upper16:i2c_mutex ; mutex
BLX             pthread_mutex_lock

loc_223C6
LDRB.W          R0, [R4,#1]!
ORRS            R0, R5  ; config_data
BL              i2c_write
CMP             R7, R4
BNE             loc_223C6
MOV             R0, #0x186A0 ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             which_i2c, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
CMP             R6, #2
BNE             loc_22404
CMP             R4, #1
BEQ             loc_2241C

loc_22404
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8026 ; "send_data_to_PIC16F1704"
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x1C
POP             {R4-R7,PC}

loc_2241C
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8026 ; "send_data_to_PIC16F1704"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, R4
ADD             SP, SP, #0x1C
POP             {R4-R7,PC}
; End of function send_data_to_PIC16F1704

off_22430 DCD __FUNCTION__.8026 ; "send_data_to_PIC16F1704"



; int __fastcall read_PIC16F1704_flash_pointer(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *flash_addr_h, unsigned __int8 *flash_addr_l)
EXPORT read_PIC16F1704_flash_pointer
read_PIC16F1704_flash_pointer

var_24= -0x24
var_20= -0x20
var_1C= -0x1C
var_18= -0x18
read_back_data= -0x14
var_E= -0xE
send_data= -0xC
var_4= -4

which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
flash_addr_h = R2       ; unsigned __int8 *
flash_addr_l = R3       ; unsigned __int8 *
PUSH.W          {R4-R11,LR}
MOV             R6, which_chain
SUB             SP, SP, #0x24
MOVS            R5, #4
MOV             R10, which_i2c
MOVW            which_i2c, #:lower16:i2c_mutex
which_i2c = R10         ; unsigned int
STRB.W          R5, [SP,#0x24+send_data+2]
LSLS            R5, R6, #0x10
MOVS            which_chain, #0
MOV.W           R12, #0xFF
MOV.W           R11, #0x55 ; 'U'
MOV.W           LR, #0xAA
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOV             R7, flash_addr_h
MOV             R8, flash_addr_l
MOVS            flash_addr_h, #8
flash_addr_h = R7       ; unsigned __int8 *
MOVS            flash_addr_l, #0xC
flash_addr_l = R8       ; unsigned __int8 *
ADD.W           R9, SP, #0x24+var_4
ORR.W           R5, R5, #0xA00000
STR             R1, [SP,#0x24+read_back_data]
ADD             R4, SP, #0x24+send_data
STRH.W          R1, [SP,#0x24+send_data+4]
ORR.W           R5, R5, which_i2c,LSL#26
STRH.W          R1, [SP,#0x24+read_back_data+4]
STRB.W          R12, [SP,#0x24+read_back_data]
STRB.W          R11, [SP,#0x24+send_data]
STRB.W          LR, [SP,#0x24+send_data+1]
STRB.W          R2, [SP,#0x24+send_data+3]
STRB.W          R3, [R9,#-3]!
BLX             pthread_mutex_lock
MOV             R0, R11
B               loc_2249C

loc_22498
LDRB.W          R0, [R4,#1]!

loc_2249C               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R4, R9
BNE             loc_22498
MOVW            R0, #:lower16:loc_186A0
ADD             R4, SP, #0x24+read_back_data
MOVT            R0, #:upper16:loc_186A0 ; useconds
ADD.W           R6, SP, #0x24+var_E
BLX             usleep

loc_224B8               ; config_data
MOV             R0, R5
BL              i2c_read
STRB.W          R0, [R4],#1
CMP             R6, R4
BNE             loc_224B8
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDRB.W          R3, [SP,#0x24+read_back_data+1]
LDRB.W          R2, [SP,#0x24+read_back_data]
CMP             R3, #8
BNE             loc_224E2
CMP             R2, #6
BEQ             loc_2250C

loc_224E2
LDRB.W          R1, [SP,#0x24+read_back_data+2]
MOVW            R0, #:lower16:aSFailedReadBac_0 ; "\n--- %s failed! read_back_data[0] = 0x"...
LDRB.W          R6, [SP,#0x24+read_back_data+5]
MOVT            R0, #:upper16:aSFailedReadBac_0 ; "\n--- %s failed! read_back_data[0] = 0x"...
LDRB.W          R5, [SP,#0x24+read_back_data+4]
LDRB.W          R4, [SP,#0x24+read_back_data+3]
STMEA.W         SP, {R1,R4-R6}
LDR             R1, =__FUNCTION__.8045 ; "read_PIC16F1704_flash_pointer"
BLX             printf
MOVS            R0, #0

loc_22506
ADD             SP, SP, #0x24 ; '$'
POP.W           {R4-R11,PC}

loc_2250C
LDRB.W          R1, [SP,#0x24+read_back_data+2]
LDRB.W          R2, [SP,#0x24+read_back_data+3]
LDRB.W          R4, [SP,#0x24+read_back_data+4]
LDRB.W          R5, [SP,#0x24+read_back_data+5]
ADDS            R3, R1, R2
ADDS            R3, #0xE
crc = R3                ; unsigned __int16
UBFX.W          R0, crc, #8, #8
CMP             R0, R4
BNE             loc_2252E
UXTB            crc, crc
CMP             R3, R5
BEQ             loc_22550

loc_2252E
MOVW            R0, #:lower16:aSFailedReadBac_0 ; "\n--- %s failed! read_back_data[0] = 0x"...
STR             R2, [SP,#0x24+var_20]
STR             R1, [SP,#0x24+var_24]
MOVS            R3, #8
STR             R5, [SP,#0x24+var_18]
MOVS            R2, #6
STR             R4, [SP,#0x24+var_1C]
MOVT            R0, #:upper16:aSFailedReadBac_0 ; "\n--- %s failed! read_back_data[0] = 0x"...
LDR             R1, =__FUNCTION__.8045 ; "read_PIC16F1704_flash_pointer"
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x24 ; '$'
POP.W           {R4-R11,PC}

loc_22550
MOVW            R0, #:lower16:aSOkFlashAddrH0 ; "\n--- %s ok! flash_addr_h = 0x%02x, fla"...
STRB            R1, [flash_addr_h]
MOV             R3, R2
STRB.W          R2, [flash_addr_l]
MOVT            R0, #:upper16:aSOkFlashAddrH0 ; "\n--- %s ok! flash_addr_h = 0x%02x, fla"...
LDRB            R2, [flash_addr_h]
LDR             R1, =__FUNCTION__.8045 ; "read_PIC16F1704_flash_pointer"
BLX             printf
MOVS            R0, #1
B               loc_22506
; End of function read_PIC16F1704_flash_pointer

off_2256C DCD __FUNCTION__.8045 ; "read_PIC16F1704_flash_pointer"


; Attributes: bp-based frame fpd=4

; int __fastcall read_PIC16F1704_flash_data(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf)
EXPORT read_PIC16F1704_flash_data
read_PIC16F1704_flash_data

var_98= -0x98
var_94= -0x94
var_90= -0x90
var_8C= -0x8C
var_88= -0x88
var_84= -0x84
var_80= -0x80
var_7C= -0x7C
var_78= -0x78
var_74= -0x74
var_70= -0x70
var_6C= -0x6C
var_68= -0x68
var_64= -0x64
var_60= -0x60
var_58= -0x58
var_54= -0x54
var_50= -0x50
var_4C= -0x4C
var_48= -0x48
var_44= -0x44
var_40= -0x40
var_3C= -0x3C
var_38= -0x38
var_34= -0x34
var_30= -0x30
var_2C= -0x2C
buf= -0x28
send_data= -0x20
var_19= -0x19
read_back_data= -0x18

which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
buf_0 = R2              ; unsigned __int8 *
PUSH.W          {R4-R11,LR}
MOV             R4, which_chain
SUB             SP, SP, #0xA4
MOVS            R5, #0xAA
MOVS            R3, #0
MOV             R9, which_i2c
STRB.W          R5, [SP,#0xA4+send_data+1]
LSLS            R5, R4, #0x10
MOVS            R7, #0xFF
STR             R3, [SP,#0xA4+read_back_data]
MOVW            which_i2c, #:lower16:i2c_mutex
which_i2c = R9          ; unsigned int
STRH.W          R3, [SP,#0xA4+send_data+4]
MOV.W           R8, #0x55 ; 'U'
STR             buf_0, [SP,#0xA4+buf]
STR             R3, [SP,#0xA4+read_back_data+4]
MOVS            which_chain, #4
STR             R3, [SP,#0xA4+read_back_data+8]
MOVS            buf_0, #3
STR             R3, [SP,#0xA4+read_back_data+0xC]
MOVT            R0, #:upper16:i2c_mutex ; mutex
STR             R3, [SP,#0xA4+read_back_data+0x10]
ORR.W           R5, R5, #0xA00000
STRB.W          R7, [SP,#0xA4+read_back_data]
MOVS            R3, #7
ADD             R7, SP, #0xA0
STRB.W          R8, [SP,#0xA4+send_data]
STRB.W          R1, [SP,#0xA4+send_data+2]
ADD             R6, SP, #0xA4+send_data
STRB.W          R2, [SP,#0xA4+send_data+3]
ORR.W           R5, R5, which_i2c,LSL#26
STRB.W          R3, [R7,#4+send_data+5]!
BLX             pthread_mutex_lock
MOV             R0, R8
B               loc_225D4

loc_225D0
LDRB.W          R0, [R6,#1]!

loc_225D4               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R6
BNE             loc_225D0
MOVW            R0, #:lower16:(gAsic_Core_Nonce_Num+0x1859C)
ADD.W           R4, SP, #0xA4+var_19
MOVT            R0, #:upper16:(gAsic_Core_Nonce_Num+0x1859C) ; useconds
ADD.W           R6, SP, #0xA4+read_back_data+0x13
BLX             usleep

loc_225F2               ; config_data
MOV             R0, R5
BL              i2c_read
STRB.W          R0, [R4,#1]!
CMP             R6, R4
BNE             loc_225F2
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDRB.W          R3, [SP,#0xA4+read_back_data+8]
MOVW            R0, #:lower16:aSReadBackData0 ; "--- %s: read_back_data[0] = 0x%x, read_"...
LDRB.W          R2, [SP,#0xA4+read_back_data+0xA]
MOVT            R0, #:upper16:aSReadBackData0 ; "--- %s: read_back_data[0] = 0x%x, read_"...
LDRB.W          R4, [SP,#0xA4+read_back_data+0xB]
MOV             R1, R3
LDRB.W          R5, [SP,#0xA4+read_back_data+0xC]
LDRB.W          R6, [SP,#0xA4+read_back_data+0xD]
STR             R3, [SP,#0xA4+var_2C]
LDRB.W          R3, [SP,#0xA4+read_back_data+9]
LDRB.W          R7, [SP,#0xA4+read_back_data+0xE]
STR             R2, [SP,#0xA4+var_54]
STR             R3, [SP,#0xA4+var_58]
LDRB.W          R2, [SP,#0xA4+read_back_data+0x10]
LDRB.W          R3, [SP,#0xA4+read_back_data+0xF]
STR             R4, [SP,#0xA4+var_50]
STR             R5, [SP,#0xA4+var_4C]
LDRB.W          R4, [SP,#0xA4+read_back_data+0x11]
LDRB.W          R5, [SP,#0xA4+read_back_data+0x12]
STR             R6, [SP,#0xA4+var_48]
LDRB.W          R6, [SP,#0xA4+read_back_data+0x13]
STR             R7, [SP,#0xA4+var_44]
STR             R3, [SP,#0xA4+var_40]
LDRB.W          R7, [SP,#0xA4+read_back_data+1]
STR             R2, [SP,#0xA4+var_3C]
STR             R4, [SP,#0xA4+var_38]
STR             R5, [SP,#0xA4+var_34]
MOV             R3, R7
STR             R6, [SP,#0xA4+var_30]
LDRB.W          R4, [SP,#0xA4+read_back_data+2]
LDRB.W          R6, [SP,#0xA4+read_back_data]
LDRB.W          R5, [SP,#0xA4+read_back_data+3]
LDRB.W          R11, [SP,#0xA4+read_back_data+4]
LDRB.W          R10, [SP,#0xA4+read_back_data+5]
MOV             R2, R6
LDRB.W          which_i2c, [SP,#0xA4+read_back_data+6]
LDRB.W          R8, [SP,#0xA4+read_back_data+7]
STR             R1, [SP,#0xA4+var_8C]
LDR             R1, [SP,#0xA4+var_58]
STR.W           R10, [SP,#0xA4+var_98]
STMEA.W         SP, {R4,R5,R11}
STR             R1, [SP,#0xA4+var_88]
LDR             R1, [SP,#0xA4+var_54]
STR.W           R8, [SP,#0xA4+var_90]
STR.W           R9, [SP,#0xA4+var_94]
STR             R1, [SP,#0xA4+var_84]
LDR             R1, [SP,#0xA4+var_50]
STR             R1, [SP,#0xA4+var_80]
LDR             R1, [SP,#0xA4+var_4C]
STR             R1, [SP,#0xA4+var_7C]
LDR             R1, [SP,#0xA4+var_48]
STR             R1, [SP,#0xA4+var_78]
LDR             R1, [SP,#0xA4+var_44]
STR             R1, [SP,#0xA4+var_74]
LDR             R1, [SP,#0xA4+var_40]
STR             R1, [SP,#0xA4+var_70]
LDR             R1, [SP,#0xA4+var_3C]
STR             R1, [SP,#0xA4+var_6C]
LDR             R1, [SP,#0xA4+var_38]
STR             R1, [SP,#0xA4+var_68]
LDR             R1, [SP,#0xA4+var_34]
STR             R1, [SP,#0xA4+var_64]
LDR             R1, [SP,#0xA4+var_30]
STR             R1, [SP,#0xA4+var_60]
LDR             R1, =__FUNCTION__.8063 ; "read_PIC16F1704_flash_data"
BLX             printf
MOV             R0, #0x186A0 ; useconds
BLX             usleep
CMP             R6, #0x14
IT EQ
CMPEQ           R7, #3
BEQ             loc_226F0
MOVW            R0, #:lower16:aSFailed ; "\n--- %s failed!\n\n"
LDR             R1, =__FUNCTION__.8063 ; "read_PIC16F1704_flash_data"
MOVT            R0, #:upper16:aSFailed ; "\n--- %s failed!\n\n"
BLX             printf
MOVS            R0, #0

loc_226EA
ADD             SP, SP, #0xA4
POP.W           {R4-R11,PC}

loc_226F0
ADDS            R3, R4, R5
ADDS            R3, #0x17
ADD.W           R2, R3, R11
LDR             R3, [SP,#0xA4+var_2C]
ADD             R2, R10
ADD             R2, R9
ADD             R2, R8
ADD             R2, R3
LDR             R3, [SP,#0xA4+var_58]
ADD             R2, R3
LDR             R3, [SP,#0xA4+var_54]
ADD             R2, R3
LDR             R3, [SP,#0xA4+var_50]
ADD             R2, R3
LDR             R3, [SP,#0xA4+var_4C]
ADD             R2, R3
LDR             R3, [SP,#0xA4+var_48]
ADD             R2, R3
LDR             R3, [SP,#0xA4+var_44]
ADD             R2, R3
LDR             R3, [SP,#0xA4+var_40]
ADD             R2, R3
LDR             R3, [SP,#0xA4+var_3C]
ADD             R2, R3
LDR             R3, [SP,#0xA4+var_38]
ADD             R2, R3
LDR             R3, [SP,#0xA4+var_34]
UXTH            R2, R2
crc = R2                ; unsigned __int16
CMP.W           R3, crc,LSR#8
BNE             loc_22738
LDR             R1, [SP,#0xA4+var_30]
UXTB            R3, crc
CMP             R1, R3
BEQ             loc_2274E

loc_22738
MOVW            R0, #:lower16:aSFailedCrc0x04 ; "\n--- %s failed! crc = 0x%04x\n\n"
LDR             R1, =__FUNCTION__.8063 ; "read_PIC16F1704_flash_data"
MOVT            R0, #:upper16:aSFailedCrc0x04 ; "\n--- %s failed! crc = 0x%04x\n\n"
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0xA4
POP.W           {R4-R11,PC}

loc_2274E
crc = R2                ; unsigned __int16
LDR             R3, [SP,#0xA4+buf]
ADD.W           crc, SP, #0xA4+read_back_data+2
ADD.W           R1, SP, #0xA4+read_back_data+0x11
SUBS            R3, #1
B               loc_22760

loc_2275C
LDRB.W          R4, [R2,#1]!

loc_22760
CMP             R2, R1
STRB.W          R4, [R3,#1]!
BNE             loc_2275C
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8063 ; "read_PIC16F1704_flash_data"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOVS            R0, #1
B               loc_226EA
; End of function read_PIC16F1704_flash_data

ALIGN 4
off_2277C DCD __FUNCTION__.8063 ; "read_PIC16F1704_flash_data"


; Attributes: bp-based frame

; int __fastcall erase_PIC16F1704_flash(unsigned int which_i2c, unsigned __int8 which_chain)
EXPORT erase_PIC16F1704_flash
erase_PIC16F1704_flash

send_data= -8

which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOVS            R2, #0
SUB             SP, SP, #8
MOV             R6, which_chain
MOV             R8, which_i2c
LSLS            R6, R6, #0x10
STRH.W          R2, [SP,#8+send_data+4]
MOVW            which_i2c, #:lower16:i2c_mutex
which_i2c = R8          ; unsigned int
MOVS            R2, #8
MOVS            R5, #0x55 ; 'U'
MOVS            R3, #4
MOVS            which_chain, #0xAA
ADD.W           R7, SP, R2
MOVT            R0, #:upper16:i2c_mutex ; mutex
STRB.W          R5, [SP,#8+send_data]
MOV             R4, SP
STRB.W          R1, [SP,#8+send_data+1]
STRB.W          R3, [SP,#8+send_data+2]
STRB.W          R3, [SP,#8+send_data+3]
STRB.W          R2, [R7,#send_data+5]!
BLX             pthread_mutex_lock
MOV             R0, R5
ORR.W           R5, R6, #0xA00000
ORR.W           R5, R5, which_i2c,LSL#26
B               loc_227D0

loc_227CC
LDRB.W          R0, [R4,#1]!

loc_227D0               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R4
BNE             loc_227CC
MOV             R0, #0x186A0 ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R6, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #gBM1397_MISC_CONTROL_reg ; useconds
BLX             usleep
CMP             R6, #4
BNE             loc_22816
CMP             R4, #1
BEQ             loc_22830

loc_22816
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8083 ; "erase_PIC16F1704_flash"
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #8
POP.W           {R4-which_i2c,PC}

loc_22830
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8083 ; "erase_PIC16F1704_flash"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, R4
ADD             SP, SP, #8
POP.W           {R4-which_i2c,PC}
; End of function erase_PIC16F1704_flash

ALIGN 4
off_22848 DCD __FUNCTION__.8083 ; "erase_PIC16F1704_flash"


; Attributes: bp-based frame

; int __fastcall write_data_into_PIC16F1704_flash(unsigned int which_i2c, unsigned __int8 which_chain)
EXPORT write_data_into_PIC16F1704_flash
write_data_into_PIC16F1704_flash

send_data= -8

which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R6, which_chain
SUB             SP, SP, #8
MOV             R8, which_i2c
MOVS            R2, #0
MOVS            R3, #0xAA
MOVW            which_i2c, #:lower16:i2c_mutex
which_i2c = R8          ; unsigned int
LSLS            R6, R6, #0x10
MOVS            R5, #0x55 ; 'U'
STRH.W          R2, [SP,#8+send_data+4]
MOVS            which_chain, #4
MOVS            R2, #5
STRB.W          R3, [SP,#8+send_data+1]
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOVS            R3, #9
ADD             R7, SP, #8
STRB.W          R5, [SP,#8+send_data]
MOV             R4, SP
STRB.W          R1, [SP,#8+send_data+2]
STRB.W          R2, [SP,#8+send_data+3]
STRB.W          R3, [R7,#send_data+5]!
BLX             pthread_mutex_lock
MOV             R0, R5
ORR.W           R5, R6, #0xA00000
ORR.W           R5, R5, which_i2c,LSL#26
B               loc_2289C

loc_22898
LDRB.W          R0, [R4,#1]!

loc_2289C               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R4
BNE             loc_22898
MOV             R0, #gBM1397_MISC_CONTROL_reg ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R6, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #gBM1397_MISC_CONTROL_reg ; useconds
BLX             usleep
CMP             R6, #5
BNE             loc_228E2
CMP             R4, #1
BEQ             loc_228FC

loc_228E2
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8100 ; "write_data_into_PIC16F1704_flash"
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #8
POP.W           {R4-which_i2c,PC}

loc_228FC
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8100 ; "write_data_into_PIC16F1704_flash"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, R4
ADD             SP, SP, #8
POP.W           {R4-which_i2c,PC}
; End of function write_data_into_PIC16F1704_flash

ALIGN 4
off_22914 DCD __FUNCTION__.8100 ; "write_data_into_PIC16F1704_flash"


; Attributes: bp-based frame

; int __fastcall jump_from_loader_to_app_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c)
EXPORT jump_from_loader_to_app_PIC16F1704
jump_from_loader_to_app_PIC16F1704

send_data= -8

which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R6, which_i2c
MOV             R8, which_chain
LSLS            R6, R6, #0x1A
SUB             SP, SP, #8
UXTB.W          R8, R8
MOVS            R2, #0
MOVS            R3, #0xAA
MOVW            which_chain, #:lower16:i2c_mutex
MOVS            R5, #0x55 ; 'U'
STRH.W          R2, [SP,#8+send_data+4]
MOVS            which_i2c, #4
MOVS            R2, #6
STRB.W          R3, [SP,#8+send_data+1]
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOVS            R3, #0xA
ADD             R7, SP, #8
ORR.W           R6, R6, #0xA00000
STRB.W          R5, [SP,#8+send_data]
STRB.W          R1, [SP,#8+send_data+2]
MOV             R4, SP
STRB.W          R2, [SP,#8+send_data+3]
STRB.W          R3, [R7,#send_data+5]!
BLX             pthread_mutex_lock
MOV             R0, R5
ORR.W           R5, R6, R8,LSL#16
B               loc_2296C

loc_22968
LDRB.W          R0, [R4,#1]!

loc_2296C               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R4
BNE             loc_22968
MOV             R0, #0x186A0 ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R6, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #(gAsic_Core_Nonce_Num+0x1859C) ; useconds
BLX             usleep
CMP             R6, #6
BNE             loc_229B2
CMP             R4, #1
BEQ             loc_229CC

loc_229B2
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8117 ; "jump_from_loader_to_app_PIC16F1704"
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #8
POP.W           {R4-R8,PC}

loc_229CC
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8117 ; "jump_from_loader_to_app_PIC16F1704"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, R4
ADD             SP, SP, #8
POP.W           {R4-R8,PC}
; End of function jump_from_loader_to_app_PIC16F1704

ALIGN 4
off_229E4 DCD __FUNCTION__.8117 ; "jump_from_loader_to_app_PIC16F1704"


; Attributes: bp-based frame

; int __fastcall reset_PIC16F1704_pic(unsigned int which_chain, unsigned __int8 which_i2c)
EXPORT reset_PIC16F1704_pic
reset_PIC16F1704_pic

send_data= -8

which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R6, which_i2c
MOV             R8, which_chain
LSLS            R6, R6, #0x1A
SUB             SP, SP, #8
UXTB.W          R8, R8
MOVS            R2, #0
MOVS            R3, #0xAA
MOVW            which_chain, #:lower16:i2c_mutex
MOVS            R5, #0x55 ; 'U'
STRH.W          R2, [SP,#8+send_data+4]
MOVS            which_i2c, #4
MOVS            R2, #7
STRB.W          R3, [SP,#8+send_data+1]
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOVS            R3, #0xB
ADD             R7, SP, #8
ORR.W           R6, R6, #0xA00000
STRB.W          R5, [SP,#8+send_data]
STRB.W          R1, [SP,#8+send_data+2]
MOV             R4, SP
STRB.W          R2, [SP,#8+send_data+3]
STRB.W          R3, [R7,#send_data+5]!
BLX             pthread_mutex_lock
MOV             R0, R5
ORR.W           R5, R6, R8,LSL#16
B               loc_22A3C

loc_22A38
LDRB.W          R0, [R4,#1]!

loc_22A3C               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R4
BNE             loc_22A38
MOV             R0, #0x186A0 ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R6, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #(gAsic_Core_Nonce_Num+0xC33FC) ; useconds
BLX             usleep
CMP             R6, #7
BNE             loc_22A82
CMP             R4, #1
BEQ             loc_22A9C

loc_22A82
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8134 ; "reset_PIC16F1704_pic"
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #8
POP.W           {R4-R8,PC}

loc_22A9C
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8134 ; "reset_PIC16F1704_pic"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, R4
ADD             SP, SP, #8
POP.W           {R4-R8,PC}
; End of function reset_PIC16F1704_pic

ALIGN 4
off_22AB4 DCD __FUNCTION__.8134 ; "reset_PIC16F1704_pic"


; Attributes: bp-based frame

; int __fastcall set_PIC16F1704_voltage(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 voltage)
EXPORT set_PIC16F1704_voltage
set_PIC16F1704_voltage

send_data= -8

which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
voltage = R2            ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R8, which_chain
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
which_chain = R8        ; unsigned int
SUB             SP, SP, #8
MOV             R5, voltage
MOVS            R3, #0
MOV             R6, which_i2c
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             which_i2c, =__FUNCTION__.8146 ; "set_PIC16F1704_voltage"
LSLS            R6, R6, #0x1A
STR             R3, [SP,#8+send_data]
ADD             R7, SP, #8
STR.W           R3, [SP,#8+send_data+3]
UXTB.W          which_chain, which_chain
ORR.W           R6, R6, #0xA00000
BLX             printf
ADD.W           R3, R5, #0x15
crc = R3                ; unsigned __int16
MOVW            R0, #:lower16:i2c_mutex
LSRS            R2, crc, #8
STRB.W          R5, [SP,#8+send_data+4]
MOVS            R1, #0xAA
STRB.W          crc, [R7,#send_data+6]!
MOVS            R5, #0x55 ; 'U'
STRB.W          R2, [SP,#8+send_data+5]
MOVS            crc, #0x10
MOVS            R2, #5
MOVT            R0, #:upper16:i2c_mutex ; mutex
STRB.W          R5, [SP,#8+send_data]
STRB.W          R1, [SP,#8+send_data+1]
MOV             R4, SP
STRB.W          R2, [SP,#8+send_data+2]
STRB.W          R3, [SP,#8+send_data+3]
BLX             pthread_mutex_lock
MOV             R0, R5
ORR.W           R5, R6, R8,LSL#16
B               loc_22B2A

loc_22B26
LDRB.W          R0, [R4,#1]!

loc_22B2A               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R4
BNE             loc_22B26
MOV             R0, #gBM1397_MISC_CONTROL_reg ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R6, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #gBM1397_MISC_CONTROL_reg ; useconds
BLX             usleep
CMP             R6, #0x10
BNE             loc_22B70
CMP             R4, #1
BEQ             loc_22B8A

loc_22B70
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8146 ; "set_PIC16F1704_voltage"
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #8
POP.W           {R4-R8,PC}

loc_22B8A
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8146 ; "set_PIC16F1704_voltage"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, R4
ADD             SP, SP, #8
POP.W           {R4-R8,PC}
; End of function set_PIC16F1704_voltage

off_22BA0 DCD __FUNCTION__.8146 ; "set_PIC16F1704_voltage"



; int __fastcall write_hash_ID_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 *buf)
EXPORT write_hash_ID_PIC16F1704
write_hash_ID_PIC16F1704

var_19= -0x19
send_data= -0x18
var_4= -4

which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
buf = R2                ; unsigned __int8 *
PUSH            {R4-R7,LR}
MOV             R7, which_chain
SUBS            which_chain, buf, #1
which_chain = R7        ; unsigned int
MOVS            R3, #0x22 ; '"'
ADDS            buf, #0xB
MOV             R4, R0
SUB             SP, SP, #0x1C
MOV             R6, which_i2c
MOVS            which_i2c, #0
STR             R1, [SP,#0x1C+send_data+4]
STR             R1, [SP,#0x1C+send_data+8]
STR             R1, [SP,#0x1C+send_data+0xC]

loc_22BBC
crc = R3                ; unsigned __int16
LDRB.W          R1, [R4,#1]!
CMP             R4, R2
ADD             crc, R1
UXTH            R3, R3
crc = R3                ; unsigned __int16
BNE             loc_22BBC
MOVS            R4, #0x55 ; 'U'
LSRS            R5, crc, #8
UXTB            crc, crc
crc_data_0 = R5         ; unsigned __int8
crc_data_1 = R3         ; unsigned __int8
MOVS            R1, #0xAA
STRB.W          R4, [SP,#0x1C+send_data]
MOVS            R4, #0x10
STRB.W          R1, [SP,#0x1C+send_data+1]
MOVS            R1, #0x12
STRB.W          R4, [SP,#0x1C+send_data+2]
ADD             R4, SP, #0x1C+var_4
STRB.W          R1, [R4,#-0x11]!

loc_22BE6
LDRB.W          R1, [R0,#1]!
CMP             R2, R0
STRB.W          R1, [R4,#1]!
BNE             loc_22BE6
STRB.W          crc_data_0, [SP,#0x1C+send_data+0x10]
LSLS            crc_data_0, R6, #0x1A
crc_data_1 = R3         ; unsigned __int8
UXTB            which_chain, which_chain
MOVW            R0, #:lower16:i2c_mutex
ORR.W           R5, R5, #0xA00000
STRB.W          crc_data_1, [SP,#0x1C+send_data+0x11]
ORR.W           R5, R5, R7,LSL#16
ADD.W           R4, SP, #0x1C+var_19
ADD.W           R6, SP, #0x1C+send_data+0x11
MOVT            R0, #:upper16:i2c_mutex ; mutex
BLX             pthread_mutex_lock

loc_22C1A
LDRB.W          R0, [R4,#1]!
ORRS            R0, R5  ; config_data
BL              i2c_write
CMP             R6, R4
BNE             loc_22C1A
MOV             R0, #(gAsic_Core_Nonce_Num+0x30C3C) ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R6, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #gBM1397_MISC_CONTROL_reg ; useconds
BLX             usleep
CMP             R6, #0x12
BNE             loc_22C64
CMP             R4, #1
BEQ             loc_22C7C

loc_22C64
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8176 ; "write_hash_ID_PIC16F1704"
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x1C
POP             {R4-R7,PC}

loc_22C7C
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8176 ; "write_hash_ID_PIC16F1704"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, R4
ADD             SP, SP, #0x1C
POP             {R4-R7,PC}
; End of function write_hash_ID_PIC16F1704

off_22C90 DCD __FUNCTION__.8176 ; "write_hash_ID_PIC16F1704"


; Attributes: bp-based frame fpd=4

; int __fastcall read_hash_id_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf)
EXPORT read_hash_id_PIC16F1704
read_hash_id_PIC16F1704

var_74= -0x74
var_70= -0x70
var_6C= -0x6C
var_68= -0x68
var_64= -0x64
var_60= -0x60
var_5C= -0x5C
var_58= -0x58
var_54= -0x54
var_50= -0x50
var_4C= -0x4C
var_48= -0x48
var_44= -0x44
var_40= -0x40
var_3C= -0x3C
var_38= -0x38
var_34= -0x34
var_30= -0x30
var_2C= -0x2C
var_28= -0x28
var_24= -0x24
buf= -0x20
send_data= -0x1C
var_15= -0x15
read_back_data= -0x14

which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
buf_0 = R2              ; unsigned __int8 *
PUSH.W          {R4-R11,LR}
MOV             R4, which_chain
SUB             SP, SP, #0x7C
MOVS            R5, #0xAA
MOVS            R3, #0
MOV             R9, which_i2c
STRB.W          R5, [SP,#0x7C+send_data+1]
LSLS            R5, R4, #0x10
MOVS            R7, #0xFF
STR             R3, [SP,#0x7C+read_back_data]
MOVW            which_i2c, #:lower16:i2c_mutex
which_i2c = R9          ; unsigned int
STRH.W          R3, [SP,#0x7C+send_data+4]
MOV.W           R8, #0x55 ; 'U'
STR             buf_0, [SP,#0x7C+buf]
STR             R3, [SP,#0x7C+read_back_data+4]
MOVS            which_chain, #4
STR             R3, [SP,#0x7C+read_back_data+8]
MOVS            buf_0, #0x13
STR             R3, [SP,#0x7C+read_back_data+0xC]
MOVT            R0, #:upper16:i2c_mutex ; mutex
STRB.W          R7, [SP,#0x7C+read_back_data]
MOVS            R3, #0x17
ADD             R7, SP, #0x78
ORR.W           R5, R5, #0xA00000
STRB.W          R8, [SP,#0x7C+send_data]
ADD             R6, SP, #0x7C+send_data
STRB.W          R1, [SP,#0x7C+send_data+2]
ORR.W           R5, R5, which_i2c,LSL#26
STRB.W          R2, [SP,#0x7C+send_data+3]
STRB.W          R3, [R7,#4+send_data+5]!
BLX             pthread_mutex_lock
MOV             R0, R8
B               loc_22CF6

loc_22CF2
LDRB.W          R0, [R6,#1]!

loc_22CF6               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R6
BNE             loc_22CF2
MOV.W           R0, #:lower16:gBM1397_MISC_CONTROL_reg
ADD.W           R4, SP, #0x7C+var_15
MOVT            R0, #:upper16:gBM1397_MISC_CONTROL_reg ; useconds
ADD.W           R6, SP, #0x7C+read_back_data+0xF
BLX             usleep

loc_22D14               ; config_data
MOV             R0, R5
BL              i2c_read
STRB.W          R0, [R4,#1]!
CMP             R6, R4
BNE             loc_22D14
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDRB.W          LR, [SP,#0x7C+read_back_data+7]
MOVW            R0, #:lower16:aSReadBackData0_0 ; "--- %s: read_back_data[0] = 0x%x, read_"...
LDRB.W          R3, [SP,#0x7C+read_back_data+4]
MOVT            R0, #:upper16:aSReadBackData0_0 ; "--- %s: read_back_data[0] = 0x%x, read_"...
LDRB.W          R1, [SP,#0x7C+read_back_data+5]
STR.W           LR, [SP,#0x7C+var_3C]
LDRB.W          LR, [SP,#0x7C+read_back_data+8]
MOV             R4, R3
STR             R1, [SP,#0x7C+var_44]
LDRB.W          R1, [SP,#0x7C+read_back_data+6]
STR.W           LR, [SP,#0x7C+var_38]
LDRB.W          LR, [SP,#0x7C+read_back_data+9]
STR             R4, [SP,#0x7C+var_74]
LDR             R4, [SP,#0x7C+var_44]
STR.W           LR, [SP,#0x7C+var_34]
LDRB.W          LR, [SP,#0x7C+read_back_data+0xA]
STR             R1, [SP,#0x7C+var_40]
LDRB.W          R5, [SP,#0x7C+read_back_data+2]
LDRB.W          R1, [SP,#0x7C+read_back_data+0xD]
LDRB.W          R6, [SP,#0x7C+read_back_data+3]
STR.W           LR, [SP,#0x7C+var_30]
STR             R4, [SP,#0x7C+var_70]
LDRB.W          LR, [SP,#0x7C+read_back_data+0xF]
LDR             R4, [SP,#0x7C+var_40]
LDRB.W          R7, [SP,#0x7C+read_back_data]
LDRB.W          R8, [SP,#0x7C+read_back_data+1]
STR             R3, [SP,#0x7C+var_24]
LDRB.W          R11, [SP,#0x7C+read_back_data+0xB]
MOV             R2, R7
LDRB.W          which_i2c, [SP,#0x7C+read_back_data+0xC]
MOV             R3, R8
STR             R1, [SP,#0x7C+var_2C]
LDRB.W          R10, [SP,#0x7C+read_back_data+0xE]
STR.W           LR, [SP,#0x7C+var_28]
STMEA.W         SP, {R5,R6}
STR             R4, [SP,#0x7C+var_6C]
LDR             R4, [SP,#0x7C+var_3C]
LDR             R1, =__FUNCTION__.8194 ; "read_hash_id_PIC16F1704"
STR.W           R11, [SP,#0x7C+var_58]
STR             R4, [SP,#0x7C+var_68]
LDR             R4, [SP,#0x7C+var_38]
STR.W           R9, [SP,#0x7C+var_54]
STR.W           R10, [SP,#0x7C+var_4C]
STR             R4, [SP,#0x7C+var_64]
LDR             R4, [SP,#0x7C+var_34]
STR.W           LR, [SP,#0x7C+var_48]
STR             R4, [SP,#0x7C+var_60]
LDR             R4, [SP,#0x7C+var_30]
STR             R4, [SP,#0x7C+var_5C]
LDR             R4, [SP,#0x7C+var_2C]
STR             R4, [SP,#0x7C+var_50]
BLX             printf
CMP             R7, #0x10
IT EQ
CMPEQ.W         R8, #0x13
BEQ             loc_22DF0
MOVW            R0, #:lower16:aSFailed ; "\n--- %s failed!\n\n"
LDR             R1, =__FUNCTION__.8194 ; "read_hash_id_PIC16F1704"
MOVT            R0, #:upper16:aSFailed ; "\n--- %s failed!\n\n"
BLX             printf
MOVS            R0, #0

loc_22DEA
ADD             SP, SP, #0x7C ; '|'
POP.W           {R4-R11,PC}

loc_22DF0
LDR             R2, [SP,#0x7C+var_24]
ADDS            R3, R5, R6
ADDS            R3, #0x23 ; '#'
ADD             R2, R3
LDR             R3, [SP,#0x7C+var_44]
ADD             R2, R3
LDR             R3, [SP,#0x7C+var_40]
ADD             R2, R3
LDR             R3, [SP,#0x7C+var_3C]
ADD             R2, R3
LDR             R3, [SP,#0x7C+var_38]
ADD             R2, R3
LDR             R3, [SP,#0x7C+var_34]
ADD             R2, R3
LDR             R3, [SP,#0x7C+var_30]
ADD             R2, R3
LDR             R3, [SP,#0x7C+var_2C]
ADD             R2, R11
ADD             R2, R9
ADD             R2, R3
UXTH            R2, R2
crc = R2                ; unsigned __int16
CMP.W           R10, crc,LSR#8
BNE             loc_22E28
LDR             R1, [SP,#0x7C+var_28]
UXTB            R3, crc
CMP             R1, R3
BEQ             loc_22E3E

loc_22E28
MOVW            R0, #:lower16:aSFailedCrc0x04 ; "\n--- %s failed! crc = 0x%04x\n\n"
LDR             R1, =__FUNCTION__.8194 ; "read_hash_id_PIC16F1704"
MOVT            R0, #:upper16:aSFailedCrc0x04 ; "\n--- %s failed! crc = 0x%04x\n\n"
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x7C ; '|'
POP.W           {R4-R11,PC}

loc_22E3E
crc = R2                ; unsigned __int16
LDR             crc, [SP,#0x7C+buf]
ADD.W           R1, SP, #0x7C+read_back_data+2
SUBS            R3, R2, #1
ADDS            R2, #0xB
B               loc_22E4E

loc_22E4A
LDRB.W          R5, [R1,#1]!

loc_22E4E
STRB.W          R5, [R3,#1]!
CMP             R2, R3
BNE             loc_22E4A
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8194 ; "read_hash_id_PIC16F1704"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOVS            R0, #1
B               loc_22DEA
; End of function read_hash_id_PIC16F1704

off_22E68 DCD __FUNCTION__.8194 ; "read_hash_id_PIC16F1704"


; Attributes: bp-based frame

; int __fastcall enable_PIC16F1704_dc_dc(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 enable)
EXPORT enable_PIC16F1704_dc_dc
enable_PIC16F1704_dc_dc

send_data= -8

which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
enable = R2             ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R8, which_chain
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
which_chain = R8        ; unsigned int
SUB             SP, SP, #8
MOV             R5, enable
MOVS            R3, #0
MOV             R6, which_i2c
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             which_i2c, =__FUNCTION__.8209 ; "enable_PIC16F1704_dc_dc"
LSLS            R6, R6, #0x1A
STR             R3, [SP,#8+send_data]
ADD             R7, SP, #8
STR.W           R3, [SP,#8+send_data+3]
UXTB.W          which_chain, which_chain
ORR.W           R6, R6, #0xA00000
BLX             printf
ADD.W           R3, R5, #0x1A
crc = R3                ; unsigned __int16
MOVW            R0, #:lower16:i2c_mutex
LSRS            R2, crc, #8
STRB.W          R5, [SP,#8+send_data+4]
MOVS            R1, #0xAA
STRB.W          crc, [R7,#send_data+6]!
MOVS            R5, #0x55 ; 'U'
STRB.W          R2, [SP,#8+send_data+5]
MOVS            crc, #0x15
MOVS            R2, #5
MOVT            R0, #:upper16:i2c_mutex ; mutex
STRB.W          R5, [SP,#8+send_data]
STRB.W          R1, [SP,#8+send_data+1]
MOV             R4, SP
STRB.W          R2, [SP,#8+send_data+2]
STRB.W          R3, [SP,#8+send_data+3]
BLX             pthread_mutex_lock
MOV             R0, R5
ORR.W           R5, R6, R8,LSL#16
B               loc_22EDE

loc_22EDA
LDRB.W          R0, [R4,#1]!

loc_22EDE               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R4
BNE             loc_22EDA
MOV             R0, #0x186A0 ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R6, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
CMP             R6, #0x15
BNE             loc_22F18
CMP             R4, #1
BEQ             loc_22F32

loc_22F18
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8209 ; "enable_PIC16F1704_dc_dc"
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #8
POP.W           {R4-R8,PC}

loc_22F32
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8209 ; "enable_PIC16F1704_dc_dc"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
MOV             R0, R4
ADD             SP, SP, #8
POP.W           {R4-R8,PC}
; End of function enable_PIC16F1704_dc_dc

off_22F54 DCD __FUNCTION__.8209 ; "enable_PIC16F1704_dc_dc"



; int __fastcall heart_beat_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c)
EXPORT heart_beat_PIC16F1704
heart_beat_PIC16F1704

read_back_data= -0x14
var_E= -0xE
send_data= -0xC
var_4= -4

which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
PUSH.W          {R4-R9,LR}
MOV             R6, which_i2c
SUB             SP, SP, #0x14
MOVS            R5, #0xAA
MOV             R9, which_chain
MOVS            R3, #0
STRB.W          R5, [SP,#0x14+send_data+1]
LSLS            R5, R6, #0x1A
MOVW            which_chain, #:lower16:i2c_mutex
which_chain = R9        ; unsigned int
UXTB.W          which_chain, which_chain
STRH.W          R3, [SP,#0x14+send_data+4]
MOVS            R7, #0x55 ; 'U'
MOVS            which_i2c, #4
STR             R3, [SP,#0x14+read_back_data]
MOVS            R2, #0x16
STRH.W          R3, [SP,#0x14+read_back_data+4]
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOVS            R3, #0x1A
ADD.W           R8, SP, #0x14+var_4
ORR.W           R5, R5, #0xA00000
STRB.W          R7, [SP,#0x14+send_data]
ADD             R4, SP, #0x14+send_data
STRB.W          R1, [SP,#0x14+send_data+2]
ORR.W           R5, R5, R9,LSL#16
STRB.W          R2, [SP,#0x14+send_data+3]
STRB.W          R3, [R8,#-3]!
BLX             pthread_mutex_lock
MOV             R0, R7
B               loc_22FB4

loc_22FB0
LDRB.W          R0, [R4,#1]!

loc_22FB4               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R4, R8
BNE             loc_22FB0
MOVW            R0, #:lower16:loc_186A0
MOV             R4, SP
MOVT            R0, #:upper16:loc_186A0 ; useconds
ADD.W           R6, SP, #0x14+var_E
BLX             usleep

loc_22FD0               ; config_data
MOV             R0, R5
BL              i2c_read
STRB.W          R0, [R4],#1
CMP             R6, R4
BNE             loc_22FD0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDRB.W          R3, [SP,#0x14+read_back_data+1]
CMP             R3, #0x16
BNE             loc_22FFA
LDRB.W          R4, [SP,#0x14+read_back_data+2]
CMP             R4, #1
BEQ             loc_23010

loc_22FFA
MOVW            R0, #:lower16:aSFailed ; "\n--- %s failed!\n\n"
LDR             R1, =__FUNCTION__.8232 ; "heart_beat_PIC16F1704"
MOVT            R0, #:upper16:aSFailed ; "\n--- %s failed!\n\n"
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x14
POP.W           {R4-R9,PC}

loc_23010
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8232 ; "heart_beat_PIC16F1704"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, R4
ADD             SP, SP, #0x14
POP.W           {R4-R9,PC}
; End of function heart_beat_PIC16F1704

ALIGN 4
off_23028 DCD __FUNCTION__.8232 ; "heart_beat_PIC16F1704"



; int __fastcall get_PIC16F1704_software_version(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *version)
EXPORT get_PIC16F1704_software_version
get_PIC16F1704_software_version

read_back_data= -0x10
var_B= -0xB
send_data= -8
var_s0=  0

which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
version = R2            ; unsigned __int8 *
PUSH.W          {R4-R10,LR}
MOV             R6, which_chain
SUB             SP, SP, #0x20
MOVS            R5, #0xAA
MOVS            R3, #0
MOV             R10, which_i2c
STRB.W          R5, [SP,#0x20+send_data+1]
LSLS            R5, R6, #0x10
MOVW            which_i2c, #:lower16:i2c_mutex
which_i2c = R10         ; unsigned int
STR             R3, [SP,#0x20+read_back_data]
STRH.W          R3, [SP,#0x20+send_data+4]
MOV.W           LR, #0xFF
MOV.W           R9, #0x55 ; 'U'
STRB.W          R3, [SP,#0x20+read_back_data+4]
MOVS            which_chain, #4
MOVS            R3, #0x1B
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOV             R7, version
ADD.W           R8, SP, #0x20+var_s0
MOVS            version, #0x17
version = R7            ; unsigned __int8 *
ORR.W           R5, R5, #0xA00000
STRB.W          LR, [SP,#0x20+read_back_data]
STRB.W          R9, [SP,#0x20+send_data]
ADD             R4, SP, #0x20+send_data
STRB.W          R1, [SP,#0x20+send_data+2]
ORR.W           R5, R5, which_i2c,LSL#26
STRB.W          R2, [SP,#0x20+send_data+3]
STRB.W          R3, [R8,#-3]!
BLX             pthread_mutex_lock
MOV             R0, R9
B               loc_23090

loc_2308C
LDRB.W          R0, [R4,#1]!

loc_23090               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R4, R8
BNE             loc_2308C
MOV.W           R0, #:lower16:gBM1397_MISC_CONTROL_reg
ADD             R4, SP, #0x20+read_back_data
MOVT            R0, #:upper16:gBM1397_MISC_CONTROL_reg ; useconds
ADD.W           R6, SP, #0x20+var_B
BLX             usleep

loc_230AC               ; config_data
MOV             R0, R5
BL              i2c_read
STRB.W          R0, [R4],#1
CMP             R4, R6
BNE             loc_230AC
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #gBM1397_MISC_CONTROL_reg ; useconds
BLX             usleep
LDRB.W          R5, [SP,#0x20+read_back_data]
MOVW            R0, #:lower16:aSReadBackData0_1 ; "--- %s: read_back_data[0] = 0x%x, read_"...
LDRB.W          R4, [SP,#0x20+read_back_data+1]
MOVT            R0, #:upper16:aSReadBackData0_1 ; "--- %s: read_back_data[0] = 0x%x, read_"...
LDRB.W          R6, [SP,#0x20+read_back_data+2]
LDRB.W          R8, [SP,#0x20+read_back_data+3]
MOV             R2, R5
LDRB.W          R9, [SP,#0x20+read_back_data+4]
MOV             R3, R4
LDR             R1, =__FUNCTION__.8250 ; "get_PIC16F1704_software_version"
STMEA.W         SP, {R6,R8,R9}
BLX             printf
CMP             R4, #0x17
IT EQ
CMPEQ           R5, #5
BEQ             loc_2311A
MOVW            R0, #:lower16:aSFailed ; "\n--- %s failed!\n\n"
LDR             R1, =__FUNCTION__.8250 ; "get_PIC16F1704_software_version"
MOVT            R0, #:upper16:aSFailed ; "\n--- %s failed!\n\n"
BLX             printf
MOVS            R0, #0

loc_23114
ADD             SP, SP, #0x20 ; ' '
POP.W           {R4-which_i2c,PC}

loc_2311A
ADD.W           R2, R6, #0x1C
crc = R2                ; unsigned __int16
UBFX.W          R3, crc, #8, #8
CMP             R3, R8
BNE             loc_2312C
UXTB            R3, crc
CMP             R9, R3
BEQ             loc_23142

loc_2312C
MOVW            R0, #:lower16:aSFailedCrc0x04 ; "\n--- %s failed! crc = 0x%04x\n\n"
LDR             R1, =__FUNCTION__.8250 ; "get_PIC16F1704_software_version"
MOVT            R0, #:upper16:aSFailedCrc0x04 ; "\n--- %s failed! crc = 0x%04x\n\n"
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x20 ; ' '
POP.W           {R4-which_i2c,PC}

loc_23142
crc = R2                ; unsigned __int16
MOVW            R0, #:lower16:aSOkVersion0x02 ; "\n--- %s ok, version = 0x%02x\n\n"
STRB            R6, [version]
MOV             crc, R6
MOVT            R0, #:upper16:aSOkVersion0x02 ; "\n--- %s ok, version = 0x%02x\n\n"
LDR             R1, =__FUNCTION__.8250 ; "get_PIC16F1704_software_version"
BLX             printf
MOVS            R0, #1
B               loc_23114
; End of function get_PIC16F1704_software_version

off_23158 DCD __FUNCTION__.8250 ; "get_PIC16F1704_software_version"



; int __fastcall get_PIC16F1704_voltage(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *voltage)
EXPORT get_PIC16F1704_voltage
get_PIC16F1704_voltage

read_back_data= -0x10
var_B= -0xB
send_data= -8
var_s0=  0

which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
voltage = R2            ; unsigned __int8 *
PUSH.W          {R4-R10,LR}
MOV             R6, which_chain
SUB             SP, SP, #0x20
MOVS            R5, #0xAA
MOVS            R3, #0
MOV             R10, which_i2c
STRB.W          R5, [SP,#0x20+send_data+1]
LSLS            R5, R6, #0x10
MOVW            which_i2c, #:lower16:i2c_mutex
which_i2c = R10         ; unsigned int
STR             R3, [SP,#0x20+read_back_data]
STRH.W          R3, [SP,#0x20+send_data+4]
MOV.W           LR, #0xFF
MOV.W           R9, #0x55 ; 'U'
STRB.W          R3, [SP,#0x20+read_back_data+4]
MOVS            which_chain, #4
MOVS            R3, #0x1C
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOV             R7, voltage
ADD.W           R8, SP, #0x20+var_s0
MOVS            voltage, #0x18
voltage = R7            ; unsigned __int8 *
ORR.W           R5, R5, #0xA00000
STRB.W          LR, [SP,#0x20+read_back_data]
STRB.W          R9, [SP,#0x20+send_data]
ADD             R4, SP, #0x20+send_data
STRB.W          R1, [SP,#0x20+send_data+2]
ORR.W           R5, R5, which_i2c,LSL#26
STRB.W          R2, [SP,#0x20+send_data+3]
STRB.W          R3, [R8,#-3]!
BLX             pthread_mutex_lock
MOV             R0, R9
B               loc_231C0

loc_231BC
LDRB.W          R0, [R4,#1]!

loc_231C0               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R4, R8
BNE             loc_231BC
MOV.W           R0, #:lower16:gBM1397_MISC_CONTROL_reg
ADD             R4, SP, #0x20+read_back_data
MOVT            R0, #:upper16:gBM1397_MISC_CONTROL_reg ; useconds
ADD.W           R6, SP, #0x20+var_B
BLX             usleep

loc_231DC               ; config_data
MOV             R0, R5
BL              i2c_read
STRB.W          R0, [R4],#1
CMP             R4, R6
BNE             loc_231DC
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDRB.W          R5, [SP,#0x20+read_back_data]
MOVW            R0, #:lower16:aSReadBackData0_1 ; "--- %s: read_back_data[0] = 0x%x, read_"...
LDRB.W          R4, [SP,#0x20+read_back_data+1]
MOVT            R0, #:upper16:aSReadBackData0_1 ; "--- %s: read_back_data[0] = 0x%x, read_"...
LDRB.W          R6, [SP,#0x20+read_back_data+2]
LDRB.W          R8, [SP,#0x20+read_back_data+3]
MOV             R2, R5
LDRB.W          R9, [SP,#0x20+read_back_data+4]
MOV             R3, R4
LDR             R1, =__FUNCTION__.8268 ; "get_PIC16F1704_voltage"
STMEA.W         SP, {R6,R8,R9}
BLX             printf
CMP             R4, #0x18
IT EQ
CMPEQ           R5, #5
BEQ             loc_2323E
MOVW            R0, #:lower16:aSFailed ; "\n--- %s failed!\n\n"
LDR             R1, =__FUNCTION__.8268 ; "get_PIC16F1704_voltage"
MOVT            R0, #:upper16:aSFailed ; "\n--- %s failed!\n\n"
BLX             printf
MOVS            R0, #0

loc_23238
ADD             SP, SP, #0x20 ; ' '
POP.W           {R4-which_i2c,PC}

loc_2323E
ADD.W           R2, R6, #0x1D
crc = R2                ; unsigned __int16
UBFX.W          R3, crc, #8, #8
CMP             R3, R8
BNE             loc_23250
UXTB            R3, crc
CMP             R9, R3
BEQ             loc_23266

loc_23250
MOVW            R0, #:lower16:aSFailedCrc0x04 ; "\n--- %s failed! crc = 0x%04x\n\n"
LDR             R1, =__FUNCTION__.8268 ; "get_PIC16F1704_voltage"
MOVT            R0, #:upper16:aSFailedCrc0x04 ; "\n--- %s failed! crc = 0x%04x\n\n"
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x20 ; ' '
POP.W           {R4-which_i2c,PC}

loc_23266
crc = R2                ; unsigned __int16
MOVW            R0, #:lower16:aSOkVoltage0x02 ; "\n--- %s ok, voltage = 0x%02x\n\n"
STRB            R6, [voltage]
MOV             crc, R6
MOVT            R0, #:upper16:aSOkVoltage0x02 ; "\n--- %s ok, voltage = 0x%02x\n\n"
LDR             R1, =__FUNCTION__.8268 ; "get_PIC16F1704_voltage"
BLX             printf
MOVS            R0, #1
B               loc_23238
; End of function get_PIC16F1704_voltage

off_2327C DCD __FUNCTION__.8268 ; "get_PIC16F1704_voltage"



; int __fastcall write_temperature_offset_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf)
EXPORT write_temperature_offset_PIC16F1704
write_temperature_offset_PIC16F1704

var_15= -0x15
send_data= -0x14
var_4= -4

which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
buf = R2                ; unsigned __int8 *
PUSH            {R4-R7,LR}
MOV             R7, which_i2c
SUBS            which_i2c, buf, #1
which_i2c = R7          ; unsigned int
MOVS            R3, #0x2E ; '.'
ADDS            buf, #7
MOV             R4, R0
SUB             SP, SP, #0x14
MOV             R6, which_chain
MOVS            which_chain, #0
STR             R1, [SP,#0x14+send_data+4]
STR             R1, [SP,#0x14+send_data+8]

loc_23296
crc = R3                ; unsigned __int16
LDRB.W          R1, [R4,#1]!
CMP             R4, R2
ADD             crc, R1
UXTH            R3, R3
crc = R3                ; unsigned __int16
BNE             loc_23296
MOVS            R1, #0x55 ; 'U'
LSRS            R5, crc, #8
UXTB            crc, crc
crc_data_0 = R5         ; unsigned __int8
crc_data_1 = R3         ; unsigned __int8
MOVS            R4, #0xAA
STRB.W          R1, [SP,#0x14+send_data]
MOVS            R1, #0xC
STRB.W          R4, [SP,#0x14+send_data+1]
MOVS            R4, #0x22 ; '"'
STRB.W          R1, [SP,#0x14+send_data+2]
ADD             R1, SP, #0x14+var_4
STRB.W          R4, [R1,#-0xD]!

loc_232C0
LDRB.W          R4, [R0,#1]!
CMP             R2, R0
STRB.W          R4, [R1,#1]!
BNE             loc_232C0
STRB.W          crc_data_0, [SP,#0x14+send_data+0xC]
LSLS            crc_data_0, R6, #0x10
crc_data_1 = R3         ; unsigned __int8
MOVW            R0, #:lower16:i2c_mutex
STRB.W          crc_data_1, [SP,#0x14+send_data+0xD]
ORR.W           R5, R5, #0xA00000
ADD.W           R4, SP, #0x14+var_15
ORR.W           R5, R5, which_i2c,LSL#26
ADD.W           R6, SP, #0x14+send_data+0xD
MOVT            R0, #:upper16:i2c_mutex ; mutex
BLX             pthread_mutex_lock

loc_232F2
LDRB.W          R0, [R4,#1]!
ORRS            R0, R5  ; config_data
BL              i2c_write
CMP             R6, R4
BNE             loc_232F2
MOV             R0, #gBM1397_MISC_CONTROL_reg ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R6, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #gBM1397_MISC_CONTROL_reg ; useconds
BLX             usleep
CMP             R6, #0x22 ; '"'
BNE             loc_2333C
CMP             R4, #1
BEQ             loc_23354

loc_2333C
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8292 ; "write_temperature_offset_PIC16F1704"
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x14
POP             {R4-which_i2c,PC}

loc_23354
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8292 ; "write_temperature_offset_PIC16F1704"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, R4
ADD             SP, SP, #0x14
POP             {R4-which_i2c,PC}
; End of function write_temperature_offset_PIC16F1704

off_23368 DCD __FUNCTION__.8292 ; "write_temperature_offset_PIC16F1704"


; Attributes: bp-based frame fpd=4

; int __fastcall read_temperature_offset_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf)
EXPORT read_temperature_offset_PIC16F1704
read_temperature_offset_PIC16F1704

var_58= -0x58
var_54= -0x54
var_50= -0x50
var_4C= -0x4C
var_48= -0x48
var_44= -0x44
var_40= -0x40
var_38= -0x38
var_34= -0x34
var_30= -0x30
var_2C= -0x2C
var_28= -0x28
var_24= -0x24
buf= -0x20
send_data= -0x18
read_back_data= -0x10
var_4= -4

which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
buf_0 = R2              ; unsigned __int8 *
PUSH.W          {R4-R11,LR}
MOV             R4, which_chain
SUB             SP, SP, #0x64
MOVS            R5, #0xAA
MOVS            R3, #0
MOV             R9, which_i2c
STRB.W          R5, [SP,#0x64+send_data+1]
LSLS            R5, R4, #0x10
MOVS            R7, #0xFF
STR             R3, [SP,#0x64+read_back_data]
MOVW            which_i2c, #:lower16:i2c_mutex
which_i2c = R9          ; unsigned int
STRH.W          R3, [SP,#0x64+send_data+4]
MOV.W           R8, #0x55 ; 'U'
STR             buf_0, [SP,#0x64+buf]
STR             R3, [SP,#0x64+read_back_data+4]
MOVS            which_chain, #4
STR             R3, [SP,#0x64+read_back_data+8]
MOVS            buf_0, #0x23 ; '#'
STRB.W          R7, [SP,#0x64+read_back_data]
MOVS            R3, #0x27 ; '''
MOVT            R0, #:upper16:i2c_mutex ; mutex
ADD             R7, SP, #0x60
ORR.W           R5, R5, #0xA00000
STRB.W          R8, [SP,#0x64+send_data]
STRB.W          R1, [SP,#0x64+send_data+2]
ADD             R6, SP, #0x64+send_data
STRB.W          R2, [SP,#0x64+send_data+3]
ORR.W           R5, R5, which_i2c,LSL#26
STRB.W          R3, [R7,#4+send_data+5]!
BLX             pthread_mutex_lock
MOV             R0, R8
B               loc_233CC

loc_233C8
LDRB.W          R0, [R6,#1]!

loc_233CC               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R6
BNE             loc_233C8
MOV.W           R0, #:lower16:gBM1397_MISC_CONTROL_reg
ADD             R4, SP, #0x64+read_back_data
MOVT            R0, #:upper16:gBM1397_MISC_CONTROL_reg ; useconds
ADD             R6, SP, #0x64+var_4
BLX             usleep

loc_233E6               ; config_data
MOV             R0, R5
BL              i2c_read
STRB.W          R0, [R4],#1
CMP             R4, R6
BNE             loc_233E6
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDRB.W          R1, [SP,#0x64+read_back_data+2]
MOVW            R0, #:lower16:aSReadBackData0_2 ; "--- %s: read_back_data[0] = 0x%x, read_"...
LDRB.W          R6, [SP,#0x64+read_back_data+3]
MOVT            R0, #:upper16:aSReadBackData0_2 ; "--- %s: read_back_data[0] = 0x%x, read_"...
LDRB.W          R10, [SP,#0x64+read_back_data+4]
STR             R1, [SP,#0x64+var_30]
LDRB.W          R1, [SP,#0x64+read_back_data+7]
LDRB.W          R2, [SP,#0x64+read_back_data+1]
LDRB.W          R3, [SP,#0x64+read_back_data]
STR             R1, [SP,#0x64+var_34]
STR             R1, [SP,#0x64+var_28]
LDR             R1, [SP,#0x64+var_30]
LDRB.W          R4, [SP,#0x64+read_back_data+8]
LDRB.W          which_i2c, [SP,#0x64+read_back_data+5]
STMEA.W         SP, {R1,R6,R10}
LDR             R1, [SP,#0x64+var_34]
LDRB.W          R8, [SP,#0x64+read_back_data+6]
LDRB.W          R7, [SP,#0x64+read_back_data+9]
LDRB.W          R11, [SP,#0x64+read_back_data+0xA]
LDRB.W          R5, [SP,#0x64+read_back_data+0xB]
STR             R2, [SP,#0x64+var_38]
MOV             R2, R3
STR             R3, [SP,#0x64+var_2C]
STR             R1, [SP,#0x64+var_50]
LDR             R3, [SP,#0x64+var_38]
LDR             R1, =__FUNCTION__.8310 ; "read_temperature_offset_PIC16F1704"
STR             R4, [SP,#0x64+var_24]
STR.W           R9, [SP,#0x64+var_58]
STR.W           R8, [SP,#0x64+var_54]
STR             R4, [SP,#0x64+var_4C]
STR             R7, [SP,#0x64+var_48]
STR.W           R11, [SP,#0x64+var_44]
STR             R5, [SP,#0x64+var_40]
BLX             printf
LDR             R3, [SP,#0x64+var_2C]
LDR             R2, [SP,#0x64+var_38]
CMP             R3, #0xC
IT EQ
CMPEQ           R2, #0x23 ; '#'
BEQ             loc_2348C
MOVW            R0, #:lower16:aSFailed ; "\n--- %s failed!\n\n"
LDR             R1, =__FUNCTION__.8310 ; "read_temperature_offset_PIC16F1704"
MOVT            R0, #:upper16:aSFailed ; "\n--- %s failed!\n\n"
BLX             printf
MOVS            R0, #0

loc_23486
ADD             SP, SP, #0x64 ; 'd'
POP.W           {R4-R11,PC}

loc_2348C
LDR             R2, [SP,#0x64+var_30]
MOV             R3, R6
ADD             R3, R2
MOV             R4, R3
LDR             R3, [SP,#0x64+var_28]
ADDS            R4, #0x2F ; '/'
ADD.W           R2, R4, R10
ADD             R2, R9
ADD             R2, R8
ADD             R2, R3
LDR             R3, [SP,#0x64+var_24]
ADD             R2, R3
ADD             R2, R7
UXTH            R2, R2
crc = R2                ; unsigned __int16
CMP.W           R11, crc,LSR#8
BNE             loc_234B6
UXTB            R3, crc
CMP             R5, R3
BEQ             loc_234CC

loc_234B6
MOVW            R0, #:lower16:aSFailedCrc0x04 ; "\n--- %s failed! crc = 0x%04x\n\n"
LDR             R1, =__FUNCTION__.8310 ; "read_temperature_offset_PIC16F1704"
MOVT            R0, #:upper16:aSFailedCrc0x04 ; "\n--- %s failed! crc = 0x%04x\n\n"
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x64 ; 'd'
POP.W           {R4-R11,PC}

loc_234CC
crc = R2                ; unsigned __int16
LDR             R1, [SP,#0x64+buf]
LDR             R7, [SP,#0x64+var_30]
MOV             R3, R1
SUBS            crc, R1, #1
ADDS            R3, #7
ADD.W           R1, SP, #0x64+read_back_data+2
B               loc_234E0

loc_234DC
LDRB.W          R7, [R1,#1]!

loc_234E0
STRB.W          R7, [R2,#1]!
CMP             R3, R2
BNE             loc_234DC
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8310 ; "read_temperature_offset_PIC16F1704"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOVS            R0, #1
B               loc_23486
; End of function read_temperature_offset_PIC16F1704

ALIGN 4
off_234FC DCD __FUNCTION__.8310 ; "read_temperature_offset_PIC16F1704"



; unsigned __int8 __fastcall erase_PIC16F1704_app_flash(unsigned int which_i2c, unsigned __int8 which_chain)
EXPORT erase_PIC16F1704_app_flash
erase_PIC16F1704_app_flash
which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
PUSH            {R4-R6,LR}
MOVS            R2, #6  ; flash_addr_h
MOVS            R3, #0  ; flash_addr_l
MOV             R5, which_chain
MOV             R6, which_i2c
MOVS            R4, #0x4C ; 'L'
BL              set_PIC16F1704_flash_pointer
MOVW            R0, #:lower16:aSEraseLoopD ; "%s: erase_loop = %d\n"
MOV             R2, R4
MOVT            R0, #:upper16:aSEraseLoopD ; "%s: erase_loop = %d\n"
LDR             R1, =__FUNCTION__.8326_0 ; "erase_PIC16F1704_app_flash"
BLX             printf

loc_23520               ; which_chain
MOV             R1, R5
MOV             R0, which_i2c ; which_i2c
BL              erase_PIC16F1704_flash
SUBS            R4, #1
BNE             loc_23520
MOVS            R0, #0xFF
POP             {R4-which_i2c,PC}
; End of function erase_PIC16F1704_app_flash

off_23530 DCD __FUNCTION__.8326_0 ; "erase_PIC16F1704_app_flash"



; int __fastcall PIC1704_update_pic_app_program(unsigned int which_i2c, unsigned __int8 which_chain)
EXPORT PIC1704_update_pic_app_program
PIC1704_update_pic_app_program

data_read= -0x13A4
var_139D= -0x139D
buf= -0x139C
program_data= -0x138C

which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB.W           SP, SP, #0x13A0
SUB             SP, SP, #4
MOVW            R2, #0x1388 ; n
MOV             R8, which_i2c
MOV             R9, which_chain
ADD             which_i2c, SP, #0x13A4+program_data ; s
which_i2c = R8          ; unsigned int
MOVS            which_chain, #0 ; c
BLX             memset
MOVW            R0, #:lower16:aUpdatePicProgr ; "\n--- update pic program"
MOVS            R4, #0
ADD             R7, SP, #0x13A4+buf
MOVT            R0, #:upper16:aUpdatePicProgr ; "\n--- update pic program"
STR             R4, [R7,#4]
STR             R4, [R7,#8]
STR             R4, [R7,#0xC]
STR             R4, [SP,#0x13A4+buf]
STR             R4, [SP,#0x13A4+data_read]
STRB.W          R4, [SP,#0x13A4+data_read+4]
BLX             puts
MOVW            R1, #:lower16:(aV9CheckAsicNum+0x18) ; "r"
MOVW            R0, #:lower16:aMntCardPic16f1 ; "/mnt/card/pic16f1704_app.txt"
MOVT            R1, #:upper16:(aV9CheckAsicNum+0x18) ; modes
MOVT            R0, #:upper16:aMntCardPic16f1 ; "/mnt/card/pic16f1704_app.txt"
BLX             fopen
pic_program_file = R0   ; FILE *
MOV             R5, pic_program_file
CMP             pic_program_file, #0
BEQ.W           loc_236D2
MOV             R2, R4  ; whence
MOV             R1, R4  ; off
BLX             fseek
MOV             R1, R4  ; c
ADD             R0, SP, #0x13A4+program_data ; s
MOVW            R2, #0x1388 ; n
MOV             R4, R0
BLX             memset
MOVW            R0, #:lower16:aPicFlashLength ; "pic_flash_length = %d\n"
ADD.W           R6, SP, #0x13A4+program_data+0x12E8
MOVT            R0, #:upper16:aPicFlashLength ; "pic_flash_length = %d\n"
MOV.W           R1, #0x980
ADDS            R6, #0x18
BLX             printf

loc_235B4               ; stream
MOV             R2, pic_program_file
MOVW            R1, #0x3FF ; n
MOV             R0, SP  ; s
ADDS            R4, #2
BLX             fgets
MOVS            R2, #0x10 ; base
MOVS            R1, #0  ; endptr
MOV             R0, SP  ; nptr
BLX             strtoul
data_int = R0           ; unsigned int
LSRS            R3, data_int, #8
STRB.W          data_int, [R4,#-1]
STRB.W          R3, [R4,#-2]
CMP             R6, R4
BNE             loc_235B4
MOV             data_int, pic_program_file ; stream
BLX             fclose
MOV             R1, R9  ; which_i2c
MOV             R0, which_i2c ; which_chain
BL              reset_PIC16F1704_pic
ret = R0                ; int
CMP             ret, #0
BEQ             loc_2369E
MOV             R1, R9  ; which_chain
MOV             ret, which_i2c ; which_i2c
BL              erase_PIC16F1704_app_flash
MOV             pic_program_file, R0
CMP             R0, #0
BEQ             loc_23684
MOVS            R3, #0  ; flash_addr_l
MOVS            R2, #6  ; flash_addr_h
MOV             R1, R9  ; which_chain
MOV             R0, which_i2c ; which_i2c
BL              set_PIC16F1704_flash_pointer
ret = R0                ; int
MOV             R5, ret
CMP             ret, #0
BEQ             loc_236B8
MOVW            R11, #:lower16:aSendPicProgram ; "send pic program time: %d\n"
MOVW            R6, #:lower16:aBufD0x02x ; "buf[%d] = 0x%02x\n"
MOVT            R11, #:upper16:aSendPicProgram ; "send pic program time: %d\n"
MOVT            R6, #:upper16:aBufD0x02x ; "buf[%d] = 0x%02x\n"
MOV.W           R10, #0

loc_23620
i = R10                 ; unsigned int
ADD             R3, SP, #0x13A4+program_data
ADD.W           R5, SP, #0x13A4+var_139D
ADD.W           R3, R3, i,LSL#4
MOVS            R4, #0
LDM             R3, {R0-R3}
STM.W           R7, {R0-R3}
MOV             R1, i
MOV             R0, R11 ; format
BLX             printf

loc_2363A
j = R4                  ; unsigned int
MOV             R1, j
LDRB.W          R2, [R5,#1]!
MOV             R0, R6  ; format
ADDS            j, #1
j = R1                  ; unsigned int
BLX             printf
j = R4                  ; unsigned int
CMP             j, #0x10
BNE             loc_2363A
MOVS            R0, #0xA ; c
ADD.W           i, i, #1
BLX             putchar
MOV             R2, R7  ; buf
MOV             R1, R9  ; which_chain
MOV             R0, which_i2c ; which_i2c
BL              send_data_to_PIC16F1704
MOV             R1, R9  ; which_chain
MOV             R0, which_i2c ; which_i2c
BL              write_data_into_PIC16F1704_flash
i = R10                 ; unsigned int
CMP.W           i, #0x130
BNE             loc_23620
MOV             R1, R9  ; which_i2c
MOV             R0, which_i2c ; which_chain
BL              reset_PIC16F1704_pic
ret = R0                ; int
CBZ             ret, loc_2369E
MOVS            ret, #1
ADD.W           SP, SP, #0x13A0
ADD             SP, SP, #4
POP.W           {j-R11,PC}

loc_23684
MOVW            R0, #:lower16:aSEraseFlashErr ; "!!! %s: erase flash error!\n\n"
LDR             R1, =__FUNCTION__.8347 ; "PIC1704_update_pic_app_program"
MOVT            R0, #:upper16:aSEraseFlashErr ; "!!! %s: erase flash error!\n\n"
BLX             printf
MOV             R0, R5
ADD.W           SP, SP, #0x13A0
ADD             SP, SP, #4
POP.W           {R4-R11,PC}

loc_2369E
ret = R0                ; int
MOVW            ret, #:lower16:aSResetPicError ; "!!! %s: reset pic error!\n\n"
LDR             R1, =__FUNCTION__.8347 ; "PIC1704_update_pic_app_program"
MOVT            R0, #:upper16:aSResetPicError ; "!!! %s: reset pic error!\n\n"
BLX             printf
MOVS            R0, #0
ADD.W           SP, SP, #0x13A0
ADD             SP, SP, #4
POP.W           {R4-R11,PC}

loc_236B8
ret = R0                ; int
MOVW            ret, #:lower16:aSSetFlashPoint ; "!!! %s: set flash pointer error!\n\n"
ret = R5                ; int
LDR             R1, =__FUNCTION__.8347 ; "PIC1704_update_pic_app_program"
MOVT            R0, #:upper16:aSSetFlashPoint ; "!!! %s: set flash pointer error!\n\n"
BLX             printf
MOV             R0, ret
ADD.W           SP, SP, #0x13A0
ADD             SP, SP, #4
POP.W           {R4-R11,PC}

loc_236D2
pic_program_file = R0   ; FILE *
MOVW            pic_program_file, #:lower16:aSOpenPic16f170 ; "\n%s: open pic16f1704_app.txt failed\n"
pic_program_file = R5   ; FILE *
LDR             R1, =__FUNCTION__.8347 ; "PIC1704_update_pic_app_program"
MOVT            R0, #:upper16:aSOpenPic16f170 ; "\n%s: open pic16f1704_app.txt failed\n"
BLX             printf
MOV             R0, pic_program_file
ADD.W           SP, SP, #0x13A0
ADD             SP, SP, #4
POP.W           {R4-R11,PC}
; End of function PIC1704_update_pic_app_program

off_236EC DCD __FUNCTION__.8347 ; "PIC1704_update_pic_app_program"


; Attributes: bp-based frame

; int __fastcall save_freq_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int16 freq)
EXPORT save_freq_PIC16F1704
save_freq_PIC16F1704

send_data= -8

which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
freq = R2               ; unsigned __int16
PUSH.W          {R4-R8,LR}
UXTB            R3, freq
LSRS            R4, freq, #8
SUB             SP, SP, #8
MOV             R6, which_i2c
ADD             R3, R4
MOV             R8, which_chain
ADDS            R3, #0x2A ; '*'
crc = R3                ; unsigned __int16
STRB.W          freq, [SP,#8+send_data+5]
LSLS            R6, R6, #0x1A
LSRS            freq, crc, #8
UXTB.W          R8, R8
STRB.W          R4, [SP,#8+send_data+4]
MOVW            which_chain, #:lower16:i2c_mutex
STRB.W          R2, [SP,#8+send_data+6]
ADD             R7, SP, #8
MOVS            R5, #0x55 ; 'U'
MOVS            which_i2c, #0xAA
MOVS            R2, #6
STRB.W          crc, [R7,#send_data+7]!
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOVS            crc, #0x24 ; '$'
ORR.W           R6, R6, #0xA00000
STRB.W          R5, [SP,#8+send_data]
MOV             R4, SP
STRB.W          R1, [SP,#8+send_data+1]
STRB.W          R2, [SP,#8+send_data+2]
STRB.W          R3, [SP,#8+send_data+3]
BLX             pthread_mutex_lock
MOV             R0, R5
ORR.W           R5, R6, R8,LSL#16
B               loc_23752

loc_2374E
LDRB.W          R0, [R4,#1]!

loc_23752               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R4
BNE             loc_2374E
MOV             R0, #(gAsic_Core_Nonce_Num+0x1859C) ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R6, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #gBM1397_MISC_CONTROL_reg ; useconds
BLX             usleep
CMP             R6, #0x24 ; '$'
BNE             loc_23798
CMP             R4, #1
BEQ             loc_237B2

loc_23798
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8374 ; "save_freq_PIC16F1704"
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #8
POP.W           {R4-R8,PC}

loc_237B2
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8374 ; "save_freq_PIC16F1704"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, R4
ADD             SP, SP, #8
POP.W           {R4-R8,PC}
; End of function save_freq_PIC16F1704

off_237C8 DCD __FUNCTION__.8374 ; "save_freq_PIC16F1704"



; int __fastcall get_PIC16F1704_freq(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int16 *freq)
EXPORT get_PIC16F1704_freq
get_PIC16F1704_freq

var_20= -0x20
var_1C= -0x1C
var_18= -0x18
var_14= -0x14
read_back_data= -0x10
var_A= -0xA
send_data= -8
var_s0=  0

which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
freq = R2               ; unsigned __int16 *
PUSH.W          {R4-R10,LR}
MOV             R6, which_i2c
SUB             SP, SP, #0x20
MOVS            R5, #0xAA
MOV             R10, which_chain
MOVS            R3, #0
STRB.W          R5, [SP,#0x20+send_data+1]
LSLS            R5, R6, #0x1A
MOVW            which_chain, #:lower16:i2c_mutex
which_chain = R10       ; unsigned int
UXTB.W          which_chain, which_chain
STR             R3, [SP,#0x20+read_back_data]
MOV.W           LR, #0xFF
STRH.W          R3, [SP,#0x20+send_data+4]
MOV.W           R9, #0x55 ; 'U'
STRH.W          R3, [SP,#0x20+read_back_data+4]
MOVS            which_i2c, #4
MOVS            R3, #0x29 ; ')'
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOV             R7, freq
ADD.W           R8, SP, #0x20+var_s0
MOVS            freq, #0x25 ; '%'
freq = R7               ; unsigned __int16 *
ORR.W           R5, R5, #0xA00000
STRB.W          LR, [SP,#0x20+read_back_data]
ADD             R4, SP, #0x20+send_data
STRB.W          R9, [SP,#0x20+send_data]
ORR.W           R5, R5, R10,LSL#16
STRB.W          R1, [SP,#0x20+send_data+2]
STRB.W          R2, [SP,#0x20+send_data+3]
STRB.W          R3, [R8,#-3]!
BLX             pthread_mutex_lock
MOV             R0, R9
B               loc_23834

loc_23830
LDRB.W          R0, [R4,#1]!

loc_23834               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R4, R8
BNE             loc_23830
MOVW            R0, #:lower16:(gAsic_Core_Nonce_Num+0x1859C)
ADD             R4, SP, #0x20+read_back_data
MOVT            R0, #:upper16:(gAsic_Core_Nonce_Num+0x1859C) ; useconds
ADD.W           R6, SP, #0x20+var_A
BLX             usleep

loc_23850               ; config_data
MOV             R0, R5
BL              i2c_read
STRB.W          R0, [R4],#1
CMP             R4, R6
BNE             loc_23850
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #gBM1397_MISC_CONTROL_reg ; useconds
BLX             usleep
LDRB.W          R5, [SP,#0x20+read_back_data]
MOVW            R0, #:lower16:aSReadBackData0_3 ; "--- %s: read_back_data[0] = 0x%x, read_"...
LDRB.W          R4, [SP,#0x20+read_back_data+1]
MOVT            R0, #:upper16:aSReadBackData0_3 ; "--- %s: read_back_data[0] = 0x%x, read_"...
LDRB.W          R8, [SP,#0x20+read_back_data+2]
LDRB.W          R6, [SP,#0x20+read_back_data+3]
MOV             R2, R5
LDRB.W          R9, [SP,#0x20+read_back_data+4]
MOV             R3, R4
LDRB.W          R10, [SP,#0x20+read_back_data+5]
STR.W           R8, [SP,#0x20+var_20]
STR             R6, [SP,#0x20+var_1C]
STR.W           R9, [SP,#0x20+var_18]
STR.W           R10, [SP,#0x20+var_14]
LDR             R1, =__FUNCTION__.8392 ; "get_PIC16F1704_freq"
BLX             printf
CMP             R4, #0x25 ; '%'
IT EQ
CMPEQ           R5, #6
BEQ             loc_238CC
MOVW            R0, #:lower16:aSFailed ; "\n--- %s failed!\n\n"
LDR             R1, =__FUNCTION__.8392 ; "get_PIC16F1704_freq"
MOVT            R0, #:upper16:aSFailed ; "\n--- %s failed!\n\n"
BLX             printf
MOVS            R0, #0

loc_238C6
ADD             SP, SP, #0x20 ; ' '
POP.W           {R4-R10,PC}

loc_238CC
ADD.W           R2, R8, R6
ADDS            R2, #0x2B ; '+'
crc = R2                ; unsigned __int16
UBFX.W          R3, crc, #8, #8
CMP             R3, R9
BNE             loc_238E0
UXTB            R3, crc
CMP             R10, R3
BEQ             loc_238F6

loc_238E0
MOVW            R0, #:lower16:aSFailedCrc0x04 ; "\n--- %s failed! crc = 0x%04x\n\n"
LDR             R1, =__FUNCTION__.8392 ; "get_PIC16F1704_freq"
MOVT            R0, #:upper16:aSFailedCrc0x04 ; "\n--- %s failed! crc = 0x%04x\n\n"
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x20 ; ' '
POP.W           {R4-R10,PC}

loc_238F6
crc = R2                ; unsigned __int16
ORR.W           crc, R6, R8,LSL#8
MOV             R0, #aSOkFreqD ; "\n--- %s ok, freq = %d\n\n"
LDR             R1, =__FUNCTION__.8392 ; "get_PIC16F1704_freq"
STRH            R2, [freq]
BLX             printf
MOVS            R0, #1
B               loc_238C6
; End of function get_PIC16F1704_freq

ALIGN 0x10
off_23910 DCD __FUNCTION__.8392 ; "get_PIC16F1704_freq"



; void __fastcall set_temperature_offset_value(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *value)
EXPORT set_temperature_offset_value
set_temperature_offset_value
which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
value = R2              ; unsigned __int8 *
PUSH            {R4-R6,LR}
MOV             R4, which_i2c
MOVW            which_i2c, #:lower16:aS ; "\n--- %s\n"
which_i2c = R4          ; unsigned int
MOV             R5, which_chain
MOV             R6, value
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             which_chain, =__FUNCTION__.8398 ; "set_temperature_offset_value"
BLX             printf
MOV             R2, value ; buf
MOV             R1, R5  ; which_chain
MOV             R0, which_i2c ; which_i2c
BL              write_temperature_offset_PIC16F1704
MOVW            R0, #:lower16:loc_186A0
POP.W           {which_i2c-value,LR}
MOVT            R0, #:upper16:loc_186A0 ; useconds
B.W             j_usleep
; End of function set_temperature_offset_value

off_23944 DCD __FUNCTION__.8398 ; "set_temperature_offset_value"



; void __fastcall write_sensor_info_into_pic(unsigned int which_i2c, unsigned __int8 which_chain)
EXPORT write_sensor_info_into_pic
write_sensor_info_into_pic

offset_value= -0xC

which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
PUSH            {R4-R7,LR}
MOV             R6, which_i2c
MOVW            which_i2c, #:lower16:aS ; "\n--- %s\n"
which_i2c = R6          ; unsigned int
SUB             SP, SP, #0xC
MOVS            R4, #0
MOV             R5, which_chain
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             which_chain, =__FUNCTION__.8404 ; "write_sensor_info_into_pic"
STR             R4, [SP,#0xC+offset_value+4]
STR             R4, [SP,#0xC+offset_value]
BLX             printf
MOVW            R3, #:lower16:Conf
MOV             R1, R5  ; which_chain
MOVT            R3, #:upper16:Conf
MOV             R0, which_i2c ; which_i2c
LDR.W           R5, [R3,#configuration.sensor_model]
MOV             R2, SP  ; value
LDR.W           LR, [R3,#configuration.TempSensor1]
LDR.W           R7, [R3,#configuration.TempSensor2]
LDR.W           which_i2c, [R3,#configuration.TempSensor3]
which_i2c = R0          ; unsigned int
ORR.W           R5, R5, #0x20 ; ' '
LDR.W           R3, [R3,#configuration.remote_local_gap]
STRB.W          R4, [SP,#0xC+offset_value+1]
STRB.W          R4, [SP,#0xC+offset_value+3]
STRB.W          R4, [SP,#0xC+offset_value+5]
STRB.W          R5, [SP,#0xC+offset_value+6]
STRB.W          LR, [SP,#0xC+offset_value]
STRB.W          R7, [SP,#0xC+offset_value+2]
STRB.W          R6, [SP,#0xC+offset_value+4]
STRB.W          R3, [SP,#0xC+offset_value+7]
BL              set_temperature_offset_value
ADD             SP, SP, #0xC
POP             {R4-R7,PC}
; End of function write_sensor_info_into_pic

ALIGN 4
off_239B4 DCD __FUNCTION__.8404 ; "write_sensor_info_into_pic"



; int __fastcall send_data_to_dsPIC33EP16GS202(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf)
EXPORT send_data_to_dsPIC33EP16GS202
send_data_to_dsPIC33EP16GS202

var_1D= -0x1D
send_data= -0x1C
var_4= -4

which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
buf = R2                ; unsigned __int8 *
PUSH            {R4-R7,LR}
SUBS            R4, buf, #1
MOV             R6, which_i2c
ADDS            buf, #0xF
MOV             which_i2c, R4
which_i2c = R6          ; unsigned int
MOVS            R3, #0x16
SUB             SP, SP, #0x1C
MOV             R7, which_chain
MOVS            which_chain, #0
STR             R1, [SP,#0x1C+send_data+4]
STR             R1, [SP,#0x1C+send_data+8]
STR             R1, [SP,#0x1C+send_data+0xC]
STR             R1, [SP,#0x1C+send_data+0x10]

loc_239D2
crc = R3                ; unsigned __int16
LDRB.W          R5, [R0,#1]!
CMP             R0, R2
ADD             crc, R5
UXTH            R3, R3
crc = R3                ; unsigned __int16
BNE             loc_239D2
MOVS            R2, #0x55 ; 'U'
LSRS            R5, crc, #8
UXTB            crc, crc
crc_data_0 = R5         ; unsigned __int8
crc_data_1 = R3         ; unsigned __int8
MOVS            R0, #0xAA
STRB.W          R2, [SP,#0x1C+send_data]
ADD.W           R1, SP, #0x1C+send_data+0x13
MOVS            R2, #0x14
STRB.W          R0, [SP,#0x1C+send_data+1]
STRB.W          R2, [SP,#0x1C+send_data+2]
MOVS            R0, #2
ADD             R2, SP, #0x1C+var_4
STRB.W          R0, [R2,#-0x15]!

loc_23A00
LDRB.W          R0, [R4,#1]!
STRB.W          R0, [R2,#1]!
CMP             R2, R1
BNE             loc_23A00
STRB.W          crc_data_0, [SP,#0x1C+send_data+0x14]
LSLS            crc_data_0, R7, #0x10
crc_data_1 = R3         ; unsigned __int8
MOVW            R0, #:lower16:i2c_mutex
STRB.W          crc_data_1, [SP,#0x1C+send_data+0x15]
ORR.W           R5, R5, #0x400000
ADD.W           R4, SP, #0x1C+var_1D
ORR.W           R5, R5, which_i2c,LSL#26
ADD.W           R7, SP, #0x1C+send_data+0x15
MOVT            R0, #:upper16:i2c_mutex ; mutex
BLX             pthread_mutex_lock

loc_23A32
LDRB.W          R0, [R4,#1]!
ORRS            R0, R5  ; config_data
BL              i2c_write
CMP             R7, R4
BNE             loc_23A32
MOV             R0, #0x186A0 ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             which_i2c, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
CMP             R6, #2
BNE             loc_23A70
CMP             R4, #1
BEQ             loc_23A88

loc_23A70
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8428 ; "send_data_to_dsPIC33EP16GS202"
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x1C
POP             {R4-R7,PC}

loc_23A88
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8428 ; "send_data_to_dsPIC33EP16GS202"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, R4
ADD             SP, SP, #0x1C
POP             {R4-R7,PC}
; End of function send_data_to_dsPIC33EP16GS202

off_23A9C DCD __FUNCTION__.8428 ; "send_data_to_dsPIC33EP16GS202"


; Attributes: bp-based frame

; int __fastcall jump_from_loader_to_app_dsPIC33EP16GS202(unsigned int which_chain, unsigned __int8 which_i2c)
EXPORT jump_from_loader_to_app_dsPIC33EP16GS202
jump_from_loader_to_app_dsPIC33EP16GS202

send_data= -8

which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R6, which_i2c
MOV             R8, which_chain
LSLS            R6, R6, #0x1A
SUB             SP, SP, #8
UXTB.W          R8, R8
MOVS            R2, #0
MOVS            R3, #0xAA
MOVW            which_chain, #:lower16:i2c_mutex
MOVS            R5, #0x55 ; 'U'
STRH.W          R2, [SP,#8+send_data+4]
MOVS            which_i2c, #4
MOVS            R2, #6
STRB.W          R3, [SP,#8+send_data+1]
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOVS            R3, #0xA
ADD             R7, SP, #8
ORR.W           R6, R6, #0x400000
STRB.W          R5, [SP,#8+send_data]
STRB.W          R1, [SP,#8+send_data+2]
MOV             R4, SP
STRB.W          R2, [SP,#8+send_data+3]
STRB.W          R3, [R7,#send_data+5]!
BLX             pthread_mutex_lock
MOV             R0, R5
ORR.W           R5, R6, R8,LSL#16
B               loc_23AF4

loc_23AF0
LDRB.W          R0, [R4,#1]!

loc_23AF4               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R4
BNE             loc_23AF0
MOV             R0, #0x186A0 ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R6, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #(gAsic_Core_Nonce_Num+0x1859C) ; useconds
BLX             usleep
CMP             R6, #6
BNE             loc_23B3A
CMP             R4, #1
BEQ             loc_23B54

loc_23B3A
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8445 ; "jump_from_loader_to_app_dsPIC33EP16GS20"...
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #8
POP.W           {R4-R8,PC}

loc_23B54
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8445 ; "jump_from_loader_to_app_dsPIC33EP16GS20"...
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, R4
ADD             SP, SP, #8
POP.W           {R4-R8,PC}
; End of function jump_from_loader_to_app_dsPIC33EP16GS202

ALIGN 4
off_23B6C DCD __FUNCTION__.8445 ; "jump_from_loader_to_app_dsPIC33EP16GS20"...


; Attributes: bp-based frame

; int __fastcall reset_dsPIC33EP16GS202_pic(unsigned int which_chain, unsigned __int8 which_i2c)
EXPORT reset_dsPIC33EP16GS202_pic
reset_dsPIC33EP16GS202_pic

send_data= -8

which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R6, which_i2c
MOV             R8, which_chain
LSLS            R6, R6, #0x1A
SUB             SP, SP, #8
UXTB.W          R8, R8
MOVS            R2, #0
MOVS            R3, #0xAA
MOVW            which_chain, #:lower16:i2c_mutex
MOVS            R5, #0x55 ; 'U'
STRH.W          R2, [SP,#8+send_data+4]
MOVS            which_i2c, #4
MOVS            R2, #7
STRB.W          R3, [SP,#8+send_data+1]
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOVS            R3, #0xB
ADD             R7, SP, #8
ORR.W           R6, R6, #0x400000
STRB.W          R5, [SP,#8+send_data]
STRB.W          R1, [SP,#8+send_data+2]
MOV             R4, SP
STRB.W          R2, [SP,#8+send_data+3]
STRB.W          R3, [R7,#send_data+5]!
BLX             pthread_mutex_lock
MOV             R0, R5
ORR.W           R5, R6, R8,LSL#16
B               loc_23BC4

loc_23BC0
LDRB.W          R0, [R4,#1]!

loc_23BC4               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R4
BNE             loc_23BC0
MOV             R0, #0x186A0 ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R6, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #(gAsic_Core_Nonce_Num+0xC33FC) ; useconds
BLX             usleep
CMP             R6, #7
BNE             loc_23C0A
CMP             R4, #1
BEQ             loc_23C24

loc_23C0A
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8462 ; "reset_dsPIC33EP16GS202_pic"
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #8
POP.W           {R4-R8,PC}

loc_23C24
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8462 ; "reset_dsPIC33EP16GS202_pic"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, R4
ADD             SP, SP, #8
POP.W           {R4-R8,PC}
; End of function reset_dsPIC33EP16GS202_pic

ALIGN 4
off_23C3C DCD __FUNCTION__.8462 ; "reset_dsPIC33EP16GS202_pic"



; int __fastcall dsPIC33EP16GS202_erase_pic_app_program(unsigned int which_chain, unsigned __int8 which_i2c)
EXPORT dsPIC33EP16GS202_erase_pic_app_program
dsPIC33EP16GS202_erase_pic_app_program

send_data= -8
var_s0=  0

which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R8, which_chain
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
which_chain = R8        ; unsigned int
SUB             SP, SP, #8
MOVS            R7, #0
MOV             R6, which_i2c
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             which_i2c, =__FUNCTION__.8473 ; "dsPIC33EP16GS202_erase_pic_app_program"
STRH.W          R7, [SP,#8+send_data+4]
LSLS            R6, R6, #0x1A
STR             R7, [SP,#8+send_data]
UXTB.W          which_chain, which_chain
MOVS            R5, #0x55 ; 'U'
BLX             printf
MOVW            R0, #:lower16:aSCrcData00xXCr ; "--- %s: crc_data[0] = 0x%x, crc_data[1]"...
MOV             R2, R7
MOVS            R3, #0xD
LDR             R1, =__FUNCTION__.8473 ; "dsPIC33EP16GS202_erase_pic_app_program"
MOVT            R0, #:upper16:aSCrcData00xXCr ; "--- %s: crc_data[0] = 0x%x, crc_data[1]"...
ADD             R7, SP, #8+var_s0
BLX             printf
MOVS            R3, #0xAA
MOVW            R0, #:lower16:i2c_mutex
MOVS            R1, #4
MOVS            R2, #9
STRB.W          R3, [SP,#8+send_data+1]
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOVS            R3, #0xD
ORR.W           R6, R6, #0x400000
STRB.W          R5, [SP,#8+send_data]
MOV             R4, SP
STRB.W          R1, [SP,#8+send_data+2]
STRB.W          R2, [SP,#8+send_data+3]
STRB.W          R3, [R7,#-3]!
BLX             pthread_mutex_lock
MOV             R0, R5
ORR.W           R5, R6, R8,LSL#16
B               loc_23CB6

loc_23CB2
LDRB.W          R0, [R4,#1]!

loc_23CB6               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R4
BNE             loc_23CB2
MOV             R0, #0x186A0 ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R5, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOVW            R0, #:lower16:aSReadBackData0_4 ; "--- %s: read_back_data[0] = 0x%x, read_"...
MOV             R3, R5
MOV             R2, R4
LDR             R1, =__FUNCTION__.8473 ; "dsPIC33EP16GS202_erase_pic_app_program"
MOVT            R0, #:upper16:aSReadBackData0_4 ; "--- %s: read_back_data[0] = 0x%x, read_"...
BLX             printf
MOV             R0, #gBM1397_MISC_CONTROL_reg ; useconds
BLX             usleep
CMP             R4, #9
IT EQ
CMPEQ           R5, #1
BEQ             loc_23D24
MOVW            R0, #:lower16:aSFailed ; "\n--- %s failed!\n\n"
LDR             R1, =__FUNCTION__.8473 ; "dsPIC33EP16GS202_erase_pic_app_program"
MOVT            R0, #:upper16:aSFailed ; "\n--- %s failed!\n\n"
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #8
POP.W           {R4-R8,PC}

loc_23D24
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8473 ; "dsPIC33EP16GS202_erase_pic_app_program"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOVS            R0, #1
ADD             SP, SP, #8
POP.W           {R4-R8,PC}
; End of function dsPIC33EP16GS202_erase_pic_app_program

ALIGN 4
off_23D3C DCD __FUNCTION__.8473 ; "dsPIC33EP16GS202_erase_pic_app_program"


; Attributes: bp-based frame

; int __fastcall set_dsPIC33EP16GS202_voltage(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 voltage)
EXPORT set_dsPIC33EP16GS202_voltage
set_dsPIC33EP16GS202_voltage

send_data= -0xC

which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
voltage = R2            ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R8, which_chain
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
which_chain = R8        ; unsigned int
SUB             SP, SP, #0x10
MOV             R5, voltage
MOVS            R3, #0
MOV             R6, which_i2c
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             which_i2c, =__FUNCTION__.8491 ; "set_dsPIC33EP16GS202_voltage"
LSLS            R6, R6, #0x1A
STR             R3, [SP,#0x10+send_data+4]
ADD             R7, SP, #0x10
STR             R3, [SP,#0x10+send_data]
UXTB.W          which_chain, which_chain
STRB.W          R3, [SP,#0x10+send_data+8]
ORR.W           R6, R6, #0x400000
BLX             printf
ADD.W           R3, R5, #0x17
crc = R3                ; unsigned __int16
MOVW            R0, #:lower16:i2c_mutex
LSRS            R2, crc, #8
STRB.W          R5, [SP,#0x10+send_data+4]
MOVS            R1, #0xAA
STRB.W          crc, [R7,#send_data+8]!
MOVS            R5, #0x55 ; 'U'
STRB.W          R2, [SP,#0x10+send_data+7]
MOVS            crc, #0x10
MOVS            R2, #7
MOVT            R0, #:upper16:i2c_mutex ; mutex
STRB.W          R5, [SP,#0x10+send_data]
STRB.W          R1, [SP,#0x10+send_data+1]
ADD             R4, SP, #0x10+send_data
STRB.W          R2, [SP,#0x10+send_data+2]
STRB.W          R3, [SP,#0x10+send_data+3]
BLX             pthread_mutex_lock
MOV             R0, R5
ORR.W           R5, R6, R8,LSL#16
B               loc_23DB4

loc_23DB0
LDRB.W          R0, [R4,#1]!

loc_23DB4               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R4
BNE             loc_23DB0
MOV             R0, #gBM1397_MISC_CONTROL_reg ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R6, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #gBM1397_MISC_CONTROL_reg ; useconds
BLX             usleep
CMP             R6, #0x10
BNE             loc_23DFA
CMP             R4, #1
BEQ             loc_23E14

loc_23DFA
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8491 ; "set_dsPIC33EP16GS202_voltage"
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x10
POP.W           {R4-R8,PC}

loc_23E14
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8491 ; "set_dsPIC33EP16GS202_voltage"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, R4
ADD             SP, SP, #0x10
POP.W           {R4-R8,PC}
; End of function set_dsPIC33EP16GS202_voltage

ALIGN 4
off_23E2C DCD __FUNCTION__.8491 ; "set_dsPIC33EP16GS202_voltage"



; int __fastcall set_dsPIC33EP16GS202_threshold_voltage(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int16 vol, unsigned __int16 vol1, unsigned __int16 vol2, unsigned __int16 vol3, unsigned __int16 vol_p)
EXPORT set_dsPIC33EP16GS202_threshold_voltage
set_dsPIC33EP16GS202_threshold_voltage

send_data= -0x14
var_4= -4
vol2=  0x24
vol3=  0x28
vol_p=  0x2C

which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
vol = R2                ; unsigned __int16
vol1 = R3               ; unsigned __int16
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x14
LDRH.W          R5, [SP,#0x14+vol_p]
MOV             R8, which_chain
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
which_chain = R8        ; unsigned int
MOVS            R4, #0
LDRH.W          R9, [SP,#0x14+vol3]
MOV             R6, which_i2c
LDRH.W          R7, [SP,#0x14+vol2]
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             which_i2c, =__FUNCTION__.8513_0 ; "set_dsPIC33EP16GS202_threshold_voltage"
MOV             R10, vol
MOV             R11, vol1
STR             R4, [SP,#0x14+send_data+4]
STR             R4, [SP,#0x14+send_data]
LSLS            R6, R6, #0x1A
STR             R4, [SP,#0x14+send_data+8]
UXTB.W          which_chain, which_chain
STR             R4, [SP,#0x14+send_data+0xC]
ORR.W           R6, R6, #0x400000
BLX             printf
ADD.W           R1, R5, #0x41 ; 'A'
MOV.W           R3, R10,LSR#8
ADD             R1, R9
MOV.W           LR, R7,LSR#8
ADD             R1, R7
STRB.W          R3, [SP,#0x14+send_data+4]
ADD             R1, R11
MOV.W           R3, R11,LSR#8
ADD             R1, R10
STRB.W          LR, [SP,#0x14+send_data+8]
UXTH            R1, R1
crc = R1                ; unsigned __int16
MOVS.W          R10, R10
IT NE
MOVNE.W         R10, #1
STRB.W          R3, [SP,#0x14+send_data+6]
MOVS.W          R11, R11
MOV.W           R2, crc,LSR#8
IT NE
MOVNE.W         R11, #1
MOV.W           R3, R9,LSR#8
MOVS.W          R12, R7
STRB.W          R2, [SP,#0x14+send_data+0xE]
IT NE
MOVNE.W         R12, #1
ADD             R7, SP, #0x14+var_4
MOVS.W          R9, R9
MOV.W           R2, R5,LSR#8
IT NE
MOVNE.W         R9, #1
STRB.W          crc, [R7,#-1]!
MOVW            R0, #:lower16:i2c_mutex
MOVS            crc, R5
IT NE
MOVNE           R1, #1
MOVS            R5, #0x55 ; 'U'
STRB.W          R12, [SP,#0x14+send_data+9]
MOV.W           LR, #0xE
MOV.W           R12, #0xAA
STRB.W          R3, [SP,#0x14+send_data+0xA]
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOVS            R3, #0x33 ; '3'
STRB.W          R5, [SP,#0x14+send_data]
MOV             R4, SP
STRB.W          R10, [SP,#0x14+send_data+5]
STRB.W          R11, [SP,#0x14+send_data+7]
STRB.W          R9, [SP,#0x14+send_data+0xB]
STRB.W          R2, [SP,#0x14+send_data+0xC]
STRB.W          R1, [SP,#0x14+send_data+0xD]
STRB.W          R12, [SP,#0x14+send_data+1]
STRB.W          LR, [SP,#0x14+send_data+2]
STRB.W          R3, [SP,#0x14+send_data+3]
BLX             pthread_mutex_lock
MOV             R0, R5
ORR.W           R5, R6, R8,LSL#16
B               loc_23F28

loc_23F24
LDRB.W          R0, [R4,#1]!

loc_23F28               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R4
BNE             loc_23F24
MOV             R0, #0x186A0 ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R6, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
CMP             R6, #0x33 ; '3'
BNE             loc_23F62
CMP             R4, #1
BEQ             loc_23F7C

loc_23F62
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8513_0 ; "set_dsPIC33EP16GS202_threshold_voltage"
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}

loc_23F7C
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8513_0 ; "set_dsPIC33EP16GS202_threshold_voltage"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
MOV             R0, R4
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}
; End of function set_dsPIC33EP16GS202_threshold_voltage

ALIGN 0x10
off_23FA0 DCD __FUNCTION__.8513_0 ; "set_dsPIC33EP16GS202_threshold_voltage"


; Attributes: bp-based frame

; int __fastcall enable_dsPIC33EP16GS202_dc_dc(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 enable)
EXPORT enable_dsPIC33EP16GS202_dc_dc
enable_dsPIC33EP16GS202_dc_dc

send_data= -8

which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
enable = R2             ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R8, which_chain
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
which_chain = R8        ; unsigned int
SUB             SP, SP, #8
MOV             R5, enable
MOVS            R3, #0
MOV             R6, which_i2c
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             which_i2c, =__FUNCTION__.8531 ; "enable_dsPIC33EP16GS202_dc_dc"
LSLS            R6, R6, #0x1A
STR             R3, [SP,#8+send_data]
ADD             R7, SP, #8
STR.W           R3, [SP,#8+send_data+3]
UXTB.W          which_chain, which_chain
ORR.W           R6, R6, #0x400000
BLX             printf
ADD.W           R3, R5, #0x1A
crc = R3                ; unsigned __int16
MOVW            R0, #:lower16:i2c_mutex
LSRS            R2, crc, #8
STRB.W          R5, [SP,#8+send_data+4]
MOVS            R1, #0xAA
STRB.W          crc, [R7,#send_data+6]!
MOVS            R5, #0x55 ; 'U'
STRB.W          R2, [SP,#8+send_data+5]
MOVS            crc, #0x15
MOVS            R2, #5
MOVT            R0, #:upper16:i2c_mutex ; mutex
STRB.W          R5, [SP,#8+send_data]
STRB.W          R1, [SP,#8+send_data+1]
MOV             R4, SP
STRB.W          R2, [SP,#8+send_data+2]
STRB.W          R3, [SP,#8+send_data+3]
BLX             pthread_mutex_lock
MOV             R0, R5
ORR.W           R5, R6, R8,LSL#16
B               loc_24016

loc_24012
LDRB.W          R0, [R4,#1]!

loc_24016               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R4
BNE             loc_24012
MOV             R0, #0x186A0 ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R6, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
CMP             R6, #0x15
BNE             loc_24050
CMP             R4, #1
BEQ             loc_2406A

loc_24050
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8531 ; "enable_dsPIC33EP16GS202_dc_dc"
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #8
POP.W           {R4-R8,PC}

loc_2406A
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8531 ; "enable_dsPIC33EP16GS202_dc_dc"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
MOV             R0, R4
ADD             SP, SP, #8
POP.W           {R4-R8,PC}
; End of function enable_dsPIC33EP16GS202_dc_dc

off_2408C DCD __FUNCTION__.8531 ; "enable_dsPIC33EP16GS202_dc_dc"



; int __fastcall enable_dsPIC33EP16GS202_clamping_voltage(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 enable)
EXPORT enable_dsPIC33EP16GS202_clamping_voltage
enable_dsPIC33EP16GS202_clamping_voltage

send_data= -8
var_s0=  0

which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
enable = R2             ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOVS            R3, #0
SUB             SP, SP, #8
MOV             R8, which_chain
MOV             R6, which_i2c
MOV             R4, enable
STR             R3, [SP,#8+send_data]
STR.W           R3, [SP,#8+send_data+3]
CMP             enable, #0
BEQ             loc_2415A
MOVW            which_chain, #:lower16:aSOn ; "\n--- %s on\n"
which_chain = R8        ; unsigned int
LDR             which_i2c, =__FUNCTION__.8549 ; "enable_dsPIC33EP16GS202_clamping_voltag"...
MOVT            R0, #:upper16:aSOn ; "\n--- %s on\n"
BLX             printf

loc_240B6
ADD.W           R3, R4, #0x36 ; '6'
crc = R3                ; unsigned __int16
LSLS            R6, R6, #0x1A
LSRS            R2, crc, #8
MOVW            R0, #:lower16:i2c_mutex
ADD             R7, SP, #8+var_s0
UXTB.W          which_chain, which_chain
MOVS            R5, #0x55 ; 'U'
STRB.W          R2, [SP,#8+send_data+5]
MOVS            R1, #0xAA
STRB.W          crc, [R7,#-2]!
MOVS            R2, #5
MOVS            crc, #0x31 ; '1'
MOVT            R0, #:upper16:i2c_mutex ; mutex
ORR.W           R6, R6, #0x400000
STRB.W          R4, [SP,#8+send_data+4]
MOV             R4, SP
STRB.W          R5, [SP,#8+send_data]
STRB.W          R1, [SP,#8+send_data+1]
STRB.W          R2, [SP,#8+send_data+2]
STRB.W          R3, [SP,#8+send_data+3]
BLX             pthread_mutex_lock
MOV             R0, R5
ORR.W           R5, R6, R8,LSL#16
B               loc_24106

loc_24102
LDRB.W          R0, [R4,#1]!

loc_24106               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R7, R4
BNE             loc_24102
MOV             R0, #0x186A0 ; useconds
BLX             usleep
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R6, R0
MOV             R0, R5  ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
CMP             R6, #0x31 ; '1'
BNE             loc_24140
CMP             R4, #1
BEQ             loc_2416A

loc_24140
MOVW            R0, #:lower16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
MOV             R3, R4
MOV             R2, R6
LDR             R1, =__FUNCTION__.8549 ; "enable_dsPIC33EP16GS202_clamping_voltag"...
MOVT            R0, #:upper16:aSFailedReadBac ; "\n--- %s failed! read_back_data[0] = 0x"...
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #8
POP.W           {R4-R8,PC}

loc_2415A
which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
enable = R2             ; unsigned __int8
MOVW            which_chain, #:lower16:aSOff ; "\n--- %s off\n"
which_chain = R8        ; unsigned int
LDR             which_i2c, =__FUNCTION__.8549 ; "enable_dsPIC33EP16GS202_clamping_voltag"...
MOVT            R0, #:upper16:aSOff ; "\n--- %s off\n"
BLX             printf
B               loc_240B6

loc_2416A
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8549 ; "enable_dsPIC33EP16GS202_clamping_voltag"...
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
MOV             R0, R4
ADD             SP, SP, #8
POP.W           {R4-R8,PC}
; End of function enable_dsPIC33EP16GS202_clamping_voltage

off_2418C DCD __FUNCTION__.8549 ; "enable_dsPIC33EP16GS202_clamping_voltag"...



; int __fastcall heart_beat_dsPIC33EP16GS202(unsigned int which_chain, unsigned __int8 which_i2c)
EXPORT heart_beat_dsPIC33EP16GS202
heart_beat_dsPIC33EP16GS202

read_back_data= -0x14
var_E= -0xE
send_data= -0xC
var_4= -4

which_chain = R0        ; unsigned int
which_i2c = R1          ; unsigned __int8
PUSH.W          {R4-R9,LR}
MOV             R6, which_i2c
SUB             SP, SP, #0x14
MOVS            R5, #0xAA
MOV             R9, which_chain
MOVS            R3, #0
STRB.W          R5, [SP,#0x14+send_data+1]
LSLS            R5, R6, #0x1A
MOVW            which_chain, #:lower16:i2c_mutex
which_chain = R9        ; unsigned int
UXTB.W          which_chain, which_chain
STRH.W          R3, [SP,#0x14+send_data+4]
MOVS            R7, #0x55 ; 'U'
MOVS            which_i2c, #4
STR             R3, [SP,#0x14+read_back_data]
MOVS            R2, #0x16
STRH.W          R3, [SP,#0x14+read_back_data+4]
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOVS            R3, #0x1A
ADD.W           R8, SP, #0x14+var_4
ORR.W           R5, R5, #0x400000
STRB.W          R7, [SP,#0x14+send_data]
ADD             R4, SP, #0x14+send_data
STRB.W          R1, [SP,#0x14+send_data+2]
ORR.W           R5, R5, R9,LSL#16
STRB.W          R2, [SP,#0x14+send_data+3]
STRB.W          R3, [R8,#-3]!
BLX             pthread_mutex_lock
MOV             R0, R7
B               loc_241EC

loc_241E8
LDRB.W          R0, [R4,#1]!

loc_241EC               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R4, R8
BNE             loc_241E8
MOVW            R0, #:lower16:loc_186A0
MOV             R4, SP
MOVT            R0, #:upper16:loc_186A0 ; useconds
ADD.W           R6, SP, #0x14+var_E
BLX             usleep

loc_24208               ; config_data
MOV             R0, R5
BL              i2c_read
STRB.W          R0, [R4],#1
CMP             R6, R4
BNE             loc_24208
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
LDRB.W          R3, [SP,#0x14+read_back_data+1]
CMP             R3, #0x16
BNE             loc_24232
LDRB.W          R4, [SP,#0x14+read_back_data+2]
CMP             R4, #1
BEQ             loc_24248

loc_24232
MOVW            R0, #:lower16:aSFailed ; "\n--- %s failed!\n\n"
LDR             R1, =__FUNCTION__.8572 ; "heart_beat_dsPIC33EP16GS202"
MOVT            R0, #:upper16:aSFailed ; "\n--- %s failed!\n\n"
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x14
POP.W           {R4-R9,PC}

loc_24248
MOVW            R0, #:lower16:aSOk ; "\n--- %s ok\n\n"
LDR             R1, =__FUNCTION__.8572 ; "heart_beat_dsPIC33EP16GS202"
MOVT            R0, #:upper16:aSOk ; "\n--- %s ok\n\n"
BLX             printf
MOV             R0, R4
ADD             SP, SP, #0x14
POP.W           {R4-R9,PC}
; End of function heart_beat_dsPIC33EP16GS202

ALIGN 0x10
off_24260 DCD __FUNCTION__.8572 ; "heart_beat_dsPIC33EP16GS202"



; int __fastcall get_dsPIC33EP16GS202_software_version(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *version)
EXPORT get_dsPIC33EP16GS202_software_version
get_dsPIC33EP16GS202_software_version

read_back_data= -0x10
var_B= -0xB
send_data= -8
var_s0=  0

which_i2c = R0          ; unsigned int
which_chain = R1        ; unsigned __int8
version = R2            ; unsigned __int8 *
PUSH.W          {R4-R10,LR}
MOV             R6, which_chain
SUB             SP, SP, #0x20
MOVS            R5, #0xAA
MOVS            R3, #0
MOV             R10, which_i2c
STRB.W          R5, [SP,#0x20+send_data+1]
LSLS            R5, R6, #0x10
MOVW            which_i2c, #:lower16:i2c_mutex
which_i2c = R10         ; unsigned int
STR             R3, [SP,#0x20+read_back_data]
STRH.W          R3, [SP,#0x20+send_data+4]
MOV.W           LR, #0xFF
MOV.W           R9, #0x55 ; 'U'
STRB.W          R3, [SP,#0x20+read_back_data+4]
MOVS            which_chain, #4
MOVS            R3, #0x1B
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOV             R7, version
ADD.W           R8, SP, #0x20+var_s0
MOVS            version, #0x17
version = R7            ; unsigned __int8 *
ORR.W           R5, R5, #0x400000
STRB.W          LR, [SP,#0x20+read_back_data]
STRB.W          R9, [SP,#0x20+send_data]
ADD             R4, SP, #0x20+send_data
STRB.W          R1, [SP,#0x20+send_data+2]
ORR.W           R5, R5, which_i2c,LSL#26
STRB.W          R2, [SP,#0x20+send_data+3]
STRB.W          R3, [R8,#-3]!
BLX             pthread_mutex_lock
MOV             R0, R9
B               loc_242C8

loc_242C4
LDRB.W          R0, [R4,#1]!

loc_242C8               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R4, R8
BNE             loc_242C4
MOV.W           R0, #:lower16:gBM1397_MISC_CONTROL_reg
ADD             R4, SP, #0x20+read_back_data
MOVT            R0, #:upper16:gBM1397_MISC_CONTROL_reg ; useconds
ADD.W           R6, SP, #0x20+var_B
BLX             usleep

loc_242E4               ; config_data
MOV             R0, R5
BL              i2c_read
STRB.W          R0, [R4],#1
CMP             R4, R6
BNE             loc_242E4
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #gBM1397_MISC_CONTROL_reg ; useconds
BLX             usleep
LDRB.W          R5, [SP,#0x20+read_back_data]
MOVW            R0, #:lower16:aSReadBackData0_1 ; "--- %s: read_back_data[0] = 0x%x, read_"...
LDRB.W          R4, [SP,#0x20+read_back_data+1]
MOVT            R0, #:upper16:aSReadBackData0_1 ; "--- %s: read_back_data[0] = 0x%x, read_"...
LDRB.W          R6, [SP,#0x20+read_back_data+2]
LDRB.W          R8, [SP,#0x20+read_back_data+3]
MOV             R2, R5
LDRB.W          R9, [SP,#0x20+read_back_data+4]
MOV             R3, R4
LDR             R1, =__FUNCTION__.8590 ; "get_dsPIC33EP16GS202_software_version"
STMEA.W         SP, {R6,R8,R9}
BLX             printf
CMP             R4, #0x17
IT EQ
CMPEQ           R5, #5
BEQ             loc_24352
MOVW            R0, #:lower16:aSFailed ; "\n--- %s failed!\n\n"
LDR             R1, =__FUNCTION__.8590 ; "get_dsPIC33EP16GS202_software_version"
MOVT            R0, #:upper16:aSFailed ; "\n--- %s failed!\n\n"
BLX             printf
MOVS            R0, #0

loc_2434C
ADD             SP, SP, #0x20 ; ' '
POP.W           {R4-which_i2c,PC}

loc_24352
ADD.W           R2, R6, #0x1C
crc = R2                ; unsigned __int16
UBFX.W          R3, crc, #8, #8
CMP             R3, R8
BNE             loc_24364
UXTB            R3, crc
CMP             R9, R3
BEQ             loc_2437A

loc_24364
MOVW            R0, #:lower16:aSFailedCrc0x04 ; "\n--- %s failed! crc = 0x%04x\n\n"
LDR             R1, =__FUNCTION__.8590 ; "get_dsPIC33EP16GS202_software_version"
MOVT            R0, #:upper16:aSFailedCrc0x04 ; "\n--- %s failed! crc = 0x%04x\n\n"
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x20 ; ' '
POP.W           {R4-which_i2c,PC}

loc_2437A
crc = R2                ; unsigned __int16
MOVW            R0, #:lower16:aSOkVersion0x02 ; "\n--- %s ok, version = 0x%02x\n\n"
STRB            R6, [version]
MOV             crc, R6
MOVT            R0, #:upper16:aSOkVersion0x02 ; "\n--- %s ok, version = 0x%02x\n\n"
LDR             R1, =__FUNCTION__.8590 ; "get_dsPIC33EP16GS202_software_version"
BLX             printf
MOVS            R0, #1
B               loc_2434C
; End of function get_dsPIC33EP16GS202_software_version

off_24390 DCD __FUNCTION__.8590 ; "get_dsPIC33EP16GS202_software_version"



; int __fastcall dsPIC33EP16GS202_read_out_4_voltage(unsigned __int8 which_iic, unsigned __int8 which_chain, unsigned int *vol0, unsigned int *vol1, unsigned int *vol2, unsigned int *vol3)
EXPORT dsPIC33EP16GS202_read_out_4_voltage
dsPIC33EP16GS202_read_out_4_voltage

var_24= -0x24
var_20= -0x20
send_data= -0x1C
read_back_data= -0x14
var_7= -7
var_4= -4
vol2=  0x24
vol3=  0x28

which_iic = R0          ; unsigned __int8
which_chain = R1        ; unsigned __int8
vol0 = R2               ; unsigned int *
vol1 = R3               ; unsigned int *
PUSH.W          {R4-R11,LR}
MOV             R4, which_chain
SUB             SP, SP, #0x24
MOVS            R5, #4
MOV             R10, which_iic
MOVW            which_iic, #:lower16:i2c_mutex
STRB.W          R5, [SP,#0x24+send_data+2]
LSLS            R5, R4, #0x10
MOVS            which_chain, #0
MOV.W           R11, #0x55 ; 'U'
MOV.W           LR, #0xAA
MOVT            R0, #:upper16:i2c_mutex ; mutex
MOV             R7, vol0
MOV             R8, vol1
MOVS            vol0, #0x28 ; '('
vol0 = R7               ; unsigned int *
MOVS            vol1, #0x2C ; ','
vol1 = R8               ; unsigned int *
ADD.W           R9, SP, #0x24+var_4
ORR.W           R5, R5, #0x400000
STRH.W          R1, [SP,#0x24+send_data+4]
STR             R1, [SP,#0x24+read_back_data]
ADD             R6, SP, #0x24+send_data
STR             R1, [SP,#0x24+read_back_data+4]
ORR.W           R5, R5, R10,LSL#26
STR             R1, [SP,#0x24+read_back_data+8]
STRB.W          R1, [SP,#0x24+read_back_data+0xC]
STRB.W          R11, [SP,#0x24+send_data]
STRB.W          LR, [SP,#0x24+send_data+1]
STRB.W          R2, [SP,#0x24+send_data+3]
STRB.W          R3, [R9,#-0x13]!
BLX             pthread_mutex_lock
MOV             R0, R11
B               loc_243F8

loc_243F4
LDRB.W          R0, [R6,#1]!

loc_243F8               ; config_data
ORRS            R0, R5
BL              i2c_write
CMP             R6, R9
BNE             loc_243F4
MOVW            R0, #:lower16:(gAsic_Core_Nonce_Num+0x1859C)
ADD             R4, SP, #0x24+read_back_data
MOVT            R0, #:upper16:(gAsic_Core_Nonce_Num+0x1859C) ; useconds
ADD.W           R6, SP, #0x24+var_7
BLX             usleep

loc_24414               ; config_data
MOV             R0, R5
BL              i2c_read
STRB.W          R0, [R4],#1
CMP             R6, R4
BNE             loc_24414
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
MOV             R0, #gBM1397_MISC_CONTROL_reg ; useconds
BLX             usleep
LDRB.W          R3, [SP,#0x24+read_back_data+1]
CMP             R3, #0x28 ; '('
BNE             loc_2444A
LDRB.W          R4, [SP,#0x24+read_back_data+2]
CMP             R4, #1
BEQ             loc_24460

loc_2444A
MOVW            R0, #:lower16:aSFailed ; "\n--- %s failed!\n\n"
LDR             R1, =__FUNCTION__.8611 ; "dsPIC33EP16GS202_read_out_4_voltage"
MOVT            R0, #:upper16:aSFailed ; "\n--- %s failed!\n\n"
BLX             printf
MOVS            R0, #0
ADD             SP, SP, #0x24 ; '$'
POP.W           {R4-R11,PC}

loc_24460
LDRB.W          R6, [SP,#0x24+read_back_data+3]
MOVW            R0, #:lower16:aSAdc0DAdc1DAdc ; "\n--- %s ADC0 = %d, ADC1 = %d, ADC2 = %"...
LDRB.W          R5, [SP,#0x24+read_back_data+5]
MOVT            R0, #:upper16:aSAdc0DAdc1DAdc ; "\n--- %s ADC0 = %d, ADC1 = %d, ADC2 = %"...
LDRB.W          R1, [SP,#0x24+read_back_data+4]
LDRB.W          R2, [SP,#0x24+read_back_data+6]
LDRB.W          LR, [SP,#0x24+read_back_data+7]
LDRB.W          R3, [SP,#0x24+read_back_data+8]
ORR.W           R1, R1, R6,LSL#8
LDRB.W          R6, [SP,#0x24+read_back_data+9]
ORR.W           R2, R2, R5,LSL#8
LDRB.W          R5, [SP,#0x24+read_back_data+0xA]
STR             R1, [vol0]
STR.W           R2, [vol1]
ORR.W           R3, R3, LR,LSL#8
LDR             R2, [SP,#0x24+vol2]
ORR.W           R5, R5, R6,LSL#8
LDR             R6, [SP,#0x24+vol2]
LDR             R1, =__FUNCTION__.8611 ; "dsPIC33EP16GS202_read_out_4_voltage"
STR             R3, [R2]
LDR             R3, [SP,#0x24+vol3]
STR             R5, [R3]
LDR             R6, [R6]
LDR.W           R3, [vol1]
LDR             R2, [vol0]
STR             R5, [SP,#0x24+var_20]
STR             R6, [SP,#0x24+var_24]
BLX             printf
MOV             R0, R4
ADD             SP, SP, #0x24 ; '$'
POP.W           {R4-R11,PC}
; End of function dsPIC33EP16GS202_read_out_4_voltage

ALIGN 4
off_244C4 DCD __FUNCTION__.8611 ; "dsPIC33EP16GS202_read_out_4_voltage"


; Attributes: noreturn

; void *__fastcall __noreturn pic_heart_beat_func(void *arg)
EXPORT pic_heart_beat_func
pic_heart_beat_func
chain_info = R0         ; chain_info *
which_chain = R5        ; unsigned __int8
which_i2c = R4          ; unsigned __int8
PUSH.W          {R3-R11,LR}
MOVW            R6, #:lower16:gHashBoard_V9
MOVW            R7, #:lower16:gHashBoard_BHB91601P
MOVW            R8, #:lower16:gHashBoard_BHB91601S
MOVW            R9, #:lower16:gHashBoard_BHB07601
MOVW            R10, #:lower16:aSPleaseCheckHa ; "\n!!! %s Please check Hashboard type!\n"...
LDR.W           R11, =__FUNCTION__.8618 ; "pic_heart_beat_func"
MOVT            R6, #:upper16:gHashBoard_V9
LDRB            which_chain, [chain_info]
MOVT            R7, #:upper16:gHashBoard_BHB91601P
LDRB            which_i2c, [chain_info,#1]
MOVT            R8, #:upper16:gHashBoard_BHB91601S
MOVT            R9, #:upper16:gHashBoard_BHB07601
MOVT            R10, #:upper16:aSPleaseCheckHa ; "\n!!! %s Please check Hashboard type!\n"...
B               loc_24518

loc_244FE
LDRB            R3, [R7]
CBNZ            R3, loc_2450E
LDRB.W          R3, [R8]
CBNZ            R3, loc_2450E
LDRB.W          R3, [R9]
CBZ             R3, loc_24528

loc_2450E
BL              heart_beat_dsPIC33EP16GS202

loc_24512               ; seconds
MOVS            R0, #0xA
BLX             sleep

loc_24518
LDRB            R3, [R6]
MOV             R1, which_i2c ; which_i2c
MOV             R0, which_chain ; which_chain
CMP             R3, #0
BEQ             loc_244FE
BL              heart_beat_PIC16F1704
B               loc_24512

loc_24528
MOV             R1, R11
MOV             R0, R10 ; format
BLX             printf
B               loc_24512
; End of function pic_heart_beat_func

ALIGN 4
off_24534 DCD __FUNCTION__.8618 ; "pic_heart_beat_func"


; Attributes: noreturn

; void __fastcall __noreturn dsPIC33EP16GS202_test(unsigned __int8 which_chain, unsigned __int8 which_i2c)
EXPORT dsPIC33EP16GS202_test
dsPIC33EP16GS202_test
which_chain = R0        ; unsigned __int8
which_i2c = R1          ; unsigned __int8
MOV             R4, which_chain
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
PUSH            {R3,LR}
MOV             R5, which_i2c
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             which_i2c, =__FUNCTION__.8624 ; "dsPIC33EP16GS202_test"
BLX             printf
BL              power_on
MOV             R0, #(gAsic_Core_Nonce_Num+0x1B763C) ; useconds
BLX             usleep
MOVS            R0, #0x14 ; N
BL              power_set_voltage
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
MOV             R1, R5  ; which_i2c
MOV             R0, R4  ; which_chain
BL              reset_dsPIC33EP16GS202_pic
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
MOV             R1, R5  ; which_i2c
MOV             R0, R4  ; which_chain
BL              jump_from_loader_to_app_dsPIC33EP16GS202
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
MOV             R1, R5  ; which_i2c
MOV             R0, R4  ; which_chain
MOVS            R2, #1  ; enable
BL              enable_dsPIC33EP16GS202_dc_dc
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep

loc_245AC               ; which_i2c
MOV             R1, R5
MOV             R0, R4  ; which_chain
BL              heart_beat_dsPIC33EP16GS202
MOVS            R2, #1  ; enable
MOV             R1, R5  ; which_i2c
MOV             R0, R4  ; which_chain
BL              enable_dsPIC33EP16GS202_clamping_voltage
MOVS            R0, #0x32 ; '2' ; seconds
BLX             sleep
MOV             R1, R5  ; which_i2c
MOV             R0, R4  ; which_chain
BL              heart_beat_dsPIC33EP16GS202
MOVS            R2, #0  ; enable
MOV             R1, R5  ; which_i2c
MOV             R0, R4  ; which_chain
BL              enable_dsPIC33EP16GS202_clamping_voltage
MOVS            R0, #0x32 ; '2' ; seconds
BLX             sleep
B               loc_245AC
; End of function dsPIC33EP16GS202_test

ALIGN 0x10
off_245E0 DCD __FUNCTION__.8624 ; "dsPIC33EP16GS202_test"



; unsigned __int8 __fastcall read_temperature_from_fpga_register(unsigned __int8 which_chain)
EXPORT read_temperature_from_fpga_register
read_temperature_from_fpga_register
which_chain = R0        ; unsigned __int8
PUSH            {R4-R6,LR}
MOV             R5, which_chain
CMP             which_chain, #0xF ; switch 16 cases
BHI             def_245EC ; jumptable 000245EC default case
TBB.W           [PC,which_chain] ; switch jump
jpt_245EC DCB 0x50      ; jump table for switch statement
DCB 0x50
DCB 0x50
DCB 0x50
DCB 0x48
DCB 0x48
DCB 0x48
DCB 0x48
DCB 0x3F
DCB 0x3F
DCB 0x3F
DCB 0x3F
DCB 8
DCB 8
DCB 8
DCB 8

loc_24600               ; jumptable 000245EC cases 12-15
SUB.W           R4, R5, #0xC
MOVS            which_chain, #0xB ; address
LSLS            R4, R4, #3
BL              read_axi_fpga
temperature = R0        ; unsigned int
LSRS            temperature, R4
UXTB            R4, R0

loc_24610
ret = R4                ; unsigned __int8
MOVW            R1, #:lower16:__FUNCTION__.7971 ; "read_temperature_from_fpga_register"
MOVW            R0, #:lower16:aSChainDTempera ; "\n%s: Chain%d temperature is %d\n\n"
MOVT            R1, #:upper16:__FUNCTION__.7971 ; "read_temperature_from_fpga_register"
MOVT            R0, #:upper16:aSChainDTempera ; "\n%s: Chain%d temperature is %d\n\n"
MOV             R3, ret
MOV             R2, R5
MOV             R6, ret
BLX             printf
CBZ             ret, loc_2463A
MOVW            R3, #:lower16:gSensor_OK
MOVS            R2, #1
MOVT            R3, #:upper16:gSensor_OK
STRB.W          R2, [R3,R5,LSL#2]

loc_2463A
MOVW            R3, #:lower16:Conf
MOV             R0, R4
MOVT            R3, #:upper16:Conf
LDR.W           R2, [R3,#configuration.StartTemp]
LDR.W           R3, [R3,#configuration.AlarmTemp]
CMP             R2, R6
ITTTT LE
MOVWLE          R2, #:lower16:gStartTest
MOVLE           R1, #1
MOVTLE          R2, #:upper16:gStartTest
STRBLE          R1, [R2]
CMP             R3, R6
ITTTT LT
MOVWLT          R3, #:lower16:gHigherThanAlarmTemp
MOVLT           R2, #1
MOVTLT          R3, #:upper16:gHigherThanAlarmTemp
STRBLT          R2, [R3]
POP             {R4-R6,PC}

loc_2466E               ; jumptable 000245EC cases 8-11
which_chain = R0        ; unsigned __int8
SUB.W           R4, R5, #8
MOVS            which_chain, #0xA ; address
LSLS            R4, R4, #3
BL              read_axi_fpga
temperature = R0        ; unsigned int
LSRS            temperature, R4
UXTB            R4, R0
ret = R4                ; unsigned __int8
B               loc_24610

loc_24680               ; jumptable 000245EC cases 4-7
which_chain = R0        ; unsigned __int8
SUBS            R4, R5, #4
MOVS            which_chain, #9 ; address
LSLS            R4, R4, #3
BL              read_axi_fpga
temperature = R0        ; unsigned int
LSRS            temperature, R4
UXTB            R4, R0
ret = R4                ; unsigned __int8
B               loc_24610

loc_24690               ; jumptable 000245EC cases 0-3
which_chain = R0        ; unsigned __int8
LSLS            R4, R5, #3
MOVS            which_chain, #8 ; address
BL              read_axi_fpga
temperature = R0        ; unsigned int
LSRS            temperature, R4
UXTB            R4, R0
ret = R4                ; unsigned __int8
B               loc_24610

def_245EC               ; jumptable 000245EC default case
which_chain = R0        ; unsigned __int8
MOVW            R3, #:lower16:gChain
MOVW            R1, #:lower16:__FUNCTION__.7971 ; "read_temperature_from_fpga_register"
MOVT            R3, #:upper16:gChain
MOVW            which_chain, #:lower16:aSWhichChainDBu ; "%s: which_chain = %d, but it is wrong! "...
LDRB            R2, [R3]
MOVT            R1, #:upper16:__FUNCTION__.7971 ; "read_temperature_from_fpga_register"
MOVT            R0, #:upper16:aSWhichChainDBu ; "%s: which_chain = %d, but it is wrong! "...
MOVS            R6, #0
BLX             printf
MOVW            R1, #:lower16:__FUNCTION__.7971 ; "read_temperature_from_fpga_register"
MOVW            R0, #:lower16:aSChainDTempera ; "\n%s: Chain%d temperature is %d\n\n"
MOV             R2, R5
MOVT            R1, #:upper16:__FUNCTION__.7971 ; "read_temperature_from_fpga_register"
MOVT            R0, #:upper16:aSChainDTempera ; "\n%s: Chain%d temperature is %d\n\n"
MOV             R3, R6
BLX             printf
MOV             R4, R6
B               loc_2463A
; End of function read_temperature_from_fpga_register

ALIGN 4



; unsigned __int8 __fastcall read_temperature_through_fpga_iic_register(unsigned __int8 which_chain, unsigned int which_i2c)
EXPORT read_temperature_through_fpga_iic_register
read_temperature_through_fpga_iic_register
which_chain = R0        ; unsigned __int8
which_i2c = R1          ; unsigned int
PUSH            {R3-R7,LR}
MOV             R3, #gHashBoard_V9
MOVW            R5, #:lower16:Conf
MOV             R7, which_chain
MOVT            R5, #:upper16:Conf
LDRB            R4, [R3]
CBZ             R4, loc_24702
LDR.W           R3, [R5,#configuration.sensor_model]
CMP             R3, #1
ITE NE
MOVNE           R4, #0
MOVEQ.W         R4, #0x900000

loc_24702
LSLS            which_i2c, which_i2c, #0x1A
MOV             R0, #i2c_mutex ; mutex
ORR.W           R1, R1, #0x1000000
ORR.W           R1, R1, R7,LSL#16
ORRS            R4, R1
config_data = R4        ; unsigned int
BLX             pthread_mutex_lock
MOV             R0, config_data ; config_data
BL              i2c_read
MOV             R6, R0
ret = R6                ; unsigned __int8
MOV             R0, config_data ; config_data
BL              i2c_read
MOV             R0, #i2c_mutex ; mutex
BLX             pthread_mutex_unlock
CMP             ret, #0xFF
MOV             R0, ret
ITTTT EQ
MOVWEQ          R3, #:lower16:gSensor_OK
MOVEQ           R2, #0
MOVTEQ          R3, #:upper16:gSensor_OK
STRBEQ.W        R2, [R3,R7,LSL#2]
LDR.W           R3, [R5,#configuration.StartTemp]
CMP             ret, R3
ITTTT GE
MOVWGE          R3, #:lower16:gStartTest
MOVGE           R2, #1
MOVTGE          R3, #:upper16:gStartTest
STRBGE          R2, [R3]
LDR.W           R3, [R5,#configuration.AlarmTemp]
CMP             ret, R3
ITTTT GT
MOVWGT          R3, #:lower16:gHigherThanAlarmTemp
MOVGT           R2, #1
MOVTGT          R3, #:upper16:gHigherThanAlarmTemp
STRBGT          R2, [R3]
POP             {R3-R7,PC}
; End of function read_temperature_through_fpga_iic_register

ALIGN 4



; void __fastcall write_EEPROM_iic(bool reg_addr_valid, unsigned __int8 reg_addr, unsigned __int8 which_iic, unsigned __int8 which_chain, unsigned __int8 data)
EXPORT write_EEPROM_iic
write_EEPROM_iic

data=  4

reg_addr_valid = R0     ; bool
reg_addr = R1           ; unsigned __int8
which_iic = R2          ; unsigned __int8
which_chain = R3        ; unsigned __int8
PUSH            {R4}
LDRB.W          R4, [SP,#data]
CBZ             reg_addr_valid, loc_24782
LSLS            reg_addr_valid, reg_addr, #8
ORR.W           R0, R0, #0x1000000

loc_24782
ORR.W           R4, R4, #0xA00000
ORR.W           which_chain, R4, which_chain,LSL#16
POP.W           {R4}
ORR.W           which_iic, R3, which_iic,LSL#26
ORRS            R0, R2
B.W             i2c_write
; End of function write_EEPROM_iic




; unsigned __int8 __fastcall read_EEPROM_iic(bool reg_addr_valid, unsigned __int8 reg_addr, unsigned __int8 which_iic, unsigned __int8 which_chain)
EXPORT read_EEPROM_iic
read_EEPROM_iic
reg_addr_valid = R0     ; bool
reg_addr = R1           ; unsigned __int8
which_iic = R2          ; unsigned __int8
which_chain = R3        ; unsigned __int8
CBZ             reg_addr_valid, loc_247A0
LSLS            reg_addr_valid, reg_addr, #8
ORR.W           R0, R0, #0x1000000

loc_247A0
LSLS            which_chain, which_chain, #0x10
ORR.W           R3, R3, #0xA00000
ORR.W           which_iic, R3, which_iic,LSL#26
ORRS            R0, R2
B.W             i2c_read
; End of function read_EEPROM_iic




; void __fastcall AT24C02_write_one_byte(unsigned __int8 address, unsigned __int8 data, unsigned __int8 which_iic, unsigned __int8 which_chain)
EXPORT AT24C02_write_one_byte
AT24C02_write_one_byte
address = R0            ; unsigned __int8
data = R1               ; unsigned __int8
which_iic = R2          ; unsigned __int8
which_chain = R3        ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R5, #i2c_mutex
MOV             R4, data
MOV             R6, address
MOV             address, R5 ; mutex
MOV             R7, which_iic
MOV             R8, which_chain
BLX             pthread_mutex_lock
ORR.W           R0, R4, #0x1A00000
ORR.W           R0, R0, R8,LSL#16
ORR.W           R0, R0, R7,LSL#26
ORR.W           R0, R0, R6,LSL#8 ; config_data
BL              i2c_write
MOV             R0, R5  ; mutex
POP.W           {R4-R8,LR}
B.W             j_pthread_mutex_unlock
; End of function AT24C02_write_one_byte




; unsigned __int8 __fastcall AT24C02_read_one_byte(unsigned __int8 address, unsigned __int8 which_iic, unsigned __int8 which_chain)
EXPORT AT24C02_read_one_byte
AT24C02_read_one_byte
address = R0            ; unsigned __int8
which_iic = R1          ; unsigned __int8
which_chain = R2        ; unsigned __int8
PUSH            {R3-R7,LR}
MOV             R5, #i2c_mutex
MOV             R4, which_chain
MOV             R6, address
MOV             address, R5 ; mutex
MOV             R7, which_iic
BLX             pthread_mutex_lock
LSLS            R0, R4, #0x10
ORR.W           R0, R0, #0x1A00000
ORR.W           R0, R0, R7,LSL#26
ORR.W           R0, R0, R6,LSL#8 ; config_data
BL              i2c_read
MOV             R4, R0
MOV             R0, R5  ; mutex
BLX             pthread_mutex_unlock
MOV             R0, R4
POP             {R3-R7,PC}
; End of function AT24C02_read_one_byte




; void __fastcall AT24C02_write_bytes(unsigned __int8 address, unsigned __int8 *buf, unsigned __int8 which_iic, unsigned __int8 which_chain, unsigned int length)
EXPORT AT24C02_write_bytes
AT24C02_write_bytes

length=  0x18

address = R0            ; unsigned __int8
buf = R1                ; unsigned __int8 *
which_iic = R2          ; unsigned __int8
which_chain = R3        ; unsigned __int8
PUSH.W          {R4-R8,LR}
LDR.W           R8, [SP,#length]
ADD.W           R4, address, R8
CMP.W           R4, #0x100
BHI             loc_2485A
CMP.W           R8, #0
BEQ             locret_24878
MOV             R7, which_chain
MOV             R6, which_iic
MOV             R5, buf
MOV             R4, address
ADD             R8, buf

loc_2483E               ; data
LDRB.W          R1, [R5],#1
MOV             R0, R4  ; address
MOV             R3, R7  ; which_chain
MOV             R2, R6  ; which_iic
BL              AT24C02_write_one_byte
CMP             R5, R8
ADD.W           R4, R4, #1
UXTB            R4, R4
BNE             loc_2483E
POP.W           {R4-R8,PC}

loc_2485A
address = R0            ; unsigned __int8
buf = R1                ; unsigned __int8 *
which_iic = R2          ; unsigned __int8
which_chain = R3        ; unsigned __int8
MOVW            buf, #:lower16:__FUNCTION__.7777 ; "AT24C02_write_bytes"
MOVW            address, #:lower16:aSAddressLength ; "\n--- %s: address + length = %d > EEPRO"...
MOV             which_iic, R4
MOVT            R1, #:upper16:__FUNCTION__.7777 ; "AT24C02_write_bytes"
MOVT            R0, #:upper16:aSAddressLength ; "\n--- %s: address + length = %d > EEPRO"...
MOV.W           which_chain, #0x100
POP.W           {R4-R8,LR}
B.W             j_printf

locret_24878
address = R0            ; unsigned __int8
buf = R1                ; unsigned __int8 *
which_iic = R2          ; unsigned __int8
which_chain = R3        ; unsigned __int8
POP.W           {R4-R8,PC}
; End of function AT24C02_write_bytes




; void __fastcall AT24C02_read_bytes(unsigned __int8 address, unsigned __int8 *buf, unsigned __int8 which_iic, unsigned __int8 which_chain, unsigned int length)
EXPORT AT24C02_read_bytes
AT24C02_read_bytes

length=  0x18

address = R0            ; unsigned __int8
buf = R1                ; unsigned __int8 *
which_iic = R2          ; unsigned __int8
which_chain = R3        ; unsigned __int8
PUSH.W          {R4-R8,LR}
LDR.W           R8, [SP,#length]
ADD.W           R4, address, R8
CMP.W           R4, #0x100
BHI             loc_248B8
CMP.W           R8, #0
BEQ             locret_248D0
MOV             R7, which_chain
MOV             R6, which_iic
MOV             R5, buf
MOV             R4, address
ADD             R8, buf

loc_2489E               ; address
MOV             R0, R4
MOV             R2, R7  ; which_chain
MOV             R1, R6  ; which_iic
ADDS            R4, #1
BL              AT24C02_read_one_byte
STRB.W          R0, [R5],#1
CMP             R5, R8
UXTB            R4, R4
BNE             loc_2489E
POP.W           {R4-R8,PC}

loc_248B8
address = R0            ; unsigned __int8
buf = R1                ; unsigned __int8 *
which_iic = R2          ; unsigned __int8
which_chain = R3        ; unsigned __int8
MOVW            address, #:lower16:aSAddressLength ; "\n--- %s: address + length = %d > EEPRO"...
MOV             which_iic, R4
MOVT            R0, #:upper16:aSAddressLength ; "\n--- %s: address + length = %d > EEPRO"...
MOV.W           which_chain, #0x100
LDR             buf, =__FUNCTION__.7789 ; "AT24C02_read_bytes"
POP.W           {R4-R8,LR}
B.W             j_printf

locret_248D0
address = R0            ; unsigned __int8
buf = R1                ; unsigned __int8 *
which_iic = R2          ; unsigned __int8
which_chain = R3        ; unsigned __int8
POP.W           {R4-R8,PC}
; End of function AT24C02_read_bytes

off_248D4 DCD __FUNCTION__.7789 ; "AT24C02_read_bytes"


; Attributes: bp-based frame fpd=0x104

; int Test_EEPROM()
EXPORT Test_EEPROM
Test_EEPROM

length= -0x10C
var_105= -0x105
buf1= -0x104
var_4= -4

PUSH.W          {R4-R9,LR}
SUB             SP, SP, #0x10C
ADD             R7, SP, #8
MOVS            R1, #0  ; c
MOV.W           R2, #0x100 ; n
MOV             R0, R7  ; s
BLX             memset
ADD             R1, SP, #0x10C+var_4
MOV             R3, R7

loc_248F0
SUBS            R2, R3, R7
STRB.W          R2, [R3],#1
CMP             R3, R1
BNE             loc_248F0
MOVW            R9, #:lower16:gChain
MOVW            R8, #:lower16:gI2c
MOV.W           R0, #0x100
MOVT            R9, #:upper16:gChain
MOVT            R8, #:upper16:gI2c
LDRB.W          R3, [R9] ; which_chain
LDRB.W          R2, [R8] ; which_iic
MOV             R1, R7  ; buf
STR             R0, [SP,#0x10C+length] ; length
ADD.W           R4, SP, #0x10C+var_105
MOVS            R0, #0  ; address
ADDW            R6, SP, #0x10C+buf1+0xFF
BL              AT24C02_write_bytes
MOV             R3, R4
MOVS            R2, #0

loc_2492C
STRB.W          R2, [R3,#1]!
CMP             R3, R6
BNE             loc_2492C
MOV.W           R0, #0x100
LDRB.W          R3, [R9] ; which_chain
STR             R0, [SP,#0x10C+length] ; length
MOVS            R0, #0  ; address
LDRB.W          R2, [R8] ; which_iic
MOV             R5, R0
MOV             R1, R7  ; buf
BL              AT24C02_read_bytes
MOV             R3, R5
MOV             R2, R4

loc_24950
i = R3                  ; unsigned int
ret = R5                ; unsigned __int8
LDRB.W          R1, [R2,#1]!
CMP             R1, i
IT NE
MOVNE           ret, #1
ADDS            i, #1
CMP.W           i, #0x100
BNE             loc_24950
MOVS            i, #0xFF

loc_24964
STRB.W          R3, [R4,#1]!
CMP             R4, R6
BNE             loc_24964
MOV.W           R0, #0x100
LDRB.W          R3, [R9] ; which_chain
STR             R0, [SP,#0x10C+length] ; length
MOV             R1, R7  ; buf
LDRB.W          R2, [R8] ; which_iic
MOVS            R0, #0  ; address
BL              AT24C02_write_bytes
MOV             R0, ret
ADD             SP, SP, #0x10C
POP.W           {R4-R9,PC}
; End of function Test_EEPROM

ALIGN 4



; int Test_EEPROM_part_area()
EXPORT Test_EEPROM_part_area
Test_EEPROM_part_area

length= -0x14
var_D= -0xD
buf1= -0xC

PUSH            {R4-R7,LR}
SUB             SP, SP, #0x14
MOVS            R2, #0
ADD.W           R5, SP, #0x14+var_D
MOV             R4, R2
MOV             R3, R5
STR             R2, [SP,#0x14+buf1]
STR             R2, [SP,#0x14+buf1+4]

loc_2499E
i = R4                  ; unsigned int
STRB.W          i, [R3,#1]!
ADDS            i, #1
CMP             i, #8
BNE             loc_2499E
MOVW            R0, #:lower16:(aSCanTFindHashb+0x38) ; "\n"
MOVW            R7, #:lower16:gChain
MOVT            R0, #:upper16:(aSCanTFindHashb+0x38) ; s
MOVT            R7, #:upper16:gChain
BLX             puts
MOVS            R2, #0  ; which_iic
LDRB            R3, [R7] ; which_chain
MOV             R0, R2  ; address
STR             i, [SP,#0x14+length] ; length
ADD             R1, SP, #0x14+buf1 ; buf
ADD.W           R6, SP, #0x14+buf1+7
BL              AT24C02_write_bytes
MOV             R3, R5
MOVS            R2, #0

loc_249D2
STRB.W          R2, [R3,#1]!
CMP             R3, R6
BNE             loc_249D2
MOVW            R0, #:lower16:(aSCanTFindHashb+0x38) ; "\n"
MOVS            R4, #0
MOVT            R0, #:upper16:(aSCanTFindHashb+0x38) ; s
BLX             puts
MOVS            R1, #8
LDRB            R3, [R7] ; which_chain
MOV             R2, R4  ; which_iic
STR             R1, [SP,#0x14+length] ; length
MOV             R0, R4  ; address
ADD             R1, SP  ; buf
BL              AT24C02_read_bytes
MOV             R3, R4
MOV             R2, R5

loc_249FC
i = R3                  ; unsigned int
ret = R4                ; unsigned __int8
LDRB.W          R1, [R2,#1]!
CMP             R1, i
IT NE
MOVNE           ret, #1
ADDS            i, #1
CMP             i, #8
BNE             loc_249FC
MOVS            i, #0xFF

loc_24A0E
STRB.W          R3, [R5,#1]!
CMP             R5, R6
BNE             loc_24A0E
MOV             R0, #(aSCanTFindHashb+0x38) ; s
BLX             puts
MOVS            R0, #8
MOVS            R2, #0  ; which_iic
LDRB            R3, [R7] ; which_chain
ADD.W           R1, SP, R0 ; buf
STR             R0, [SP,#0x14+length] ; length
MOV             R0, R2  ; address
BL              AT24C02_write_bytes
MOV             R0, ret
ADD             SP, SP, #0x14
POP             {ret-R7,PC}
; End of function Test_EEPROM_part_area

ALIGN 4



; void __fastcall AT24C02_save_offset_value(unsigned __int8 which_iic, unsigned __int8 which_chain, unsigned __int8 *offset_value)
EXPORT AT24C02_save_offset_value
AT24C02_save_offset_value

length= -0xC

which_iic = R0          ; unsigned __int8
which_chain = R1        ; unsigned __int8
offset_value = R2       ; unsigned __int8 *
PUSH.W          {R4-R9,LR}
MOV             R4, which_iic
LDR.W           R8, =__FUNCTION__.7835 ; "AT24C02_save_offset_value"
MOVW            which_iic, #:lower16:aS ; "\n--- %s\n"
MOV             R5, offset_value
SUB             SP, SP, #0xC
MOV             R9, which_chain
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
MOV             which_chain, R8
MOVW            R6, #:lower16:aSOffsetValueDD ; "%s: offset_value[%d] = %d\n"
BLX             printf
MOVT            R6, #:upper16:aSOffsetValueDD ; "%s: offset_value[%d] = %d\n"
MOVS            R0, #8
MOV             R2, R4  ; which_iic
MOV             R4, offset_value
STR             R0, [SP,#0xC+length] ; length
ADDS            R7, offset_value, R0
MOV             R3, R9  ; which_chain
MOV             R1, offset_value ; buf
MOVS            R0, #0x98 ; address
BL              AT24C02_write_bytes

loc_24A76
SUBS            R2, R4, offset_value
LDRB.W          R3, [R4],#1
MOV             R1, R8
MOV             R0, R6  ; format
BLX             printf
CMP             R4, R7
BNE             loc_24A76
ADD             SP, SP, #0xC
POP.W           {R4-R9,PC}
; End of function AT24C02_save_offset_value

ALIGN 0x10
off_24A90 DCD __FUNCTION__.7835 ; "AT24C02_save_offset_value"



; void __fastcall AT24C02_save_voltage(unsigned __int8 which_iic, unsigned __int8 which_chain, unsigned int voltage)
EXPORT AT24C02_save_voltage
AT24C02_save_voltage
which_iic = R0          ; unsigned __int8
which_chain = R1        ; unsigned __int8
voltage = R2            ; unsigned int
PUSH            {R3-R7,LR}
MOV             R6, which_iic
LDR             R5, =__FUNCTION__.7844 ; "AT24C02_save_voltage"
MOVW            which_iic, #:lower16:aS ; "\n--- %s\n"
MOV             R4, voltage
MOV             R7, which_chain
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
MOV             which_chain, R5
BLX             printf
MOV             R3, R7  ; which_chain
MOV             R2, R6  ; which_iic
UXTB            R1, voltage ; data
MOVS            R0, #0x90 ; address
BL              AT24C02_write_one_byte
MOV             R2, R6  ; which_iic
UBFX.W          R1, voltage, #8, #8 ; data
MOV             R3, R7  ; which_chain
MOVS            R0, #0x91 ; address
BL              AT24C02_write_one_byte
MOVW            R0, #:lower16:aSVoltage0x02x ; "%s: voltage = 0x%02x\n"
MOV             R2, voltage
MOV             R1, R5
MOVT            R0, #:upper16:aSVoltage0x02x ; "%s: voltage = 0x%02x\n"
POP.W           {R3-R7,LR}
voltage = R2            ; unsigned int
B.W             j_printf
; End of function AT24C02_save_voltage

ALIGN 4
off_24ADC DCD __FUNCTION__.7844 ; "AT24C02_save_voltage"



; unsigned __int8 __fastcall c2hex(unsigned __int8 value)
EXPORT c2hex
c2hex
value = R0              ; unsigned __int8
PUSH            {R3,LR}
SUB.W           R3, value, #0x30 ; '0'
CMP             R3, #9
BLS             loc_24AFE
AND.W           R3, value, #0xDF
CMP             R3, #0x41 ; 'A'
BNE             loc_24AF6
MOVS            value, #0xA
POP             {R3,PC}

loc_24AF6
value = R0              ; unsigned __int8
CMP             R3, #0x42 ; 'B'
BNE             loc_24B04
MOVS            value, #0xB
POP             {R3,PC}

loc_24AFE
value = R0              ; unsigned __int8
AND.W           value, value, #0xF
ret = R0                ; unsigned __int8
POP             {R3,PC}

loc_24B04
value = R0              ; unsigned __int8
CMP             R3, #0x43 ; 'C'
BNE             loc_24B0C
MOVS            value, #0xC
POP             {R3,PC}

loc_24B0C
value = R0              ; unsigned __int8
CMP             R3, #0x44 ; 'D'
BNE             loc_24B14
MOVS            value, #0xD
POP             {R3,PC}

loc_24B14
value = R0              ; unsigned __int8
CMP             R3, #0x45 ; 'E'
BNE             loc_24B1C
MOVS            value, #0xE
POP             {R3,PC}

loc_24B1C
value = R0              ; unsigned __int8
CMP             R3, #0x46 ; 'F'
BNE             loc_24B24
MOVS            value, #0xF
ret = R0                ; unsigned __int8
POP             {R3,PC}

loc_24B24
value = R0              ; unsigned __int8
MOV             R1, value
MOV             R0, #aInputValueErro ; "input value error: %c\n"
BLX             printf
MOVS            R0, #0xFF
POP             {R3,PC}
; End of function c2hex

ALIGN 4



; unsigned __int8 __fastcall twoc2hex(unsigned __int8 high, unsigned __int8 low)
EXPORT twoc2hex
twoc2hex
high = R0               ; unsigned __int8
low = R1                ; unsigned __int8
PUSH            {R3-R5,LR}
MOV             R5, low
BL              c2hex
MOV             R4, R0
high = R4               ; unsigned __int8
MOV             R0, R5  ; value
LSLS            high, high, #4
UXTB            R4, R4
BL              c2hex
low = R0                ; unsigned __int8
EORS            low, R4
UXTB            R0, R0
POP             {R3-R5,PC}
; End of function twoc2hex

ALIGN 4



; int __fastcall s2hex(unsigned __int8 *dst, const unsigned __int8 *src, int inlen)
EXPORT s2hex
s2hex

dst= -8

dst_0 = R0              ; unsigned __int8 *
src = R1                ; const unsigned __int8 *
inlen = R2              ; int
CMP             dst_0, #0
IT NE
CMPNE           inlen, #0
PUSH.W          {R4-R11,LR}
ITE LE
MOVLE           R4, #1
MOVGT           R4, #0
CMP             src, #0
IT EQ
ORREQ.W         R4, R4, #1
SUB             SP, SP, #0xC
STR             dst_0, [SP,#0xC+dst]
MOV             R9, src
CBNZ            R4, loc_24BDC
ASRS            R7, inlen, #1
len = R7                ; int
AND.W           R8, inlen, #1
p = R8                  ; int
BEQ             loc_24BA8
LDR             R3, [SP,#0xC+dst]
ADD.W           R6, src, len,LSL#1
MOV             R4, src
ADD.W           R11, R3, #0xFFFFFFFF

loc_24B88
src = R9                ; const unsigned __int8 *
LDRB.W          R10, [R4,#1]
low = R10               ; unsigned __int8
LDRB.W          R0, [R4],#2 ; value
BL              c2hex
MOV             R5, R0
MOV             R0, low ; value
BL              c2hex
CMP             R4, R6
EOR.W           R0, R0, R5,LSL#4
STRB.W          R0, [R11,#1]!
BNE             loc_24B88

loc_24BA8
CMP.W           p, #0
BNE             loc_24BB8

loc_24BAE
ADD.W           R0, len, p

loc_24BB2
ADD             SP, SP, #0xC
POP.W           {R4-R11,PC}

loc_24BB8               ; value
len = R7                ; int
p = R8                  ; int
LDRB.W          R0, [src,len,LSL#1]
BL              c2hex
MOV             R4, R0
MOV             R0, #aInputValueErro ; "input value error: %c\n"
MOVS            R1, #0
BLX             printf
LSLS            R3, R4, #4
LDR             R2, [SP,#0xC+dst]
UXTB            R3, R3
MVNS            R3, R3
STRB            R3, [R2,len]
B               loc_24BAE

loc_24BDC
dst_0 = R0              ; unsigned __int8 *
src = R1                ; const unsigned __int8 *
inlen = R2              ; int
MOVW            dst_0, #:lower16:aS2hexParaError ; "s2hex para error dst(%p), src(%p), inle"...
MOV             R3, inlen
MOVT            R0, #:upper16:aS2hexParaError ; "s2hex para error dst(%p), src(%p), inle"...
MOV             inlen, src
inlen = R3              ; int
LDR             src, [SP,#0xC+dst]
src = R9                ; const unsigned __int8 *
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_24BB2
; End of function s2hex




; void print_works()
EXPORT print_works
print_works

which_asic= -0x30
OpenCoreNum1= -0x2C
OpenCoreNum2= -0x28
OpenCoreNum3= -0x24
OpenCoreNum4= -0x20
OpenCoreNum5= -0x1C
OpenCoreNum6= -0x18
OpenCoreNum7= -0x14
OpenCoreNum8= -0x10
format= -0xC
var_8= -8

PUSH.W          {R4-R11,LR}
MOV             R11, #Conf
SUB             SP, SP, #0x34
MOVW            R1, #:lower16:__FUNCTION__.8187 ; "print_works"
MOVW            R0, #:lower16:aSBegin ; "\n--- %s begin\n\n"
LDR.W           R3, [R11,#configuration.OpenCoreNum1]
MOVT            R1, #:upper16:__FUNCTION__.8187 ; "print_works"
MOVT            R0, #:upper16:aSBegin ; "\n--- %s begin\n\n"
STR             R3, [SP,#0x34+OpenCoreNum1]
OpenCoreNum1_0 = R3     ; unsigned int
LDR.W           OpenCoreNum1_0, [R11,#configuration.OpenCoreNum2]
STR             R3, [SP,#0x34+OpenCoreNum2]
OpenCoreNum2_0 = R3     ; unsigned int
LDR.W           OpenCoreNum2_0, [R11,#configuration.OpenCoreNum3]
STR             R3, [SP,#0x34+OpenCoreNum3]
OpenCoreNum3_0 = R3     ; unsigned int
LDR.W           OpenCoreNum3_0, [R11,#configuration.OpenCoreNum4]
STR             R3, [SP,#0x34+OpenCoreNum4]
OpenCoreNum4_0 = R3     ; unsigned int
LDR.W           OpenCoreNum4_0, [R11,#configuration.OpenCoreNum5]
STR             R3, [SP,#0x34+OpenCoreNum5]
OpenCoreNum5_0 = R3     ; unsigned int
LDR.W           OpenCoreNum5_0, [R11,#configuration.OpenCoreNum6]
STR             R3, [SP,#0x34+OpenCoreNum6]
OpenCoreNum6_0 = R3     ; unsigned int
LDR.W           OpenCoreNum6_0, [R11,#configuration.OpenCoreNum7]
STR             R3, [SP,#0x34+OpenCoreNum7]
OpenCoreNum7_0 = R3     ; unsigned int
LDR.W           OpenCoreNum7_0, [R11,#configuration.OpenCoreNum8]
STR             R3, [SP,#0x34+OpenCoreNum8]
OpenCoreNum8_0 = R3     ; unsigned int
BLX             printf
LDR.W           R3, [R11,#configuration.AsicNum]
CMP             R3, #1
BEQ             loc_24D40
CMP             R3, #0
BEQ             loc_24D22
LDR             R3, =(cgpu.workdataFilePrefix+0x3C)
MOVW            R5, #:lower16:a02x_0 ; "%02x"
MOVW            R2, #:lower16:aData2 ; " data2="
MOVW            R1, #:lower16:aNonce0x08x ; " nonce=0x%08x\n"
MOVT            R5, #:upper16:a02x_0 ; "%02x"
MOVT            R2, #:upper16:aData2 ; " data2="
STR             R3, [SP,#0x34+OpenCoreNum5]
MOV             R3, #aAsic02d02d02dM ; "asic[%02d][%02d][%02d].midstate=0x"
MOVT            R1, #:upper16:aNonce0x08x ; " nonce=0x%08x\n"
STR             R3, [SP,#0x34+OpenCoreNum2]
MOVS            R3, #0
STR             R2, [SP,#0x34+OpenCoreNum3]
STR             R1, [SP,#0x34+OpenCoreNum4]
STR             R3, [SP,#0x34+which_asic]

loc_24C80
LDR             R2, [SP,#0x34+OpenCoreNum5]
MOV.W           R10, #0
LDR.W           R3, [R11,#configuration.CoreNum]
MOV             R1, R2
LDR.W           R2, [R1,#4]!
STR             R2, [SP,#0x34+OpenCoreNum1]
STR             R1, [SP,#0x34+OpenCoreNum5]
works_0 = R2            ; work *
CBZ             R3, loc_24D0C

loc_24C96
which_core = R10        ; unsigned int
LDR.W           R3, [R11,#configuration.pattern_number]
MOV.W           R9, #0
CBZ             R3, loc_24D00

loc_24CA0
which_pattern = R9      ; unsigned int
MLA             R8, R3, which_core, which_pattern
LDR             R4, [SP,#0x34+OpenCoreNum1]
LDR             R1, [SP,#0x34+which_asic]
MOV             R3, which_pattern
LDR             R0, [SP,#0x34+OpenCoreNum2] ; format
MOV             R2, which_core
ADD.W           R8, R8, R8,LSL#4
ADD.W           R8, R4, R8,LSL#2
work = R8               ; work *
ADD.W           R7, work, #0x13
ADD.W           R6, work, #0x33 ; '3'
MOV             R4, R7
BLX             printf

loc_24CC4
LDRB.W          R1, [R4,#1]!
MOV             R0, R5  ; format
BLX             printf
CMP             R4, R6
BNE             loc_24CC4
LDR             R0, [SP,#0x34+OpenCoreNum3] ; format
ADD.W           R4, work, #7
BLX             printf

loc_24CDC
LDRB.W          R1, [R4,#1]!
MOV             R0, R5  ; format
BLX             printf
CMP             R7, R4
BNE             loc_24CDC
LDR.W           R1, [work,#4]
ADD.W           which_pattern, which_pattern, #1
LDR             R0, [SP,#0x34+OpenCoreNum4] ; format
BLX             printf
which_pattern = R9      ; unsigned int
LDR.W           R3, [R11,#configuration.pattern_number]
CMP             R3, which_pattern
BHI             loc_24CA0

loc_24D00
LDR.W           R3, [R11,#configuration.CoreNum]
ADD.W           which_core, which_core, #1
CMP             R3, which_core
BHI             loc_24C96

loc_24D0C
LDR             R3, [SP,#0x34+which_asic]
MOVS            R0, #0xA ; c
ADDS            R3, #1
MOV             R4, R3
STR             R3, [SP,#0x34+which_asic]
BLX             putchar
which_asic_0 = R4       ; unsigned int
LDR.W           R3, [R11,#configuration.AsicNum]
CMP             R3, which_asic_0
BHI             loc_24C80

loc_24D22
MOVW            R1, #:lower16:__FUNCTION__.8187 ; "print_works"
MOVW            R0, #:lower16:aSEnd ; "\n--- %s end\n\n"
MOVT            R1, #:upper16:__FUNCTION__.8187 ; "print_works"
MOVT            R0, #:upper16:aSEnd ; "\n--- %s end\n\n"
ADD             SP, SP, #0x34 ; '4'
POP.W           {R4-R11,LR}
B.W             j_printf
off_24D3C DCD cgpu.workdataFilePrefix+0x3C

loc_24D40
MOVS            R3, #0
MOVW            R4, #:lower16:a02x_0 ; "%02x"
MOVW            R10, #:lower16:cgpu
MOVW            R2, #:lower16:aCore02d02dMids ; "core[%02d][%02d].midstate=0x"
MOV             R8, R3
MOVT            R4, #:upper16:a02x_0 ; "%02x"
MOVT            R10, #:upper16:cgpu
MOVT            R2, #:upper16:aCore02d02dMids ; "core[%02d][%02d].midstate=0x"
STR             R3, [SP,#0x34+which_asic]
STR             R2, [SP,#0x34+format]
STR.W           R10, [SP,#0x34+var_8]

loc_24D64
which_core = R8         ; unsigned int
LDR             R3, [SP,#0x34+OpenCoreNum1]
LSLS            R3, R3, #0x1F
BPL             loc_24DEA
LDR             R3, [SP,#0x34+which_asic]
MOVW            R9, #:lower16:aData2 ; " data2="
LDR             R1, [SP,#0x34+var_8]
MOVT            R9, #:upper16:aData2 ; " data2="
LDR.W           R2, [R11,#configuration.pattern_number]
MOVS            R7, #0
ADD.W           R3, R3, #0x20000
ADDS            R3, #0x2A ; '*'
ADD.W           R3, R1, R3,LSL#2
LDR             R5, [R3,#4]
works_0 = R5            ; work *
ADDS            works_0, #0x13
CBZ             R2, loc_24DDE

loc_24D8C
which_pattern = R7      ; unsigned int
ADD.W           R10, R5, #0x20 ; ' '
MOV             R6, R5
MOV             R2, which_pattern
MOV             R1, which_core
LDR             R0, [SP,#0x34+format] ; format
BLX             printf

loc_24D9C
LDRB.W          R1, [R6,#1]!
MOV             R0, R4  ; format
BLX             printf
CMP             R6, R10
BNE             loc_24D9C
MOV             R0, R9  ; format
SUB.W           R6, R5, #0xC
BLX             printf

loc_24DB4
LDRB.W          R1, [R6,#1]!
MOV             R0, R4  ; format
BLX             printf
CMP             R6, R5
BNE             loc_24DB4
MOVW            R0, #:lower16:aNonce0x08x ; " nonce=0x%08x\n"
LDR.W           R1, [R5,#-0xF]
MOVT            R0, #:upper16:aNonce0x08x ; " nonce=0x%08x\n"
ADDS            which_pattern, #1
BLX             printf
which_pattern = R7      ; unsigned int
LDR.W           R3, [R11,#configuration.pattern_number]
ADDS            R5, #0x44 ; 'D'
CMP             R3, which_pattern
BHI             loc_24D8C

loc_24DDE
LDR             R3, [SP,#0x34+which_asic]
MOVS            R0, #0xA ; c
ADDS            R3, #1
STR             R3, [SP,#0x34+which_asic]
BLX             putchar

loc_24DEA
LDR             R3, [SP,#0x34+OpenCoreNum1]
ADD.W           which_core, which_core, #1
CMP.W           R8, #0x20 ; ' '
MOV.W           R3, R3,LSR#1
STR             R3, [SP,#0x34+OpenCoreNum1]
n = R8                  ; int
OpenCoreNum1_0 = R3     ; unsigned int
BNE             loc_24D64
MOVW            R4, #:lower16:a02x_0 ; "%02x"
MOVW            OpenCoreNum1_0, #:lower16:cgpu
MOVW            R10, #:lower16:aCore02d02dMids ; "core[%02d][%02d].midstate=0x"
MOVT            R4, #:upper16:a02x_0 ; "%02x"
MOVT            R3, #:upper16:cgpu
MOVT            R10, #:upper16:aCore02d02dMids ; "core[%02d][%02d].midstate=0x"
STR             R3, [SP,#0x34+OpenCoreNum1]
STR.W           R10, [SP,#0x34+format]

loc_24E1A
which_core = R8         ; unsigned int
LDR             R3, [SP,#0x34+OpenCoreNum2]
LSLS            R7, R3, #0x1F
BPL             loc_24EA0
LDR             R3, [SP,#0x34+which_asic]
MOVW            R9, #:lower16:aData2 ; " data2="
LDR             R1, [SP,#0x34+OpenCoreNum1]
MOVT            R9, #:upper16:aData2 ; " data2="
LDR.W           R2, [R11,#configuration.pattern_number]
MOVS            R7, #0
ADD.W           R3, R3, #0x20000
ADDS            R3, #0x2A ; '*'
ADD.W           R3, R1, R3,LSL#2
LDR             R5, [R3,#4]
works_0 = R5            ; work *
ADDS            works_0, #0x13
CBZ             R2, loc_24E94

loc_24E42
which_pattern = R7      ; unsigned int
ADD.W           R10, R5, #0x20 ; ' '
MOV             R6, R5
MOV             R2, which_pattern
MOV             R1, which_core
LDR             R0, [SP,#0x34+format] ; format
BLX             printf

loc_24E52
LDRB.W          R1, [R6,#1]!
MOV             R0, R4  ; format
BLX             printf
CMP             R6, R10
BNE             loc_24E52
MOV             R0, R9  ; format
SUB.W           R6, R5, #0xC
BLX             printf

loc_24E6A
LDRB.W          R1, [R6,#1]!
MOV             R0, R4  ; format
BLX             printf
CMP             R6, R5
BNE             loc_24E6A
MOVW            R0, #:lower16:aNonce0x08x ; " nonce=0x%08x\n"
LDR.W           R1, [R5,#-0xF]
MOVT            R0, #:upper16:aNonce0x08x ; " nonce=0x%08x\n"
ADDS            which_pattern, #1
BLX             printf
which_pattern = R7      ; unsigned int
LDR.W           R3, [R11,#configuration.pattern_number]
ADDS            R5, #0x44 ; 'D'
CMP             R3, which_pattern
BHI             loc_24E42

loc_24E94
LDR             R3, [SP,#0x34+which_asic]
MOVS            R0, #0xA ; c
ADDS            R3, #1
STR             R3, [SP,#0x34+which_asic]
BLX             putchar

loc_24EA0
LDR             R3, [SP,#0x34+OpenCoreNum2]
ADD.W           which_core, which_core, #1
CMP.W           R8, #0x40 ; '@'
MOV.W           R3, R3,LSR#1
STR             R3, [SP,#0x34+OpenCoreNum2]
OpenCoreNum2_0 = R3     ; unsigned int
which_core = R8         ; unsigned int
BNE             loc_24E1A
MOVW            R4, #:lower16:a02x_0 ; "%02x"
MOVW            OpenCoreNum2_0, #:lower16:cgpu
MOVW            R10, #:lower16:aCore02d02dMids ; "core[%02d][%02d].midstate=0x"
MOVT            R4, #:upper16:a02x_0 ; "%02x"
MOVT            R3, #:upper16:cgpu
MOVT            R10, #:upper16:aCore02d02dMids ; "core[%02d][%02d].midstate=0x"
STR             R3, [SP,#0x34+OpenCoreNum1]
STR.W           R10, [SP,#0x34+OpenCoreNum2]

loc_24ED0
LDR             R3, [SP,#0x34+OpenCoreNum3]
LSLS            R6, R3, #0x1F
BPL             loc_24F56
LDR             R3, [SP,#0x34+which_asic]
MOVW            R9, #:lower16:aData2 ; " data2="
LDR             R1, [SP,#0x34+OpenCoreNum1]
MOVT            R9, #:upper16:aData2 ; " data2="
LDR.W           R2, [R11,#configuration.pattern_number]
MOVS            R7, #0
ADD.W           R3, R3, #0x20000
ADDS            R3, #0x2A ; '*'
ADD.W           R3, R1, R3,LSL#2
LDR             R5, [R3,#4]
works_0 = R5            ; work *
ADDS            works_0, #0x13
CBZ             R2, loc_24F4A

loc_24EF8
which_pattern = R7      ; unsigned int
ADD.W           R10, R5, #0x20 ; ' '
MOV             R6, R5
MOV             R2, which_pattern
MOV             R1, which_core
LDR             R0, [SP,#0x34+OpenCoreNum2] ; format
BLX             printf

loc_24F08
LDRB.W          R1, [R6,#1]!
MOV             R0, R4  ; format
BLX             printf
CMP             R6, R10
BNE             loc_24F08
MOV             R0, R9  ; format
SUB.W           R6, R5, #0xC
BLX             printf

loc_24F20
LDRB.W          R1, [R6,#1]!
MOV             R0, R4  ; format
BLX             printf
CMP             R6, R5
BNE             loc_24F20
MOVW            R0, #:lower16:aNonce0x08x ; " nonce=0x%08x\n"
LDR.W           R1, [R5,#-0xF]
MOVT            R0, #:upper16:aNonce0x08x ; " nonce=0x%08x\n"
ADDS            which_pattern, #1
BLX             printf
which_pattern = R7      ; unsigned int
LDR.W           R3, [R11,#configuration.pattern_number]
ADDS            R5, #0x44 ; 'D'
CMP             R3, which_pattern
BHI             loc_24EF8

loc_24F4A
LDR             R3, [SP,#0x34+which_asic]
MOVS            R0, #0xA ; c
ADDS            R3, #1
STR             R3, [SP,#0x34+which_asic]
BLX             putchar

loc_24F56
LDR             R3, [SP,#0x34+OpenCoreNum3]
ADD.W           which_core, which_core, #1
CMP.W           R8, #0x60 ; '`'
MOV.W           R3, R3,LSR#1
STR             R3, [SP,#0x34+OpenCoreNum3]
OpenCoreNum3_0 = R3     ; unsigned int
which_core = R8         ; unsigned int
BNE             loc_24ED0
MOVW            R4, #:lower16:a02x_0 ; "%02x"
MOVW            OpenCoreNum3_0, #:lower16:cgpu
MOVW            R10, #:lower16:aCore02d02dMids ; "core[%02d][%02d].midstate=0x"
MOVT            R4, #:upper16:a02x_0 ; "%02x"
MOVT            R3, #:upper16:cgpu
MOVT            R10, #:upper16:aCore02d02dMids ; "core[%02d][%02d].midstate=0x"
STR             R3, [SP,#0x34+OpenCoreNum1]
STR.W           R10, [SP,#0x34+OpenCoreNum2]

loc_24F86
LDR             R3, [SP,#0x34+OpenCoreNum4]
LSLS            R5, R3, #0x1F
BPL             loc_2500C
LDR             R3, [SP,#0x34+which_asic]
MOVW            R9, #:lower16:aData2 ; " data2="
LDR             R1, [SP,#0x34+OpenCoreNum1]
MOVT            R9, #:upper16:aData2 ; " data2="
LDR.W           R2, [R11,#configuration.pattern_number]
MOVS            R7, #0
ADD.W           R3, R3, #0x20000
ADDS            R3, #0x2A ; '*'
ADD.W           R3, R1, R3,LSL#2
LDR             R5, [R3,#4]
works_0 = R5            ; work *
ADDS            works_0, #0x13
CBZ             R2, loc_25000

loc_24FAE
which_pattern = R7      ; unsigned int
ADD.W           R10, R5, #0x20 ; ' '
MOV             R6, R5
MOV             R2, which_pattern
MOV             R1, which_core
LDR             R0, [SP,#0x34+OpenCoreNum2] ; format
BLX             printf

loc_24FBE
LDRB.W          R1, [R6,#1]!
MOV             R0, R4  ; format
BLX             printf
CMP             R6, R10
BNE             loc_24FBE
MOV             R0, R9  ; format
SUB.W           R6, R5, #0xC
BLX             printf

loc_24FD6
LDRB.W          R1, [R6,#1]!
MOV             R0, R4  ; format
BLX             printf
CMP             R6, R5
BNE             loc_24FD6
MOVW            R0, #:lower16:aNonce0x08x ; " nonce=0x%08x\n"
LDR.W           R1, [R5,#-0xF]
MOVT            R0, #:upper16:aNonce0x08x ; " nonce=0x%08x\n"
ADDS            which_pattern, #1
BLX             printf
which_pattern = R7      ; unsigned int
LDR.W           R3, [R11,#configuration.pattern_number]
ADDS            R5, #0x44 ; 'D'
CMP             R3, which_pattern
BHI             loc_24FAE

loc_25000
LDR             R3, [SP,#0x34+which_asic]
MOVS            R0, #0xA ; c
ADDS            R3, #1
STR             R3, [SP,#0x34+which_asic]
BLX             putchar

loc_2500C
LDR             R3, [SP,#0x34+OpenCoreNum4]
ADD.W           which_core, which_core, #1
CMP.W           R8, #0x80
MOV.W           R3, R3,LSR#1
STR             R3, [SP,#0x34+OpenCoreNum4]
OpenCoreNum4_0 = R3     ; unsigned int
which_core = R8         ; unsigned int
BNE             loc_24F86
MOVW            R4, #:lower16:a02x_0 ; "%02x"
MOVW            OpenCoreNum4_0, #:lower16:cgpu
MOVW            R10, #:lower16:aCore02d02dMids ; "core[%02d][%02d].midstate=0x"
MOVT            R4, #:upper16:a02x_0 ; "%02x"
MOVT            R3, #:upper16:cgpu
MOVT            R10, #:upper16:aCore02d02dMids ; "core[%02d][%02d].midstate=0x"
STR             R3, [SP,#0x34+OpenCoreNum1]
STR.W           R10, [SP,#0x34+OpenCoreNum2]

loc_2503C
LDR             R3, [SP,#0x34+OpenCoreNum5]
LSLS            R0, R3, #0x1F
BPL             loc_250C2
LDR             R3, [SP,#0x34+which_asic]
MOVW            R9, #:lower16:aData2 ; " data2="
LDR             R1, [SP,#0x34+OpenCoreNum1]
MOVT            R9, #:upper16:aData2 ; " data2="
LDR.W           R2, [R11,#configuration.pattern_number]
MOVS            R7, #0
ADD.W           R3, R3, #0x20000
ADDS            R3, #0x2A ; '*'
ADD.W           R3, R1, R3,LSL#2
LDR             R5, [R3,#4]
works_0 = R5            ; work *
ADDS            works_0, #0x13
CBZ             R2, loc_250B6

loc_25064
which_pattern = R7      ; unsigned int
ADD.W           R10, R5, #0x20 ; ' '
MOV             R6, R5
MOV             R2, which_pattern
MOV             R1, which_core
LDR             R0, [SP,#0x34+OpenCoreNum2] ; format
BLX             printf

loc_25074
LDRB.W          R1, [R6,#1]!
MOV             R0, R4  ; format
BLX             printf
CMP             R6, R10
BNE             loc_25074
MOV             R0, R9  ; format
SUB.W           R6, R5, #0xC
BLX             printf

loc_2508C
LDRB.W          R1, [R6,#1]!
MOV             R0, R4  ; format
BLX             printf
CMP             R6, R5
BNE             loc_2508C
MOVW            R0, #:lower16:aNonce0x08x ; " nonce=0x%08x\n"
LDR.W           R1, [R5,#-0xF]
MOVT            R0, #:upper16:aNonce0x08x ; " nonce=0x%08x\n"
ADDS            which_pattern, #1
BLX             printf
which_pattern = R7      ; unsigned int
LDR.W           R3, [R11,#configuration.pattern_number]
ADDS            R5, #0x44 ; 'D'
CMP             R3, which_pattern
BHI             loc_25064

loc_250B6
LDR             R3, [SP,#0x34+which_asic]
MOVS            R0, #0xA ; c
ADDS            R3, #1
STR             R3, [SP,#0x34+which_asic]
BLX             putchar

loc_250C2
LDR             R3, [SP,#0x34+OpenCoreNum5]
ADD.W           which_core, which_core, #1
CMP.W           R8, #0xA0
MOV.W           R3, R3,LSR#1
STR             R3, [SP,#0x34+OpenCoreNum5]
OpenCoreNum5_0 = R3     ; unsigned int
which_core = R8         ; unsigned int
BNE             loc_2503C
MOVW            R4, #:lower16:a02x_0 ; "%02x"
MOVW            OpenCoreNum5_0, #:lower16:cgpu
MOVW            R2, #:lower16:aCore02d02dMids ; "core[%02d][%02d].midstate=0x"
MOVT            R4, #:upper16:a02x_0 ; "%02x"
MOVT            R3, #:upper16:cgpu
MOVT            R2, #:upper16:aCore02d02dMids ; "core[%02d][%02d].midstate=0x"
STR             R3, [SP,#0x34+OpenCoreNum1]
STR             R2, [SP,#0x34+OpenCoreNum2]

loc_250F0
LDR             R3, [SP,#0x34+OpenCoreNum6]
LSLS            R1, R3, #0x1F
BPL             loc_25176
LDR             R3, [SP,#0x34+which_asic]
MOVW            R9, #:lower16:aData2 ; " data2="
LDR             R1, [SP,#0x34+OpenCoreNum1]
MOVT            R9, #:upper16:aData2 ; " data2="
LDR.W           R2, [R11,#configuration.pattern_number]
MOVS            R7, #0
ADD.W           R3, R3, #0x20000
ADDS            R3, #0x2A ; '*'
ADD.W           R3, R1, R3,LSL#2
LDR             R5, [R3,#4]
works_0 = R5            ; work *
ADDS            works_0, #0x13
CBZ             R2, loc_2516A

loc_25118
which_pattern = R7      ; unsigned int
ADD.W           R10, R5, #0x20 ; ' '
MOV             R6, R5
MOV             R2, which_pattern
MOV             R1, which_core
LDR             R0, [SP,#0x34+OpenCoreNum2] ; format
BLX             printf

loc_25128
LDRB.W          R1, [R6,#1]!
MOV             R0, R4  ; format
BLX             printf
CMP             R10, R6
BNE             loc_25128
MOV             R0, R9  ; format
SUB.W           R6, R5, #0xC
BLX             printf

loc_25140
LDRB.W          R1, [R6,#1]!
MOV             R0, R4  ; format
BLX             printf
CMP             R6, R5
BNE             loc_25140
MOVW            R0, #:lower16:aNonce0x08x ; " nonce=0x%08x\n"
LDR.W           R1, [R5,#-0xF]
MOVT            R0, #:upper16:aNonce0x08x ; " nonce=0x%08x\n"
ADDS            which_pattern, #1
BLX             printf
which_pattern = R7      ; unsigned int
LDR.W           R3, [R11,#configuration.pattern_number]
ADDS            R5, #0x44 ; 'D'
CMP             R3, which_pattern
BHI             loc_25118

loc_2516A
LDR             R3, [SP,#0x34+which_asic]
MOVS            R0, #0xA ; c
ADDS            R3, #1
STR             R3, [SP,#0x34+which_asic]
BLX             putchar

loc_25176
LDR             R3, [SP,#0x34+OpenCoreNum6]
ADD.W           which_core, which_core, #1
CMP.W           R8, #0xC0
MOV.W           R3, R3,LSR#1
STR             R3, [SP,#0x34+OpenCoreNum6]
OpenCoreNum6_0 = R3     ; unsigned int
which_core = R8         ; unsigned int
BNE             loc_250F0
MOVW            R4, #:lower16:a02x_0 ; "%02x"
MOVW            OpenCoreNum6_0, #:lower16:cgpu
MOVW            R2, #:lower16:aCore02d02dMids ; "core[%02d][%02d].midstate=0x"
MOVT            R4, #:upper16:a02x_0 ; "%02x"
MOVT            R3, #:upper16:cgpu
MOVT            R2, #:upper16:aCore02d02dMids ; "core[%02d][%02d].midstate=0x"
STR             R3, [SP,#0x34+OpenCoreNum1]
STR             R2, [SP,#0x34+OpenCoreNum2]

loc_251A4
LDR             R3, [SP,#0x34+OpenCoreNum7]
LSLS            R2, R3, #0x1F
BPL             loc_2522A
LDR             R3, [SP,#0x34+which_asic]
MOVW            R9, #:lower16:aData2 ; " data2="
LDR             R1, [SP,#0x34+OpenCoreNum1]
MOVT            R9, #:upper16:aData2 ; " data2="
LDR.W           R2, [R11,#configuration.pattern_number]
MOVS            R7, #0
ADD.W           R3, R3, #0x20000
ADDS            R3, #0x2A ; '*'
ADD.W           R3, R1, R3,LSL#2
LDR             R5, [R3,#4]
works_0 = R5            ; work *
ADDS            works_0, #0x13
CBZ             R2, loc_2521E

loc_251CC
which_pattern = R7      ; unsigned int
ADD.W           R10, R5, #0x20 ; ' '
MOV             R6, R5
MOV             R2, which_pattern
MOV             R1, which_core
LDR             R0, [SP,#0x34+OpenCoreNum2] ; format
BLX             printf

loc_251DC
LDRB.W          R1, [R6,#1]!
MOV             R0, R4  ; format
BLX             printf
CMP             R10, R6
BNE             loc_251DC
MOV             R0, R9  ; format
SUB.W           R6, R5, #0xC
BLX             printf

loc_251F4
LDRB.W          R1, [R6,#1]!
MOV             R0, R4  ; format
BLX             printf
CMP             R6, R5
BNE             loc_251F4
MOVW            R0, #:lower16:aNonce0x08x ; " nonce=0x%08x\n"
LDR.W           R1, [R5,#-0xF]
MOVT            R0, #:upper16:aNonce0x08x ; " nonce=0x%08x\n"
ADDS            which_pattern, #1
BLX             printf
which_pattern = R7      ; unsigned int
LDR.W           R3, [R11,#configuration.pattern_number]
ADDS            R5, #0x44 ; 'D'
CMP             R3, which_pattern
BHI             loc_251CC

loc_2521E
LDR             R3, [SP,#0x34+which_asic]
MOVS            R0, #0xA ; c
ADDS            R3, #1
STR             R3, [SP,#0x34+which_asic]
BLX             putchar

loc_2522A
LDR             R3, [SP,#0x34+OpenCoreNum7]
ADD.W           which_core, which_core, #1
CMP.W           R8, #0xE0
MOV.W           R3, R3,LSR#1
STR             R3, [SP,#0x34+OpenCoreNum7]
OpenCoreNum7_0 = R3     ; unsigned int
which_core = R8         ; unsigned int
BNE             loc_251A4
MOVW            R4, #:lower16:a02x_0 ; "%02x"
MOVW            OpenCoreNum7_0, #:lower16:cgpu
MOVW            R2, #:lower16:aCore02d02dMids ; "core[%02d][%02d].midstate=0x"
MOVT            R4, #:upper16:a02x_0 ; "%02x"
MOVT            R3, #:upper16:cgpu
MOVT            R2, #:upper16:aCore02d02dMids ; "core[%02d][%02d].midstate=0x"
STR             R3, [SP,#0x34+OpenCoreNum1]
STR             R2, [SP,#0x34+OpenCoreNum2]

loc_25258
LDR             R3, [SP,#0x34+OpenCoreNum8]
LSLS            R3, R3, #0x1F
BPL             loc_252DE
LDR             R3, [SP,#0x34+which_asic]
MOVW            R9, #:lower16:aData2 ; " data2="
LDR             R1, [SP,#0x34+OpenCoreNum1]
MOVT            R9, #:upper16:aData2 ; " data2="
LDR.W           R2, [R11,#configuration.pattern_number]
MOVS            R7, #0
ADD.W           R3, R3, #0x20000
ADDS            R3, #0x2A ; '*'
ADD.W           R3, R1, R3,LSL#2
LDR             R5, [R3,#4]
works_0 = R5            ; work *
ADDS            works_0, #0x13
CBZ             R2, loc_252D2

loc_25280
which_pattern = R7      ; unsigned int
ADD.W           R10, R5, #0x20 ; ' '
MOV             R6, R5
MOV             R2, which_pattern
MOV             R1, which_core
LDR             R0, [SP,#0x34+OpenCoreNum2] ; format
BLX             printf

loc_25290
LDRB.W          R1, [R6,#1]!
MOV             R0, R4  ; format
BLX             printf
CMP             R10, R6
BNE             loc_25290
MOV             R0, R9  ; format
SUB.W           R6, R5, #0xC
BLX             printf

loc_252A8
LDRB.W          R1, [R6,#1]!
MOV             R0, R4  ; format
BLX             printf
CMP             R6, R5
BNE             loc_252A8
MOVW            R0, #:lower16:aNonce0x08x ; " nonce=0x%08x\n"
LDR.W           R1, [R5,#-0xF]
MOVT            R0, #:upper16:aNonce0x08x ; " nonce=0x%08x\n"
ADDS            which_pattern, #1
BLX             printf
which_pattern = R7      ; unsigned int
LDR.W           R3, [R11,#configuration.pattern_number]
ADDS            R5, #0x44 ; 'D'
CMP             R3, which_pattern
BHI             loc_25280

loc_252D2
LDR             R3, [SP,#0x34+which_asic]
MOVS            R0, #0xA ; c
ADDS            R3, #1
STR             R3, [SP,#0x34+which_asic]
BLX             putchar

loc_252DE
LDR             R3, [SP,#0x34+OpenCoreNum8]
ADD.W           which_core, which_core, #1
CMP.W           R8, #0x100
MOV.W           R3, R3,LSR#1
STR             R3, [SP,#0x34+OpenCoreNum8]
OpenCoreNum8_0 = R3     ; unsigned int
which_core = R8         ; unsigned int
BNE             loc_25258
B               loc_24D22
; End of function print_works

ALIGN 4



; int __fastcall get_work(int id, int count)
EXPORT get_work
get_work

str= -0x404

id = R0                 ; int
count = R1              ; int
PUSH.W          {R4-R11,LR}
SUBW            SP, SP, #0x404
MOV             R10, id
MOV             R9, count
MOV.W           R2, #0x400 ; n
MOVS            count, #0 ; c
count = R9              ; int
MOV             id, SP  ; s
id = R10                ; int
MOVW            R7, #:lower16:cgpu
BLX             memset
ADD.W           R0, count, count,LSL#4
MOVT            R7, #:upper16:cgpu
MOVS            R5, #0
LSLS            R0, R0, #2 ; size
MOVW            R8, #:lower16:aNonce ; "nonce"
MOV             R4, R5
BLX             malloc
ADD.W           R3, id, #0x20000
MOVT            R8, #:upper16:aNonce ; "nonce"
ADDS            R3, #0x2A ; '*'
ADD.W           R6, R7, R3,LSL#2
STR             R0, [R6,#4]
CMP             R0, #0
BEQ             loc_25420

loc_2533A               ; stream
subid = R4              ; int
LDR.W           R2, [R7,id,LSL#2]
MOVW            R1, #0x3FF ; n
MOV             R0, SP  ; s
BLX             fgets
CMP             R0, #0
BEQ             loc_253FA
LDR             R3, [R6,#4]
MOV             R1, R8  ; needle
MOV             R0, SP  ; haystack
ADD.W           R11, R3, R5
new_work = R11          ; work *
BLX             strstr
temp = R0               ; char *
CMP             temp, #0
BEQ             err
LDRB            R3, [temp,#5]
ADDS            R1, temp, #5
temp = R1               ; char *
CMP             R3, #0x20 ; ' '
BNE             loc_2536E

loc_25366               ; src
LDRB.W          R3, [temp,#1]!
CMP             R3, #0x20 ; ' '
BEQ             loc_25366

loc_2536E               ; inlen
MOVS            R2, #8
ADD.W           R0, new_work, #4 ; dst
BL              s2hex
LDR.W           R3, [new_work,#4]
MOV             R1, #aMidstate ; "midstate"
MOV             R0, SP  ; haystack
REV             R3, R3
STR.W           R3, [new_work,#4]
BLX             strstr
temp = R0               ; char *
CBZ             temp, err
LDRB            R3, [temp,#8]
ADD.W           R1, temp, #8
temp = R1               ; char *
CMP             R3, #0x20 ; ' '
BNE             loc_253A4

loc_2539C               ; src
LDRB.W          R3, [temp,#1]!
CMP             R3, #0x20 ; ' '
BEQ             loc_2539C

loc_253A4               ; inlen
MOVS            R2, #0x40 ; '@'
ADD.W           R0, new_work, #0x14 ; dst
BL              s2hex
MOVW            R1, #:lower16:aData ; "data"
MOV             R0, SP  ; haystack
MOVT            R1, #:upper16:aData ; "data"
BLX             strstr
temp = R0               ; char *
CBZ             temp, err
LDRB            R3, [temp,#4]
ADDS            R1, temp, #4
temp = R1               ; char *
CMP             R3, #0x20 ; ' '
BNE             loc_253CE

loc_253C6               ; src
LDRB.W          R3, [temp,#1]!
CMP             R3, #0x20 ; ' '
BEQ             loc_253C6

loc_253CE               ; inlen
MOVS            R2, #0x18
ADD.W           R0, new_work, #8 ; dst
BL              s2hex
STR.W           subid, [new_work]
ADDS            subid, #1
CMP             count, R4
MOV.W           R3, #0
ADD.W           R5, R5, #0x44 ; 'D'
STR.W           R3, [new_work,#0x34]
STR.W           R3, [new_work,#0x38]
STR.W           R3, [new_work,#0x3C]
STR.W           R3, [new_work,#0x40]
subid = R4              ; int
BGT             loc_2533A

loc_253FA
MOV             R0, subid
ADDW            SP, SP, #0x404
POP.W           {subid-R11,PC}

err                     ; ptr
new_work = R11          ; work *
temp = R0               ; char *
MOV             temp, new_work
BLX             free
MOV             R0, #aGetWorkErr ; "get work err"
BLX             puts
MOV             R0, subid

loc_25418
ADDW            SP, SP, #0x404
POP.W           {R4-R11,PC}

loc_25420
MOV             R4, R0
MOV             R0, #aMallocStructWo ; "malloc struct work err"
BLX             puts
MOV             R0, R4
B               loc_25418
; End of function get_work

ALIGN 4



; int __fastcall get_work_hash_board(int which_asic, int which_core, FILE *stream, int count)
EXPORT get_work_hash_board
get_work_hash_board

str= -0x400

which_asic = R0         ; int
which_core = R1         ; int
stream = R2             ; FILE *
count = R3              ; int
PUSH.W          {R4-R10,LR}
MOV             R8, count
MOV             R5, which_core
SUB.W           SP, SP, #0x400
MUL             R5, R8, R5
MOV             R6, which_asic
MOV             R9, stream
MOV             which_asic, SP ; s
which_asic = R6         ; int
MOV.W           stream, #0x400 ; n
stream = R9             ; FILE *
MOVS            which_core, #0 ; c
MOVW            R7, #:lower16:aNonce ; "nonce"
BLX             memset
ADD.W           R5, R5, R5,LSL#4
ADD.W           R3, which_asic, #0x20000
MOVW            which_asic, #:lower16:cgpu
ADDS            R3, #0x2A ; '*'
MOVT            R6, #:upper16:cgpu
ADD.W           R6, R6, R3,LSL#2
LSLS            R5, R5, #2
MOVT            R7, #:upper16:aNonce ; "nonce"
MOVS            R4, #0

loc_25476               ; stream
subid = R4              ; unsigned int
MOV             R2, stream
MOVW            R1, #0x3FF ; n
MOV             R0, SP  ; s
BLX             fgets
CMP             R0, #0
BEQ             loc_25534
LDR             R3, [R6,#4]
MOV             R1, R7  ; needle
MOV             R0, SP  ; haystack
ADD.W           R10, R3, R5
new_work = R10          ; work *
BLX             strstr
temp = R0               ; char *
CMP             temp, #0
BEQ             err
LDRB            R3, [temp,#5]
ADDS            R1, temp, #5
temp = R1               ; char *
CMP             R3, #0x20 ; ' '
BNE             loc_254A8

loc_254A0               ; src
LDRB.W          R3, [temp,#1]!
CMP             R3, #0x20 ; ' '
BEQ             loc_254A0

loc_254A8               ; inlen
MOVS            R2, #8
ADD.W           R0, new_work, #4 ; dst
BL              s2hex
LDR.W           R3, [new_work,#4]
MOV             R1, #aMidstate ; "midstate"
MOV             R0, SP  ; haystack
REV             R3, R3
STR.W           R3, [new_work,#4]
BLX             strstr
temp = R0               ; char *
CBZ             temp, err
LDRB            R3, [temp,#8]
ADD.W           R1, temp, #8
temp = R1               ; char *
CMP             R3, #0x20 ; ' '
BNE             loc_254DE

loc_254D6               ; src
LDRB.W          R3, [temp,#1]!
CMP             R3, #0x20 ; ' '
BEQ             loc_254D6

loc_254DE               ; inlen
MOVS            R2, #0x40 ; '@'
ADD.W           R0, new_work, #0x14 ; dst
BL              s2hex
MOVW            R1, #:lower16:aData ; "data"
MOV             R0, SP  ; haystack
MOVT            R1, #:upper16:aData ; "data"
BLX             strstr
temp = R0               ; char *
CBZ             temp, err
LDRB            R3, [temp,#4]
ADDS            R1, temp, #4
temp = R1               ; char *
CMP             R3, #0x20 ; ' '
BNE             loc_25508

loc_25500               ; src
LDRB.W          R3, [temp,#1]!
CMP             R3, #0x20 ; ' '
BEQ             loc_25500

loc_25508               ; inlen
MOVS            R2, #0x18
ADD.W           R0, new_work, #8 ; dst
BL              s2hex
STR.W           subid, [new_work]
ADDS            subid, #1
CMP             R4, count
MOV.W           R3, #0
ADD.W           R5, R5, #0x44 ; 'D'
STR.W           R3, [new_work,#0x34]
STR.W           R3, [new_work,#0x38]
STR.W           R3, [new_work,#0x3C]
STR.W           R3, [new_work,#0x40]
subid = R4              ; unsigned int
BCC             loc_25476

loc_25534
MOV             R0, subid
ADD.W           SP, SP, #0x400
POP.W           {subid-R10,PC}

err                     ; ptr
new_work = R10          ; work *
temp = R0               ; char *
MOV             temp, new_work
BLX             free
MOV             R0, #aGetWorkErr ; "get work err"
BLX             puts
MOV             R0, subid
ADD.W           SP, SP, #0x400
POP.W           {subid-new_work,PC}
; End of function get_work_hash_board

ALIGN 4



; int __fastcall skip_rows(FILE *stream, int count)
EXPORT skip_rows
skip_rows

str= -0x404

stream = R0             ; FILE *
count = R1              ; int
PUSH            {R4,R5,LR}
MOV             R4, count
SUBW            SP, SP, #0x404
MOV             R5, stream
MOV.W           R2, #0x400 ; n
MOV             stream, SP ; s
stream = R5             ; FILE *
MOVS            count, #0 ; c
count = R4              ; int
BLX             memset
CBZ             R4, loc_25584

loc_25574               ; stream
MOV             R2, stream
MOVW            R1, #0x3FF ; n
MOV             R0, SP  ; s
BLX             fgets
SUBS            R4, #1
BNE             loc_25574

loc_25584
MOVS            R0, #0
ADDW            SP, SP, #0x404
POP             {R4,stream,PC}
; End of function skip_rows




; int get_works_v1()
EXPORT get_works_v1
get_works_v1

var_124= -0x124
var_120= -0x120
format= -0x11C
var_118= -0x118
var_114= -0x114
var_110= -0x110
var_10C= -0x10C
asic_num= -0x108
strFilePath= -0x104

PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x124
MOV.W           R2, #0x100 ; n
MOVS            R1, #0  ; c
ADD             R0, SP, #0x124+strFilePath ; s
MOVW            R10, #:lower16:Conf
BLX             memset
MOVW            R0, #:lower16:aS ; "\n--- %s\n"
LDR             R1, =__FUNCTION__.8380 ; "get_works_v1"
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
MOVT            R10, #:upper16:Conf
BLX             printf
LDR.W           R3, [R10,#configuration.AsicType]
MOVW            R2, #0x569
CMP             R3, R2
BEQ.W           loc_2578E
SUB.W           R2, R3, #0x3640
SUBS            R2, #0x17
CMP             R2, #1
BLS.W           loc_257AE
MOVW            R2, #0x1397
CMP             R3, R2
IT EQ
MOVEQ.W         R11, #0x2A0
BNE.W           loc_257CE

loc_255DE
core_number = R11       ; int
MOV             R3, #gHashBoard_V9
LDRB            R3, [R3]
CMP             R3, #0
BEQ.W           loc_25724
MOVS            R3, #0x2D ; '-'
STR             R3, [SP,#0x124+var_110]
STR             R3, [SP,#0x124+asic_num]

loc_255F4
LDR             R3, =(cgpu.workdataFilePrefix+0x3C)
MOVW            R2, #:lower16:aS02iS03iTxt ; "%s%02i%s%03i.txt"
MOV.W           R1, core_number,LSL#2
MOVS            R6, #0
MOVT            R2, #:upper16:aS02iS03iTxt ; "%s%02i%s%03i.txt"
STR             R3, [SP,#0x124+var_118]
MOV             R3, #cgpu
STR             R1, [SP,#0x124+var_10C]
STR             R3, [SP,#0x124+var_114]
STR             R2, [SP,#0x124+format]

loc_25614
which_asic = R6         ; unsigned int
LDR.W           R0, [R10,#configuration.pattern_number]
ADD.W           R0, R0, R0,LSL#4
LSLS            R0, R0, #2
MUL             R0, core_number, R0 ; size
BLX             malloc
LDR             R3, [SP,#0x124+var_118]
STR.W           R0, [R3,#4]!
STR             R3, [SP,#0x124+var_118]
CMP             R0, #0
BEQ.W           loc_257B4
LDR             R5, [SP,#0x124+var_114]
MOV             R9, #(aV9CheckAsicNum+0x18) ; "r"
MOVS            R4, #0
ADD.W           R7, R5, #0x80000
ADD.W           R7, R7, #0x2A8

loc_25648
which_core = R4         ; unsigned int
LDR             R2, =cgpu.workdataFilePrefix
MOV             R3, which_asic
STR             which_core, [SP,#0x124+var_120]
ADD             R0, SP, #0x124+strFilePath ; s
LDR             R1, [SP,#0x124+format] ; format
MOV             R8, R5
STR             R2, [SP,#0x124+var_124]
SUBS            R2, #0x40 ; '@'
BLX             sprintf
MOV             R1, R9  ; modes
ADD             R0, SP, #0x124+strFilePath ; filename
BLX             fopen
MOV             R3, R0
MOV             R1, which_core ; which_core
STR             R3, [R5]
MOV             R0, which_asic ; which_asic
MOV             R2, R3  ; stream
ADDS            which_core, #1
which_core = R1         ; unsigned int
ADDS            R5, #4
CMP             R3, #0
BEQ             loc_25754
which_asic = R0         ; unsigned int
LDR.W           R3, [R10,#configuration.pattern_number] ; count
BL              get_work_hash_board
STR.W           R0, [R7,#4]!
LDR.W           R0, [R8] ; stream
BLX             fclose
which_core = R4         ; unsigned int
CMP             core_number, which_core
BHI             loc_25648
LDR             R3, [SP,#0x124+var_114]
ADDS            which_asic, #1
LDR             R2, [SP,#0x124+var_10C]
ADD             R3, R2
STR             R3, [SP,#0x124+var_114]
LDR             R3, [SP,#0x124+var_110]
CMP             which_asic, R3
BCC             loc_25614

loc_2569E
LDR             R1, =cgpu.send_id
LDR.W           R3, [R10,#configuration.AsicNum]
LDR.W           R6, [R1,#(cgpu.subid - 0x2B0FC4)]
ADD.W           R4, R1, #0x80000
CMP             R3, #1
STR.W           R6, [R4,#(cgpu.min_work_subid - 0x330FC4)]
BEQ.W           loc_257C8
LDR             R3, [SP,#0x124+asic_num]
MUL             core_number, R3, core_number
CMP.W           R11, #0
BLE.W           loc_257C8
MOVS            R7, #0
ADD.W           R1, R1, #0x2AC
MOV             R3, R7
MOV             R5, R7
MOV             R0, R6
B               loc_256E2

loc_256D2
i = R3                  ; int
LDR.W           R2, [R1,#4]!
CMP             R2, R0
ITTTT LT
MOVLT           R6, R2
MOVLT           R5, i
MOVLT           R0, R6
MOVLT           R7, #1

loc_256E2
ADDS            R3, #1
i = R3                  ; int
CMP             R11, i
BNE             loc_256D2
CMP             R7, #0
BNE.W           loc_2582E

loc_256EE
record = R5             ; int
LDR.W           R3, [R10,#configuration.pattern_number]
CMP             R3, R0
IT LS
MOVLS           R0, #0
BLS             loc_25788
MOVW            R1, #:lower16:aGetLessWork ; "Get Less Work"
MOVS            R2, #0xD ; size
MOVT            R1, #:upper16:aGetLessWork ; "Get Less Work"
MOVS            R0, #1  ; line
BL              write_lcd
MOVW            R0, #:lower16:aSCgpuSubidDDIs ; "%s: cgpu.subid[%d] = %d, is the least p"...
LDR.W           R3, [R4,#(cgpu.min_work_subid - 0x330FC4)]
MOV             R2, record
MOVT            R0, #:upper16:aSCgpuSubidDDIs ; "%s: cgpu.subid[%d] = %d, is the least p"...
LDR             R1, =__FUNCTION__.8380 ; "get_works_v1"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_25788

loc_25724
core_number = R11       ; int
MOV             R3, #gHashBoard_BHB91601P
LDRB            R3, [R3]
CBNZ            R3, loc_2573C
MOV             R3, #gHashBoard_BHB91601S
LDRB            R3, [R3]
CBZ             R3, loc_25794

loc_2573C
MOV             R3, #BHB91601_ASIC_NUMBER
LDR             R3, [R3]
STR             R3, [SP,#0x124+asic_num]

loc_25748
LDR             R3, [SP,#0x124+asic_num]
STR             R3, [SP,#0x124+var_110]
CMP             R3, #0
BNE.W           loc_255F4
B               loc_2569E

loc_25754
which_core = R1         ; unsigned int
which_asic = R0         ; unsigned int
MOVW            which_core, #:lower16:aGetPattern ; "   Get pattern  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aGetPattern ; "   Get pattern  "
MOVS            which_asic, #1 ; line
which_asic = R6         ; unsigned int
BL              write_lcd
MOVW            R1, #:lower16:aError ; "      Error     "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aError ; "      Error     "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSOpenTestFileS ; "%s: Open test file %s error\n"
ADD             R2, SP, #0x124+strFilePath
LDR             R1, =__FUNCTION__.8380 ; "get_works_v1"
MOVT            R0, #:upper16:aSOpenTestFileS ; "%s: Open test file %s error\n"
BLX             printf
MOV.W           R0, #0xFFFFFFFF

loc_25788
ADD             SP, SP, #0x124
POP.W           {R4-R11,PC}

loc_2578E
MOV.W           R11, #0x32 ; '2'
B               loc_255DE

loc_25794
core_number = R11       ; int
MOV             R3, #gHashBoard_BHB07601
LDRB            R3, [R3]
CBZ             R3, loc_257F2
MOV             R3, #BHB07601_ASIC_NUMBER
LDR             R3, [R3]
STR             R3, [SP,#0x124+asic_num]
asic_num_0 = R3         ; int
B               loc_25748

loc_257AE
MOV.W           R11, #0x100
B               loc_255DE

loc_257B4
core_number = R11       ; int
which_asic = R6         ; unsigned int
MOVW            R0, #:lower16:aSMallocStructW ; "%s: malloc struct work err!\n"
LDR             R1, =__FUNCTION__.8380 ; "get_works_v1"
MOVT            R0, #:upper16:aSMallocStructW ; "%s: malloc struct work err!\n"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_25788

loc_257C8
MOV             R0, R6
MOVS            R5, #0
B               loc_256EE

loc_257CE
MOVW            R1, #:lower16:aAsictypeError ; " AsicType Error "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aAsictypeError ; " AsicType Error "
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R0, #:lower16:aSAsictypeError ; "\n!!!%s: AsicType error\n"
LDR             R1, =__FUNCTION__.8380 ; "get_works_v1"
MOVT            R0, #:upper16:aSAsictypeError ; "\n!!!%s: AsicType error\n"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_25788

loc_257F2
core_number = R11       ; int
MOVW            R1, #:lower16:aBoardName ; "   Board Name   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aBoardName ; "   Board Name   "
MOVS            R0, #1  ; line
BL              write_lcd
MOVW            R1, #:lower16:aError ; "      Error     "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aError ; "      Error     "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R2, #:lower16:Conf
MOVW            R0, #:lower16:aSBoardNameIsSE ; "\n!!!%s: Board Name is: %s, error\n"
MOVT            R2, #:upper16:Conf
MOVT            R0, #:upper16:aSBoardNameIsSE ; "\n!!!%s: Board Name is: %s, error\n"
LDR             R1, =__FUNCTION__.8380 ; "get_works_v1"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_25788

loc_2582E
i = R3                  ; int
STR.W           R6, [R4,#(cgpu.min_work_subid - 0x330FC4)]
B               loc_256EE
; End of function get_works_v1

off_25834 DCD __FUNCTION__.8380 ; "get_works_v1"
off_25838 DCD cgpu.workdataFilePrefix+0x3C
off_2583C DCD cgpu.workdataFilePrefix
off_25840 DCD cgpu.send_id



; int get_works_v2()
EXPORT get_works_v2
get_works_v2

var_110= -0x110
asic_num= -0x10C
var_108= -0x108
strFilePath= -0x104

PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x114
MOV.W           R2, #0x100 ; n
MOVS            R1, #0  ; c
ADD             R0, SP, #0x114+strFilePath ; s
MOVW            R7, #:lower16:Conf
BLX             memset
MOVW            R0, #:lower16:aS ; "\n--- %s\n"
LDR             R1, =__FUNCTION__.8412 ; "get_works_v2"
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
MOVT            R7, #:upper16:Conf
BLX             printf
LDR             R2, [R7,#configuration.AsicType]
MOVW            R3, #0x1397
CMP             R2, R3
BNE.W           loc_259D4
MOV             R3, #gHashBoard_BHB07601
LDRB.W          R10, [R3]
CMP.W           R10, #0
BEQ.W           loc_259F8
LDR             R3, =cgpu.workdataFilePrefix
MOVW            R1, #:lower16:aSSTxt ; "%s%s.txt"
LDR             R2, [R7,#configuration.AsicNum]
MOVT            R1, #:upper16:aSSTxt ; "%s%s.txt"
ADD             R0, SP, #0x114+strFilePath ; s
MOV             R5, #cgpu
STR             R2, [SP,#0x114+asic_num]
asic_num_0 = R2         ; int
SUB.W           asic_num_0, R3, #0x40 ; '@'
BLX             sprintf
MOVW            R1, #:lower16:(aV9CheckAsicNum+0x18) ; "r"
ADD             R0, SP, #0x114+strFilePath ; filename
MOVT            R1, #:upper16:(aV9CheckAsicNum+0x18) ; modes
BLX             fopen
STR             R0, [R5]
CMP             R0, #0
BEQ.W           loc_25A2E
LDR             R3, [R7,#configuration.pattern_number]
CMP             R3, #8
BHI.W           loc_25A64
LDR             R2, [SP,#0x114+asic_num]
CMP             R2, #0
BEQ.W           loc_25A7A
LDR.W           R11, =(cgpu.workdataFilePrefix+0x3C)
MOV.W           R8, #0
STR.W           R10, [SP,#0x114+var_108]
MOV             R10, R2
ADD.W           R9, R11, #0x200

loc_258E4
which_asic = R8         ; unsigned int
MOVW            R2, #0xB280
STR             R3, [SP,#0x114+var_110]
MUL             R0, R2, R3 ; size
BLX             malloc
LDR             R3, [SP,#0x114+var_110]
STR.W           R0, [R11,#4]!
CBZ             R0, loc_25934
MOV             R6, R9
MOVS            R4, #0
B               loc_25902

loc_25900               ; count
which_core = R4         ; unsigned int
LDR             R3, [R7,#configuration.pattern_number]

loc_25902               ; which_core
MOV             R1, which_core
LDR             R2, [R5] ; stream
MOV             R0, which_asic ; which_asic
ADDS            which_core, #1
which_core = R1         ; unsigned int
BL              get_work_hash_board
LDR             R1, [R7,#configuration.pattern_number]
STR.W           R0, [R6,#4]!
LDR             R0, [R5] ; stream
RSB.W           R1, R1, #8 ; count
BL              skip_rows
which_core = R4         ; unsigned int
CMP.W           which_core, #0x2A0
BNE             loc_25900
ADD.W           which_asic, which_asic, #1
ADD.W           R9, R9, #0xA80
CMP             R10, which_asic
BEQ             loc_2594C
LDR             R3, [R7,#configuration.pattern_number]
B               loc_258E4

loc_25934
MOVW            R0, #:lower16:aSMallocStructW ; "%s: malloc struct work err!\n"
LDR             R1, =__FUNCTION__.8412 ; "get_works_v2"
MOVT            R0, #:upper16:aSMallocStructW ; "%s: malloc struct work err!\n"
BLX             printf
MOV.W           R0, #0xFFFFFFFF

loc_25946
ADD             SP, SP, #0x114
POP.W           {R4-R11,PC}

loc_2594C               ; stream
which_core = R4         ; unsigned int
which_asic = R8         ; unsigned int
LDR             R0, [R5]
LDR.W           R10, [SP,#0x114+var_108]
BLX             fclose
LDR             R3, [SP,#0x114+asic_num]
LDR             R1, =cgpu.send_id
MUL             which_core, which_core, R3
LDR.W           LR, [R1,#(cgpu.subid - 0x2B0FC4)]
ADD.W           R5, R1, #0x80000
STR.W           LR, [R5,#(cgpu.min_work_subid - 0x330FC4)]
CMP             R4, #0
ITT LE
MOVLE           R0, LR
MOVLE           R6, #0
BLE             loc_259A0
MOV.W           R12, #0
ADD.W           R1, R1, #0x2AC
MOV             R3, R12
MOV             R6, R12
MOV             R0, LR
B               loc_25994

loc_25984
i = R3                  ; int
LDR.W           R2, [R1,#4]!
CMP             R2, R0
ITTTT LT
MOVLT           LR, R2
MOVLT           R12, R10
MOVLT           R0, LR
MOVLT           R6, i

loc_25994
ADDS            R3, #1
i = R3                  ; int
CMP             R4, i
BNE             loc_25984
CMP.W           R12, #0
BNE             loc_25A92

loc_259A0
LDR             R3, [R7,#configuration.pattern_number]
CMP             R3, R0
IT LS
MOVLS           R0, #0
BLS             loc_25946
MOVW            R1, #:lower16:aGetLessWork ; "Get Less Work"
MOVS            R2, #0xD ; size
MOVT            R1, #:upper16:aGetLessWork ; "Get Less Work"
MOVS            R0, #1  ; line
BL              write_lcd
MOVW            R0, #:lower16:aSCgpuSubidDDIs ; "%s: cgpu.subid[%d] = %d, is the least p"...
LDR.W           R3, [R5,#(cgpu.min_work_subid - 0x330FC4)]
MOV             R2, R6
MOVT            R0, #:upper16:aSCgpuSubidDDIs ; "%s: cgpu.subid[%d] = %d, is the least p"...
LDR             R1, =__FUNCTION__.8412 ; "get_works_v2"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_25946

loc_259D4
MOVW            R1, #:lower16:aAsictypeError ; " AsicType Error "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aAsictypeError ; " AsicType Error "
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R0, #:lower16:aSAsictypeError ; "\n!!!%s: AsicType error\n"
LDR             R1, =__FUNCTION__.8412 ; "get_works_v2"
MOVT            R0, #:upper16:aSAsictypeError ; "\n!!!%s: AsicType error\n"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_25946

loc_259F8
MOVW            R1, #:lower16:aBoardName ; "   Board Name   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aBoardName ; "   Board Name   "
MOVS            R0, #1  ; line
BL              write_lcd
MOVW            R1, #:lower16:aError ; "      Error     "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aError ; "      Error     "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSBoardNameIsSE ; "\n!!!%s: Board Name is: %s, error\n"
MOV             R2, R7
LDR             R1, =__FUNCTION__.8412 ; "get_works_v2"
MOVT            R0, #:upper16:aSBoardNameIsSE ; "\n!!!%s: Board Name is: %s, error\n"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_25946

loc_25A2E
MOVW            R1, #:lower16:aGetPattern ; "   Get pattern  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aGetPattern ; "   Get pattern  "
MOVS            R0, #1  ; line
BL              write_lcd
MOVW            R1, #:lower16:aError ; "      Error     "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aError ; "      Error     "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSOpenTestFileS ; "%s: Open test file %s error\n"
ADD             R2, SP, #0x114+strFilePath
LDR             R1, =__FUNCTION__.8412 ; "get_works_v2"
MOVT            R0, #:upper16:aSOpenTestFileS ; "%s: Open test file %s error\n"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_25946

loc_25A64
MOVW            R0, #:lower16:aSPatternNumDTo ; "%s: pattern_num %d too large\n"
MOV             R2, R3
MOVT            R0, #:upper16:aSPatternNumDTo ; "%s: pattern_num %d too large\n"
LDR             R1, =__FUNCTION__.8412 ; "get_works_v2"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_25946

loc_25A7A
BLX             fclose
ADD.W           R3, R5, #0x80000
ADD.W           R5, R5, #0x100000
LDR.W           R0, [R3,#(cgpu.subid - 0x2B0FC4)]
LDR             R6, [SP,#0x114+asic_num]
STR.W           R0, [R5,#(cgpu.min_work_subid - 0x330FC4)]
B               loc_259A0

loc_25A92
i = R3                  ; int
which_asic = R8         ; unsigned int
STR.W           LR, [R5,#(cgpu.min_work_subid - 0x330FC4)]
B               loc_259A0
; End of function get_works_v2

off_25A98 DCD __FUNCTION__.8412 ; "get_works_v2"
off_25A9C DCD cgpu.workdataFilePrefix
off_25AA0 DCD cgpu.send_id
off_25AA4 DCD cgpu.workdataFilePrefix+0x3C



; void clear_nonce_return_flag()
EXPORT clear_nonce_return_flag
clear_nonce_return_flag
PUSH.W          {R3-R9,LR}
MOV             R6, #Conf
LDR             R0, =__FUNCTION__.8440 ; "clear_nonce_return_flag"
ADD.W           R4, R6, #0xCC
LDM.W           R4, {R4,R7-R9}
OpenCoreNum4 = R9       ; unsigned int
BLX             puts
LDR             R3, [R6,#configuration.AsicNum]
CMP             R3, #1
IT NE
MOVNE           R5, #0
BEQ             loc_25B70

loc_25ACC
get_pattern_loop = R5   ; int
MOVW            R2, #:lower16:gHashBoard_V9
LDR             R4, [R6,#configuration.AsicType]
MOVT            R2, #:upper16:gHashBoard_V9
MOVW            R1, #0x569
LDRB            R2, [R2]
CMP             R4, R1
ITE EQ
MOVEQ           R4, #0x32 ; '2'
MOVNE           R4, #0
core_num = R4           ; int
CBZ             R2, loc_25B2A
CMP             R3, #1
BEQ             loc_25B2E
LDR             R6, [R6,#configuration.pattern_number]
MOVS            R2, #0
LDR             R7, =(cgpu.workdataFilePrefix+0x3C)
ADD.W           get_pattern_loop, R6, R6,LSL#4
ADD.W           LR, R7, #0xB4
LSLS            R5, R5, #2

loc_25AFA
LDR.W           R3, [R7,#4]!
CBZ             core_num, loc_25B22
MOVS            R0, #0

loc_25B02
which_core = R0         ; unsigned int
ADDS            R1, R3, R5
CBZ             R6, loc_25B1A

loc_25B06
STR             R2, [R3,#0x34]
ADDS            R3, #0x44 ; 'D'
STR.W           R2, [R3,#-0xC]
STR.W           R2, [R3,#-8]
STR.W           R2, [R3,#-4]
CMP             R1, R3
BNE             loc_25B06

loc_25B1A
ADDS            which_core, #1
MOV             R3, R1
CMP             core_num, which_core
BNE             loc_25B02

loc_25B22
CMP             LR, R7
BNE             loc_25AFA
POP.W           {R3-OpenCoreNum4,PC}

loc_25B2A
get_pattern_loop = R5   ; int
CMP             R3, #1
BNE             locret_25B6C

loc_25B2E
CBZ             get_pattern_loop, locret_25B6C
LDR             core_num, [R6,#configuration.pattern_number]
MOVS            R2, #0
MOVW            R6, #:lower16:cgpu
MOV             R1, R2
MOVT            R6, #:upper16:cgpu
ADD.W           R0, R4, R4,LSL#4
LSLS            R0, R0, #2

loc_25B44
i = R2                  ; int
CBZ             R4, loc_25B66
LSLS            R3, i, #2
ADD.W           R3, R3, #0x80000
ADDS            R3, #0xAC
LDR             R3, [R3,R6]
ADDS            R7, R3, R0

loc_25B52
STR             R1, [R3,#0x34]
ADDS            R3, #0x44 ; 'D'
STR.W           R1, [R3,#-0xC]
STR.W           R1, [R3,#-8]
STR.W           R1, [R3,#-4]
CMP             R7, R3
BNE             loc_25B52

loc_25B66
ADDS            i, #1
CMP             get_pattern_loop, i
BNE             loc_25B44

locret_25B6C
POP.W           {R3-OpenCoreNum4,PC}

loc_25B70
MOVS            R3, #0x20 ; ' '
MOVS            R5, #0

loc_25B74
get_pattern_loop = R5   ; int
OpenCoreNum1 = R4       ; unsigned int
OpenCoreNum2 = R7       ; unsigned int
OpenCoreNum3 = R8       ; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           get_pattern_loop, #1
OpenCoreNum1 = R4       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE           get_pattern_loop, #1
OpenCoreNum2 = R7       ; unsigned int
TST.W           OpenCoreNum3, #1
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
IT NE
ADDNE           get_pattern_loop, #1
OpenCoreNum3 = R8       ; unsigned int
TST.W           OpenCoreNum4, #1
MOV.W           OpenCoreNum4, OpenCoreNum4,LSR#1
IT NE
ADDNE           get_pattern_loop, #1
OpenCoreNum4 = R9       ; unsigned int
SUBS            R3, #1
BNE             loc_25B74
MOVW            R0, #:lower16:aSSingleAsicGet ; "%s: single ASIC get_pattern_loop = %d\n"
MOV             R2, get_pattern_loop
MOVT            R0, #:upper16:aSSingleAsicGet ; "%s: single ASIC get_pattern_loop = %d\n"
LDR             R1, =__FUNCTION__.8440 ; "clear_nonce_return_flag"
BLX             printf
LDR             R3, [R6,#configuration.AsicNum]
B               loc_25ACC
; End of function clear_nonce_return_flag

off_25BBC DCD __FUNCTION__.8440 ; "clear_nonce_return_flag"
off_25BC0 DCD cgpu.workdataFilePrefix+0x3C



; int bitmain_axi_init()
EXPORT bitmain_axi_init
bitmain_axi_init

fd= -0xC
offset= -8

MOVW            R0, #:lower16:aDevAxiFpgaDev ; "/dev/axi_fpga_dev"
PUSH            {R4,R5,LR}
MOVS            R1, #2  ; oflag
SUB             SP, SP, #0xC ; fd
MOVT            R0, #:upper16:aDevAxiFpgaDev ; "/dev/axi_fpga_dev"
BLX             open
LDR             R3, =cgpu.send_id
CMP             R0, #0
MOV             R1, R0
STR             R0, [R3,#(cgpu.fpga_fd - 0x2B0FC4)]
BLT             loc_25C68
MOVS            R4, #0
MOVW            R5, #:lower16:axi_fpga_addr
STMEA.W         SP, {R1,R4}
MOV             R0, R4  ; addr
MOV.W           R1, #0x400 ; len
MOVS            R3, #1  ; flags
MOVS            R2, #3  ; prot
MOVT            R5, #:upper16:axi_fpga_addr
BLX             mmap
MOV             R1, R0
STR             R0, [R5]
CMP             R0, #0
BEQ             loc_25C8C
MOV             R0, #aMmapAxiFpgaAdd ; "mmap axi_fpga_addr = %p\n"
BLX             printf
LDR             R3, [R5]
MOV             R0, #aAxiFpgaAddrDat ; "axi_fpga_addr data = 0x%x\n"
LDRH            R1, [R3]
BLX             printf
MOVW            R0, #:lower16:aDevFpgaMem ; "/dev/fpga_mem"
MOVS            R1, #2  ; oflag
MOVT            R0, #:upper16:aDevFpgaMem ; "/dev/fpga_mem"
BLX             open
MOVW            R3, #:lower16:fd_fpga_mem
CMP             R0, #0
MOVT            R3, #:upper16:fd_fpga_mem
MOV             R1, R0
STR             R0, [R3]
BLT             loc_25C7A
STR             R0, [SP,#0xC+fd] ; fd
MOV.W           R1, #0x1000000 ; len
STR             R4, [SP,#0xC+offset] ; offset
MOVS            R3, #1  ; flags
MOVS            R2, #3  ; prot
MOV             R0, R4  ; addr
BLX             mmap
MOV             R1, R0
STR             R0, [R5,#(fpga_mem_addr - 0x230FBC)]
CBZ             R0, loc_25C9E
MOV             R0, #aMmapFpgaMemAdd ; "mmap fpga_mem_addr = %p\n"
BLX             printf
MOV             R0, R4

loc_25C64
ADD             SP, SP, #0xC
POP             {R4,R5,PC}

loc_25C68
MOV             R0, #aDevAxiFpgaDevO ; "/dev/axi_fpga_dev open failed. fd = %d"...
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_25C64

loc_25C7A
MOV             R0, #aDevFpgaMemOpen ; "/dev/fpga_mem open failed. fd_fpga_mem "...
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_25C64

loc_25C8C
MOV             R0, #aMmapAxiFpgaAdd_0 ; "mmap axi_fpga_addr failed. axi_fpga_add"...
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_25C64

loc_25C9E
MOV             R0, #aMmapFpgaMemAdd_0 ; "mmap fpga_mem_addr failed. fpga_mem_add"...
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_25C64
; End of function bitmain_axi_init

off_25CB0 DCD cgpu.send_id



; void bitmain_axi_close()
EXPORT bitmain_axi_close
bitmain_axi_close
PUSH            {R4,LR}
MOVW            R1, #:lower16:__FUNCTION__.7923 ; "bitmain_axi_close"
MOVW            R0, #:lower16:aS_1 ; "\n\n--- %s\n"
MOVW            R4, #:lower16:axi_fpga_addr
MOVT            R1, #:upper16:__FUNCTION__.7923 ; "bitmain_axi_close"
MOVT            R0, #:upper16:aS_1 ; "\n\n--- %s\n"
MOVT            R4, #:upper16:axi_fpga_addr
BLX             printf
LDR             R0, [R4] ; addr
MOV.W           R1, #0x400 ; len
BLX             munmap
ret = R0                ; int
CMP             ret, #0
BLT             loc_25D16

loc_25CE0               ; addr
LDR             R0, [R4,#(fpga_mem_addr - 0x230FBC)]
MOV.W           R1, #0x1000000 ; len
BLX             munmap
ret = R0                ; int
CMP             ret, #0
BLT             loc_25D08

loc_25CEE
LDR             R3, =cgpu.send_id
LDR             R0, [R3,#(cgpu.fpga_fd - 0x2B0FC4)] ; fd
BLX             close
MOVW            R3, #:lower16:fd_fpga_mem
POP.W           {R4,LR}
MOVT            R3, #:upper16:fd_fpga_mem
LDR             R0, [R3] ; fd
B.W             j_close

loc_25D08
MOV             R0, #aMunmapFailed ; "munmap failed!"
BLX             puts
B               loc_25CEE

loc_25D16
MOV             R0, #aMunmapFailed ; "munmap failed!"
BLX             puts
B               loc_25CE0
; End of function bitmain_axi_close

off_25D24 DCD cgpu.send_id



; unsigned int __fastcall read_axi_fpga(unsigned int address)
EXPORT read_axi_fpga
read_axi_fpga
address = R0            ; unsigned int
MOV             R3, #axi_fpga_addr
LDR             R3, [R3]
LDR.W           address, [R3,address,LSL#2]
BX              LR
; End of function read_axi_fpga




; void __fastcall write_axi_fpga(unsigned int address, unsigned int data)
EXPORT write_axi_fpga
write_axi_fpga
address = R0            ; unsigned int
data = R1               ; unsigned int
MOV             R3, #axi_fpga_addr
LDR             R3, [R3]
STR.W           data, [R3,address,LSL#2]
BX              LR
; End of function write_axi_fpga




; void init_fpga()
EXPORT init_fpga
init_fpga
PUSH            {R4,LR}
MOVW            R0, #:lower16:aS ; "\n--- %s\n"
MOVW            R4, #:lower16:axi_fpga_addr
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
MOVT            R4, #:upper16:axi_fpga_addr
LDR             R1, =__FUNCTION__.7936 ; "init_fpga"
BLX             printf
LDR             R3, [R4]
MOV.W           R2, #0x80008000
STR.W           R2, [R3,#0x80]

loc_25D6A               ; useconds
MOVW            R0, #0x2710
BLX             usleep
LDR             R3, [R4]
LDR.W           R3, [R3,#0x80]
CMP             R3, #0
BLT             loc_25D6A
MOVW            R0, #:lower16:loc_186A0
POP.W           {R4,LR}
MOVT            R0, #:upper16:loc_186A0 ; useconds
B.W             j_usleep
; End of function init_fpga

off_25D8C DCD __FUNCTION__.7936 ; "init_fpga"



; void __fastcall get_return_nonce(unsigned int *buf)
EXPORT get_return_nonce
get_return_nonce
buf = R0                ; unsigned int *
MOV             R3, #axi_fpga_addr
LDR             R3, [R3]
LDR             R2, [R3,#0x10]
STR             R2, [buf]
LDR             R3, [R3,#0x14]
STR             R3, [buf,#4]
BX              LR
; End of function get_return_nonce




; void __fastcall set_BC_command_buffer(unsigned int *value)
EXPORT set_BC_command_buffer
set_BC_command_buffer
value = R0              ; unsigned int *
MOVW            R3, #:lower16:axi_fpga_addr
LDR             R2, [value]
MOVT            R3, #:upper16:axi_fpga_addr
LDR             R3, [R3]
STR.W           R2, [R3,#0xC4]
LDR             R2, [value,#4]
STR.W           R2, [R3,#0xC8]
LDR             R2, [value,#8]
STR.W           R2, [R3,#0xCC]
BX              LR
; End of function set_BC_command_buffer

ALIGN 4



; unsigned int get_BC_write_command()
EXPORT get_BC_write_command
get_BC_write_command
MOV             R3, #axi_fpga_addr
LDR             R3, [R3]
LDR.W           R0, [R3,#0xC0]
BX              LR
; End of function get_BC_write_command




; void __fastcall set_BC_write_command(unsigned int value)
EXPORT set_BC_write_command
set_BC_write_command
value = R0              ; unsigned int
PUSH            {R4-R6,LR}
SUBS            R6, value, #0
BLT             loc_25DEA
MOV             R3, #axi_fpga_addr
LDR             R3, [R3]

loc_25DE4
value = R6              ; unsigned int
STR.W           value, [R3,#0xC0]
POP             {R4-value,PC}

loc_25DEA
value = R0              ; unsigned int
MOVW            R5, #:lower16:axi_fpga_addr
MOVS            R4, #0x65 ; 'e'
MOVT            R5, #:upper16:axi_fpga_addr

loc_25DF4
value = R6              ; unsigned int
LDR             R3, [R5]
MOV.W           R0, #0x3E8 ; useconds
LDR.W           R2, [R3,#0xC0]
CMP             R2, #0
BGE             loc_25DE4
BLX             usleep
SUBS            R3, R4, #1
ANDS.W          R4, R3, #0xFF
BNE             loc_25DF4
MOVW            R0, #:lower16:aSTimeout ; "\n%s: timeout\n\n"
LDR             R1, =__FUNCTION__.7954 ; "set_BC_write_command"
MOVT            R0, #:upper16:aSTimeout ; "\n%s: timeout\n\n"
BLX             printf
LDR             R3, [R5]
B               loc_25DE4
; End of function set_BC_write_command

off_25E20 DCD __FUNCTION__.7954 ; "set_BC_write_command"



; void __fastcall set_TW_write_command(unsigned int *value)
EXPORT set_TW_write_command
set_TW_write_command
value = R0              ; unsigned int *
MOVW            R3, #:lower16:axi_fpga_addr
PUSH            {R4}
MOVT            R3, #:upper16:axi_fpga_addr
LDR             R4, [value]
ADD.W           R1, value, #0x30 ; '0'
LDR             R2, [R3]
STR             R4, [R2,#0x40]

loc_25E38
LDR.W           R3, [R0,#4]!
CMP             R0, R1
STR             R3, [R2,#0x44]
BNE             loc_25E38
POP.W           {R4}
BX              LR
; End of function set_TW_write_command




; void __fastcall set_fpga_baud(unsigned __int8 asic_baud)
EXPORT set_fpga_baud
set_fpga_baud
asic_baud = R0          ; unsigned __int8
MOV             R3, #axi_fpga_addr
LDR             R3, [R3]
LDR             R2, [R3,#0x3C]
BFI.W           R2, asic_baud, #0x10, #6
fpga_bt8d = R2          ; fpga_bt8d_t
STR             fpga_bt8d, [R3,#0x3C]
BX              LR
; End of function set_fpga_baud

ALIGN 0x10



; void *__fastcall single_BM1397_send_func(void *arg)
EXPORT single_BM1397_send_func
single_BM1397_send_func

var_A4= -0xA4
OpenCoreNum3= -0x98
OpenCoreNum4= -0x94
OpenCoreNum8= -0x90
var_8C= -0x8C
var_88= -0x88
var_84= -0x84
var_80= -0x80
useconds= -0x7C
test_core_number= -0x78
test_core_index= -0x74
var_70= -0x70
work_vil_1397= -0x6C
buf_vil= -0x38
var_4= -4

chain_info = R0         ; chain_info *
work = R6               ; work *
PUSH.W          {R4-R11,LR}
MOVW            R8, #:lower16:Conf
SUB             SP, SP, #0xA4
MOVT            R8, #:upper16:Conf
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
LDRB            R7, [chain_info]
which_chain = R7        ; unsigned __int8
ADD             chain_info, SP, #0xA4+buf_vil ; s
BLX             memset
MOVW            R4, #:lower16:gBegin_Get_Nonce
LDR.W           R3, [R8,#configuration.OpenCoreNum3]
MOVT            R4, #:upper16:gBegin_Get_Nonce
ADD.W           R9, R8, #0xDC
LDRB            R2, [R4]
STR             R3, [SP,#0xA4+OpenCoreNum3]
LDR.W           R3, [R8,#configuration.OpenCoreNum4]
LDR.W           R5, [R8,#configuration.OpenCoreNum1]
OpenCoreNum1 = R5       ; unsigned int
LDR.W           work, [R8,#configuration.OpenCoreNum2]
OpenCoreNum2 = R6       ; unsigned int
STR             R3, [SP,#0xA4+OpenCoreNum4]
OpenCoreNum4_0 = R3     ; unsigned int
LDM.W           R9, {R9-R11}
OpenCoreNum7 = R11      ; unsigned int
LDR.W           OpenCoreNum4_0, [R8,#configuration.OpenCoreNum8]
OpenCoreNum8_0 = R3     ; unsigned int
CBNZ            R2, loc_25EBE
MOVS            R0, #7  ; address
STR             OpenCoreNum8_0, [SP,#0xA4+OpenCoreNum8]
BL              read_axi_fpga
ORR.W           R1, R0, #0x10000 ; data
MOVS            R0, #7  ; address
BL              write_axi_fpga
LDR             R3, [SP,#0xA4+OpenCoreNum8]
MOVS            R2, #1
STRB            R2, [R4]

loc_25EBE
OpenCoreNum5 = R9       ; unsigned int
OpenCoreNum6 = R10      ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
LDR             R1, [SP,#0xA4+OpenCoreNum3]
MOVS            R4, #0x20 ; ' '
LDR             R0, [SP,#0xA4+OpenCoreNum4]
MOVS            R2, #0

loc_25EC6
test_core_number_0 = R2 ; unsigned int
OpenCoreNum3_0 = R1     ; unsigned int
OpenCoreNum4_0 = R0     ; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum1 = R5       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
work = R6               ; work *
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum2 = R6       ; unsigned int
TST.W           OpenCoreNum3_0, #1
MOV.W           OpenCoreNum3_0, OpenCoreNum3_0,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum3_0 = R1     ; unsigned int
TST.W           OpenCoreNum4_0, #1
MOV.W           OpenCoreNum4_0, OpenCoreNum4_0,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum4_0 = R0     ; unsigned int
TST.W           OpenCoreNum5, #1
MOV.W           OpenCoreNum5, OpenCoreNum5,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum5 = R9       ; unsigned int
TST.W           OpenCoreNum6, #1
MOV.W           OpenCoreNum6, OpenCoreNum6,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum6 = R10      ; unsigned int
TST.W           OpenCoreNum7, #1
MOV.W           OpenCoreNum7, OpenCoreNum7,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum7 = R11      ; unsigned int
TST.W           OpenCoreNum8_0, #1
MOV.W           OpenCoreNum8_0, OpenCoreNum8_0,LSR#1
IT NE
ADDNE           test_core_number_0, #1
OpenCoreNum8_0 = R3     ; unsigned int
SUBS            R4, #1
BNE             loc_25EC6
MOV             OpenCoreNum1, test_core_number_0
MOVW            OpenCoreNum3_0, #:lower16:__FUNCTION__.8795 ; "single_BM1397_send_func"
MOVW            OpenCoreNum4_0, #:lower16:aSThereAreDCore_0 ; "%s: There are %d cores should be test\n"
MOVT            R1, #:upper16:__FUNCTION__.8795 ; "single_BM1397_send_func"
MOVT            R0, #:upper16:aSThereAreDCore_0 ; "%s: There are %d cores should be test\n"
STR             test_core_number_0, [SP,#0xA4+test_core_number]
BLX             printf
CMP             test_core_number_0, #0
BEQ.W           loc_2616E
ORR.W           R2, which_chain, #0x80
ADD.W           R3, which_chain, which_chain,LSL#4
MOV             R0, R2
STR             R2, [SP,#0xA4+var_8C]
ADD.W           LR, which_chain, which_chain,LSL#1
MOV             R2, #HW_check_mutex
LSLS            R3, R3, #9
LDR             R1, =(cgpu.workdataFilePrefix+0x3C)
ADD.W           R2, R2, LR,LSL#3
LSLS            R0, R0, #0x10
MOV             test_core_number_0, R3
STR             R3, [SP,#0xA4+var_84]
MOVW            OpenCoreNum2, #:lower16:gWorks_For_Hw_Check
work = R6               ; work *
STR             R2, [SP,#0xA4+OpenCoreNum4]
MOVW            R2, #:lower16:gReadingTemp
LDR.W           R3, [R8,#configuration.pattern_number]
MOVT            work, #:upper16:gWorks_For_Hw_Check
STR             R1, [SP,#0xA4+var_70]
MOVW            OpenCoreNum7, #:lower16:gSend_Work_Num
MOV             R1, R2
ORR.W           R2, R0, #0x1000000
STR             R4, [SP,#0xA4+test_core_index]
MOVT            R11, #:upper16:gSend_Work_Num
STR             R2, [SP,#0xA4+var_88]
ADDS            R4, work, R5
MOV             R2, R1
STR             work, [SP,#0xA4+var_80]
MOVT            R2, #:upper16:gReadingTemp
STR             R2, [SP,#0xA4+OpenCoreNum3]

loc_25FA0
LDR             R1, [SP,#0xA4+var_70]
MOVS            R5, #0
MOVW            R2, #:lower16:(gAsic_Core_Nonce_Num+0x492DC)
CMP             R5, R3
MOVT            R2, #:upper16:(gAsic_Core_Nonce_Num+0x492DC)
MOV             R0, R1
STR             R2, [SP,#0xA4+useconds]
LDR.W           R1, [R0,#4]!
STR             R1, [SP,#0xA4+OpenCoreNum8]
STR             R0, [SP,#0xA4+var_70]
which_pattern = R5      ; unsigned int
works_0 = R1            ; work *
BCS.W           loc_2610E

loc_25FBE
LDR             R3, [SP,#0xA4+OpenCoreNum3]
LDRB            R3, [R3]
CMP             R3, #0
BNE.W           loc_26166

loc_25FC8               ; address
MOVS            R0, #3
MOV.W           R9, #1
BL              read_axi_fpga
work_fifo_ready = R0    ; unsigned int
MOV             R3, #gChain
LDRB            R3, [R3]
LSL.W           R3, R9, R3
TST             R3, work_fifo_ready
BEQ.W           loc_2615C
LDR             R3, [SP,#0xA4+OpenCoreNum8]
ADD.W           work, which_pattern, which_pattern,LSL#4
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             work_fifo_ready, SP, #0xA4+buf_vil ; s
ADD.W           work, R3, work,LSL#2
BLX             memset
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             R0, SP, #0xA4+work_vil_1397 ; s
BLX             memset
LDRB.W          R0, [SP,#0xA4+var_8C]
ADDS            R3, work, #7
ADD.W           R2, work, #0x13
ADD.W           R1, SP, #0xA4+work_vil_1397.work_count+3
STRB.W          R9, [SP,#0xA4+work_vil_1397]
STRB.W          R0, [SP,#0xA4+work_vil_1397.chain_id]
STR             which_pattern, [SP,#0xA4+work_vil_1397.work_count]

loc_2601C
LDRB.W          R0, [R3,#1]!
CMP             R2, R3
STRB.W          R0, [R1,#1]!
BNE             loc_2601C
ADD.W           R3, SP, #0xA4+work_vil_1397.data+0xB
ADD.W           R0, SP, #0xA4+work_vil_1397.midstate+0x1F

loc_26030
LDRB.W          R1, [R2,#1]!
STRB.W          R1, [R3,#1]!
CMP             R3, R0
BNE             loc_26030
ADD             R3, SP, #0xA4+work_vil_1397
LDR             R2, [SP,#0xA4+var_88]
ADD.W           R10, SP, #0xA4+work_vil_1397.data+4
MOV             R12, R3
ADD.W           R9, SP, #0xA4+var_4
STR             R2, [SP,#0xA4+buf_vil]
STR.W           which_pattern, [R9,#-0x30]!

loc_26050
LDRB.W          R1, [R12,#9]
ADD.W           R12, R12, #4
LDRB.W          LR, [R12,#4]
LDRB.W          R2, [R12,#7]
LDRB.W          R0, [R12,#6]
CMP             R12, R10
MOV.W           R1, R1,LSL#16
ORR.W           R1, R1, LR,LSL#24
ORR.W           R2, R2, R1
ORR.W           R2, R2, R0,LSL#8
STR.W           R2, [R9,#4]!
BNE             loc_26050
ADD.W           R12, SP, #0xA4+buf_vil+0x10
ADD.W           R9, SP, #0xA4+work_vil_1397.midstate+0xC

loc_26084
LDRB            R1, [R3,#0x15]
ADDS            R3, #4
LDRB.W          LR, [R3,#0x10]
LDRB            R2, [R3,#0x13]
LDRB            R0, [R3,#0x12]
CMP             R3, R9
MOV.W           R1, R1,LSL#16
ORR.W           R1, R1, LR,LSL#24
ORR.W           R2, R2, R1
ORR.W           R2, R2, R0,LSL#8
STR.W           R2, [R12,#4]!
BNE             loc_26084
ADD             R0, SP, #0xA4+buf_vil ; value
BL              set_TW_write_command
LDR             R0, [SP,#0xA4+OpenCoreNum4] ; mutex
BLX             pthread_mutex_lock
LDR             R3, [SP,#0xA4+var_84]
ADD.W           R0, R3, #0x2180
LDR             R3, [SP,#0xA4+var_80]
ADDS            R0, #0x3C ; '<'
ADD             R0, R3  ; dest

loc_260C0
SUB.W           R9, R0, #0x44 ; 'D'
MOVS            R2, #0x44 ; 'D' ; n
MOV             R1, R9  ; src
BLX             memcpy
CMP             R4, R9
MOV             R0, R9
BNE             loc_260C0
MOVW            R2, #:lower16:gWork_Num_For_Hw_Check
MOV             R1, work ; src
MOVT            R2, #:upper16:gWork_Num_For_Hw_Check
MOV             R0, R4  ; dest
LDRB            R3, [R2]
ADDS            which_pattern, #1
ADDS            R3, #1
UXTB            R3, R3
CMP             R3, #0x7E ; '~'
IT HI
MOVHI           R3, #0x7F
STRB            R3, [R2]
MOVS            R2, #0x44 ; 'D' ; n
BLX             memcpy
LDR             R0, [SP,#0xA4+OpenCoreNum4] ; mutex
BLX             pthread_mutex_unlock
which_pattern = R5      ; unsigned int
LDR.W           R3, [R11,which_chain,LSL#2]
ADDS            R3, #1
STR.W           R3, [R11,which_chain,LSL#2]

loc_26104
LDR.W           R3, [R8,#configuration.pattern_number]
CMP             which_pattern, R3
BCC.W           loc_25FBE

loc_2610E
LDR             R2, [SP,#0xA4+test_core_index]
LDR             R1, [SP,#0xA4+test_core_number]
ADDS            R2, #1
CMP             R1, R2
STR             R2, [SP,#0xA4+test_core_index]
test_core_index_0 = R2  ; unsigned int
BNE.W           loc_25FA0
MOV             test_core_index_0, R1
MUL             R2, R3, R2
LDR.W           R3, [R11,which_chain,LSL#2]
CMP             R3, R2
ITTTT CC
MOVWCC          which_pattern, #:lower16:__FUNCTION__.8795 ; "single_BM1397_send_func"
MOVWCC          R4, #:lower16:aSChainDSendWor ; "\n\n---%s: Chain%d send work num : %d, "...
MOVTCC          R5, #:upper16:__FUNCTION__.8795 ; "single_BM1397_send_func"
MOVTCC          R4, #:upper16:aSChainDSendWor ; "\n\n---%s: Chain%d send work num : %d, "...
BCS             loc_26184

loc_2613C
STR             R2, [SP,#0xA4+var_A4]
MOV             R1, R5
MOV             R2, which_chain
MOV             R0, R4  ; format
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R1, [SP,#0xA4+test_core_number]
LDR.W           R3, [R11,which_chain,LSL#2]
MUL             R2, R2, R1
CMP             R3, R2
BCC             loc_2613C
B               loc_26184

loc_2615C               ; useconds
which_pattern = R5      ; unsigned int
work_fifo_ready = R0    ; unsigned int
MOVW            work_fifo_ready, #0x1388
BLX             usleep
B               loc_26104

loc_26166               ; useconds
LDR             R0, [SP,#0xA4+useconds]
BLX             usleep
B               loc_25FC8

loc_2616E
test_core_number_0 = R5 ; unsigned int
OpenCoreNum2 = R6       ; unsigned int
OpenCoreNum5 = R9       ; unsigned int
OpenCoreNum6 = R10      ; unsigned int
OpenCoreNum7 = R11      ; unsigned int
MOVW            R3, #:lower16:gSend_Work_Num
MOVW            R2, #:lower16:gReadingTemp
MOVT            R3, #:upper16:gSend_Work_Num
MOVT            R2, #:upper16:gReadingTemp
LDR.W           R3, [R3,which_chain,LSL#2]
STR             R2, [SP,#0xA4+OpenCoreNum3]

loc_26184
work = R6               ; work *
MOVW            R1, #:lower16:__FUNCTION__.8795 ; "single_BM1397_send_func"
MOVW            R0, #:lower16:aSChainDSendWor_0 ; "\n\n---%s: Chain%d send work num : %d\n"
MOVT            R1, #:upper16:__FUNCTION__.8795 ; "single_BM1397_send_func"
MOV             R2, which_chain
MOVT            R0, #:upper16:aSChainDSendWor_0 ; "\n\n---%s: Chain%d send work num : %d\n"
MOVW            R4, #:lower16:gValid_Nonce_Num
BLX             printf
MOVW            R0, #:lower16:aSendTestPatter ; "\nsend test pattern done"
MOVT            R4, #:upper16:gValid_Nonce_Num
MOVT            R0, #:upper16:aSendTestPatter ; "\nsend test pattern done"
MOVW            R9, #:lower16:(gAsic_Core_Nonce_Num+0xC33FC)
BLX             puts
MOVW            R0, #:lower16:aDate ; "date"
MOVT            R9, #:upper16:(gAsic_Core_Nonce_Num+0xC33FC)
MOVT            R0, #:upper16:aDate ; "date"
MOVS            R5, #0
BLX             system
MOVS            R0, #0xA ; c
ADDS            R5, #1
BLX             putchar
LDR.W           R8, [R4,which_chain,LSL#2]
received_data = R8      ; unsigned int
MOV             R0, R9  ; useconds
MOV             work, received_data
count = R5              ; unsigned int
CMP             R8, work
BNE             loc_261EC

loc_261D8
CMP             count, #2
BHI             loc_261FE
BLX             usleep

loc_261E0
LDR.W           work, [R4,which_chain,LSL#2]
ADDS            R5, #1
count = R5              ; unsigned int
MOV             R0, R9  ; useconds
CMP             R8, work
BEQ             loc_261D8

loc_261EC
BLX             usleep
MOV             R8, work
MOVS            count, #0
B               loc_261E0

loc_261F6               ; useconds
count = R5              ; unsigned int
MOVW            R0, #0x2710
BLX             usleep

loc_261FE
LDR             R3, [SP,#0xA4+OpenCoreNum3]
LDRB            R3, [R3]
CMP             R3, #0
BNE             loc_261F6
MOVW            R3, #:lower16:start_receive
MOVW            R0, #:lower16:aToStopReceive ; "to stop receive"
MOVT            R3, #:upper16:start_receive
MOVS            R4, #0
MOVT            R0, #:upper16:aToStopReceive ; "to stop receive"
STRB            R4, [R3]
BLX             puts
MOV             R0, R4
ADD             SP, SP, #0xA4
POP.W           {R4-R11,PC}
; End of function single_BM1397_send_func

ALIGN 4
off_26228 DCD cgpu.workdataFilePrefix+0x3C



; uint32_t __fastcall BM1397_get_core_id(uint32_t nonce)
EXPORT BM1397_get_core_id
BM1397_get_core_id
nonce = R0              ; uint32_t
LSRS            R3, nonce, #0x1F
UBFX.W          nonce, nonce, #0x16, #9
ORR.W           R0, R3, R0,LSL#1
core_id = R0            ; uint32_t
BX              LR
; End of function BM1397_get_core_id




; void __fastcall BM1397_set_config(unsigned __int8 which_chain, unsigned __int8 asic_addr, unsigned __int8 reg_addr, unsigned int reg_data, bool mode)
EXPORT BM1397_set_config
BM1397_set_config

var_1C= -0x1C
var_18= -0x18
var_14= -0x14
cmd_buf= -0x10
mode=  0x14

which_chain = R0        ; unsigned __int8
asic_addr_0 = R1        ; unsigned __int8
reg_addr_0 = R2         ; unsigned __int8
reg_data = R3           ; unsigned int
PUSH            {R4-R7,LR}
SUB             SP, SP, #0x1C
LDRB.W          R6, [SP,#0x1C+mode]
MOVS            R4, #0
MOV             R5, which_chain
STRB.W          R4, [SP,#0x1C+var_14]
STR             R4, [SP,#0x1C+cmd_buf]
STR             R4, [SP,#0x1C+cmd_buf+4]
STR             R4, [SP,#0x1C+cmd_buf+8]
CMP             R6, #0
BEQ             loc_262C4
MOVS            which_chain, #0x51 ; 'Q'
STRB.W          R0, [SP,#0x1C+var_1C]

loc_26258
LSRS            R7, reg_data, #0x18
LSRS            R6, reg_data, #0x10
LSRS            R4, reg_data, #8
STRB.W          asic_addr_0, [SP,#0x1C+var_1C+2]
STRB.W          reg_addr_0, [SP,#0x1C+var_1C+3]
MOV             R0, SP  ; ptr
MOVS            reg_addr_0, #9
MOVS            asic_addr_0, #0x40 ; '@' ; len
STRB.W          reg_data, [SP,#0x1C+var_18+3]
STRB.W          R4, [SP,#0x1C+var_18+2]
STRB.W          R2, [SP,#0x1C+var_1C+1]
STRB.W          R7, [SP,#0x1C+var_18]
STRB.W          R6, [SP,#0x1C+var_18+1]
BL              CRC5
LDR             R2, [SP,#0x1C+var_1C]
MOV             R1, R0
LDR             R3, [SP,#0x1C+var_18]
LSLS            R4, R1, #0x18
ADD             R0, SP, #0x1C+cmd_buf ; value
STRB.W          R1, [SP,#0x1C+var_14]
REV             R2, R2
STR             R4, [SP,#0x1C+cmd_buf+8]
REV             R3, R3
STR             R2, [SP,#0x1C+cmd_buf]
STR             R3, [SP,#0x1C+cmd_buf+4]
BL              set_BC_command_buffer
BL              get_BC_write_command
ret = R0                ; unsigned int
MOVS            R3, #0
BIC.W           ret, ret, #0xF0000
MOVT            R3, #0x8080
ORR.W           R3, R3, R5,LSL#16
ORRS            R0, R3  ; value
BL              set_BC_write_command
MOVW            R0, #0x2710 ; useconds
BLX             usleep
ADD             SP, SP, #0x1C
POP             {R4-R7,PC}

loc_262C4
which_chain = R0        ; unsigned __int8
asic_addr_0 = R1        ; unsigned __int8
reg_addr_0 = R2         ; unsigned __int8
reg_data = R3           ; unsigned int
MOVS            which_chain, #0x41 ; 'A'
STRB.W          R0, [SP,#0x1C+var_1C]
B               loc_26258
; End of function BM1397_set_config




; void __fastcall BM1397_get_status(unsigned __int8 which_chain, unsigned __int8 asic_addr, unsigned __int8 reg_addr, unsigned __int8 mode)
EXPORT BM1397_get_status
BM1397_get_status

buf= -0x14
cmd_buf= -0xC

which_chain = R0        ; unsigned __int8
asic_addr = R1          ; unsigned __int8
reg_addr = R2           ; unsigned __int8
mode = R3               ; unsigned __int8
PUSH            {R4-R6,LR}
MOVS            R4, #0
SUB             SP, SP, #0x18
MOV             R5, which_chain
MOV             R6, asic_addr
STRB.W          R4, [SP,#0x18+buf+4]
STR             R4, [SP,#0x18+cmd_buf]
STR             R4, [SP,#0x18+cmd_buf+4]
STR             R4, [SP,#0x18+cmd_buf+8]
CBZ             mode, loc_26330
MOVS            mode, #0x52 ; 'R'
STRB.W          R3, [SP,#0x18+buf]

loc_262E8
MOVS            R3, #5
ADD             which_chain, SP, #0x18+buf ; ptr
MOVS            asic_addr, #0x20 ; ' ' ; len
STRB.W          reg_addr, [SP,#0x18+buf+3]
STRB.W          R3, [SP,#0x18+buf+1]
STRB.W          R6, [SP,#0x18+buf+2]
BL              CRC5
LDR             R3, [SP,#0x18+buf]
MOV             R2, R0
LSLS            R1, R2, #0x18
ADD             R0, SP, #0x18+cmd_buf ; value
STRB.W          R2, [SP,#0x18+buf+4]
REV             R3, R3
STR             R1, [SP,#0x18+cmd_buf+4]
STR             R3, [SP,#0x18+cmd_buf]
BL              set_BC_command_buffer
BL              get_BC_write_command
ret = R0                ; unsigned int
MOVS            R3, #0
BIC.W           ret, ret, #0xF0000
MOVT            R3, #0x8080
ORR.W           R3, R3, R5,LSL#16
ORRS            R0, R3  ; value
BL              set_BC_write_command
ADD             SP, SP, #0x18
POP             {R4-R6,PC}

loc_26330
which_chain = R0        ; unsigned __int8
asic_addr = R1          ; unsigned __int8
reg_addr = R2           ; unsigned __int8
mode = R3               ; unsigned __int8
MOVS            mode, #0x42 ; 'B'
STRB.W          R3, [SP,#0x18+buf]
B               loc_262E8
; End of function BM1397_get_status




; void __fastcall BM1397_set_clock_order(unsigned __int8 which_chain, unsigned __int8 chip_addr, bool mode)
EXPORT BM1397_set_clock_order
BM1397_set_clock_order

var_8= -8

which_chain = R0        ; unsigned __int8
chip_addr = R1          ; unsigned __int8
mode = R2               ; bool
PUSH            {R4-R6,LR}
MOV             R4, which_chain
MOVW            which_chain, #:lower16:aChainDSetOrder ; "chain[%d]: set order clock, stragegy 3"...
SUB             SP, SP, #8
MOV             R6, mode
MOV             R5, chip_addr
MOVT            R0, #:upper16:aChainDSetOrder ; "chain[%d]: set order clock, stragegy 3"...
MOV             chip_addr, R4
BLX             printf
MOV             R1, R5  ; asic_addr
MOV             R0, R4  ; which_chain
STR             R6, [SP,#8+var_8] ; mode
MOVS            R3, #0  ; reg_data
MOVS            R2, #0x80 ; reg_addr
BL              BM1397_set_config
MOV             R1, R5  ; asic_addr
MOV             R0, R4  ; which_chain
MOVS            R3, #0  ; reg_data
MOVS            R2, #0x84 ; reg_addr
STR             R6, [SP,#8+var_8] ; mode
BL              BM1397_set_config
MOV             R0, #0x186A0 ; useconds
BLX             usleep
STR             R6, [SP,#8+var_8] ; mode
MOV             R1, R5  ; asic_addr
MOV             R0, R4  ; which_chain
MOVS            R3, #1  ; reg_data
MOVS            R2, #0x20 ; ' ' ; reg_addr
BL              BM1397_set_config
ADD             SP, SP, #8
POP             {R4-R6,PC}
; End of function BM1397_set_clock_order

ALIGN 4



; void __fastcall set_BM1397_freq(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int freq, bool mode)
EXPORT set_BM1397_freq
set_BM1397_freq

var_14= -0x14
var_C= -0xC
var_8= -8

which_chain = R0        ; unsigned __int8
chip_addr = R1          ; unsigned __int8
freq = R2               ; unsigned int
mode = R3               ; bool
VMOV            S15, freq
PUSH.W          {R4-R11,LR}
MOVS            R4, #0
VPUSH           {D8-D13}
MOV             R9, which_chain
MOV             R10, chip_addr
MOV             R11, R4
VCVT.F32.U32    S19, S15
MOV             R8, R4
VLDR            S11, =0.0
MOV             R7, R4
VLDR            S23, =3200.0
SUB             SP, SP, #0x14
VLDR            S22, =3125.0
VLDR            D12, =0.0001
VLDR            S18, =2000.0
VLDR            D8, =0.000001
VMOV.F32        S26, #25.0
VMOV.F32        S21, #2.0
VMOV.F32        S20, #1.0
STR             mode, [SP,#0x14+var_8]

loc_263D0
VCMPE.F32       S23, S22
VMOV.F32        S14, #12.5
VMRS            APSR_nzcv, FPSCR
VMOV.F32        S15, #25.0
ITE MI
MOVMI           R2, #2
MOVPL           R2, #1
ITE PL
VMOVPL.F32      S13, S20
VMOVMI.F32      S13, S21
IT PL
VMOVPL.F32      S14, S15
CBZ             R4, loc_26400
VSUB.F32        S23, S11, S14
VMOV.F32        S26, S15

loc_26400
VDIV.F32        S15, S23, S19
VCVT.U32.F32    S12, S15
VSTR            S12, [SP,#0x14+var_C]
VCVT.F32.U32    S12, S12
VSUB.F32        S15, S15, S12
VCMPE.F32       S15, S26
VMRS            APSR_nzcv, FPSCR
BPL             loc_26452
VMUL.F32        S13, S23, S13
MOV             R8, R2
VMOV.F32        S9, #25.0
VCVT.F64.F32    D5, S15
LDRB.W          R11, [SP,#0x14+var_C]
VDIV.F32        S12, S13, S9
VMOV.F32        S26, S15
VCMPE.F64       D5, D8
VMRS            APSR_nzcv, FPSCR
VCVT.U32.F32    S13, S12
VSTR            S13, [SP,#0x14+var_C]
LDRB.W          R7, [SP,#0x14+var_C]
BMI             loc_26466
VMOV.F32        S11, S23

loc_26452
VSUB.F32        S23, S23, S14
VCMPE.F32       S23, S18
VMRS            APSR_nzcv, FPSCR
BGE.W           loc_265AC
VMOV.F32        S23, S11

loc_26466
CMP.W           R11, #0x10
BLS.W           loc_26614
VMOV            S15, R11
MOVS            R2, #0xF
VCVT.F32.U32    S13, S15

loc_26478
VMOV            S15, R2
UXTB            R4, R2
SUBS            R2, #1
VCVT.F32.S32    S15, S15
SUBS            R1, R4, #1
VDIV.F32        S14, S13, S15
VCVT.U32.F32    S15, S14
VCVT.F32.U32    S15, S15
VSUB.F32        S14, S14, S15
VCVT.F64.F32    D7, S14
VCMPE.F64       D7, D12
VMRS            APSR_nzcv, FPSCR
BMI.W           loc_265B0
CMP             R2, #1
UXTB            R4, R1
BNE             loc_26478
CMP             R4, #2
BEQ.W           loc_265C2

loc_264B2
CMP.W           R11, #7
BLS.W           loc_2661E
VMOV            S15, R11
MOVS            R5, #6
VCVT.F32.U32    S13, S15

loc_264C4
VMOV            S15, R5
SUBS            R2, R5, #1
VCVT.F32.S32    S15, S15
VDIV.F32        S14, S13, S15
VCVT.U32.F32    S15, S14
VSTR            S15, [SP,#0x14+var_C]
VCVT.F32.U32    S15, S15
VSUB.F32        S14, S14, S15
VCVT.F64.F32    D7, S14
VCMPE.F64       D7, D12
VMRS            APSR_nzcv, FPSCR
BMI             loc_265EA
UXTB            R5, R2
CMP             R5, #0xFF
BNE             loc_264C4
MOV             R2, R5
MOVS            R6, #1

loc_264FA
CMP             R11, R2
MOV             R1, R11
BNE.W           loc_26626
LSLS            R5, R5, #4

loc_26504
VMOV            S15, R8
MUL             R1, R1, R4
VMOV.F32        S12, #25.0
ORRS            R5, R6
VCVT.F32.S32    S15, S15
ORR.W           R5, R5, R7,LSL#16
VMOV            S14, R7
MOVW            R0, #:lower16:aSWantFreqFReal ; "\n--- %s: Want freq %f  real freq %f\n"
VCVT.F64.F32    D5, S19
ORR.W           R5, R5, R8,LSL#8
VCVT.F32.S32    S14, S14
SUBS            R4, #1
VDIV.F32        S13, S12, S15
ORR.W           R5, R5, #0xC0000000
VMOV            S15, R1
MOVT            R0, #:upper16:aSWantFreqFReal ; "\n--- %s: Want freq %f  real freq %f\n"
VMOV            R2, R3, D5
VCVT.F32.S32    S15, S15
LDR             R1, =__FUNCTION__.8248 ; "BM1397_get_pllparam_divider"
VMUL.F32        S13, S13, S14
VDIV.F32        S14, S13, S15
VCVT.F64.F32    D7, S14
VSTR            D7, [SP,#0x14+var_14]
BLX             printf

loc_2655E
LDR             R6, [SP,#0x14+var_8]
MOV             R3, R5  ; reg_data
MOV             R1, R10 ; asic_addr
MOVS            R2, #8  ; reg_addr
MOV             R0, R9  ; which_chain
STR             R6, [SP,#0x14+var_14] ; mode
BL              BM1397_set_config
MOVW            R0, #0x2710 ; useconds
BLX             usleep
MOV             R3, R4  ; reg_data
MOV             R1, R10 ; asic_addr
MOVS            R2, #0x70 ; 'p' ; reg_addr
MOV             R0, R9  ; which_chain
STR             R6, [SP,#0x14+var_14] ; mode
BL              BM1397_set_config
MOVW            R0, #0x2710 ; useconds
BLX             usleep
MOV             R0, R9  ; which_chain
STR             R6, [SP,#0x14+var_14] ; mode
MOV             R3, R5  ; reg_data
MOV             R1, R10 ; asic_addr
MOVS            R2, #8  ; reg_addr
BL              BM1397_set_config
MOVW            R0, #0x2710 ; useconds
ADD             SP, SP, #0x14
VPOP            {D8-D13}
POP.W           {R4-R11,LR}
B.W             j_usleep

loc_265AC
MOVS            R4, #0
B               loc_263D0

loc_265B0
MOV             R0, R11
MOV             R1, R4
BL              __aeabi_uidiv
CMP             R4, #2
UXTB.W          R11, R0
BNE.W           loc_264B2

loc_265C2
TST.W           R11, #1
BEQ.W           loc_264B2
MOVW            R0, #:lower16:aSNeedRecal1 ; "\n--- %s: need recal 1\n"
LDR             R1, =__FUNCTION__.8248 ; "BM1397_get_pllparam_divider"
MOVT            R0, #:upper16:aSNeedRecal1 ; "\n--- %s: need recal 1\n"
BLX             printf
VCMPE.F32       S23, S18
VMRS            APSR_nzcv, FPSCR
BLE             loc_26656

loc_265E2
VMOV.F32        S11, S23
MOVS            R4, #1
B               loc_263D0

loc_265EA
LDRB.W          R6, [SP,#0x14+var_C]
CMP             R6, #7
IT LS
CMPLS           R6, R5
BLS             loc_2660E
MOVW            R0, #:lower16:aSNeedRecal2 ; "\n--- %s: need recal 2\n"
LDR             R1, =__FUNCTION__.8248 ; "BM1397_get_pllparam_divider"
MOVT            R0, #:upper16:aSNeedRecal2 ; "\n--- %s: need recal 2\n"
BLX             printf
VCMPE.F32       S23, S18
VMRS            APSR_nzcv, FPSCR
BGT             loc_265E2

loc_2660E
MUL             R2, R6, R5
B               loc_264FA

loc_26614
MOVS            R1, #1
MOV             R4, R11
MOV             R6, R1
MOVS            R5, #0x10
B               loc_26504

loc_2661E
MOV             R1, R11
MOVS            R6, #1
LSLS            R5, R1, #4
B               loc_26504

loc_26626
MOVW            R0, #:lower16:aSDonTFindPostd ; "\n--- %s: Don't find postdiv1 %d * post"...
MOV             R2, R5
MOV             R3, R6
LDR             R1, =__FUNCTION__.8248 ; "BM1397_get_pllparam_divider"
STR.W           R11, [SP,#0x14+var_14]
MOVT            R0, #:upper16:aSDonTFindPostd ; "\n--- %s: Don't find postdiv1 %d * post"...
BLX             printf
MOVW            R0, #:lower16:aSSetFreqDonTOk ; "\n--- %s: !!!!!!!!!!!!!!!Set freq don't"...
LDR             R1, =__FUNCTION__.8248 ; "BM1397_get_pllparam_divider"
MOVT            R0, #:upper16:aSSetFreqDonTOk ; "\n--- %s: !!!!!!!!!!!!!!!Set freq don't"...
MOVW            R5, #0x111
BLX             printf
MOVT            R5, #0xC078
MOVS            R4, #0xE
B               loc_2655E

loc_26656
MOVW            R0, #:lower16:aSSetFreqDonTOk ; "\n--- %s: !!!!!!!!!!!!!!!Set freq don't"...
MOVW            R5, #0x111
LDR             R1, =__FUNCTION__.8248 ; "BM1397_get_pllparam_divider"
MOVT            R0, #:upper16:aSSetFreqDonTOk ; "\n--- %s: !!!!!!!!!!!!!!!Set freq don't"...
MOVT            R5, #0xC078
MOVS            R4, #0xE
BLX             printf
B               loc_2655E
; End of function set_BM1397_freq

dbl_26670 DCFD 0.0001
dbl_26678 DCFD 0.000001
flt_26680 DCFS 0.0
flt_26684 DCFS 3200.0
flt_26688 DCFS 3125.0
flt_2668C DCFS 2000.0
off_26690 DCD __FUNCTION__.8248 ; "BM1397_get_pllparam_divider"



; void __fastcall set_BM1397_freq_slowly(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int freq, bool mode)
EXPORT set_BM1397_freq_slowly
set_BM1397_freq_slowly
which_chain = R0        ; unsigned __int8
chip_addr = R1          ; unsigned __int8
freq = R2               ; unsigned int
mode = R3               ; bool
PUSH.W          {R4-R8,LR}
MOV             R5, which_chain
MOV             R6, chip_addr
MOV             R7, freq
MOVS            R4, #0x32 ; '2'

loc_266A0               ; mode
freq = R7               ; unsigned int
temp_freq = R4          ; unsigned int
MOVS            R3, #1
MOV             R2, temp_freq ; freq
MOV             R1, R6  ; chip_addr
MOV             R0, R5  ; which_chain
BL              set_BM1397_freq
ADD.W           R3, R4, #0x32 ; '2'
ADDS            R4, #0x19
temp_freq = R4          ; unsigned int
CMP             freq, R3
BHI             loc_266A0
MOV             R2, freq
MOV             R1, R6
MOV             R0, R5
MOVS            R3, #1
POP.W           {temp_freq-R8,LR}
freq = R2               ; unsigned int
B.W             set_BM1397_freq
; End of function set_BM1397_freq_slowly

ALIGN 4



; unsigned int __fastcall check_BM1397_asic_reg(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 reg, bool mode)
EXPORT check_BM1397_asic_reg
check_BM1397_asic_reg

var_14= -0x14
var_10= -0x10
reg_buf= -0xC

which_chain = R0        ; unsigned __int8
chip_addr = R1          ; unsigned __int8
reg = R2                ; unsigned __int8
mode = R3               ; bool
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x14
MOV             R7, reg
MOV             R6, which_chain
MOV             R4, chip_addr
MOV             R5, mode
STR             reg, [SP,#0x14+var_10]
MOVS            reg, #0
STR             R2, [SP,#0x14+reg_buf]
STR.W           R2, [SP,#0x14+reg_buf+3]
BL              clear_register_value_buf
MOV             R3, R5  ; mode
MOV             R2, R7  ; reg_addr
MOV             R1, R4  ; asic_addr
MOV             R0, R6  ; which_chain
BL              BM1397_get_status
CBNZ            R7, loc_266FA
LDR             R3, =(cgpu.subid+0x7FD54)
ADD             R3, R6
STRB.W          R7, [R3,#0x30C]

loc_266FA
MOVW            R3, #:lower16:cgpu
MOVS            R2, #0
MOVT            R3, #:upper16:cgpu
MOVW            R7, #:lower16:reg_value_buf
MOVW            R5, #:lower16:reg_mutex
ADD.W           R10, R3, R6
MOV             R4, R2
MOVT            R7, #:upper16:reg_value_buf
MOVT            R5, #:upper16:reg_mutex
STR             R2, [SP,#0x14+var_14]

loc_2671C               ; useconds
not_reg_data_time = R4  ; unsigned int
MOVW            R0, #0x7530
BLX             usleep
MOV             R0, R5  ; mutex
BLX             pthread_mutex_lock
LDR             R3, [R7]
MOV             R0, R5  ; mutex
LDR.W           R8, [R3,#8]
reg_value_num = R8      ; unsigned int
BLX             pthread_mutex_unlock
CMP.W           reg_value_num, #0
BEQ.W           loc_2686E
MOVS            not_reg_data_time, #0
ADD.W           R11, R10, #0x100000
B               loc_26782

loc_26746
i = R4                  ; unsigned int
LDR             R1, [R2,#8]
ADDS            R3, #1
CMP.W           R3, #0x200
STR             R3, [R2,#4]
MOVW            R0, #:lower16:aSTheReturnData ; "%s: the return data is from chain%d, bu"...
ADD.W           i, i, #1
ADD.W           R1, R1, #0xFFFFFFFF
MOVT            R0, #:upper16:aSTheReturnData ; "%s: the return data is from chain%d, bu"...
STR             R1, [R2,#8]
ITTT EQ
MOVEQ           R1, #0
MOVEQ           R3, R1
STREQ           R1, [R2,#4]
ADD.W           R3, R2, R3,LSL#3
LDR             R1, =__FUNCTION__.8312_0 ; "check_BM1397_asic_reg"
LDRB            R2, [R3,#0x17]
MOV             R3, R6
BLX             printf
MOV             R0, R5  ; mutex
BLX             pthread_mutex_unlock
i = R4                  ; unsigned int
CMP             reg_value_num, i
BEQ             loc_2681E

loc_26782               ; mutex
MOV             R0, R5
BLX             pthread_mutex_lock
LDR             R2, [R7]
LDR             R3, [R2,#4]
ADD.W           R1, R2, R3,LSL#3
LDRB            R1, [R1,#0x17]
CMP             R1, R6
BNE             loc_26746
MOV.W           R9, #0
MOVS            R1, #0x33 ; '3' ; len
STR.W           R9, [SP,#0x14+reg_buf]
ADD             R0, SP, #0x14+reg_buf ; ptr
STR.W           R9, [SP,#0x14+reg_buf+3]
LDR             R3, [R2,#4]
ADD.W           R3, R2, R3,LSL#3
LDR             R2, [R3,#0x10]
LDRB.W          LR, [R3,#0x14]
LDRB            R3, [R3,#0x15]
STRB.W          R2, [SP,#0x14+reg_buf+3]
MOV.W           R12, R2,LSR#8
STRB.W          LR, [SP,#0x14+reg_buf+4]
MOV.W           LR, R2,LSR#16
LSRS            R2, R2, #0x18
STRB.W          R3, [SP,#0x14+reg_buf+5]
STRB.W          LR, [SP,#0x14+reg_buf+1]
STRB.W          R2, [SP,#0x14+reg_buf]
STRB.W          R12, [SP,#0x14+reg_buf+2]
BL              CRC5
LDR             R1, [R7]
MOV             R2, R0
crc_value = R2          ; unsigned __int8
LDR             R0, [R1,#4]
ADD.W           LR, R1, R0,LSL#3
LDRB.W          R3, [LR,#0x16]
CMP             crc_value, R3
BEQ             loc_26822
MOVW            R0, #:lower16:aSCrcIs0xXButIt ; "%s: crc is 0x%x, but it should be 0x%x"...
LDR             R1, =__FUNCTION__.8312_0 ; "check_BM1397_asic_reg"
MOVT            R0, #:upper16:aSCrcIs0xXButIt ; "%s: crc is 0x%x, but it should be 0x%x"...
BLX             printf
LDR             R3, [R7]
LDR             R2, [R3,#4]
LDR             R1, [R3,#8]
ADDS            R2, #1
SUBS            R1, #1
CMP.W           R2, #0x200
STR             R2, [R3,#4]
STR             R1, [R3,#8]
IT EQ
STREQ.W         R9, [R3,#4]

loc_26812               ; mutex
MOV             R0, R5
ADDS            i, #1
BLX             pthread_mutex_unlock
i = R4                  ; unsigned int
CMP             reg_value_num, i
BNE             loc_26782

loc_2681E
MOVS            i, #0
B               loc_2671C

loc_26822
crc_value = R2          ; unsigned __int8
i = R4                  ; unsigned int
LDR             R3, [SP,#0x14+var_10]
CBNZ            R3, loc_2684C
LDRB.W          R3, [SP,#0x14+reg_buf]
CMP             R3, #0x13
BNE             loc_26836
LDRB.W          R3, [SP,#0x14+reg_buf+1]
CMP             R3, #0x97
BEQ             loc_268B0

loc_26836
MOVW            R0, #:lower16:aSErrorAsicAddr ; "%s: error asic address : 0x%08x\n"
LDR             R1, =__FUNCTION__.8312_0 ; "check_BM1397_asic_reg"
LDR.W           crc_value, [LR,#0x10]
MOVT            R0, #:upper16:aSErrorAsicAddr ; "%s: error asic address : 0x%08x\n"
BLX             printf
LDR             R1, [R7]
LDR             R0, [R1,#4]

loc_2684C
LDR             R3, [R1,#8]
ADDS            R2, R0, #2
LDR.W           R2, [R1,R2,LSL#3]
ADDS            R0, #1
CMP.W           R0, #0x200
STR             R0, [R1,#4]
ADD.W           R3, R3, #0xFFFFFFFF
STR             R3, [R1,#8]
IT EQ
MOVEQ           R3, #0
STR             R2, [SP,#0x14+var_14]
ret = R2                ; unsigned int
IT EQ
STREQ           R3, [R1,#4]
B               loc_26812

loc_2686E
not_reg_data_time = R4  ; unsigned int
ADDS            not_reg_data_time, #1
MOVW            R0, #0x7530 ; useconds
BLX             usleep
not_reg_data_time = R4  ; unsigned int
CMP             not_reg_data_time, #3
BNE.W           loc_2671C
LDR             R3, [SP,#0x14+var_10]
CBNZ            R3, loc_268A4
MOV             R2, #cgpu
ADDS            R3, R2, R6
ADD.W           R2, R2, #0x100000
ADD.W           R3, R3, #0x100000
LDR.W           R1, [R2,#(cgpu.max_asic_num_in_one_chain - 0x330FC4)]
LDRB.W          R3, [R3,#0x30C]
CMP             R3, R1
IT HI
STRHI.W         R3, [R2,#(cgpu.max_asic_num_in_one_chain - 0x330FC4)]

loc_268A4
BL              clear_register_value_buf
LDR             R0, [SP,#0x14+var_14]
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}

loc_268B0
crc_value = R2          ; unsigned __int8
i = R4                  ; unsigned int
LDRB.W          R3, [R11,#0x30C]
ADDS            R3, #1
STRB.W          R3, [R11,#0x30C]
LDR             R0, [R1,#4]
B               loc_2684C
; End of function check_BM1397_asic_reg

ALIGN 0x10
off_268C0 DCD cgpu.subid+0x7FD54
off_268C4 DCD __FUNCTION__.8312_0 ; "check_BM1397_asic_reg"



; void __fastcall BM1397_chain_inactive(unsigned __int8 which_chain)
EXPORT BM1397_chain_inactive
BM1397_chain_inactive

buf= -0x18
cmd_buf= -0x10

which_chain = R0        ; unsigned __int8
PUSH            {R4,R5,LR}
MOV             R5, which_chain
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
SUB             SP, SP, #0x1C
MOVS            R4, #0
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             R1, =__FUNCTION__.8327 ; "BM1397_chain_inactive"
STRB.W          R4, [SP,#0x1C+buf+4]
STR             R4, [SP,#0x1C+buf]
STR             R4, [SP,#0x1C+cmd_buf]
STR             R4, [SP,#0x1C+cmd_buf+4]
STR             R4, [SP,#0x1C+cmd_buf+8]
BLX             printf
MOVS            R2, #0x53 ; 'S'
MOVS            R3, #5
ADD             R0, SP, #0x1C+buf ; ptr
MOVS            R1, #0x20 ; ' ' ; len
STRB.W          R2, [SP,#0x1C+buf]
STRB.W          R3, [SP,#0x1C+buf+1]
STRB.W          R4, [SP,#0x1C+buf+2]
STRB.W          R4, [SP,#0x1C+buf+3]
BL              CRC5
LDR             R2, [SP,#0x1C+buf]
MOV             R1, R0
LSLS            R3, R1, #0x18
ADD             R0, SP, #0x1C+cmd_buf ; value
STRB.W          R1, [SP,#0x1C+buf+4]
REV             R2, R2
STR             R3, [SP,#0x1C+cmd_buf+4]
STR             R2, [SP,#0x1C+cmd_buf]
BL              set_BC_command_buffer
BL              get_BC_write_command
ret = R0                ; unsigned int
MOV             R3, R4
BIC.W           ret, ret, #0xF0000
MOVT            R3, #0x8080
ORR.W           R3, R3, R5,LSL#16
ORRS            R0, R3  ; value
BL              set_BC_write_command
MOVW            R0, #0x1388 ; useconds
BLX             usleep
ADD             SP, SP, #0x1C
POP             {R4,R5,PC}
; End of function BM1397_chain_inactive

off_26940 DCD __FUNCTION__.8327 ; "BM1397_chain_inactive"



; void __fastcall BM1397_set_address(unsigned __int8 which_chain, unsigned __int8 address)
EXPORT BM1397_set_address
BM1397_set_address

ptr= -0x18
var_14= -0x14
cmd_buf= -0x10

which_chain = R0        ; unsigned __int8
address_0 = R1          ; unsigned __int8
PUSH            {R4,R5,LR}
MOVS            R3, #0
SUB             SP, SP, #0x1C
MOV             R4, which_chain
MOVS            R2, #5
ADD             which_chain, SP, #0x1C+ptr ; ptr
STR             R3, [SP,#0x1C+ptr]
MOVS            R5, #0x40 ; '@'
STRB.W          address_0, [SP,#0x1C+ptr+2]
MOVS            address_0, #0x20 ; ' ' ; len
STR             R3, [SP,#0x1C+cmd_buf]
STR             R3, [SP,#0x1C+cmd_buf+4]
STR             R3, [SP,#0x1C+cmd_buf+8]
STRB.W          R3, [SP,#0x1C+var_14]
STRB.W          R2, [SP,#0x1C+ptr+1]
STRB.W          R5, [SP,#0x1C+ptr]
BL              CRC5
LDR             R2, [SP,#0x1C+ptr]
MOV             R1, R0
LSLS            R3, R1, #0x18
ADD             R0, SP, #0x1C+cmd_buf ; value
STRB.W          R1, [SP,#0x1C+var_14]
REV             R2, R2
STR             R3, [SP,#0x1C+cmd_buf+4]
STR             R2, [SP,#0x1C+cmd_buf]
BL              set_BC_command_buffer
BL              get_BC_write_command
ret = R0                ; unsigned int
MOVS            R3, #0
BIC.W           ret, ret, #0xF0000
MOVT            R3, #0x8080
ORR.W           R3, R3, R4,LSL#16
ORRS            R0, R3  ; value
BL              set_BC_write_command
ADD             SP, SP, #0x1C
POP             {R4,R5,PC}
; End of function BM1397_set_address

ALIGN 4



; void __fastcall set_baud_ext(unsigned __int8 which_chain, unsigned __int8 chip_addr, bool mode)
EXPORT set_baud_ext
set_baud_ext

var_C= -0xC

which_chain = R0        ; unsigned __int8
chip_addr = R1          ; unsigned __int8
mode = R2               ; bool
PUSH            {R4-R7,LR}
MOV             R5, which_chain
MOVW            which_chain, #:lower16:aSSetBaudExt ; "\n--- %s: set baud ext\n"
SUB             SP, SP, #0xC
MOV             R6, chip_addr
MOVT            R0, #:upper16:aSSetBaudExt ; "\n--- %s: set baud ext\n"
LDR             chip_addr, =__FUNCTION__.8355 ; "set_baud_ext"
MOVS            R4, #0xF
MOV             R7, mode
MOVT            R4, #0x600
fast_uart_conf = R4     ; fast_UART_configuration_t
BLX             printf
MOVS            R3, #0xF
MOVS            R2, #6
BFI.W           fast_uart_conf, R3, #0, #8
MOVW            R3, #0x111
BFC.W           fast_uart_conf, #0x10, #6
MOV             R1, R6  ; asic_addr
BFI.W           fast_uart_conf, R2, #0x18, #4
MOV             R0, R5  ; which_chain
STR             R7, [SP,#0xC+var_C] ; mode
MOVT            R3, #0xC070 ; reg_data
MOVS            R2, #0x68 ; 'h' ; reg_addr
BL              BM1397_set_config
MOV             R3, fast_uart_conf ; reg_data
STR             R7, [SP,#0xC+var_C] ; mode
MOV             R1, R6  ; asic_addr
MOV             R0, R5  ; which_chain
MOVS            R2, #0x28 ; '(' ; reg_addr
BL              BM1397_set_config
ADD             SP, SP, #0xC
POP             {fast_uart_conf-R7,PC}
; End of function set_baud_ext

off_269F8 DCD __FUNCTION__.8355 ; "set_baud_ext"



; void __fastcall single_BM1397_set_baud(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int asic_baud, bool mode)
EXPORT single_BM1397_set_baud
single_BM1397_set_baud

var_8= -8

which_chain = R0        ; unsigned __int8
chip_addr = R1          ; unsigned __int8
asic_baud = R2          ; unsigned int
mode = R3               ; bool
CMP             asic_baud, #4
PUSH.W          {R4-R8,LR}
MOV             R6, which_chain
SUB             SP, SP, #8
MOV             R7, chip_addr
MOV             R8, mode
BEQ             loc_26A74
CMP             asic_baud, #5
BEQ             loc_26A70
CMP             asic_baud, #3
BEQ             loc_26A4C
AND.W           chip_addr, asic_baud, #0x1F
UBFX.W          mode, asic_baud, #5, #4

loc_26A1C
MOVW            R5, #:lower16:gBM1397_MISC_CONTROL_reg
SUBS            asic_baud, #3
MOVT            R5, #:upper16:gBM1397_MISC_CONTROL_reg
CMP             R2, #2
LDR             R4, [R5]
BFI.W           R4, R1, #8, #5
misc_reg = R4           ; misc_ctrl_t
BFI.W           misc_reg, R3, #0x18, #4
BLS             loc_26A60

loc_26A34               ; mode
STR.W           R8, [SP,#8+var_8]
MOV             R1, R7  ; asic_addr
MOV             R0, R6  ; which_chain
MOV             R3, misc_reg ; reg_data
MOVS            R2, #0x18 ; reg_addr
STR             misc_reg, [R5]
BL              BM1397_set_config
ADD             SP, SP, #8
POP.W           {misc_reg-R8,PC}

loc_26A4C
which_chain = R0        ; unsigned __int8
chip_addr = R1          ; unsigned __int8
asic_baud = R2          ; unsigned int
mode = R3               ; bool
MOVS            mode, #7

loc_26A4E
MOV             R5, #gBM1397_MISC_CONTROL_reg
LDR             R4, [R5]
BFI.W           R4, R3, #8, #5
misc_reg = R4           ; misc_ctrl_t
BFC.W           misc_reg, #0x18, #4

loc_26A60               ; mode
MOV             R2, R8
MOV             R1, R7  ; chip_addr
MOV             which_chain, R6 ; which_chain
ORR.W           misc_reg, misc_reg, #0x10000
BL              set_baud_ext
B               loc_26A34

loc_26A70
which_chain = R0        ; unsigned __int8
chip_addr = R1          ; unsigned __int8
asic_baud = R2          ; unsigned int
mode = R3               ; bool
MOVS            mode, #1
B               loc_26A4E

loc_26A74
mode = R3               ; bool
MOVS            mode, #0
MOVS            chip_addr, #3
B               loc_26A1C
; End of function single_BM1397_set_baud

ALIGN 4



; void __fastcall single_BM1397_set_IO_strength(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int data, bool mode)
EXPORT single_BM1397_set_IO_strength
single_BM1397_set_IO_strength

var_C= -0xC

which_chain = R0        ; unsigned __int8
chip_addr = R1          ; unsigned __int8
data = R2               ; unsigned int
mode = R3               ; bool
PUSH            {R4-R7,LR}
MOV             R4, which_chain
MOVW            which_chain, #:lower16:aSIoStrengthIs0 ; "\n--- %s: IO strength is 0x%08x\n"
SUB             SP, SP, #0xC
MOV             R7, mode
MOV             R6, data
MOV             R5, chip_addr
MOVT            R0, #:upper16:aSIoStrengthIs0 ; "\n--- %s: IO strength is 0x%08x\n"
LDR             chip_addr, =__FUNCTION__.8370 ; "single_BM1397_set_IO_strength"
BLX             printf
STR             R7, [SP,#0xC+var_C] ; mode
MOV             R3, data ; reg_data
MOV             R1, R5  ; asic_addr
MOV             R0, R4  ; which_chain
MOVS            R2, #0x58 ; 'X' ; reg_addr
BL              BM1397_set_config
ADD             SP, SP, #0xC
POP             {R4-R7,PC}
; End of function single_BM1397_set_IO_strength

off_26AA8 DCD __FUNCTION__.8370 ; "single_BM1397_set_IO_strength"



; void reset_single_BM1397_global_arg()
EXPORT reset_single_BM1397_global_arg
reset_single_BM1397_global_arg

var_C= -0xC
var_8= -8

MOVW            R3, #:lower16:Conf
MOVW            R2, #:lower16:gBM1397_MISC_CONTROL_reg
PUSH.W          {R4-R11,LR}
MOVT            R3, #:upper16:Conf
SUB             SP, SP, #0xC
MOVT            R2, #:upper16:gBM1397_MISC_CONTROL_reg
MOVW            R1, #0x3A01
STR             R1, [R2]
LDR.W           R11, [R3,#configuration.OpenCoreNum1]
OpenCoreNum1 = R11      ; unsigned int
LDR.W           R10, [R3,#configuration.OpenCoreNum2]
OpenCoreNum2 = R10      ; unsigned int
LDR.W           R9, [R3,#configuration.OpenCoreNum3]
OpenCoreNum3 = R9       ; unsigned int
LDR.W           R8, [R3,#configuration.OpenCoreNum4]
OpenCoreNum4 = R8       ; unsigned int
LDR.W           R5, [R3,#configuration.OpenCoreNum5]
OpenCoreNum5 = R5       ; unsigned int
LDR.W           R7, [R3,#configuration.OpenCoreNum6]
OpenCoreNum6 = R7       ; unsigned int
LDR.W           R6, [R3,#configuration.OpenCoreNum7]
OpenCoreNum7 = R6       ; unsigned int
LDR.W           R4, [R3,#configuration.OpenCoreNum8]
STR             R3, [SP,#0xC+var_C]
OpenCoreNum8 = R4       ; unsigned int
BL              reset_global_arg
MOVW            R0, #:lower16:aS ; "\n--- %s\n"
LDR             R1, =__FUNCTION__.8390 ; "reset_single_BM1397_global_arg"
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
BLX             printf
LDR             R3, [SP,#0xC+var_C]
MOVS            R2, #0x20 ; ' '
MOV.W           R12, #0

loc_26B04
get_pattern_loop = R12  ; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum1 = R11      ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum2 = R10      ; unsigned int
TST.W           OpenCoreNum3, #1
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
IT NE
ADDNE.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum3 = R9       ; unsigned int
TST.W           OpenCoreNum4, #1
MOV.W           OpenCoreNum4, OpenCoreNum4,LSR#1
IT NE
ADDNE.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum4 = R8       ; unsigned int
LSLS            R0, OpenCoreNum5, #0x1F
MOV.W           OpenCoreNum5, OpenCoreNum5,LSR#1
IT MI
ADDMI.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum5 = R5       ; unsigned int
LSLS            R1, OpenCoreNum6, #0x1F
MOV.W           OpenCoreNum6, OpenCoreNum6,LSR#1
IT MI
ADDMI.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum6 = R7       ; unsigned int
LSLS            R0, OpenCoreNum7, #0x1F
MOV.W           OpenCoreNum7, OpenCoreNum7,LSR#1
IT MI
ADDMI.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum7 = R6       ; unsigned int
LSLS            R1, OpenCoreNum8, #0x1F
MOV.W           OpenCoreNum8, OpenCoreNum8,LSR#1
IT MI
ADDMI.W         get_pattern_loop, get_pattern_loop, #1
OpenCoreNum8 = R4       ; unsigned int
SUBS            R2, #1
BNE             loc_26B04
LDR             OpenCoreNum6, [R3,#configuration.pattern_number]
MOV             OpenCoreNum5, R2
LDR             R1, =0x3312CF
ADD.W           R3, get_pattern_loop, #0x20000
MOVW            OpenCoreNum7, #:lower16:cgpu
LDR.W           OpenCoreNum1, =(reg_mutex+0x14)
ADDS            R3, #0x2A ; '*'
MOVT            R6, #:upper16:cgpu
ADD.W           R2, R7, R7,LSL#4
MOVW            OpenCoreNum2, #:lower16:gRepeated_Nonce_Id
MOVW            OpenCoreNum3, #:lower16:gValid_Nonce_Num
STR             R1, [SP,#0xC+var_C]
MOVW            OpenCoreNum4, #:lower16:gSend_Work_Num
ADD.W           R6, R6, R3,LSL#2
MOV             R1, R5
LSLS            R3, R2, #2
MOVT            R10, #:upper16:gRepeated_Nonce_Id
MOVT            R9, #:upper16:gValid_Nonce_Num
MOVT            R8, #:upper16:gSend_Work_Num
STR             R3, [SP,#0xC+var_8]

loc_26BB0
LDR             R3, [SP,#0xC+var_C]
STR.W           R1, [R10],#4
STR.W           R1, [R9],#4
STRB.W          R1, [R3,#1]!
STR.W           R1, [R8],#4
STR             R3, [SP,#0xC+var_C]
CMP.W           get_pattern_loop, #0
BEQ             loc_26BEE
LDR             R3, [SP,#0xC+var_8]
MOV             R4, R11
LDR             R0, =(cgpu.workdataFilePrefix+0x3C)
ADD.W           LR, R5, R3

loc_26BD4
LDR.W           R2, [R0,#4]!
works = R2              ; work *
ADDS            R3, works, R5
ADD             works, LR
CBZ             R7, loc_26BE6

loc_26BDE
STR             R1, [R3,#0x34]
ADDS            R3, #0x44 ; 'D'
CMP             R3, R2
BNE             loc_26BDE

loc_26BE6
CMP             R0, R6
STR.W           R1, [R4,#4]!
BNE             loc_26BD4

loc_26BEE
ADDS            R5, #4
ADD.W           R11, R11, #0x80000
CMP             R5, #0x10
BNE             loc_26BB0
ADD             SP, SP, #0xC
POP.W           {R4-R11,PC}
; End of function reset_single_BM1397_global_arg

ALIGN 0x10
off_26C00 DCD __FUNCTION__.8390 ; "reset_single_BM1397_global_arg"
dword_26C04 DCD 0x3312CF
off_26C08 DCD cgpu.workdataFilePrefix+0x3C
off_26C0C DCD reg_mutex+0x14



; void single_BM1397_calculate_timeout_and_baud()
EXPORT single_BM1397_calculate_timeout_and_baud
single_BM1397_calculate_timeout_and_baud
MOVW            R0, #:lower16:aS ; "\n--- %s\n"
PUSH.W          {R4-R8,LR}
LDR             R1, =__FUNCTION__.8408 ; "single_BM1397_calculate_timeout_and_bau"...
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
MOVW            R6, #:lower16:Conf
BLX             printf
MOV.W           R0, #0x2A0 ; actual_core_number
BL              calculate_core_number
MOVW            R3, #:lower16:pattern_test_time
MOV             R4, R0
temp_corenum = R0       ; unsigned int
MOVT            R3, #:upper16:pattern_test_time
LDRB            R2, [R3]
CMP             R2, #8  ; switch 9 cases
BHI             def_26C3E ; jumptable 00026C3E default case
TBB.W           [PC,R2] ; switch jump
jpt_26C3E DCB 0x34      ; jump table for switch statement
DCB 0x38
DCB 0x3C
DCB 0x40
DCB 0x44
DCB 0x48
DCB 0x4C
DCB 0x50
DCB 5
ALIGN 2

loc_26C4C               ; jumptable 00026C3E case 8
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq9]

loc_26C52
temp_corenum = R4       ; unsigned int
temp_freq = R5          ; unsigned int
MOV             R1, temp_corenum
MOV.W           R0, #0x1000000
BL              __aeabi_uidiv
MOVW            R3, #:lower16:gChain_Asic_Interval
MOV             R1, temp_freq
MOVT            R3, #:upper16:gChain_Asic_Interval
MOVW            temp_corenum, #0x851F
LDR             R3, [R3]
MOVT            R4, #0x51EB
MOVS            R7, #0
MUL             R0, R3, R0
BL              __aeabi_uidiv
MOV             R3, R0
STR             temp_freq, [R6,#configuration.Freq]
ADD.W           R2, R3, R3,LSL#1
MOVW            R0, #:lower16:aSBaudrateDTime ; "\n---%s: Baudrate = %d, timeout = %d us"...
STR.W           R7, [R6,#configuration.baud]
MOVT            R0, #:upper16:aSBaudrateDTime ; "\n---%s: Baudrate = %d, timeout = %d us"...
RSB.W           R3, R3, R2,LSL#5
LDR             R1, =__FUNCTION__.8408 ; "single_BM1397_calculate_timeout_and_bau"...
MOV             R2, R7
UMULL           R4, temp_freq, R3, R4
LSRS            R4, temp_freq, #5
MOV             R3, R4
STR.W           R4, [R6,#configuration.timeout]
POP.W           {R4-R8,LR}
B.W             j_printf

loc_26CAA               ; jumptable 00026C3E case 0
temp_corenum = R0       ; unsigned int
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq1]
temp_freq = R5          ; unsigned int
B               loc_26C52

loc_26CB2               ; jumptable 00026C3E case 1
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq2]
temp_freq = R5          ; unsigned int
B               loc_26C52

loc_26CBA               ; jumptable 00026C3E case 2
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq3]
temp_freq = R5          ; unsigned int
B               loc_26C52

loc_26CC2               ; jumptable 00026C3E case 3
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq4]
temp_freq = R5          ; unsigned int
B               loc_26C52

loc_26CCA               ; jumptable 00026C3E case 4
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq5]
temp_freq = R5          ; unsigned int
B               loc_26C52

loc_26CD2               ; jumptable 00026C3E case 5
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq6]
temp_freq = R5          ; unsigned int
B               loc_26C52

loc_26CDA               ; jumptable 00026C3E case 6
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq7]
temp_freq = R5          ; unsigned int
B               loc_26C52

loc_26CE2               ; jumptable 00026C3E case 7
MOVT            R6, #:upper16:Conf
LDR             R5, [R6,#configuration.Freq8]
temp_freq = R5          ; unsigned int
B               loc_26C52

def_26C3E               ; jumptable 00026C3E default case
MOVW            temp_corenum, #:lower16:aSPatternTestTi ; "%s: pattern_test_time = %d, error!!! \n"
temp_corenum = R4       ; unsigned int
LDR             R1, =__FUNCTION__.8408 ; "single_BM1397_calculate_timeout_and_bau"...
MOVT            R0, #:upper16:aSPatternTestTi ; "%s: pattern_test_time = %d, error!!! \n"
MOVT            R6, #:upper16:Conf
MOVS            R5, #0
BLX             printf
B               loc_26C52
; End of function single_BM1397_calculate_timeout_and_baud

off_26D00 DCD __FUNCTION__.8408 ; "single_BM1397_calculate_timeout_and_bau"...



; void __fastcall BM1397_software_set_address(unsigned __int8 which_chain)
EXPORT BM1397_software_set_address
BM1397_software_set_address
which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R8,LR}
MOV             R7, which_chain
MOVW            which_chain, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R2, R7
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
MOVW            R6, #:lower16:BHB07601_ASIC_NUMBER
LDR             R1, =__FUNCTION__.8425 ; "BM1397_software_set_address"
MOVT            R6, #:upper16:BHB07601_ASIC_NUMBER
BLX             printf
MOV             R0, R7  ; which_chain
BL              BM1397_chain_inactive
LDR             R3, [R6]
CBZ             R3, locret_26D56
MOVS            R4, #0
MOVW            R8, #:lower16:gChain_Asic_Interval
MOV             R5, R4
MOVT            R8, #:upper16:gChain_Asic_Interval

loc_26D38               ; address
chip_addr = R5          ; unsigned int
i = R4                  ; unsigned int
UXTB            R1, chip_addr
MOV             R0, R7  ; which_chain
ADDS            i, #1
BL              BM1397_set_address
MOV.W           R0, #0x7D0 ; useconds
BLX             usleep
LDR             R3, [R6]
LDR.W           R2, [R8]
CMP             R3, R4
ADD             chip_addr, R2
i = R4                  ; unsigned int
BHI             loc_26D38

locret_26D56
POP.W           {R4-R8,PC}
; End of function BM1397_software_set_address

ALIGN 4
off_26D5C DCD __FUNCTION__.8425 ; "BM1397_software_set_address"



; void __fastcall BM1397_set_baud(unsigned __int8 which_chain, unsigned int baud)
EXPORT BM1397_set_baud
BM1397_set_baud
which_chain = R0        ; unsigned __int8
baud = R1               ; unsigned int
PUSH            {R3-R5,LR}
MOV             R5, which_chain
MOVW            which_chain, #:lower16:aSChainDBaudD ; "\n--- %s: Chain : %d, baud = %d\n"
MOV             R4, baud
MOV             R3, baud
MOV             R2, R5
LDR             baud, =__FUNCTION__.8433 ; "BM1397_set_baud"
baud = R3               ; unsigned int
MOVT            R0, #:upper16:aSChainDBaudD ; "\n--- %s: Chain : %d, baud = %d\n"
BLX             printf
MOV             R2, baud ; asic_baud
MOVS            R3, #1  ; mode
MOV             R0, R5  ; which_chain
MOVS            R1, #0  ; chip_addr
BL              single_BM1397_set_baud
MOVW            R0, #0xC350 ; useconds
BLX             usleep
UXTB            R0, baud ; asic_baud
BL              set_fpga_baud
MOVW            R0, #0xC350 ; useconds
POP.W           {R3-R5,LR}
B.W             j_usleep
; End of function BM1397_set_baud

ALIGN 0x10
off_26DA0 DCD __FUNCTION__.8433 ; "BM1397_set_baud"



; void __fastcall BM1397_set_TM(unsigned __int8 which_chain, unsigned __int8 asic_addr, unsigned int tm, bool mode)
EXPORT BM1397_set_TM
BM1397_set_TM

var_1C= -0x1C
var_18= -0x18
var_14= -0x14
cmd_buf= -0x10

which_chain = R0        ; unsigned __int8
asic_addr_0 = R1        ; unsigned __int8
tm = R2                 ; unsigned int
mode = R3               ; bool
PUSH            {R4-R7,LR}
MOVS            R4, #0
SUB             SP, SP, #0x1C
MOV             R5, which_chain
STRB.W          R4, [SP,#0x1C+var_14]
STR             R4, [SP,#0x1C+cmd_buf]
STR             R4, [SP,#0x1C+cmd_buf+4]
STR             R4, [SP,#0x1C+cmd_buf+8]
CMP             mode, #0
BEQ             loc_26E46
MOVS            mode, #0x51 ; 'Q'
STRB.W          R3, [SP,#0x1C+var_1C]

loc_26DC0
LSRS            R6, tm, #0x18
UXTB            R4, tm
STRB.W          asic_addr_0, [SP,#0x1C+var_1C+2]
MOVW            R3, #:lower16:bit_swap_table
UBFX.W          which_chain, tm, #0x10, #8
MOVT            R3, #:upper16:bit_swap_table
UBFX.W          tm, tm, #8, #8
LDRB.W          LR, [R3,R6]
MOVS            asic_addr_0, #0x40 ; '@' ; len
LDRB            R7, [R3,R0]
MOV             R0, SP  ; ptr
LDRB            R6, [R3,R2]
MOVS            R2, #9
LDRB            R4, [R3,R4]
MOVS            R3, #0x14
STRB.W          LR, [SP,#0x1C+var_18]
STRB.W          R2, [SP,#0x1C+var_1C+1]
STRB.W          R4, [SP,#0x1C+var_18+3]
STRB.W          R3, [SP,#0x1C+var_1C+3]
STRB.W          R7, [SP,#0x1C+var_18+1]
STRB.W          R6, [SP,#0x1C+var_18+2]
BL              CRC5
LDR             R2, [SP,#0x1C+var_1C]
MOV             R1, R0
LDR             R3, [SP,#0x1C+var_18]
LSLS            R4, R1, #0x18
ADD             R0, SP, #0x1C+cmd_buf ; value
STRB.W          R1, [SP,#0x1C+var_14]
REV             R2, R2
STR             R4, [SP,#0x1C+cmd_buf+8]
REV             R3, R3
STR             R2, [SP,#0x1C+cmd_buf]
STR             R3, [SP,#0x1C+cmd_buf+4]
BL              set_BC_command_buffer
BL              get_BC_write_command
ret = R0                ; unsigned int
MOVS            R3, #0
BIC.W           ret, ret, #0xF0000
MOVT            R3, #0x8080
ORR.W           R3, R3, R5,LSL#16
ORRS            R0, R3  ; value
BL              set_BC_write_command
MOVW            R0, #0x2710 ; useconds
BLX             usleep
ADD             SP, SP, #0x1C
POP             {R4-R7,PC}

loc_26E46
which_chain = R0        ; unsigned __int8
asic_addr_0 = R1        ; unsigned __int8
tm = R2                 ; unsigned int
mode = R3               ; bool
MOVS            mode, #0x41 ; 'A'
STRB.W          R3, [SP,#0x1C+var_1C]
B               loc_26DC0
; End of function BM1397_set_TM

ALIGN 0x10



; void __fastcall BM1397_enable_read_temperature_from_asic(unsigned __int8 which_chain, unsigned __int8 asic_addr)
EXPORT BM1397_enable_read_temperature_from_asic
BM1397_enable_read_temperature_from_asic

mode= -0xC

which_chain = R0        ; unsigned __int8
asic_addr = R1          ; unsigned __int8
MOVW            R3, #:lower16:gBM1397_MISC_CONTROL_reg
PUSH            {LR}
MOVS            R2, #0
SUB             SP, SP, #0xC
MOVT            R3, #:upper16:gBM1397_MISC_CONTROL_reg
STR             R2, [SP,#0xC+mode] ; mode
MOVS            R2, #0x18 ; reg_addr
LDR             R3, [R3]
ORR.W           R3, R3, #0x4000
ORR.W           R3, R3, #0x30 ; '0' ; reg_data
BL              BM1397_set_config
ADD             SP, SP, #0xC
POP.W           {PC}
; End of function BM1397_enable_read_temperature_from_asic

ALIGN 4



; void __fastcall BM1397_set_core_clock_delay_all(unsigned __int8 which_chain, unsigned __int8 which_asic, unsigned __int8 reg_data, unsigned __int8 mode)
EXPORT BM1397_set_core_clock_delay_all
BM1397_set_core_clock_delay_all

var_8= -8

which_chain = R0        ; unsigned __int8
which_asic = R1         ; unsigned __int8
reg_data = R2           ; unsigned __int8
mode = R3               ; unsigned __int8
PUSH            {R4,LR}
MOVS            R4, mode
SUB             SP, SP, #8
IT NE
MOVNE           R4, #1
ORR.W           mode, reg_data, #0x80008000 ; reg_data
MOVS            reg_data, #0 ; reg_addr
STR             R4, [SP,#8+var_8] ; mode
BL              BM1397_set_config
MOVW            R0, #0x1388 ; useconds
ADD             SP, SP, #8
POP.W           {R4,LR}
B.W             j_usleep
; End of function BM1397_set_core_clock_delay_all




; void __fastcall BM1397_enable_core_clock(unsigned __int8 which_chain, unsigned __int8 which_asic, unsigned int core_id, unsigned __int8 mode)
EXPORT BM1397_enable_core_clock
BM1397_enable_core_clock

var_8= -8

which_chain = R0        ; unsigned __int8
which_asic = R1         ; unsigned __int8
core_id = R2            ; unsigned int
mode = R3               ; unsigned __int8
PUSH            {R4,LR}
MOVS            R4, mode
SUB             SP, SP, #8
IT NE
MOVNE           R4, #1
MOVW            mode, #0x84AA
ORR.W           R3, R3, core_id,LSL#16 ; reg_data
data = R3               ; unsigned int
STR             R4, [SP,#8+var_8] ; mode
MOVS            core_id, #0x3C ; '<' ; reg_addr
BL              BM1397_set_config
MOVW            R0, #0x1388 ; useconds
ADD             SP, SP, #8
POP.W           {R4,LR}
B.W             j_usleep
; End of function BM1397_enable_core_clock




; void __fastcall single_BM1397_open_core(unsigned __int8 which_chain)
EXPORT single_BM1397_open_core
single_BM1397_open_core

buf_vil_tw= -0x38

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x3C
MOV             R8, which_chain
MOVS            R2, #0x34 ; '4' ; n
MOVS            R1, #0  ; c
ADD             which_chain, SP, #0x3C+buf_vil_tw ; s
BLX             memset
MOVW            R0, #:lower16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV             R2, R8
LDR             R1, =__FUNCTION__.8472 ; "single_BM1397_open_core"
MOVW            R11, #:lower16:gIsOpenCoreEnd
MOVT            R0, #:upper16:aSChainD ; "\n--- %s: Chain : %d\n"
MOV.W           R9, #0x80
BLX             printf
MOVS            R4, #0
MOVT            R11, #:upper16:gIsOpenCoreEnd
MOVS            R0, #0x40 ; '@' ; address
MOVS            R5, #1
MOVT            R9, #0x100
STRB.W          R4, [R11]
MOVW            R10, #:lower16:Conf
LSL.W           R5, R5, R8
ORR.W           R9, R9, R8,LSL#16
MOV             R6, R4
MOVT            R10, #:upper16:Conf
BL              read_axi_fpga
BIC.W           R1, R0, #0x20 ; ' ' ; data
MOVS            R0, #0x40 ; '@' ; address
BL              write_axi_fpga
MOV             R1, R4  ; data
MOVS            R0, #0x24 ; '$' ; address
BL              write_axi_fpga
MOV             R1, R4  ; c
ADD             R0, SP, #0x3C+buf_vil_tw ; s
MOVS            R2, #0x34 ; '4' ; n
BLX             memset

loc_26F32
core_id = R6            ; unsigned int
ADD.W           R7, core_id, #0x150
MOV             R4, core_id

loc_26F38               ; useconds
core_index = R4         ; unsigned int
MOV.W           R0, #0x3E8
BLX             usleep
MOV             R2, core_index ; core_id
MOVS            R3, #1  ; mode
MOVS            R1, #0  ; which_asic
ADDS            core_index, #0x54 ; 'T'
core_index = R2         ; unsigned int
MOV             R0, R8  ; which_chain
BL              BM1397_enable_core_clock
CMP             R4, R7
BNE             loc_26F38
MOVW            R0, #0x1388 ; useconds

loc_26F56
BLX             usleep
MOVS            R0, #3  ; address
BL              read_axi_fpga
work_fifo_ready = R0    ; unsigned int
TST             R5, work_fifo_ready
MOVW            work_fifo_ready, #0xBB8
BEQ             loc_26F56
ADD             R0, SP, #0x3C+buf_vil_tw ; value
STR.W           R9, [SP,#0x3C+buf_vil_tw]
ADDS            core_id, #1
BL              set_TW_write_command
LDR.W           R0, [R10,#configuration.OpenCoreGap] ; useconds
BLX             usleep
core_id = R6            ; unsigned int
CMP             core_id, #0x54 ; 'T'
BNE             loc_26F32
MOVS            R0, #0x30 ; '0' ; address
BL              read_axi_fpga
ORR.W           R1, R0, #0x400000 ; data
MOVS            R0, #0x30 ; '0' ; address
BL              write_axi_fpga
MOVW            R0, #:lower16:aSEndChainD ; "\n--- %s end: Chain : %d\n"
MOVS            R3, #1
MOV             R2, R8
LDR             R1, =__FUNCTION__.8472 ; "single_BM1397_open_core"
MOVT            R0, #:upper16:aSEndChainD ; "\n--- %s end: Chain : %d\n"
STRB.W          R3, [R11]
BLX             printf
ADD             SP, SP, #0x3C ; '<'
POP.W           {R4-R11,PC}
; End of function single_BM1397_open_core

off_26FAC DCD __FUNCTION__.8472 ; "single_BM1397_open_core"



; unsigned int __fastcall single_BM1397_get_result(unsigned __int8 which_chain)
EXPORT single_BM1397_get_result
single_BM1397_get_result

var_34= -0x34
var_30= -0x30
var_2C= -0x2C
OpenCoreNum2= -0x28
OpenCoreNum3= -0x24
OpenCoreNum4= -0x20
OpenCoreNum5= -0x1C
OpenCoreNum6= -0x18
OpenCoreNum7= -0x14
OpenCoreNum8= -0x10
works= -0xC
which_core= -8

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
MOV             R8, #Conf
SUB             SP, SP, #0x34
MOV             R4, which_chain
MOVW            R5, #:lower16:gAsic_Core_Nonce_Num
LDR.W           R3, [R8,#configuration.OpenCoreNum2]
MOVT            R5, #:upper16:gAsic_Core_Nonce_Num
STR             which_chain, [SP,#0x34+var_34]
MOV             R0, #asc_29AF4 ; "\n\n-----------------------------------"...
LDR.W           R9, [R8,#configuration.OpenCoreNum1]
OpenCoreNum1 = R9       ; unsigned int
STR             R3, [SP,#0x34+OpenCoreNum2]
OpenCoreNum2_0 = R3     ; unsigned int
ADD.W           R5, R5, R4,LSL#19
LDR.W           OpenCoreNum2_0, [R8,#configuration.OpenCoreNum3]
MOV             R6, #aCore03d02d ; "core[%03d]=%02d\t"
MOVS            R7, #0
SUBS            R4, R5, #4
STR             R3, [SP,#0x34+OpenCoreNum3]
OpenCoreNum3_0 = R3     ; unsigned int
LDR.W           OpenCoreNum3_0, [R8,#configuration.OpenCoreNum4]
STR             R3, [SP,#0x34+OpenCoreNum4]
OpenCoreNum4_0 = R3     ; unsigned int
LDR.W           OpenCoreNum4_0, [R8,#configuration.OpenCoreNum5]
STR             R3, [SP,#0x34+OpenCoreNum5]
OpenCoreNum5_0 = R3     ; unsigned int
LDR.W           OpenCoreNum5_0, [R8,#configuration.OpenCoreNum6]
STR             R3, [SP,#0x34+OpenCoreNum6]
OpenCoreNum6_0 = R3     ; unsigned int
LDR.W           OpenCoreNum6_0, [R8,#configuration.OpenCoreNum7]
STR             R3, [SP,#0x34+OpenCoreNum7]
OpenCoreNum7_0 = R3     ; unsigned int
LDR.W           OpenCoreNum7_0, [R8,#configuration.OpenCoreNum8]
STR             R3, [SP,#0x34+OpenCoreNum8]
OpenCoreNum8_0 = R3     ; unsigned int
BLX             puts
MOVW            R0, #:lower16:aEveryCoreRequi ; "every CORE require nonce number: %u\n\n"
LDR.W           R1, [R8,#configuration.pattern_number]
MOVT            R0, #:upper16:aEveryCoreRequi ; "every CORE require nonce number: %u\n\n"
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum1]
MOV             R0, #aOpenCoreNumber ; "Open core number : Conf.OpenCoreNum1 = "...
MOV             R1, R2
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum2]
MOV             R0, #aOpenCoreNumber_0 ; "Open core number : Conf.OpenCoreNum2 = "...
MOV             R1, R2
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum3]
MOV             R0, #aOpenCoreNumber_1 ; "Open core number : Conf.OpenCoreNum3 = "...
MOV             R1, R2
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum4]
MOV             R0, #aOpenCoreNumber_3 ; "Open core number : Conf.OpenCoreNum4 = "...
MOV             R1, R2
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum5]
MOV             R0, #aOpenCoreNumber_4 ; "Open core number : Conf.OpenCoreNum5 = "...
MOV             R1, R2
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum6]
MOV             R0, #aOpenCoreNumber_5 ; "Open core number : Conf.OpenCoreNum6 = "...
MOV             R1, R2
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum7]
MOV             R0, #aOpenCoreNumber_6 ; "Open core number : Conf.OpenCoreNum7 = "...
MOV             R1, R2
BLX             printf
LDR.W           R2, [R8,#configuration.OpenCoreNum8]
MOV             R0, #aOpenCoreNumber_7 ; "Open core number : Conf.OpenCoreNum8 = "...
MOV             R1, R2
BLX             printf
B               loc_270CA

loc_270B6
which_core_0 = R7       ; unsigned int
MOV             R1, which_core_0
LDR.W           R2, [R4,#4]!
MOV             R0, R6  ; format
ADDS            which_core_0, #1
which_core_0 = R1       ; unsigned int
BLX             printf
which_core_0 = R7       ; unsigned int
CMP.W           which_core_0, #0x2A0
BEQ             loc_270D6

loc_270CA
LSLS            R0, which_core_0, #0x1D
BNE             loc_270B6
MOVS            R0, #0xA ; c
BLX             putchar
B               loc_270B6

loc_270D6
LDR             R2, [SP,#0x34+var_34]
MOVW            R3, #:lower16:cgpu
MOVW            R0, #:lower16:(aSCreateSingleB_1+0x2C) ; "\n\n"
MOV.W           R10, #0
MOVT            R3, #:upper16:cgpu
MOVW            R6, #:lower16:aSWhichCoreDErr ; "%s: which_core = %d, error!!!\n"
MOVT            R0, #:upper16:(aSCreateSingleB_1+0x2C) ; s
LDR             which_core_0, =__FUNCTION__.8526 ; "single_BM1397_get_result"
LSLS            R2, R2, #2
MOV             R4, R10
MOVT            R6, #:upper16:aSWhichCoreDErr ; "%s: which_core = %d, error!!!\n"
STR             R3, [SP,#0x34+var_2C]
STR             R2, [SP,#0x34+var_30]
MOV.W           R11, #3
BLX             puts
B               loc_27162

loc_27108
which_core_0 = R4       ; unsigned int
test_core_index = R10   ; unsigned int
SUB.W           R3, which_core_0, #0x20 ; ' '
CMP             R3, #0x1F
BLS.W           loc_27388
SUB.W           R3, which_core_0, #0x40 ; '@'
CMP             R3, #0x1F
BLS.W           loc_275C6
SUB.W           R3, which_core_0, #0x60 ; '`'
CMP             R3, #0x1F
BLS.W           loc_2759C
SUB.W           R3, which_core_0, #0x80
CMP             R3, #0x1F
BLS.W           loc_274A6
SUB.W           R3, which_core_0, #0xA0
CMP             R3, #0x1F
BLS.W           loc_2747C
SUB.W           R3, which_core_0, #0xC0
CMP             R3, #0x1F
BLS.W           loc_273E0
SUB.W           R3, which_core_0, #0xE0
CMP             R3, #0x1F
BLS.W           loc_273B6
MOV             R2, which_core_0
MOV             R1, R7
MOV             R0, R6  ; format
BLX             printf

loc_27158
ADDS            R4, #1
which_core_0 = R4       ; unsigned int
ADDS            R5, #4
CMP.W           which_core_0, #0x2A0
BEQ             loc_27192

loc_27162
CMP             which_core_0, #0x1F
BHI             loc_27108
TST.W           OpenCoreNum1, #1
IT EQ
MOVEQ.W         OpenCoreNum1, OpenCoreNum1,LSR#1
BEQ             loc_27158
LDR             R2, [R5]
LDR.W           R3, [R8,#configuration.pattern_number]
CMP             R2, R3
BCC.W           loc_272D4

loc_2717E
ADDS            R4, #1
MOV.W           R9, R9,LSR#1
OpenCoreNum1 = R9       ; unsigned int
CMP.W           R4, #0x2A0
ADD.W           test_core_index, test_core_index, #1
which_core_0 = R4       ; unsigned int
ADD.W           R5, R5, #4
BNE             loc_27162

loc_27192
LDR.W           R3, [R8,#configuration.TempSensor1]
CBZ             R3, loc_271D4
MOV             R3, #Sensor1_temp
LDR             R1, [R3]
CMP             R1, #0
BEQ.W           loc_27352
MOV             R3, #Sensor1_OK
LDRB            R3, [R3]
CMP             R3, #0
BEQ.W           loc_27352
MOV             R3, #gNotReadOutTemp
LDRB            R3, [R3]
CMP             R3, #0
BNE.W           loc_27352
MOV             R0, #aTemperature1D ; "temperature1 = %d\n"
BLX             printf

loc_271D4
ret = R11               ; unsigned int
LDR.W           R3, [R8,#configuration.TempSensor2]
CBZ             R3, loc_27216
MOV             R3, #Sensor2_temp
LDR             R1, [R3]
CMP             R1, #0
BEQ.W           loc_27376
MOV             R3, #Sensor2_OK
LDRB            R3, [R3]
CMP             R3, #0
BEQ.W           loc_27376
MOV             R3, #gNotReadOutTemp
LDRB            R3, [R3]
CMP             R3, #0
BNE.W           loc_27376
MOV             R0, #aTemperature2D ; "temperature2 = %d\n"
BLX             printf

loc_27216
LDR.W           R3, [R8,#configuration.TempSensor3]
CBZ             R3, loc_27258
MOV             R3, #Sensor3_temp
LDR             R1, [R3]
CMP             R1, #0
BEQ.W           loc_27364
MOV             R3, #Sensor3_OK
LDRB            R3, [R3]
CMP             R3, #0
BEQ.W           loc_27364
MOV             R3, #gNotReadOutTemp
LDRB            R3, [R3]
CMP             R3, #0
BNE.W           loc_27364
MOV             R0, #aTemperature3D ; "temperature3 = %d\n"
BLX             printf

loc_27258
MOV             R0, #asc_29CA4 ; "\n-------------------------------------"...
BLX             puts
LDR             R1, [SP,#0x34+var_34]
MOV             R3, #gValid_Nonce_Num
MOV             R0, #aChainDTotalVal ; "Chain%d total valid nonce number: %d\n"...
LDR.W           R2, [R3,R1,LSL#2]
BLX             printf
TST.W           ret, #1
ITETE NE
MOVWNE          R0, #0x9D38
MOVWEQ          R0, #0x9D44
MOVTNE          R0, #2
MOVTEQ          R0, #2  ; s
BLX             puts
TST.W           ret, #2
ITETE NE
MOVWNE          R0, #0xAB0C
MOVWEQ          R0, #0xAB18
MOVTNE          R0, #2
MOVTEQ          R0, #2  ; s
BLX             puts
LDR             R2, [SP,#0x34+var_34]
MOV             R3, #gHw_Nonce_Num
MOV             R0, #aHwNumberD ; "HW number = %d\n\n"
LDR.W           R1, [R3,R2,LSL#2]
BLX             printf
MOV             R0, ret
ADD             SP, SP, #0x34 ; '4'
POP.W           {which_core_0-ret,PC}

loc_272D4
LDR             R1, [SP,#0x34+var_2C]
ADD.W           R3, test_core_index, #0x20000
ADDS            R3, #0x2A ; '*'
MOV             R0, #aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
ADD.W           R3, R1, R3,LSL#2
MOV             R1, which_core_0
LDR.W           R11, [R3,#4]
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
CBZ             R2, loc_27346
LDR             R2, [SP,#0x34+var_30]
MOV             R3, #aD ; "%d  "
STR             which_core_0, [SP,#0x34+which_core]
MOV             which_core_0, R3
MOV             R3, R6
ADD             R2, R11
STR             R5, [SP,#0x34+works]
MOV             R6, R8
MOV.W           R11, #0
MOV             R5, R2
MOV             R8, R3
B               loc_27322

loc_27318
which_pattern = R11     ; unsigned int
LDR             R1, [R6,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R1, which_pattern
BLS             loc_2733C

loc_27322
LDR             R1, [R5,#0x34]
ADDS            R5, #0x44 ; 'D'
CMP             R1, #0
BNE             loc_27318
MOV             R1, which_pattern
MOV             R0, R4  ; format
BLX             printf
LDR             R1, [R6,#configuration.pattern_number]
ADD.W           which_pattern, which_pattern, #1
CMP             R1, which_pattern
BHI             loc_27322

loc_2733C
LDR             R5, [SP,#0x34+works]
MOV             R3, R8
LDR             R4, [SP,#0x34+which_core]
MOV             R8, R6
MOV             R6, R3

loc_27346               ; c
MOVS            R0, #0xA
MOV.W           R11, #2
BLX             putchar
B               loc_2717E

loc_27352
which_core_0 = R4       ; unsigned int
OpenCoreNum1 = R9       ; unsigned int
MOVW            R0, #:lower16:aTemperature1Ch ; "temperature1 check error"
BIC.W           R11, R11, #2
MOVT            R0, #:upper16:aTemperature1Ch ; "temperature1 check error"
BLX             puts
ret = R11               ; unsigned int
B               loc_271D4

loc_27364
MOVW            R0, #:lower16:aTemperature3Ch ; "temperature3 check error"
BIC.W           ret, ret, #2
MOVT            R0, #:upper16:aTemperature3Ch ; "temperature3 check error"
BLX             puts
ret = R11               ; unsigned int
B               loc_27258

loc_27376
MOVW            R0, #:lower16:aTemperature2Ch ; "temperature2 check error"
BIC.W           ret, ret, #2
MOVT            R0, #:upper16:aTemperature2Ch ; "temperature2 check error"
BLX             puts
ret = R11               ; unsigned int
B               loc_27216

loc_27388
LDR             R3, [SP,#0x34+OpenCoreNum2]
LSLS            R1, R3, #0x1F
BPL.W           loc_2771C
LDR             R0, [SP,#0x34+var_2C]
ADD.W           R3, test_core_index, #0x20000
LDR             R2, [R5]
ADDS            R3, #0x2A ; '*'
LDR.W           R1, [R8,#configuration.pattern_number]
ADD.W           R3, R0, R3,LSL#2
CMP             R2, R1
LDR             R3, [R3,#4]
works_0 = R3            ; work *
BCC.W           loc_2753C

loc_273AA
LDR             R3, [SP,#0x34+OpenCoreNum2]
ADD.W           test_core_index, test_core_index, #1
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum2]
test_core_index = R10   ; unsigned int
OpenCoreNum2_0 = R3     ; unsigned int
B               loc_27158

loc_273B6
which_core_0 = R4       ; unsigned int
LDR             R3, [SP,#0x34+OpenCoreNum8]
LSLS            R3, R3, #0x1F
BPL             loc_27474
LDR             R0, [SP,#0x34+var_2C]
ADD.W           R3, test_core_index, #0x20000
LDR             R2, [R5]
ADDS            R3, #0x2A ; '*'
LDR.W           R1, [R8,#configuration.pattern_number]
ADD.W           R3, R0, R3,LSL#2
CMP             R2, R1
LDR             R3, [R3,#4]
works_0 = R3            ; work *
BCC             loc_27414

loc_273D4
LDR             R3, [SP,#0x34+OpenCoreNum8]
ADD.W           test_core_index, test_core_index, #1
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum8]
test_core_index = R10   ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
B               loc_27158

loc_273E0
which_core_0 = R4       ; unsigned int
LDR             R3, [SP,#0x34+OpenCoreNum7]
LSLS            R2, R3, #0x1F
BPL.W           loc_27724
LDR             R0, [SP,#0x34+var_2C]
ADD.W           R3, test_core_index, #0x20000
LDR             R2, [R5]
ADDS            R3, #0x2A ; '*'
LDR.W           R1, [R8,#configuration.pattern_number]
ADD.W           R3, R0, R3,LSL#2
CMP             R2, R1
LDR             R3, [R3,#4]
works_0 = R3            ; work *
BCC.W           loc_2765C

loc_27402
LDR             R3, [SP,#0x34+OpenCoreNum7]
ADD.W           test_core_index, test_core_index, #1
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum7]
test_core_index = R10   ; unsigned int
OpenCoreNum7_0 = R3     ; unsigned int
B               loc_27158
ALIGN 0x10
off_27410 DCD __FUNCTION__.8526 ; "single_BM1397_get_result"

loc_27414
which_core_0 = R4       ; unsigned int
works_0 = R3            ; work *
MOVW            R0, #:lower16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
MOV             R1, which_core_0
MOVT            R0, #:upper16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
STR             works_0, [SP,#0x34+works]
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R3, [SP,#0x34+works]
CBZ             R2, loc_27468
LDR             R1, [SP,#0x34+var_30]
MOV             R2, #aD ; "%d  "
STR             which_core_0, [SP,#0x34+works]
STR             R6, [SP,#0x34+which_core]
MOV             R6, R5
ADD.W           R11, R3, R1
MOVS            R3, #0
MOV             which_core_0, R3
MOV             R5, R2

loc_27446
which_pattern = R4      ; unsigned int
LDR.W           R1, [R11,#0x34]
ADD.W           R11, R11, #0x44 ; 'D'
CBNZ            R1, loc_27458
MOV             R1, which_pattern
MOV             R0, R5  ; format
BLX             printf

loc_27458
LDR.W           R1, [R8,#configuration.pattern_number]
ADDS            which_pattern, #1
CMP             R1, which_pattern
BHI             loc_27446
MOV             R5, R6
LDR             which_pattern, [SP,#0x34+works]
LDR             R6, [SP,#0x34+which_core]

loc_27468               ; c
MOVS            R0, #0xA
MOV.W           R11, #2
BLX             putchar
B               loc_273D4

loc_27474
which_core_0 = R4       ; unsigned int
LDR             R3, [SP,#0x34+OpenCoreNum8]
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum8]
OpenCoreNum8_0 = R3     ; unsigned int
B               loc_27158

loc_2747C
LDR             R3, [SP,#0x34+OpenCoreNum6]
LSLS            R1, R3, #0x1F
BPL             loc_27534
LDR             R0, [SP,#0x34+var_2C]
ADD.W           R3, test_core_index, #0x20000
LDR             R2, [R5]
ADDS            R3, #0x2A ; '*'
LDR.W           R1, [R8,#configuration.pattern_number]
ADD.W           R3, R0, R3,LSL#2
CMP             R2, R1
LDR             R3, [R3,#4]
works_0 = R3            ; work *
BCC             loc_274D4

loc_2749A
LDR             R3, [SP,#0x34+OpenCoreNum6]
ADD.W           test_core_index, test_core_index, #1
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum6]
test_core_index = R10   ; unsigned int
OpenCoreNum6_0 = R3     ; unsigned int
B               loc_27158

loc_274A6
which_core_0 = R4       ; unsigned int
LDR             R3, [SP,#0x34+OpenCoreNum5]
LSLS            R0, R3, #0x1F
BPL.W           loc_2778C
LDR             R0, [SP,#0x34+var_2C]
ADD.W           R3, test_core_index, #0x20000
LDR             R2, [R5]
ADDS            R3, #0x2A ; '*'
LDR.W           R1, [R8,#configuration.pattern_number]
ADD.W           R3, R0, R3,LSL#2
CMP             R2, R1
LDR             R3, [R3,#4]
works_0 = R3            ; work *
BCC.W           loc_276BC

loc_274C8
LDR             R3, [SP,#0x34+OpenCoreNum5]
ADD.W           test_core_index, test_core_index, #1
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum5]
test_core_index = R10   ; unsigned int
OpenCoreNum5_0 = R3     ; unsigned int
B               loc_27158

loc_274D4
which_core_0 = R4       ; unsigned int
works_0 = R3            ; work *
MOVW            R0, #:lower16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
MOV             R1, which_core_0
MOVT            R0, #:upper16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
STR             works_0, [SP,#0x34+works]
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R3, [SP,#0x34+works]
CBZ             R2, loc_27528
LDR             R1, [SP,#0x34+var_30]
MOV             R2, #aD ; "%d  "
STR             which_core_0, [SP,#0x34+works]
STR             R6, [SP,#0x34+which_core]
MOV             R6, R5
ADD.W           R11, R3, R1
MOVS            R3, #0
MOV             which_core_0, R3
MOV             R5, R2

loc_27506
which_pattern = R4      ; unsigned int
LDR.W           R1, [R11,#0x34]
ADD.W           R11, R11, #0x44 ; 'D'
CBNZ            R1, loc_27518
MOV             R1, which_pattern
MOV             R0, R5  ; format
BLX             printf

loc_27518
LDR.W           R1, [R8,#configuration.pattern_number]
ADDS            which_pattern, #1
CMP             R1, which_pattern
BHI             loc_27506
MOV             R5, R6
LDR             which_pattern, [SP,#0x34+works]
LDR             R6, [SP,#0x34+which_core]

loc_27528               ; c
MOVS            R0, #0xA
MOV.W           R11, #2
BLX             putchar
B               loc_2749A

loc_27534
which_core_0 = R4       ; unsigned int
LDR             R3, [SP,#0x34+OpenCoreNum6]
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum6]
OpenCoreNum6_0 = R3     ; unsigned int
B               loc_27158

loc_2753C
works_0 = R3            ; work *
MOVW            R0, #:lower16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
MOV             R1, which_core_0
MOVT            R0, #:upper16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
STR             works_0, [SP,#0x34+works]
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R3, [SP,#0x34+works]
CBZ             R2, loc_27590
LDR             R1, [SP,#0x34+var_30]
MOV             R2, #aD ; "%d  "
STR             which_core_0, [SP,#0x34+works]
STR             R6, [SP,#0x34+which_core]
MOV             R6, R5
ADD.W           R11, R3, R1
MOVS            R3, #0
MOV             which_core_0, R3
MOV             R5, R2

loc_2756E
which_pattern = R4      ; unsigned int
LDR.W           R1, [R11,#0x34]
ADD.W           R11, R11, #0x44 ; 'D'
CBNZ            R1, loc_27580
MOV             R1, which_pattern
MOV             R0, R5  ; format
BLX             printf

loc_27580
LDR.W           R1, [R8,#configuration.pattern_number]
ADDS            which_pattern, #1
CMP             R1, which_pattern
BHI             loc_2756E
MOV             R5, R6
LDR             which_pattern, [SP,#0x34+works]
LDR             R6, [SP,#0x34+which_core]

loc_27590               ; c
MOVS            R0, #0xA
MOV.W           R11, #2
BLX             putchar
B               loc_273AA

loc_2759C
which_core_0 = R4       ; unsigned int
LDR             R3, [SP,#0x34+OpenCoreNum4]
LSLS            R3, R3, #0x1F
BPL             loc_27654
LDR             R0, [SP,#0x34+var_2C]
ADD.W           R3, test_core_index, #0x20000
LDR             R2, [R5]
ADDS            R3, #0x2A ; '*'
LDR.W           R1, [R8,#configuration.pattern_number]
ADD.W           R3, R0, R3,LSL#2
CMP             R2, R1
LDR             R3, [R3,#4]
works_0 = R3            ; work *
BCC             loc_275F4

loc_275BA
LDR             R3, [SP,#0x34+OpenCoreNum4]
ADD.W           test_core_index, test_core_index, #1
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum4]
test_core_index = R10   ; unsigned int
OpenCoreNum4_0 = R3     ; unsigned int
B               loc_27158

loc_275C6
which_core_0 = R4       ; unsigned int
LDR             R3, [SP,#0x34+OpenCoreNum3]
LSLS            R2, R3, #0x1F
BPL.W           loc_27794
LDR             R0, [SP,#0x34+var_2C]
ADD.W           R3, test_core_index, #0x20000
LDR             R2, [R5]
ADDS            R3, #0x2A ; '*'
LDR.W           R1, [R8,#configuration.pattern_number]
ADD.W           R3, R0, R3,LSL#2
CMP             R2, R1
LDR             R3, [R3,#4]
works_0 = R3            ; work *
BCC.W           loc_2772C

loc_275E8
LDR             R3, [SP,#0x34+OpenCoreNum3]
ADD.W           test_core_index, test_core_index, #1
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum3]
test_core_index = R10   ; unsigned int
OpenCoreNum3_0 = R3     ; unsigned int
B               loc_27158

loc_275F4
which_core_0 = R4       ; unsigned int
works_0 = R3            ; work *
MOVW            R0, #:lower16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
MOV             R1, which_core_0
MOVT            R0, #:upper16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
STR             works_0, [SP,#0x34+works]
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R3, [SP,#0x34+works]
CBZ             R2, loc_27648
LDR             R1, [SP,#0x34+var_30]
MOV             R2, #aD ; "%d  "
STR             which_core_0, [SP,#0x34+works]
STR             R6, [SP,#0x34+which_core]
MOV             R6, R5
ADD.W           R11, R3, R1
MOVS            R3, #0
MOV             which_core_0, R3
MOV             R5, R2

loc_27626
which_pattern = R4      ; unsigned int
LDR.W           R1, [R11,#0x34]
ADD.W           R11, R11, #0x44 ; 'D'
CBNZ            R1, loc_27638
MOV             R1, which_pattern
MOV             R0, R5  ; format
BLX             printf

loc_27638
LDR.W           R1, [R8,#configuration.pattern_number]
ADDS            which_pattern, #1
CMP             R1, which_pattern
BHI             loc_27626
MOV             R5, R6
LDR             which_pattern, [SP,#0x34+works]
LDR             R6, [SP,#0x34+which_core]

loc_27648               ; c
MOVS            R0, #0xA
MOV.W           R11, #2
BLX             putchar
B               loc_275BA

loc_27654
which_core_0 = R4       ; unsigned int
LDR             R3, [SP,#0x34+OpenCoreNum4]
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum4]
OpenCoreNum4_0 = R3     ; unsigned int
B               loc_27158

loc_2765C
works_0 = R3            ; work *
MOVW            R0, #:lower16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
MOV             R1, which_core_0
MOVT            R0, #:upper16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
STR             works_0, [SP,#0x34+works]
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R3, [SP,#0x34+works]
CBZ             R2, loc_276B0
LDR             R1, [SP,#0x34+var_30]
MOV             R2, #aD ; "%d  "
STR             which_core_0, [SP,#0x34+works]
STR             R6, [SP,#0x34+which_core]
MOV             R6, R5
ADD.W           R11, R3, R1
MOVS            R3, #0
MOV             which_core_0, R3
MOV             R5, R2

loc_2768E
which_pattern = R4      ; unsigned int
LDR.W           R1, [R11,#0x34]
ADD.W           R11, R11, #0x44 ; 'D'
CBNZ            R1, loc_276A0
MOV             R1, which_pattern
MOV             R0, R5  ; format
BLX             printf

loc_276A0
LDR.W           R1, [R8,#configuration.pattern_number]
ADDS            which_pattern, #1
CMP             R1, which_pattern
BHI             loc_2768E
MOV             R5, R6
LDR             which_pattern, [SP,#0x34+works]
LDR             R6, [SP,#0x34+which_core]

loc_276B0               ; c
MOVS            R0, #0xA
MOV.W           R11, #2
BLX             putchar
B               loc_27402

loc_276BC
which_core_0 = R4       ; unsigned int
works_0 = R3            ; work *
MOVW            R0, #:lower16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
MOV             R1, which_core_0
MOVT            R0, #:upper16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
STR             works_0, [SP,#0x34+works]
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R3, [SP,#0x34+works]
CBZ             R2, loc_27710
LDR             R1, [SP,#0x34+var_30]
MOV             R2, #aD ; "%d  "
STR             which_core_0, [SP,#0x34+works]
STR             R6, [SP,#0x34+which_core]
MOV             R6, R5
ADD.W           R11, R3, R1
MOVS            R3, #0
MOV             which_core_0, R3
MOV             R5, R2

loc_276EE
which_pattern = R4      ; unsigned int
LDR.W           R1, [R11,#0x34]
ADD.W           R11, R11, #0x44 ; 'D'
CBNZ            R1, loc_27700
MOV             R1, which_pattern
MOV             R0, R5  ; format
BLX             printf

loc_27700
LDR.W           R1, [R8,#configuration.pattern_number]
ADDS            which_pattern, #1
CMP             R1, which_pattern
BHI             loc_276EE
MOV             R5, R6
LDR             which_pattern, [SP,#0x34+works]
LDR             R6, [SP,#0x34+which_core]

loc_27710               ; c
MOVS            R0, #0xA
MOV.W           R11, #2
BLX             putchar
B               loc_274C8

loc_2771C
which_core_0 = R4       ; unsigned int
LDR             R3, [SP,#0x34+OpenCoreNum2]
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum2]
OpenCoreNum2_0 = R3     ; unsigned int
B               loc_27158

loc_27724
LDR             R3, [SP,#0x34+OpenCoreNum7]
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum7]
OpenCoreNum7_0 = R3     ; unsigned int
B               loc_27158

loc_2772C
works_0 = R3            ; work *
MOVW            R0, #:lower16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
MOV             R1, which_core_0
MOVT            R0, #:upper16:aCore03dDLostTh ; "core[%03d] = %d,      lost these nonce "...
STR             works_0, [SP,#0x34+works]
BLX             printf
LDR.W           R2, [R8,#configuration.pattern_number]
LDR             R3, [SP,#0x34+works]
CBZ             R2, loc_27780
LDR             R1, [SP,#0x34+var_30]
MOV             R2, #aD ; "%d  "
STR             which_core_0, [SP,#0x34+works]
STR             R6, [SP,#0x34+which_core]
MOV             R6, R5
ADD.W           R11, R3, R1
MOVS            R3, #0
MOV             which_core_0, R3
MOV             R5, R2

loc_2775E
which_pattern = R4      ; unsigned int
LDR.W           R1, [R11,#0x34]
ADD.W           R11, R11, #0x44 ; 'D'
CBNZ            R1, loc_27770
MOV             R1, which_pattern
MOV             R0, R5  ; format
BLX             printf

loc_27770
LDR.W           R1, [R8,#configuration.pattern_number]
ADDS            which_pattern, #1
CMP             R1, which_pattern
BHI             loc_2775E
MOV             R5, R6
LDR             which_pattern, [SP,#0x34+works]
LDR             R6, [SP,#0x34+which_core]

loc_27780               ; c
MOVS            R0, #0xA
MOV.W           R11, #2
BLX             putchar
B               loc_275E8

loc_2778C
which_core_0 = R4       ; unsigned int
LDR             R3, [SP,#0x34+OpenCoreNum5]
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum5]
OpenCoreNum5_0 = R3     ; unsigned int
B               loc_27158

loc_27794
LDR             R3, [SP,#0x34+OpenCoreNum3]
LSRS            R3, R3, #1
STR             R3, [SP,#0x34+OpenCoreNum3]
OpenCoreNum3_0 = R3     ; unsigned int
B               loc_27158
; End of function single_BM1397_get_result




; void __fastcall single_BM1397_print_lcd(unsigned __int8 which_chain, unsigned int result)
EXPORT single_BM1397_print_lcd
single_BM1397_print_lcd

lcd_display_buf= -0x14

which_chain = R0        ; unsigned __int8
result = R1             ; unsigned int
LDR             R3, =dword_2F0E4
PUSH            {R4,R5,LR}
MOV             R5, result
SUB             SP, SP, #0x14
MOV             R4, SP
LDR             which_chain, [R3]
LDR             result, [R3,#(dword_2F0E8 - 0x2F0E4)]
result = R5             ; unsigned int
LDR             R2, [R3,#(dword_2F0EC - 0x2F0E4)]
LDR             R3, [R3,#(dword_2F0F0 - 0x2F0E4)]
STM             R4!, {R0-R3}
BL              display_level_result_on_lcd
MOVW            R2, #:lower16:gChain
MOVW            R3, #:lower16:gHw_Nonce_Num
MOVT            R2, #:upper16:gChain
MOVT            R3, #:upper16:gHw_Nonce_Num
LDRB            R2, [R2]
MOV             R1, #(aT1DT2D+0xC) ; format
ADD.W           R0, SP, #0x14+lcd_display_buf+0xA ; s
LDR.W           R2, [R3,R2,LSL#2]
BLX             sprintf
MOV             R1, SP  ; buf
MOVS            R2, #0x10 ; size
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
LSLS            R2, result, #0x1F
MOV.W           R0, #2  ; line
ITETE MI
MOVWMI          R1, #0x9D64
MOVWPL          R1, #0x9D78
MOVTMI          R1, #2
MOVTPL          R1, #2  ; buf
ITE MI
MOVMI           R2, #0x10
MOVPL           R2, #0x10 ; size
BL              write_lcd_no_memset
LSLS            R3, result, #0x1E
MOV.W           R0, #3  ; line
ITETT MI
MOVWMI          R1, #0xAB24
MOVWPL          R1, #0xAB38
MOVMI           R2, #0x10
MOVTMI          R1, #2
ITT PL
MOVPL           R2, #0x10 ; size
MOVTPL          R1, #2  ; buf
BL              write_lcd_no_memset
ADD             SP, SP, #0x14
POP             {R4,result,PC}
; End of function single_BM1397_print_lcd

off_2782C DCD dword_2F0E4



; void __fastcall BM1397_soft_reset_sensor(unsigned __int8 which_chain)
EXPORT BM1397_soft_reset_sensor
BM1397_soft_reset_sensor

mode= -0x14
var_8= -8

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
MOVW            R10, #:lower16:Conf
MOVW            R9, #:lower16:read_loop
MOVW            R11, #:lower16:gBM1397_MISC_CONTROL_reg
MOV             R8, which_chain
MOVT            R10, #:upper16:Conf
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
MOVT            R9, #:upper16:read_loop
MOVS            R7, #0
SUB             SP, SP, #0x14
MOVT            R11, #:upper16:gBM1397_MISC_CONTROL_reg
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             R1, =__FUNCTION__.8544 ; "BM1397_soft_reset_sensor"
BLX             printf
STR.W           R11, [SP,#0x14+var_8]

loc_27864
i = R7                  ; unsigned int
CMP             i, #0
BEQ             loc_2795E
CMP             i, #1
IT EQ
LDREQ.W         R5, [R10,#configuration.TempSensor2]
BEQ             loc_2787E
CMP             i, #2
ITE EQ
LDREQ.W         R5, [R10,#configuration.TempSensor3]
LDRNE.W         R5, [R10,#configuration.TempSensor4]

loc_2787E
CBNZ            R5, loc_27898

loc_27880
ADDS            R7, #1
i = R7                  ; unsigned int
CMP             i, #4
BNE             loc_27864
MOV             R0, #(gAsic_Core_Nonce_Num+0x1859C) ; useconds
ADD             SP, SP, #0x14
POP.W           {R4-R11,LR}
B.W             j_usleep

loc_27898
MOVW            R6, #:lower16:gChain_Asic_Interval
LDR             R3, [SP,#0x14+var_8]
MOVT            R6, #:upper16:gChain_Asic_Interval
SUBS            R5, #1
LDR             R1, [R6]
UXTB            R5, R5
LDR             R3, [R3]
MOV.W           R11, #0
MOV             R0, R8  ; which_chain
MOVS            R2, #0x18 ; reg_addr
STR.W           R11, [SP,#0x14+mode] ; mode
MOV             R4, R11
SMULBB          R1, R1, R5
ORR.W           R3, R3, #0x4000
ORR.W           R3, R3, #0x30 ; '0' ; reg_data
UXTB            R1, R1  ; asic_addr
BL              BM1397_set_config
LDR             R1, [R6]
MOV             R3, R11 ; mode
MOVS            R2, #0x18 ; reg
MOV             R0, R8  ; which_chain
SMULBB          R1, R1, R5
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
B               loc_278E6

loc_278DE
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
LDR.W           R3, [R9]
CMP             read_temperature_time, R3
BCS             loc_27940

loc_278E6
LDR             R1, [R6]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R8  ; which_chain
ADDS            read_temperature_time, #1
SMULBB          R1, R1, R5
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
ANDS.W          R1, ret, #0xC0000000
BNE             loc_278DE
STR             R1, [SP,#0x14+mode] ; mode
MOV             R4, R1
LDRH            R1, [R6]
MOVS            R3, #0x10006 ; reg_data
MOVS            R2, #0x1C ; reg_addr
MOV             ret, R8 ; which_chain
SMULBB          R1, R1, R5
UXTB            R1, R1  ; asic_addr
BL              BM1397_set_config
B               loc_27924

loc_2791C
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
LDR.W           R3, [R9]
CMP             read_temperature_time, R3
BCS             loc_27880

loc_27924
LDR             R1, [R6]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R8  ; which_chain
ADDS            read_temperature_time, #1
SMULBB          R1, R1, R5
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_2791C
B               loc_27880

loc_27940
MOVW            R3, #:lower16:gNotReadOutTemp
MOV             R2, ret
MOVT            R3, #:upper16:gNotReadOutTemp
MOVS            R1, #1
MOVW            ret, #:lower16:aSCanTReadOutGe ; "%s: Can't read out GENERAL_I2C_COMMAND."...
ret = R2                ; unsigned int
STRB            R1, [R3]
MOVT            R0, #:upper16:aSCanTReadOutGe ; "%s: Can't read out GENERAL_I2C_COMMAND."...
LDR             R1, =__FUNCTION__.8544 ; "BM1397_soft_reset_sensor"
BLX             printf
B               loc_27880

loc_2795E
LDR.W           R5, [R10,#configuration.TempSensor1]
which_sensor = R5       ; unsigned int
B               loc_2787E
; End of function BM1397_soft_reset_sensor

off_27964 DCD __FUNCTION__.8544 ; "BM1397_soft_reset_sensor"



; void __fastcall BM1397_enable_extended_mode_of_temperature_sensor(unsigned __int8 which_chain)
EXPORT BM1397_enable_extended_mode_of_temperature_sensor
BM1397_enable_extended_mode_of_temperature_sensor

mode= -0x1C
var_14= -0x14
var_10= -0x10
var_C= -0xC
var_8= -8

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
MOVW            R1, #0xFCFF
MOVW            R10, #:lower16:Conf
MOVW            R6, #:lower16:gChain_Asic_Interval
MOVW            R8, #:lower16:read_loop
SUB             SP, SP, #0x1C
MOVT            R1, #0xFEFE
MOVW            R3, #:lower16:gBM1397_MISC_CONTROL_reg
MOVW            R2, #0x904
MOV             R7, which_chain
MOVT            R10, #:upper16:Conf
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
MOVT            R6, #:upper16:gChain_Asic_Interval
MOVT            R8, #:upper16:read_loop
MOV.W           R9, #0
MOVT            R3, #:upper16:gBM1397_MISC_CONTROL_reg
MOVT            R2, #0x101
STR             R1, [SP,#0x1C+var_C]
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             R1, =__FUNCTION__.8560 ; "BM1397_enable_extended_mode_of_temperat"...
STR             R3, [SP,#0x1C+var_14]
STR             R2, [SP,#0x1C+var_10]
BLX             printf

loc_279B8
i = R9                  ; unsigned int
CMP.W           i, #0
BEQ.W           loc_27B38
CMP.W           i, #1
IT EQ
LDREQ.W         R4, [R10,#configuration.TempSensor2]
BEQ             loc_279DA
CMP.W           i, #2
ITE EQ
LDREQ.W         R4, [R10,#configuration.TempSensor3]
LDRNE.W         R4, [R10,#configuration.TempSensor4]

loc_279DA
CBNZ            R4, loc_279EC

loc_279DC
ADD.W           R9, R9, #1
i = R9                  ; unsigned int
CMP.W           i, #4
BNE             loc_279B8
ADD             SP, SP, #0x1C
POP.W           {R4-R11,PC}

loc_279EC
LDR             R1, [R6]
SUBS            R4, #1
LDR             R3, [SP,#0x1C+var_14]
UXTB            R4, R4
MOV.W           R11, #0
MOV             R0, R7  ; which_chain
MOVS            R2, #0x18 ; reg_addr
LDR             R3, [R3]
SMULBB          R1, R1, R4
STR.W           R11, [SP,#0x1C+mode] ; mode
MOV             R5, R11
ORR.W           R3, R3, #0x4000
UXTB            R1, R1  ; asic_addr
ORR.W           R3, R3, #0x30 ; '0' ; reg_data
BL              BM1397_set_config
LDR             R1, [R6]
MOV             R3, R11 ; mode
MOVS            R2, #0x18 ; reg
MOV             R0, R7  ; which_chain
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
B               loc_27A32

loc_27A2A
ret = R0                ; unsigned int
read_temperature_time = R5; unsigned int
LDR.W           R3, [R8]
CMP             read_temperature_time, R3
BCS             loc_27B1A

loc_27A32
LDR             R1, [R6]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R7  ; which_chain
ADDS            read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R5; unsigned int
ANDS.W          R1, ret, #0xC0000000
BNE             loc_27A2A
STR             R1, [SP,#0x1C+mode] ; mode
MOV             R5, R1
LDRH            R1, [R6]
MOV             R11, #gSensor_i2c_addr_high_4_bit
MOVS            R2, #0x1C ; reg_addr
LDR.W           R3, [R11]
MOV             ret, R7 ; which_chain
SMULBB          LR, R1, R4
LDR             R1, [SP,#0x1C+var_10]
ORRS            R3, R1  ; reg_data
UXTB.W          R1, LR  ; asic_addr
BL              BM1397_set_config
B               loc_27A7C

loc_27A74
ret = R0                ; unsigned int
read_temperature_time = R5; unsigned int
LDR.W           R3, [R8]
CMP             read_temperature_time, R3
BCS             loc_27A96

loc_27A7C
LDR             R1, [R6]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R7  ; which_chain
ADDS            read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R5; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_27A74

loc_27A96
MOVS            R3, #0
MOVW            ret, #0x2710 ; useconds
STR             R3, [SP,#0x1C+var_8]
BLX             usleep
LDR             R3, [SP,#0x1C+var_8]
MOVS            R2, #0x1C ; reg_addr
LDR             R1, [R6]
MOV             R0, R7  ; which_chain
LDR.W           LR, [R11]
MOV             R5, R3
STR             R3, [SP,#0x1C+mode] ; mode
LDR             R3, [SP,#0x1C+var_C]
SMULBB          R1, R1, R4
AND.W           R3, LR, R3
ORR.W           R3, R3, #0x1000000
UXTB            R1, R1  ; asic_addr
ORR.W           R3, R3, #0x300 ; reg_data
BL              BM1397_set_config
B               loc_27AD4

loc_27ACC
ret = R0                ; unsigned int
read_temperature_time = R5; unsigned int
LDR.W           R3, [R8]
CMP             read_temperature_time, R3
BCS             loc_27AEE

loc_27AD4
LDR             R1, [R6]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R7  ; which_chain
ADDS            read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R5; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_27ACC

loc_27AEE
MOVS            R3, #4
MOV             R2, ret
MOVT            R3, #0xC000
ANDS            R3, ret
CMP             R3, #4
BEQ.W           loc_279DC
MOVW            R3, #:lower16:gNotReadOutTemp
MOVS            R1, #1
MOVT            R3, #:upper16:gNotReadOutTemp
MOVW            ret, #:lower16:aSCanTSetExtend ; "\n!!! %s: Can't set extended mode. ret "...
ret = R2                ; unsigned int
STRB            R1, [R3]
MOVT            R0, #:upper16:aSCanTSetExtend ; "\n!!! %s: Can't set extended mode. ret "...
LDR             R1, =__FUNCTION__.8560 ; "BM1397_enable_extended_mode_of_temperat"...
BLX             printf
B               loc_279DC

loc_27B1A
ret = R0                ; unsigned int
read_temperature_time = R5; unsigned int
MOVW            R3, #:lower16:gNotReadOutTemp
MOV             R2, ret
MOVT            R3, #:upper16:gNotReadOutTemp
MOVS            R1, #1
MOVW            ret, #:lower16:aSCanTReadOutGe_0 ; "\n!!! %s: Can't read out GENERAL_I2C_CO"...
ret = R2                ; unsigned int
STRB            R1, [R3]
MOVT            R0, #:upper16:aSCanTReadOutGe_0 ; "\n!!! %s: Can't read out GENERAL_I2C_CO"...
LDR             R1, =__FUNCTION__.8560 ; "BM1397_enable_extended_mode_of_temperat"...
BLX             printf
B               loc_279DC

loc_27B38
LDR.W           R4, [R10,#configuration.TempSensor1]
which_sensor = R4       ; unsigned int
B               loc_279DA
; End of function BM1397_enable_extended_mode_of_temperature_sensor

ALIGN 0x10
off_27B40 DCD __FUNCTION__.8560 ; "BM1397_enable_extended_mode_of_temperat"...



; void __fastcall BM1397_get_temperature_offset_value_from_asic(unsigned __int8 which_chain)
EXPORT BM1397_get_temperature_offset_value_from_asic
BM1397_get_temperature_offset_value_from_asic

mode= -0x24
var_1C= -0x1C
local_temp= -0x18
remote_temp= -0x14
var_10= -0x10
offset_value= -0xC

which_chain = R0        ; unsigned __int8
PUSH.W          {R4-R11,LR}
MOVW            R1, #:lower16:gBM1397_MISC_CONTROL_reg
MOVW            R7, #:lower16:read_loop
SUB             SP, SP, #0x24
MOVT            R1, #:upper16:gBM1397_MISC_CONTROL_reg
MOVW            R11, #:lower16:Conf
MOV             R6, which_chain
MOVT            R7, #:upper16:read_loop
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
MOVS            R3, #0
STR             R1, [SP,#0x24+var_10]
MOVT            R11, #:upper16:Conf
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
LDR             R1, =__FUNCTION__.8582 ; "BM1397_get_temperature_offset_value_fro"...
STR             R3, [SP,#0x24+remote_temp]
MOV             R9, R3
STR             R3, [SP,#0x24+local_temp]
STR             R3, [SP,#0x24+offset_value]
STR             R3, [SP,#0x24+offset_value+4]
BLX             printf
STR.W           R11, [SP,#0x24+var_1C]

loc_27B84
i = R9                  ; unsigned int
LDR             R3, [SP,#0x24+var_1C]
CMP.W           i, #0
BEQ.W           loc_27DE0
CMP.W           i, #1
ITE EQ
LDREQ.W         R11, [R3,#configuration.TempSensor2]
LDRNE.W         R11, [R3,#configuration.TempSensor3]

loc_27B9C
CMP.W           R11, #0
BNE             loc_27C1C

loc_27BA2
ADD.W           R9, R9, #1
i = R9                  ; unsigned int
CMP.W           i, #3
BNE             loc_27B84
LDR.W           R11, [SP,#0x24+var_1C]
MOVS            R2, #0
MOVW            R6, #:lower16:(aSOffsetValueDD+4) ; "offset_value[%d] = %d\n"
MOVS            R0, #0xA ; c
MOV             R4, R2
MOVT            R6, #:upper16:(aSOffsetValueDD+4) ; "offset_value[%d] = %d\n"
LDR.W           R3, [R11,#configuration.sensor_model]
ADD.W           R5, SP, #0x24+var_10+3
STRB.W          R2, [SP,#0x24+offset_value+7]
ORR.W           R3, R3, #0x20 ; ' '
STRB.W          R3, [SP,#0x24+offset_value+6]
BLX             putchar

loc_27BD6
i = R4                  ; unsigned int
MOV             R1, i
LDRB.W          R2, [R5,#1]!
MOV             R0, R6  ; format
ADDS            i, #1
i = R1                  ; unsigned int
BLX             printf
i = R4                  ; unsigned int
CMP             i, #8
BNE             loc_27BD6
MOV             R3, #pattern_test_time
LDRB            R3, [R3]
CBNZ            R3, loc_27C16
LDR.W           R3, [R11,#configuration.AsicNum]
CMP             R3, #1
BEQ             loc_27C16
MOVW            R1, #:lower16:gChain
MOVW            R3, #:lower16:gI2c
MOVT            R1, #:upper16:gChain
MOVT            R3, #:upper16:gI2c
ADD             R2, SP, #0x24+offset_value ; offset_value
LDRB            R1, [R1] ; which_chain
LDRB            R0, [R3] ; which_iic
BL              AT24C02_save_offset_value

loc_27C16
ADD             SP, SP, #0x24 ; '$'
POP.W           {i-R11,PC}

loc_27C1C
MOVW            R5, #:lower16:gChain_Asic_Interval
LDR             R3, [SP,#0x24+var_10]
MOVT            R5, #:upper16:gChain_Asic_Interval
ADD.W           R4, R11, #0xFFFFFFFF
LDR             R1, [R5]
UXTB            R4, R4
LDR             R3, [R3]
MOV.W           R10, #0
MOV             R0, R6  ; which_chain
MOVS            R2, #0x18 ; reg_addr
STR.W           R10, [SP,#0x24+mode] ; mode
MOV             R8, R10
SMULBB          R1, R1, R4
ORR.W           R3, R3, #0x4000
ORR.W           R3, R3, #0x30 ; '0' ; reg_data
UXTB            R1, R1  ; asic_addr
BL              BM1397_set_config
LDR             R1, [R5]
MOV             R3, R10 ; mode
MOVS            R2, #0x18 ; reg
MOV             R0, R6  ; which_chain
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
B               loc_27C6A

loc_27C64
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS             loc_27C86

loc_27C6A
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_27C64

loc_27C86
LDR             R1, [R5]
MOV             R8, #gSensor_i2c_addr_high_4_bit
MOVS            R2, #0
LDR.W           R3, [R8]
MOV             R10, R2
STR             R2, [SP,#0x24+mode] ; mode
MOV             ret, R6 ; which_chain
SMULBB          R1, R1, R4
MOVS            R2, #0x1C ; reg_addr
BIC.W           R3, R3, #0x1000100
BIC.W           R3, R3, #0x10000
ORR.W           R3, R3, #0x1000100 ; reg_data
UXTB            R1, R1  ; asic_addr
BL              BM1397_set_config
B               loc_27CBE

loc_27CB6
ret = R0                ; unsigned int
read_temperature_time = R10; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS.W           loc_27DC0

loc_27CBE
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R10; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_27CB6
UXTB            R2, ret
MOVW            ret, #:lower16:aAsicTemperatur ; "\nASIC temperature is %d\n"
MOVW            R10, #:lower16:gNotReadOutTemp
SUB.W           R3, R2, #0x40 ; '@'
MOVT            R0, #:upper16:aAsicTemperatur ; "\nASIC temperature is %d\n"
MOV             R1, R3
STR             R3, [SP,#0x24+remote_temp]
remote_temp_0 = R1      ; int
MOVT            R10, #:upper16:gNotReadOutTemp
BLX             printf

loc_27CF8
LDR             R1, [R5]
MOVS            R2, #0
LDR.W           R3, [R8]
MOV             R0, R6  ; which_chain
MOV             R8, R2
STR             R2, [SP,#0x24+mode] ; mode
MOVS            R2, #0x1C ; reg_addr
SMULBB          R1, R1, R4
BIC.W           R3, R3, #0x1000000
BIC.W           R3, R3, #0x10000
ORR.W           R3, R3, #0x1000000 ; reg_data
UXTB            R1, R1  ; asic_addr
BL              BM1397_set_config
B               loc_27D26

loc_27D20
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS             loc_27DA8

loc_27D26
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_27D20
UXTB            R2, ret
MOV             R0, #aPcbTemperature ; "\nPCB temperature is %d\n"
SUB.W           R3, R2, #0x40 ; '@'
MOV             R1, R3
STR             R3, [SP,#0x24+local_temp]
local_temp_0 = R1       ; int
BLX             printf

loc_27D58
LDRB.W          R3, [R10]
CBNZ            R3, loc_27DA0
LDR             R2, [SP,#0x24+remote_temp]
LDR             R3, [SP,#0x24+local_temp]
SUBS            R3, R3, R2
UXTB            R3, R3
temp_offset_value = R3  ; char
SXTB            R2, temp_offset_value
MOV             R1, R2

loc_27D6A
CMP.W           R9, #0
BEQ             loc_27DE6
CMP.W           R9, #1
BEQ             loc_27E04
LDR             R0, =cgpu.T3_offset_value
MOV             R4, #gT3_offset_value
STRB.W          R11, [SP,#0x24+offset_value+4]
STRB            R2, [R4]
LDRB            R2, [R0]
ADD             temp_offset_value, R2
UXTB            R3, R3
STRB            R3, [R0]
STRB.W          R3, [SP,#0x24+offset_value+5]

loc_27D92
MOV             R0, #aTempOffsetValu ; "\ntemp_offset_value = %d\n"
BLX             printf
B               loc_27BA2

loc_27DA0
MOVS            R1, #0
MOV             R2, R1
MOV             R3, R1
B               loc_27D6A

loc_27DA8
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
MOV             R2, ret
MOVW            ret, #:lower16:aSCanTReadOutHa ; "%s: Can't read out HASH BOARD TEMP. ret"...
ret = R2                ; unsigned int
MOVS            R3, #1
LDR             R1, =__FUNCTION__.8582 ; "BM1397_get_temperature_offset_value_fro"...
MOVT            R0, #:upper16:aSCanTReadOutHa ; "%s: Can't read out HASH BOARD TEMP. ret"...
STRB.W          R3, [R10]
BLX             printf
B               loc_27D58

loc_27DC0
ret = R0                ; unsigned int
read_temperature_time = R10; unsigned int
MOV             R2, ret
MOVW            R10, #:lower16:gNotReadOutTemp
MOVW            ret, #:lower16:aSCanTReadOutAs ; "%s: Can't read out ASIC TEMP. ret = 0x%"...
ret = R2                ; unsigned int
MOVT            R10, #:upper16:gNotReadOutTemp
MOVS            R3, #1
LDR             R1, =__FUNCTION__.8582 ; "BM1397_get_temperature_offset_value_fro"...
MOVT            R0, #:upper16:aSCanTReadOutAs ; "%s: Can't read out ASIC TEMP. ret = 0x%"...
STRB.W          R3, [R10]
BLX             printf
B               loc_27CF8

loc_27DE0
LDR.W           R11, [R3,#configuration.TempSensor1]
which_sensor = R11      ; unsigned int
B               loc_27B9C

loc_27DE6
temp_offset_value = R3  ; char
LDR             R0, =cgpu.T1_offset_value
MOV             R4, #gT1_offset_value
STRB.W          R11, [SP,#0x24+offset_value]
STRB            R2, [R4]
LDRB            R2, [R0]
ADD             temp_offset_value, R2
UXTB            R3, R3
STRB            R3, [R0]
STRB.W          R3, [SP,#0x24+offset_value+1]
B               loc_27D92

loc_27E04
temp_offset_value = R3  ; char
LDR             R0, =cgpu.T2_offset_value
MOV             R4, #gT2_offset_value
STRB.W          R11, [SP,#0x24+offset_value+2]
STRB            R2, [R4]
LDRB            R2, [R0]
ADD             temp_offset_value, R2
UXTB            R3, R3
STRB            R3, [R0]
STRB.W          R3, [SP,#0x24+offset_value+3]
B               loc_27D92
; End of function BM1397_get_temperature_offset_value_from_asic

ALIGN 4
off_27E24 DCD __FUNCTION__.8582 ; "BM1397_get_temperature_offset_value_fro"...
off_27E28 DCD cgpu.T3_offset_value
off_27E2C DCD cgpu.T1_offset_value
off_27E30 DCD cgpu.T2_offset_value



; void __fastcall BM1397_set_default_temperature_offset_value(unsigned __int8 which_chain)
EXPORT BM1397_set_default_temperature_offset_value
BM1397_set_default_temperature_offset_value

mode= -0x24
which_sensor= -0x1C
var_18= -0x18
var_14= -0x14
var_10= -0x10
var_C= -0xC
temp= -8

which_chain = R0        ; unsigned __int8
MOVW            R3, #:lower16:Conf
PUSH.W          {R4-R11,LR}
MOV             R4, R3
MOV             R6, which_chain
MOVW            R3, #:lower16:gT3_offset_value
MOVW            which_chain, #:lower16:aS ; "\n--- %s\n"
SUB             SP, SP, #0x24
MOV             R5, R3
MOVT            R0, #:upper16:aS ; "\n--- %s\n"
MOV.W           R3, #0x1100
LDR             R1, =__FUNCTION__.8606 ; "BM1397_set_default_temperature_offset_v"...
MOVW            R7, #:lower16:read_loop
STR             R3, [SP,#0x24+var_18]
MOVW            R10, #0xEEFF
BLX             printf
LDR             R3, [SP,#0x24+var_18]
MOV             R2, R4
MOVT            R2, #:upper16:Conf
MOVT            R7, #:upper16:read_loop
STR             R2, [SP,#0x24+var_C]
MOV.W           R11, #1
MOV             R2, R5
MOV.W           R9, #0
MOVT            R2, #:upper16:gT3_offset_value
MOVT            R3, #0x101
MOVT            R10, #0xFEFE
STR.W           R9, [SP,#0x24+var_14]
STR.W           R9, [SP,#0x24+which_sensor]
STR             R2, [SP,#0x24+temp]
STR             R3, [SP,#0x24+var_18]
STR.W           R10, [SP,#0x24+var_10]

loc_27E98
i = R9                  ; unsigned int
CMP.W           i, #0
BEQ.W           loc_28006
CMP.W           i, #1
BEQ.W           loc_28058
CMP.W           i, #2
IT NE
MOVNE.W         R10, #0
BEQ.W           loc_28032

loc_27EB6
data = R10              ; unsigned int
LDR             R3, [SP,#0x24+which_sensor]
CBNZ            R3, loc_27ED0

loc_27EBA
i = R11                 ; unsigned int
CMP.W           i, #3
BEQ             loc_27ECA

loc_27EC0
ADD.W           R9, R9, #1
ADD.W           i, i, #1
B               loc_27E98

loc_27ECA
i = R11                 ; unsigned int
ADD             SP, SP, #0x24 ; '$'
POP.W           {R4-i,PC}

loc_27ED0
MOVW            R5, #:lower16:gChain_Asic_Interval
SUBS            R4, R3, #1
MOVT            R5, #:upper16:gChain_Asic_Interval
MOVW            R3, #:lower16:gBM1397_MISC_CONTROL_reg
LDR             R1, [R5]
UXTB            R4, R4
MOVT            R3, #:upper16:gBM1397_MISC_CONTROL_reg
LDR             R3, [R3]
MOVS            R2, #0
STR             R2, [SP,#0x24+mode] ; mode
MOV             R0, R6  ; which_chain
SMULBB          R1, R1, R4
MOVS            R2, #0x18 ; reg_addr
ORR.W           R3, R3, #0x4000
ORR.W           R3, R3, #0x30 ; '0' ; reg_data
MOV.W           R8, #0
UXTB            R1, R1  ; asic_addr
BL              BM1397_set_config
LDR             R1, [R5]
MOV             R3, R8  ; mode
MOVS            R2, #0x18 ; reg
MOV             R0, R6  ; which_chain
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
B               loc_27F20

loc_27F1A
read_temperature_time = R8; unsigned int
ret = R0                ; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS             loc_27F3C

loc_27F20
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
read_temperature_time = R8; unsigned int
ret = R0                ; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_27F1A

loc_27F3C
LDR             R1, [R5]
MOVS            R2, #0
MOV             R8, R2
STR             R2, [SP,#0x24+mode] ; mode
MOV             R3, data ; reg_data
MOVS            R2, #0x1C ; reg_addr
MOV             ret, R6 ; which_chain
SMULBB          R1, R1, R4
UXTB            R1, R1  ; asic_addr
BL              BM1397_set_config
B               loc_27F5C

loc_27F56
read_temperature_time = R8; unsigned int
ret = R0                ; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS             loc_27F78

loc_27F5C
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
read_temperature_time = R8; unsigned int
ret = R0                ; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_27F56

loc_27F78
LDR             R1, [R5]
MOV             R3, #gSensor_i2c_addr_high_4_bit
MOVS            R2, #0
LDR             R3, [R3]
MOV             R8, R2
STR             R2, [SP,#0x24+mode] ; mode
MOV             ret, R6 ; which_chain
SMULBB          LR, R1, R4
LDR             R1, [SP,#0x24+var_10]
MOVS            R2, #0x1C ; reg_addr
ANDS            R3, R1
UXTB.W          R1, LR  ; asic_addr
ORR.W           R3, R3, #0x1000000
ORR.W           R3, R3, #0x1100 ; reg_data
BL              BM1397_set_config
B               loc_27FAE

loc_27FA8
read_temperature_time = R8; unsigned int
ret = R0                ; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS             loc_27FCA

loc_27FAE
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
read_temperature_time = R8; unsigned int
ret = R0                ; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_27FA8

loc_27FCA
offset = R0             ; char
LDR             R3, [SP,#0x24+var_14]
SXTB            offset, offset
CMP             R3, offset
BEQ.W           loc_27EBA
CMP.W           R9, #0
BEQ             loc_28092
CMP.W           R9, #1
BEQ             loc_28078
CMP.W           R9, #2
BNE.W           loc_27EBA
MOVW            R3, #:lower16:Sensor3_OK
MOVS            R2, #0
MOVT            R3, #:upper16:Sensor3_OK
MOV             R0, #aSensor3IsError ; "!!! sensor3 is error!\n"
STRB            R2, [R3]
ADD             SP, SP, #0x24 ; '$'
POP.W           {R4-R11,LR}
B.W             j_puts

loc_28006
LDR             R1, [SP,#0x24+var_C]
MOVW            R3, #:lower16:gSensor_i2c_addr_high_4_bit
MOVW            R2, #:lower16:gT1_offset_value
MOVT            R3, #:upper16:gSensor_i2c_addr_high_4_bit
MOVT            R2, #:upper16:gT1_offset_value
LDR             R3, [R3]
LDR.W           R1, [R1,#configuration.TempSensor1]
LDRSB.W         R2, [R2]
STR             R2, [SP,#0x24+var_14]

loc_28024
which_sensor_0 = R1     ; unsigned int
STR             which_sensor_0, [SP,#0x24+which_sensor]
UXTB            R2, R2
data = R2               ; unsigned int
LDR             which_sensor_0, [SP,#0x24+var_18]
ORRS            R3, R1
ORR.W           R10, R3, data
data = R10              ; unsigned int
B               loc_27EB6

loc_28032
i = R9                  ; unsigned int
LDR             R1, [SP,#0x24+var_C]
MOVW            R3, #:lower16:gSensor_i2c_addr_high_4_bit
LDR             R2, [SP,#0x24+temp]
MOVT            R3, #:upper16:gSensor_i2c_addr_high_4_bit
LDR             R3, [R3]
LDR.W           R1, [R1,#configuration.TempSensor3]
LDRSB.W         R2, [R2]
STR             R1, [SP,#0x24+which_sensor]
LDR             R1, [SP,#0x24+var_18]
STR             R2, [SP,#0x24+var_14]
UXTB            R2, R2
data = R2               ; unsigned int
ORRS            R3, R1
ORR.W           R10, R3, data
data = R10              ; unsigned int
B               loc_27EB6

loc_28058
MOVW            R2, #:lower16:gT2_offset_value
LDR             R1, [SP,#0x24+var_C]
MOVT            R2, #:upper16:gT2_offset_value
MOVW            R3, #:lower16:gSensor_i2c_addr_high_4_bit
LDRSB.W         R2, [R2]
MOVT            R3, #:upper16:gSensor_i2c_addr_high_4_bit
LDR             R3, [R3]
LDR.W           R1, [R1,#configuration.TempSensor2]
STR             R2, [SP,#0x24+var_14]
B               loc_28024

loc_28078
data = R10              ; unsigned int
offset = R0             ; char
MOVW            R3, #:lower16:Sensor2_OK
MOVW            offset, #:lower16:aSensor2IsError ; "!!! sensor2 is error!\n"
MOVT            R3, #:upper16:Sensor2_OK
MOVS            R2, #0
MOVT            R0, #:upper16:aSensor2IsError ; "!!! sensor2 is error!\n"
STRB            R2, [R3]
BLX             puts
i = R11                 ; unsigned int
B               loc_27EC0

loc_28092
offset = R0             ; char
MOVW            R3, #:lower16:Sensor1_OK
MOVW            offset, #:lower16:aSensor1IsError ; "!!! sensor1 is error!\n"
MOVT            R3, #:upper16:Sensor1_OK
MOVT            R0, #:upper16:aSensor1IsError ; "!!! sensor1 is error!\n"
STRB.W          R9, [R3]
BLX             puts
B               loc_27EBA
; End of function BM1397_set_default_temperature_offset_value

off_280AC DCD __FUNCTION__.8606 ; "BM1397_set_default_temperature_offset_v"...



; void __fastcall BM1397_read_asic_temperature_local_remote(unsigned __int8 which_chain)
EXPORT BM1397_read_asic_temperature_local_remote
BM1397_read_asic_temperature_local_remote

mode= -0x2C
var_24= -0x24
var_20= -0x20
var_1C= -0x1C
var_18= -0x18
var_14= -0x14
var_10= -0x10
var_C= -0xC
var_8= -8

which_chain = R0        ; unsigned __int8
LDR             R3, =(gSensor_OK+0xC)
MOVW            R2, #:lower16:Sensor1_temp
PUSH.W          {R4-R11,LR}
SUB             SP, SP, #0x2C
MOVW            R7, #:lower16:read_loop
MOVW            R1, #:lower16:Sensor2_temp
MOVW            R4, #:lower16:Sensor3_temp
MOVW            R5, #:lower16:Sensor4_temp
STR             R3, [SP,#0x2C+var_24]
MOVW            R3, #:lower16:Conf
MOV             R6, which_chain
MOVT            R7, #:upper16:read_loop
MOV             which_chain, R3
MOV.W           R9, #0
MOVW            R3, #:lower16:gBM1397_MISC_CONTROL_reg
MOVT            R0, #:upper16:Conf
MOVT            R2, #:upper16:Sensor1_temp
MOVT            R1, #:upper16:Sensor2_temp
MOVT            R4, #:upper16:Sensor3_temp
MOVT            R5, #:upper16:Sensor4_temp
MOVT            R3, #:upper16:gBM1397_MISC_CONTROL_reg
STR             R0, [SP,#0x2C+var_20]
STR             R2, [SP,#0x2C+var_C]
STR             R1, [SP,#0x2C+var_10]
STR             R4, [SP,#0x2C+var_14]
STR             R5, [SP,#0x2C+var_18]
STR             R3, [SP,#0x2C+var_1C]

loc_28106
i = R9                  ; unsigned int
CMP.W           i, #2
LDR             R3, [SP,#0x2C+var_20]
BEQ.W           loc_283DE
CMP.W           i, #3
BEQ.W           loc_283D8
CMP.W           i, #1
ITE NE
LDRNE.W         R10, [R3,#configuration.TempSensor1]
which_sensor = R10      ; unsigned int
LDREQ.W         which_sensor, [R3,#configuration.TempSensor2]

loc_28126
CMP.W           which_sensor, #0
BNE.W           loc_28274

loc_2812E
LDR             R3, [SP,#0x2C+var_24]
ADD.W           i, i, #1
CMP.W           i, #4
ADD.W           R3, R3, #1
STR             R3, [SP,#0x2C+var_24]
BNE             loc_28106
LDR             R3, [SP,#0x2C+var_C]
MOV             R8, #last_Sensor1_temp
MOV             R10, #last_Sensor2_temp
MOVW            R11, #:lower16:last_Sensor3_temp
LDR             R4, [R3]
MOVT            R11, #:upper16:last_Sensor3_temp
LDR             R3, [SP,#0x2C+var_10]
MOVW            i, #:lower16:last_Sensor4_temp
LDR.W           R0, [R10]
MOVT            R9, #:upper16:last_Sensor4_temp
MOVW            R1, #:lower16:gSensor_number
LDR             R6, [R3]
MOVT            R1, #:upper16:gSensor_number
LDR             R3, [SP,#0x2C+var_14]
LDR             R1, [R1]
ADDS            R2, R4, R6
LDR             R5, [R3]
LDR             R3, [SP,#0x2C+var_18]
ADD             R2, R5
LDR             R7, [R3]
LDR.W           R3, [R8]
ADD             R2, R7
SUBS            R3, R2, R3
LDR.W           R2, [R11]
SUBS            R0, R3, R0
LDR.W           R3, [R9]
SUBS            R0, R0, R2
SUBS            R0, R0, R3
BL              __aeabi_uidiv
MOV             R3, #temp_change
STR             R0, [R3]
CBZ             R0, loc_281B8
STR.W           R4, [R8]
STR.W           R6, [R10]
STR.W           R5, [R11]
STR.W           R7, [R9]

loc_281B8
MOVW            R2, #:lower16:highest_temp
MOVW            R1, #:lower16:lowest_temp
MOVT            R2, #:upper16:highest_temp
LDR             R3, [R2]
CMP             R4, R3
ITT GT
MOVGT           R3, R4
STRGT           R4, [R2]
CMP             R6, R3
ITT GT
MOVGT           R3, R6
STRGT           R6, [R2]
CMP             R5, R3
ITT GT
MOVGT           R3, R5
STRGT           R5, [R2]
CMP             R7, R3
ITT GT
STRGT           R7, [R2]
MOVGT           R3, R7
CMP             R6, #0
IT NE
CMPNE           R4, R6
ITEET LE
MOVTLE          R1, #:upper16:lowest_temp
MOVTGT          R1, #0x23 ; '#'
MOVGT           R4, R6
STRLE           R4, [R1]
IT GT
STRGT           R6, [R1]
MOVS            R2, R5
IT NE
MOVNE           R2, #1
CMP             R5, #0
IT NE
CMPNE           R5, R4
ITT LT
MOVLT           R4, R5
STRLT           R5, [R1]
CMP             R7, R4
ITE GE
MOVGE           R2, #0
ANDLT.W         R2, R2, #1
CBZ             R2, loc_28220
MOV             R4, R7
STR             R7, [R1]

loc_28220
MOVW            R2, #:lower16:gGlobalHighestTemp
SUBS            R4, R3, R4
max_temp_gap = R4       ; int
MOVT            R2, #:upper16:gGlobalHighestTemp
LDR             R1, [R2]
CMP             R1, R3
IT LT
STRLT           R3, [R2]
LDR             R2, [SP,#0x2C+var_20]
LDR.W           R2, [R2,#configuration.AlarmTemp]
CMP             R2, R3
ITTTT LT
MOVWLT          R2, #:lower16:gHigherThanAlarmTemp
MOVLT           R1, #1
MOVTLT          R2, #:upper16:gHigherThanAlarmTemp
STRBLT          R1, [R2]
LDR             R2, [SP,#0x2C+var_20]
LDR.W           R2, [R2,#configuration.MaxTempGap]
CMP             R2, max_temp_gap
BCS             loc_2826E
MOVW            R3, #:lower16:gMaxTempGap_value
MOVW            R2, #:lower16:gHigherThanMaxTempGap
MOVT            R3, #:upper16:gMaxTempGap_value
MOVT            R2, #:upper16:gHigherThanMaxTempGap
LDR             R1, [R3]
MOVS            R0, #1
STRB            R0, [R2]
CMP             max_temp_gap, R1
BGT.W           loc_2842C

loc_2826E
ADD             SP, SP, #0x2C ; ','
POP.W           {max_temp_gap-R11,PC}

loc_28274
i = R9                  ; unsigned int
which_sensor = R10      ; unsigned int
MOVW            R5, #:lower16:gChain_Asic_Interval
LDR             R3, [SP,#0x2C+var_1C]
MOVT            R5, #:upper16:gChain_Asic_Interval
ADD.W           R4, which_sensor, #0xFFFFFFFF
LDR             R1, [R5]
UXTB            R4, R4
LDR             R3, [R3]
MOV.W           R11, #0
MOV             R0, R6  ; which_chain
MOVS            R2, #0x18 ; reg_addr
STR.W           R11, [SP,#0x2C+mode] ; mode
MOV             R8, R11
SMULBB          R1, R1, R4
ORR.W           R3, R3, #0x4000
ORR.W           R3, R3, #0x30 ; '0' ; reg_data
UXTB            R1, R1  ; asic_addr
BL              BM1397_set_config
LDR             R1, [R5]
MOV             R3, R11 ; mode
MOVS            R2, #0x18 ; reg
MOV             R0, R6  ; which_chain
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
B               loc_282C2

loc_282BC
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS             loc_282DE

loc_282C2
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_282BC

loc_282DE
LDR             R1, [R5]
MOV             R11, #gSensor_i2c_addr_high_4_bit
MOVS            R2, #0
LDR.W           R3, [R11]
MOV             R8, R2
STR             R2, [SP,#0x2C+mode] ; mode
MOV             ret, R6 ; which_chain
SMULBB          R1, R1, R4
MOVS            R2, #0x1C ; reg_addr
BIC.W           R3, R3, #0x1000100
BIC.W           R3, R3, #0x10000
ORR.W           R3, R3, #0x1000100 ; reg_data
UXTB            R1, R1  ; asic_addr
BL              BM1397_set_config
B               loc_28314

loc_2830E
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS             loc_283E4

loc_28314
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_2830E
UXTB.W          R8, ret
MOV             R0, #aAsicDTempIsD ; "\nASIC %d TEMP is : %d\n"
SUB.W           R8, R8, #0x40 ; '@'
remote_temp = R8        ; int
MOV             R1, which_sensor
MOV             R2, remote_temp
BLX             printf
CMP.W           i, #0
BEQ.W           loc_28494
CMP.W           i, #1
ITT EQ
LDREQ           R3, [SP,#0x2C+var_10]
STREQ.W         remote_temp, [R3]
BEQ             loc_2836C
CMP.W           i, #2
ITE EQ
LDREQ           R3, [SP,#0x2C+var_14]
LDRNE           R3, [SP,#0x2C+var_18]
STR.W           remote_temp, [R3]

loc_2836C
LDR             R3, [SP,#0x2C+var_20]
LDR.W           R3, [R3,#configuration.StartSensor]
CMP             which_sensor, R3
BEQ             loc_28442

loc_28376
LDR             R1, [R5]
MOVS            R2, #0
LDR.W           R3, [R11]
MOV             R8, R2
STR             R2, [SP,#0x2C+mode] ; mode
MOV             R0, R6  ; which_chain
MOVS            R2, #0x1C ; reg_addr
SMULBB          R1, R1, R4
BIC.W           R3, R3, #0x1000000
BIC.W           R3, R3, #0x10000
ORR.W           R3, R3, #0x1000000 ; reg_data
UXTB            R1, R1  ; asic_addr
BL              BM1397_set_config
B               loc_283A4

loc_2839E
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
LDR             R3, [R7]
CMP             read_temperature_time, R3
BCS             loc_28408

loc_283A4
LDR             R1, [R5]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R6  ; which_chain
ADD.W           read_temperature_time, read_temperature_time, #1
SMULBB          R1, R1, R4
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R8; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_2839E
UXTB            R2, ret
MOVW            ret, #:lower16:aAsicDHashBoard ; "\nASIC %d Hash Board temperature is %d"...
MOV             R1, which_sensor
SUBS            R2, #0x40 ; '@'
MOVT            R0, #:upper16:aAsicDHashBoard ; "\nASIC %d Hash Board temperature is %d"...
BLX             printf
B               loc_2812E
off_283D4 DCD gSensor_OK+0xC

loc_283D8
LDR.W           R10, [R3,#configuration.TempSensor4]
which_sensor = R10      ; unsigned int
B               loc_28126

loc_283DE
LDR.W           R10, [R3,#configuration.TempSensor3]
which_sensor = R10      ; unsigned int
B               loc_28126

loc_283E4
ret = R0                ; unsigned int
MOVW            ret, #:lower16:aSDoNotReadOutA_0 ; "\n!!! %s: do not read out ASIC %d tempe"...
MOV             R2, which_sensor
LDR             R1, =__FUNCTION__.8637 ; "BM1397_read_asic_temperature_local_remo"...
MOVT            R0, #:upper16:aSDoNotReadOutA_0 ; "\n!!! %s: do not read out ASIC %d tempe"...
BLX             printf
MOVW            R3, #:lower16:gNotReadOutTemp
MOVS            R1, #1
MOVT            R3, #:upper16:gNotReadOutTemp
MOVS            R2, #0
STRB            R1, [R3]
LDR             R3, [SP,#0x2C+var_24]
STRB            R2, [R3]
B               loc_28376

loc_28408
ret = R0                ; unsigned int
MOVW            ret, #:lower16:aSDoNotReadOutA ; "\n!!! %s: do not read out ASIC %d Hash "...
MOV             R2, which_sensor
LDR             R1, =__FUNCTION__.8637 ; "BM1397_read_asic_temperature_local_remo"...
MOVT            R0, #:upper16:aSDoNotReadOutA ; "\n!!! %s: do not read out ASIC %d Hash "...
BLX             printf
MOVW            R3, #:lower16:gNotReadOutTemp
MOVS            R1, #1
MOVT            R3, #:upper16:gNotReadOutTemp
MOVS            R2, #0
STRB            R1, [R3]
LDR             R3, [SP,#0x2C+var_24]
STRB            R2, [R3]
B               loc_2812E

loc_2842C
max_temp_gap = R4       ; int
MOVW            R0, #:lower16:aGmaxtempgapVal ; "gMaxTempGap_value is %d\n\n"
MOV             R1, max_temp_gap
MOVT            R0, #:upper16:aGmaxtempgapVal ; "gMaxTempGap_value is %d\n\n"
STR             max_temp_gap, [R3]
ADD             SP, SP, #0x2C ; ','
POP.W           {max_temp_gap-R11,LR}
max_temp_gap = R1       ; int
B.W             j_printf

loc_28442
i = R9                  ; unsigned int
which_sensor = R10      ; unsigned int
remote_temp = R8        ; int
LDR             R3, [SP,#0x2C+var_20]
LDR.W           R3, [R3,#configuration.StartTemp]
CMP             remote_temp, R3
BLT             loc_2845E
MOV             R3, #gStartTest
LDRB            R2, [R3]
CBZ             R2, loc_2847E

loc_28458
MOVS            R2, #1
STRB            R2, [R3]
B               loc_28376

loc_2845E
MOV             R2, #gStartTest
LDRB            R2, [R2]
CMP             R2, #0
BNE             loc_28376
MOVW            R0, #:lower16:aAsicDTemperatu ; "\nASIC %d temperature is %d, waiting it"...
MOV             R2, remote_temp
MOV             R1, which_sensor
MOVT            R0, #:upper16:aAsicDTemperatu ; "\nASIC %d temperature is %d, waiting it"...
BLX             printf
B               loc_28376

loc_2847E
MOVW            R0, #:lower16:aBeginTestStart ; "\nBegin test!!! Start sensor is %d, ASI"...
MOV             R2, remote_temp
MOVT            R0, #:upper16:aBeginTestStart ; "\nBegin test!!! Start sensor is %d, ASI"...
MOV             R1, which_sensor
STR             R3, [SP,#0x2C+var_8]
BLX             printf
LDR             R3, [SP,#0x2C+var_8]
B               loc_28458

loc_28494
LDR             R3, [SP,#0x2C+var_C]
STR.W           remote_temp, [R3]
B               loc_2836C
; End of function BM1397_read_asic_temperature_local_remote

off_2849C DCD __FUNCTION__.8637 ; "BM1397_read_asic_temperature_local_remo"...



; void __fastcall BM1397_read_asic_temperature_local(unsigned __int8 which_chain)
EXPORT BM1397_read_asic_temperature_local
BM1397_read_asic_temperature_local

mode= -0x1C
var_10= -0x10
var_C= -0xC
var_8= -8

which_chain = R0        ; unsigned __int8
MOVW            R3, #:lower16:gSensor_read_ok_counter
MOVW            R2, #:lower16:gSensor_OK
MOVT            R3, #:upper16:gSensor_read_ok_counter
PUSH.W          {R4-R11,LR}
ADD.W           R3, R3, which_chain,LSL#4
SUB             SP, SP, #0x1C
MOVT            R2, #:upper16:gSensor_OK
MOVW            R11, #:lower16:Conf
STR             R3, [SP,#0x1C+var_10]
MOV             R7, which_chain
ADD.W           R3, R2, which_chain,LSL#2
MOVT            R11, #:upper16:Conf
STR             R2, [SP,#0x1C+var_8]
MOV.W           R8, #0
STR             R3, [SP,#0x1C+var_C]

loc_284D2
i = R8                  ; unsigned int
CMP.W           i, #0
BEQ.W           loc_286A6
CMP.W           i, #1
IT EQ
LDREQ.W         R10, [R11,#configuration.TempSensor2]
BEQ             loc_284F4
CMP.W           i, #2
ITE EQ
LDREQ.W         R10, [R11,#configuration.TempSensor3]
LDRNE.W         R10, [R11,#configuration.TempSensor4]

loc_284F4
CMP.W           R10, #0
BNE             loc_2850A

loc_284FA
ADD.W           R8, R8, #1
i = R8                  ; unsigned int
CMP.W           i, #4
BNE             loc_284D2

loc_28504
ADD             SP, SP, #0x1C
POP.W           {R4-R11,PC}

loc_2850A
MOVW            R6, #:lower16:gChain_Asic_Interval
ADD.W           R5, R10, #0xFFFFFFFF
MOVT            R6, #:upper16:gChain_Asic_Interval
MOVW            R3, #:lower16:gBM1397_MISC_CONTROL_reg
LDR             R1, [R6]
UXTB            R5, R5
MOVT            R3, #:upper16:gBM1397_MISC_CONTROL_reg
LDR             R3, [R3]
MOVS            R2, #0
STR             R2, [SP,#0x1C+mode] ; mode
MOV             R0, R7  ; which_chain
SMULBB          R1, R1, R5
MOVS            R2, #0x18 ; reg_addr
ORR.W           R3, R3, #0x4000
ORR.W           R3, R3, #0x30 ; '0' ; reg_data
MOVS            R4, #0
UXTB            R1, R1  ; asic_addr
MOV             R9, #read_loop
BL              BM1397_set_config
LDR             R1, [R6]
MOV             R3, R4  ; mode
MOVS            R2, #0x18 ; reg
MOV             R0, R7  ; which_chain
SMULBB          R1, R1, R5
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
B               loc_28564

loc_2855C
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
LDR.W           R3, [R9]
CMP             read_temperature_time, R3
BCS             loc_2857E

loc_28564
LDR             R1, [R6]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R7  ; which_chain
ADDS            read_temperature_time, #1
SMULBB          R1, R1, R5
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_2855C

loc_2857E
LDR             R1, [R6]
MOV             R3, #gSensor_i2c_addr_high_4_bit
MOVS            R2, #0
LDR             R3, [R3]
MOV             R4, R2
STR             R2, [SP,#0x1C+mode] ; mode
MOVW            R9, #:lower16:read_loop
SMULBB          R1, R1, R5
MOVS            R2, #0x1C ; reg_addr
BIC.W           R3, R3, #0x1000000
BIC.W           R3, R3, #0x10000
MOV             ret, R7 ; which_chain
ORR.W           R3, R3, #0x1000000 ; reg_data
UXTB            R1, R1  ; asic_addr
MOVT            R9, #:upper16:read_loop
BL              BM1397_set_config
B               loc_285BC

loc_285B4
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
LDR.W           R3, [R9]
CMP             read_temperature_time, R3
BCS             loc_28652

loc_285BC
LDR             R1, [R6]
MOVS            R3, #0  ; mode
MOVS            R2, #0x1C ; reg
MOV             R0, R7  ; which_chain
ADDS            read_temperature_time, #1
SMULBB          R1, R1, R5
UXTB            R1, R1  ; chip_addr
BL              check_BM1397_asic_reg
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
TST.W           ret, #0xC0000000
BNE             loc_285B4
MOVW            R2, #:lower16:highest_temp
UXTB            R3, ret
MOVT            R2, #:upper16:highest_temp
LDR             R1, [R2]
SUB.W           R4, R3, #0x40 ; '@'
local_temp = R4         ; int
CMP             local_temp, R1
IT GT
STRGT           local_temp, [R2]
CMP.W           R8, #0
BEQ             loc_286AC
CMP.W           R8, #1
BEQ.W           loc_28710
CMP.W           R8, #2
BEQ             loc_286D2
CMN.W           local_temp, #0x40 ; '@'
BEQ             loc_286F2
LDR             ret, [SP,#0x1C+var_10]
MOV             R2, #Sensor4_temp
MOVS            R1, #1
STR             local_temp, [R2]
LDR             R3, [R0,#0xC]
LDR             R2, [SP,#0x1C+var_C]
ADD             R3, R1
STRB            R1, [R2,#3]
STR             R3, [R0,#0xC]

loc_2861E
MOVW            R0, #:lower16:aAsicDHashBoard_0 ; "\nASIC %d Hash Board temperature is %d"...
MOV             R2, local_temp
MOVT            R0, #:upper16:aAsicDHashBoard_0 ; "\nASIC %d Hash Board temperature is %d"...
MOV             R1, R10
BLX             printf
LDR.W           R3, [R11,#configuration.StartSensor]
CMP             R10, R3
BNE.W           loc_284FA

loc_28638
LDR.W           R3, [R11,#configuration.StartTemp]
CMP             R3, R4
BGT             loc_28672
MOV             R5, #gStartTest
LDRB            R3, [R5]
CBZ             R3, loc_28694

loc_2864C
MOVS            R3, #1
STRB            R3, [R5]
B               loc_284FA

loc_28652
ret = R0                ; unsigned int
read_temperature_time = R4; unsigned int
MOV             R3, ret
MOVW            ret, #:lower16:aSDoNotReadOutA_1 ; "%s: do not read out ASIC %d Hash Boardt"...
ret = R3                ; unsigned int
MOV             R2, R10
MOVT            R0, #:upper16:aSDoNotReadOutA_1 ; "%s: do not read out ASIC %d Hash Boardt"...
LDR             R1, =__FUNCTION__.8656 ; "BM1397_read_asic_temperature_local"
BLX             printf
MOVW            R3, #:lower16:gNotReadOutTemp
MOVS            R2, #1
MOVT            R3, #:upper16:gNotReadOutTemp
STRB            R2, [R3]
B               loc_284FA

loc_28672
MOV             R2, #gStartTest
LDRB            R2, [R2]
CMP             R2, #0
BNE.W           loc_284FA
MOVW            R0, #:lower16:aAsicDHashBoard_1 ; "\nASIC %d Hash Board temperature is %d,"...
MOV             R2, R4
MOV             R1, R10
MOVT            R0, #:upper16:aAsicDHashBoard_1 ; "\nASIC %d Hash Board temperature is %d,"...
BLX             printf
B               loc_284FA

loc_28694
MOVW            R0, #:lower16:aBeginTestStart_0 ; "\nBegin test!!! Start sensor is %d, Has"...
MOV             R2, R4
MOV             R1, R10
MOVT            R0, #:upper16:aBeginTestStart_0 ; "\nBegin test!!! Start sensor is %d, Has"...
BLX             printf
B               loc_2864C

loc_286A6
LDR.W           R10, [R11,#configuration.TempSensor1]
which_sensor = R10      ; unsigned int
B               loc_284F4

loc_286AC
ret = R0                ; unsigned int
local_temp = R4         ; int
CMN.W           local_temp, #0x40 ; '@'
BEQ             loc_286CE
LDR             ret, [SP,#0x1C+var_10]
MOV             R2, #Sensor1_temp
MOVS            R1, #1
STR             local_temp, [R2]
LDR             R3, [R0]
LDR             R2, [SP,#0x1C+var_8]
ADD             R3, R1
STRB.W          R1, [R2,R7,LSL#2]
STR             R3, [R0]
B               loc_2861E

loc_286CE
ret = R0                ; unsigned int
MOVS            local_temp, #0
B               loc_2861E

loc_286D2
local_temp = R4         ; int
CMN.W           local_temp, #0x40 ; '@'
BEQ             loc_286CE
LDR             ret, [SP,#0x1C+var_10]
MOV             R2, #Sensor3_temp
MOVS            R1, #1
STR             local_temp, [R2]
LDR             R3, [R0,#8]
LDR             R2, [SP,#0x1C+var_C]
ADD             R3, R1
STRB            R1, [R2,#2]
STR             R3, [R0,#8]
B               loc_2861E

loc_286F2
ret = R0                ; unsigned int
MOVW            ret, #:lower16:aAsicDHashBoard_0 ; "\nASIC %d Hash Board temperature is %d"...
MOVS            R2, #0
MOVT            R0, #:upper16:aAsicDHashBoard_0 ; "\nASIC %d Hash Board temperature is %d"...
MOV             R1, R10
BLX             printf
LDR.W           R3, [R11,#configuration.StartSensor]
CMP             R10, R3
BNE.W           loc_28504
MOVS            R4, #0
B               loc_28638

loc_28710
ret = R0                ; unsigned int
local_temp = R4         ; int
CMN.W           local_temp, #0x40 ; '@'
BEQ             loc_286CE
LDR             R1, [SP,#0x1C+var_10]
MOVW            R2, #:lower16:Sensor2_temp
LDR             ret, [SP,#0x1C+var_C]
MOVT            R2, #:upper16:Sensor2_temp
STR             local_temp, [R2]
LDR             R3, [R1,#4]
STRB.W          R8, [R0,#1]
ADDS            R3, #1
STR             R3, [R1,#4]
B               loc_2861E
; End of function BM1397_read_asic_temperature_local

off_28730 DCD __FUNCTION__.8656 ; "BM1397_read_asic_temperature_local"


; Attributes: noreturn

; void *__fastcall __noreturn single_BM1397_show_status_func(void *arg)
EXPORT single_BM1397_show_status_func
single_BM1397_show_status_func

var_14= -0x14
var_10= -0x10
var_C= -0xC
var_8= -8

chain_info = R0         ; chain_info *
which_chain = R6        ; unsigned __int8
PUSH.W          {R4-R11,LR}
MOVW            R3, #:lower16:gIsOpenCoreEnd
MOVW            R4, #:lower16:gReadingTemp
SUB             SP, SP, #0x14
MOV             which_chain, R4
MOVT            R3, #:upper16:gIsOpenCoreEnd
STR             R3, [SP,#0x14+var_14]
MOV             R3, which_chain
MOVT            R3, #:upper16:gReadingTemp
MOVW            R2, #:lower16:start_receive
MOVW            R1, #:lower16:Conf
MOVW            R4, #:lower16:time_counter
MOVW            R8, #:lower16:gIsReadTemp
MOVW            R7, #:lower16:gValid_Nonce_Num
MOVW            R11, #:lower16:Sensor1_temp
MOVW            R10, #:lower16:lcd_fd
MOVW            R9, #:lower16:gStartTest
MOVW            R5, #:lower16:lcd_output
MOVT            R2, #:upper16:start_receive
MOVT            R1, #:upper16:Conf
STR             R3, [SP,#0x14+var_C]
MOVT            R4, #:upper16:time_counter
MOVS            R3, #0
LDRB            which_chain, [chain_info]
MOVT            R8, #:upper16:gIsReadTemp
STR             R2, [SP,#0x14+var_8]
STR             R1, [SP,#0x14+var_10]
MOVT            R7, #:upper16:gValid_Nonce_Num
MOVT            R11, #:upper16:Sensor1_temp
MOVT            R10, #:upper16:lcd_fd
MOVT            R9, #:upper16:gStartTest
MOVT            R5, #:upper16:lcd_output
STR             R3, [R4]
B               loc_287B2

loc_287A6               ; useconds
MOV             R0, #(gAsic_Core_Nonce_Num+0x926BC)
BLX             usleep

loc_287B2               ; n
MOVS            R2, #0x40 ; '@'
MOVS            R1, #0x20 ; ' ' ; c
MOV             R0, R5  ; s
BLX             memset
LDRB.W          R3, [R8]
CBZ             R3, loc_287C8
LDR             R3, [SP,#0x14+var_14]
LDRB            R3, [R3]
CBNZ            R3, loc_28828

loc_287C8
MOVW            R1, #:lower16:aTimeDs ; "   time %ds"
LDR             R2, [R4]
MOVT            R1, #:upper16:aTimeDs ; "   time %ds"
MOV             R0, R5  ; s
BLX             sprintf
MOVW            R1, #:lower16:aNonceD ; "   nonce=%d"
LDR.W           R2, [R7,which_chain,LSL#2]
MOVT            R1, #:upper16:aNonceD ; "   nonce=%d"
LDR             R0, =(lcd_output+0x10) ; s
BLX             sprintf
MOVW            R1, #:lower16:aT1DC ; "   T1 %d `C"
LDR.W           R2, [R11]
MOVT            R1, #:upper16:aT1DC ; "   T1 %d `C"
LDR             R0, =(lcd_output+0x20) ; s
BLX             sprintf
LDR             R3, [R4]
MOVS            R2, #0x40 ; '@' ; n
MOV             R1, R5  ; buf
LDR.W           R0, [R10] ; fd
ADDS            R3, #1
STR             R3, [R4]
BLX             write
LDRB.W          R3, [R9]
CMP             R3, #0
BEQ             loc_287A6
MOVW            R0, #:lower16:aGvalidNonceNum ; "\ngValid_Nonce_Num = %d\n"
LDR.W           R1, [R7,which_chain,LSL#2]
MOVT            R0, #:upper16:aGvalidNonceNum ; "\ngValid_Nonce_Num = %d\n"
BLX             printf
B               loc_287A6

loc_28828
LDR             R3, [SP,#0x14+var_8]
MOVW            R0, #:lower16:aS1StartReceive ; "%s 1: start_receive = %d\n"
LDR             R1, =__FUNCTION__.8665 ; "single_BM1397_show_status_func"
MOVT            R0, #:upper16:aS1StartReceive ; "%s 1: start_receive = %d\n"
LDRB            R2, [R3]
BLX             printf
MOVW            R0, #:lower16:aS1GisreadtempD ; "%s 1: gIsReadTemp = %d\n"
LDRB.W          R2, [R8]
LDR             R1, =__FUNCTION__.8665 ; "single_BM1397_show_status_func"
MOVT            R0, #:upper16:aS1GisreadtempD ; "%s 1: gIsReadTemp = %d\n"
BLX             printf
LDR             R3, [SP,#0x14+var_10]
MOVW            R0, #:lower16:aS1ConfSensorMo ; "%s 1: Conf.sensor_model = %d\n"
LDR             R1, =__FUNCTION__.8665 ; "single_BM1397_show_status_func"
MOVT            R0, #:upper16:aS1ConfSensorMo ; "%s 1: Conf.sensor_model = %d\n"
LDR.W           R2, [R3,#configuration.sensor_model]
BLX             printf
LDR             R2, [SP,#0x14+var_10]
MOVS            R3, #1
LDR             R1, [SP,#0x14+var_C]
LDR.W           R0, [R2,#configuration.timeout]
STRB            R3, [R1]
RSB.W           R0, R0, R0,LSL#4 ; useconds
BLX             usleep
LDR             R2, [SP,#0x14+var_10]
LDR.W           R3, [R2,#configuration.sensor_model]
SUBS            R2, R3, #1
CMP             R2, #1
BLS             loc_288BC
SUBS            R3, #3
CMP             R3, #5
BLS             loc_288A2
MOVW            R0, #:lower16:aSPleaseConfigS ; "\n%s: please config sensor_model in Con"...
LDR             R1, =__FUNCTION__.8665 ; "single_BM1397_show_status_func"
MOVT            R0, #:upper16:aSPleaseConfigS ; "\n%s: please config sensor_model in Con"...
BLX             printf

loc_28894               ; level
MOVS            R0, #6
BL              fan_control
LDR             R2, [SP,#0x14+var_C]
MOVS            R3, #0
STRB            R3, [R2]
B               loc_287C8

loc_288A2
MOVW            R0, #:lower16:aSD ; "%s %d\n"
MOVW            R2, #0x8DD
LDR             R1, =__FUNCTION__.8665 ; "single_BM1397_show_status_func"
MOVT            R0, #:upper16:aSD ; "%s %d\n"
BLX             printf
MOV             R0, which_chain ; which_chain
BL              BM1397_read_asic_temperature_local
B               loc_28894

loc_288BC
MOVW            R0, #:lower16:aSD ; "%s %d\n"
MOVW            R2, #0x8D7
LDR             R1, =__FUNCTION__.8665 ; "single_BM1397_show_status_func"
MOVT            R0, #:upper16:aSD ; "%s %d\n"
BLX             printf
MOV             R0, which_chain ; which_chain
BL              BM1397_read_asic_temperature_local_remote
B               loc_28894
; End of function single_BM1397_show_status_func

ALIGN 4
off_288D8 DCD lcd_output+0x10
off_288DC DCD lcd_output+0x20
off_288E0 DCD __FUNCTION__.8665 ; "single_BM1397_show_status_func"



; int __fastcall BM1397_is_nonce_or_reg_value(unsigned int data)
EXPORT BM1397_is_nonce_or_reg_value
BM1397_is_nonce_or_reg_value
data = R0               ; unsigned int
LSRS            data, data, #0x1F
BX              LR
; End of function BM1397_is_nonce_or_reg_value




; int __fastcall BM1397_check_nonce_flag(unsigned int data)
EXPORT BM1397_check_nonce_flag
BM1397_check_nonce_flag
data = R0               ; unsigned int
PUSH            {R3,LR}
AND.W           R3, data, #0xE0
CMP             R3, #0x80
BEQ             loc_28906
MOV             R2, data
MOVW            data, #:lower16:aSData0x08x ; "%s: data = 0x%08x\n"
data = R2               ; unsigned int
LDR             R1, =__FUNCTION__.8673 ; "BM1397_check_nonce_flag"
MOVT            R0, #:upper16:aSData0x08x ; "%s: data = 0x%08x\n"
BLX             printf
MOVS            R0, #0
POP             {R3,PC}

loc_28906
data = R0               ; unsigned int
MOVS            data, #1
POP             {R3,PC}
; End of function BM1397_check_nonce_flag

ALIGN 4
off_2890C DCD __FUNCTION__.8673 ; "BM1397_check_nonce_flag"



; int __fastcall single_BM1397_check_nonce(unsigned __int8 which_chain, unsigned int *buf)
EXPORT single_BM1397_check_nonce
single_BM1397_check_nonce

var_14= -0x14
temp_nonce= -0x10
OpenCoreNum4= -0xC
OpenCoreNum8= -8

which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
PUSH.W          {R4-R11,LR}
MOVW            R3, #:lower16:gChain_Asic_Interval
LDR             R5, [buf,#4]
MOVT            R3, #:upper16:gChain_Asic_Interval
SUB             SP, SP, #0x14
MOV             R8, which_chain
LDR.W           R10, [buf]
MOVW            R9, #:lower16:Conf
LDR             buf, [R3]
UBFX.W          which_chain, R5, #0xE, #8
LSRS            R6, R5, #0x1F
MOVT            R9, #:upper16:Conf
UBFX.W          R7, R10, #0x10, #0xF
BL              __aeabi_uidiv
UBFX.W          R3, R5, #0x16, #9
MOV             R2, R0
ORR.W           R6, R6, R3,LSL#1
LDR.W           R3, [R9,#configuration.OpenCoreNum4]
LDR.W           R1, [R9,#configuration.OpenCoreNum1]
OpenCoreNum1 = R1       ; unsigned int
LDR.W           R0, [R9,#configuration.OpenCoreNum2]
OpenCoreNum2 = R0       ; unsigned int
STR             R3, [SP,#0x14+OpenCoreNum4]
LDR.W           R3, [R9,#configuration.OpenCoreNum8]
LDR.W           R4, [R9,#configuration.OpenCoreNum3]
OpenCoreNum3 = R4       ; unsigned int
LDR.W           LR, [R9,#configuration.OpenCoreNum5]
OpenCoreNum5 = R14      ; unsigned int
LDR.W           R12, [R9,#configuration.OpenCoreNum6]
OpenCoreNum6 = R12      ; unsigned int
LDR.W           R11, [R9,#configuration.OpenCoreNum7]
OpenCoreNum7 = R11      ; unsigned int
STR             R3, [SP,#0x14+OpenCoreNum8]
which_asic = R2         ; unsigned int
which_pattern = R7      ; unsigned int
data_0 = R10            ; unsigned int
data_1 = R5             ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
CMP             which_asic, #0
BNE.W           loc_28C68
CMP.W           R6, #0x2A0
BGE.W           loc_28C9A
LDR.W           R9, [R9,#configuration.pattern_number]
CMP             which_pattern, R9
BCS.W           loc_28C80
CMP             R6, #0x1F
BLE             loc_28A08
SUB.W           R9, R6, #0x20 ; ' '
CMP.W           R9, #0x1F
BHI             loc_28A88
MOVS            OpenCoreNum8_0, #0x20 ; ' '

loc_28994
the_core_should_be_test = R2; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum1 = R1       ; unsigned int
SUBS            R3, #1
BNE             loc_28994
SUB.W           OpenCoreNum1, R6, #0x1F

loc_289A8
i = R3                  ; unsigned int
TST.W           OpenCoreNum2, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R1, R3
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
i = R3                  ; unsigned int
BNE             loc_289A8

loc_289BC
SUBS            the_core_should_be_test, #1

loc_289BE
ADD.W           R2, R2, #0x20000
MOV             R3, #cgpu
ADDS            R2, #0x2A ; '*'
ADD.W           R2, R3, R2,LSL#2
ADD.W           which_pattern, which_pattern, which_pattern,LSL#4
LDR             R3, [R2,#4]
ADD.W           R7, R3, R7,LSL#2
work = R7               ; work *
LDR             R3, [work,#4]
CMP             data_1, R3
BNE             loc_28A22
ADD.W           work, work, R8,LSL#2
match_nonce = R3        ; unsigned int
LDR             R0, [R7,#0x34]
CMP             R0, #0
BEQ             loc_28AE6
MOVW            match_nonce, #:lower16:gRepeated_Nonce_Id
ADDS            R0, #1
MOVT            R3, #:upper16:gRepeated_Nonce_Id
STR             R0, [R7,#0x34]
LDR.W           R2, [R3,R8,LSL#2]
MOVS            R0, #0
ADDS            R2, #1
STR.W           R2, [R3,R8,LSL#2]

loc_28A02
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}

loc_28A08
which_asic = R2         ; unsigned int
which_pattern = R7      ; unsigned int
data_0 = R10            ; unsigned int
data_1 = R5             ; unsigned int
OpenCoreNum1 = R1       ; unsigned int
OpenCoreNum2 = R0       ; unsigned int
OpenCoreNum3 = R4       ; unsigned int
OpenCoreNum5 = R14      ; unsigned int
OpenCoreNum6 = R12      ; unsigned int
OpenCoreNum7 = R11      ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
ADDS            OpenCoreNum2, R6, #1
MOV             OpenCoreNum8_0, which_asic

loc_28A0C
i = R3                  ; unsigned int
the_core_should_be_test = R2; unsigned int
TST.W           OpenCoreNum1, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R3, R0
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
i = R3                  ; unsigned int
BNE             loc_28A0C
B               loc_289BC

loc_28A22
match_nonce = R3        ; unsigned int
work = R7               ; work *
MOVW            match_nonce, #:lower16:HW_check_mutex
ADD.W           data_0, R8, R8,LSL#1
data_1 = R5             ; unsigned int
MOVT            R3, #:upper16:HW_check_mutex
ADD.W           R10, R3, R10,LSL#3
MOV             R9, #gWork_Num_For_Hw_Check
MOV             R0, R10 ; mutex
BLX             pthread_mutex_lock
LDRB.W          OpenCoreNum3, [R9]
CMP             R4, #0
BEQ.W           loc_28C5E
MOVW            R3, #:lower16:gWorks_For_Hw_Check
ADD.W           R4, R8, R8,LSL#4
MOVT            R3, #:upper16:gWorks_For_Hw_Check
ADD.W           R4, R3, R4,LSL#9
MOVS            work, #0
B               loc_28A66

loc_28A5E
i = R7                  ; unsigned int
LDRB.W          R3, [R9]
CMP             R3, i
BLS             loc_28B18

loc_28A66               ; work
MOV             R0, R4
MOVS            R2, #0  ; print
MOV             R1, data_1 ; nonce
ADDS            i, #1
ADDS            R4, #0x44 ; 'D'
BL              check_hw
i = R7                  ; unsigned int
CMP             R0, #0
BNE             loc_28A5E
MOV             OpenCoreNum7, R0
MOV             R0, R10 ; mutex
BLX             pthread_mutex_unlock
MOV             R0, R11
ADD             SP, SP, #0x14
POP.W           {R4-R11,PC}

loc_28A88
which_asic = R2         ; unsigned int
which_pattern = R7      ; unsigned int
data_0 = R10            ; unsigned int
data_1 = R5             ; unsigned int
OpenCoreNum1 = R1       ; unsigned int
OpenCoreNum2 = R0       ; unsigned int
OpenCoreNum3 = R4       ; unsigned int
OpenCoreNum5 = R14      ; unsigned int
OpenCoreNum6 = R12      ; unsigned int
OpenCoreNum7 = R11      ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
SUB.W           R9, R6, #0x40 ; '@'
CMP.W           R9, #0x1F
BLS             loc_28B58
SUB.W           R9, R6, #0x60 ; '`'
CMP.W           R9, #0x1F
BHI             loc_28B90
LDR             OpenCoreNum8_0, [SP,#0x14+OpenCoreNum4]
MOV.W           LR, #0x20 ; ' '

loc_28AA2
the_core_should_be_test = R2; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum1 = R1       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum2 = R0       ; unsigned int
TST.W           OpenCoreNum3, #1
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum3 = R4       ; unsigned int
SUBS.W          LR, LR, #1
BNE             loc_28AA2
OpenCoreNum4_0 = R3     ; unsigned int
SUB.W           OpenCoreNum1, R6, #0x5F ; '_'

loc_28AD0
i = R14                 ; unsigned int
TST.W           OpenCoreNum4_0, #1
ADD.W           LR, LR, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             LR, R1
MOV.W           OpenCoreNum4_0, OpenCoreNum4_0,LSR#1
i = R14                 ; unsigned int
BNE             loc_28AD0
B               loc_289BC

loc_28AE6
match_nonce = R3        ; unsigned int
ADD.W           R6, R6, R8,LSL#17
MOVW            match_nonce, #:lower16:gAsic_Core_Nonce_Num
MOVW            R2, #:lower16:gValid_Nonce_Num
MOVT            R3, #:upper16:gAsic_Core_Nonce_Num
MOVT            R2, #:upper16:gValid_Nonce_Num
MOVS            R1, #1
LDR.W           OpenCoreNum3, [R2,R8,LSL#2]
STR             R1, [R7,#0x34]
LDR.W           R1, [R3,R6,LSL#2]
ADDS            R4, #1
STR.W           R4, [R2,R8,LSL#2]
ADDS            R1, #1
STR.W           R1, [R3,R6,LSL#2]
ADD             SP, SP, #0x14
POP.W           {R4-OpenCoreNum7,PC}

loc_28B18
i = R7                  ; unsigned int
data_1 = R5             ; unsigned int
MOV             OpenCoreNum7, R0
ret = R0                ; int
MOV             ret, R10 ; mutex
ret = R11               ; int
BLX             pthread_mutex_unlock
CMP.W           ret, #1
IT NE
MOVNE           R0, #0
BNE.W           loc_28A02
MOVW            R4, #:lower16:gHw_Nonce_Num
STR             data_1, [SP,#0x14+temp_nonce]
MOVT            R4, #:upper16:gHw_Nonce_Num
MOVW            R0, #:lower16:aSFindAHwChainD ; "%s: Find a HW. Chain%d ASIC%d Core%d : "...
LDR.W           data_1, [R4,R8,LSL#2]
MOV             R2, R8
STR             R6, [SP,#0x14+var_14]
MOVT            R0, #:upper16:aSFindAHwChainD ; "%s: Find a HW. Chain%d ASIC%d Core%d : "...
MOVS            R3, #0
LDR             R1, =__FUNCTION__.8698 ; "single_BM1397_check_nonce"
ADDS            R5, #1
STR.W           R5, [R4,R8,LSL#2]
BLX             printf
MOVS            R0, #0
B               loc_28A02

loc_28B58
which_asic = R2         ; unsigned int
which_pattern = R7      ; unsigned int
data_0 = R10            ; unsigned int
data_1 = R5             ; unsigned int
OpenCoreNum1 = R1       ; unsigned int
OpenCoreNum2 = R0       ; unsigned int
OpenCoreNum3 = R4       ; unsigned int
OpenCoreNum5 = R14      ; unsigned int
OpenCoreNum6 = R12      ; unsigned int
OpenCoreNum7 = R11      ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
MOVS            OpenCoreNum8_0, #0x20 ; ' '

loc_28B5A
the_core_should_be_test = R2; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum1 = R1       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum2 = R0       ; unsigned int
SUBS            R3, #1
BNE             loc_28B5A
SUB.W           OpenCoreNum1, R6, #0x3F ; '?'

loc_28B7A
i = R3                  ; unsigned int
TST.W           OpenCoreNum3, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R1, R3
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
i = R3                  ; unsigned int
BNE             loc_28B7A
B               loc_289BC

loc_28B90
which_asic = R2         ; unsigned int
OpenCoreNum1 = R1       ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
SUB.W           R9, R6, #0x80
CMP.W           R9, #0x1F
BLS             loc_28C08
SUB.W           R9, R6, #0xA0
CMP.W           R9, #0x1F
BHI.W           loc_28CB4
LDR             OpenCoreNum8_0, [SP,#0x14+OpenCoreNum4]
MOV.W           R9, #0x20 ; ' '

loc_28BAC
the_core_should_be_test = R2; unsigned int
OpenCoreNum4_0 = R3     ; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum1 = R1       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum2 = R0       ; unsigned int
TST.W           OpenCoreNum3, #1
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum3 = R4       ; unsigned int
TST.W           OpenCoreNum4_0, #1
MOV.W           OpenCoreNum4_0, OpenCoreNum4_0,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum4_0 = R3     ; unsigned int
TST.W           LR, #1
MOV.W           LR, LR,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum5 = R14      ; unsigned int
SUBS.W          R9, R9, #1
BNE             loc_28BAC
SUB.W           OpenCoreNum4_0, R6, #0x9F

loc_28BF2
i = R9                  ; unsigned int
TST.W           OpenCoreNum6, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R3, R9
MOV.W           OpenCoreNum6, OpenCoreNum6,LSR#1
i = R9                  ; unsigned int
BNE             loc_28BF2
B               loc_289BC

loc_28C08
which_asic = R2         ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
LDR             OpenCoreNum8_0, [SP,#0x14+OpenCoreNum4]
MOV.W           OpenCoreNum6, #0x20 ; ' '

loc_28C0E
the_core_should_be_test = R2; unsigned int
OpenCoreNum4_0 = R3     ; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum1 = R1       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum2 = R0       ; unsigned int
TST.W           OpenCoreNum3, #1
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum3 = R4       ; unsigned int
TST.W           OpenCoreNum4_0, #1
MOV.W           OpenCoreNum4_0, OpenCoreNum4_0,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum4_0 = R3     ; unsigned int
SUBS.W          R12, R12, #1
BNE             loc_28C0E
SUB.W           OpenCoreNum4_0, R6, #0x7F

loc_28C48
i = R12                 ; unsigned int
TST.W           LR, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R12, R3
MOV.W           LR, LR,LSR#1
i = R12                 ; unsigned int
BNE             loc_28C48
B               loc_289BC

loc_28C5E               ; mutex
data_1 = R5             ; unsigned int
work = R7               ; work *
MOV             R0, R10
BLX             pthread_mutex_unlock
MOV             R0, R4
B               loc_28A02

loc_28C68
which_asic = R2         ; unsigned int
which_pattern = R7      ; unsigned int
data_0 = R10            ; unsigned int
data_1 = R5             ; unsigned int
OpenCoreNum1 = R1       ; unsigned int
OpenCoreNum2 = R0       ; unsigned int
OpenCoreNum3 = R4       ; unsigned int
OpenCoreNum5 = R14      ; unsigned int
OpenCoreNum6 = R12      ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
MOVW            OpenCoreNum2, #:lower16:aSReceivedAsic0_0 ; "%s: received ASIC%02d nonce. error!!! d"...
STR             data_1, [SP,#0x14+var_14]
MOV             OpenCoreNum8_0, data_0
MOVT            R0, #:upper16:aSReceivedAsic0_0 ; "%s: received ASIC%02d nonce. error!!! d"...
LDR             OpenCoreNum1, =__FUNCTION__.8698 ; "single_BM1397_check_nonce"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_28A02

loc_28C80
which_asic = R2         ; unsigned int
OpenCoreNum1 = R1       ; unsigned int
OpenCoreNum2 = R0       ; unsigned int
OpenCoreNum5 = R14      ; unsigned int
OpenCoreNum6 = R12      ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
MOVW            OpenCoreNum2, #:lower16:aSReceivedWorkI_0 ; "%s: received work_id = %02d nonce. erro"...
STR             data_1, [SP,#0x14+var_14]
MOV             OpenCoreNum8_0, data_0
MOV             which_asic, which_pattern
MOVT            R0, #:upper16:aSReceivedWorkI_0 ; "%s: received work_id = %02d nonce. erro"...
LDR             OpenCoreNum1, =__FUNCTION__.8698 ; "single_BM1397_check_nonce"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_28A02

loc_28C9A
which_asic = R2         ; unsigned int
OpenCoreNum1 = R1       ; unsigned int
OpenCoreNum2 = R0       ; unsigned int
OpenCoreNum5 = R14      ; unsigned int
OpenCoreNum6 = R12      ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
MOVW            OpenCoreNum2, #:lower16:aSReceivedCore0_0 ; "%s: received core%02d nonce. error!!! d"...
STR             data_1, [SP,#0x14+var_14]
MOV             OpenCoreNum8_0, data_0
MOV             which_asic, R6
MOVT            R0, #:upper16:aSReceivedCore0_0 ; "%s: received core%02d nonce. error!!! d"...
LDR             OpenCoreNum1, =__FUNCTION__.8698 ; "single_BM1397_check_nonce"
BLX             printf
MOV.W           R0, #0xFFFFFFFF
B               loc_28A02

loc_28CB4
which_asic = R2         ; unsigned int
OpenCoreNum1 = R1       ; unsigned int
OpenCoreNum2 = R0       ; unsigned int
OpenCoreNum5 = R14      ; unsigned int
OpenCoreNum6 = R12      ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
SUB.W           which_asic, R6, #0xC0
CMP             R2, #0x1F
BHI             loc_28D2C
LDR             OpenCoreNum8_0, [SP,#0x14+OpenCoreNum4]
MOV.W           R9, #0x20 ; ' '
MOVS            R2, #0

loc_28CC4
the_core_should_be_test = R2; unsigned int
OpenCoreNum4_0 = R3     ; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum1 = R1       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum2 = R0       ; unsigned int
TST.W           OpenCoreNum3, #1
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum3 = R4       ; unsigned int
TST.W           OpenCoreNum4_0, #1
MOV.W           OpenCoreNum4_0, OpenCoreNum4_0,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum4_0 = R3     ; unsigned int
TST.W           LR, #1
MOV.W           LR, LR,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum5 = R14      ; unsigned int
TST.W           OpenCoreNum6, #1
MOV.W           OpenCoreNum6, OpenCoreNum6,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum6 = R12      ; unsigned int
SUBS.W          R9, R9, #1
BNE             loc_28CC4
SUB.W           OpenCoreNum4_0, R6, #0xBF

loc_28D16
i = R9                  ; unsigned int
TST.W           OpenCoreNum7, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R9, R3
MOV.W           OpenCoreNum7, OpenCoreNum7,LSR#1
i = R9                  ; unsigned int
BNE             loc_28D16
B               loc_289BC

loc_28D2C
OpenCoreNum8_0 = R3     ; unsigned int
SUB.W           R2, R6, #0xE0
CMP             R2, #0x1F
BHI             loc_28DB2
LDR             OpenCoreNum8_0, [SP,#0x14+OpenCoreNum4]
MOV.W           R9, #0x20 ; ' '
MOVS            R2, #0

loc_28D3C
the_core_should_be_test = R2; unsigned int
OpenCoreNum4_0 = R3     ; unsigned int
TST.W           OpenCoreNum1, #1
MOV.W           OpenCoreNum1, OpenCoreNum1,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum1 = R1       ; unsigned int
TST.W           OpenCoreNum2, #1
MOV.W           OpenCoreNum2, OpenCoreNum2,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum2 = R0       ; unsigned int
TST.W           OpenCoreNum3, #1
MOV.W           OpenCoreNum3, OpenCoreNum3,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum3 = R4       ; unsigned int
TST.W           OpenCoreNum4_0, #1
MOV.W           OpenCoreNum4_0, OpenCoreNum4_0,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum4_0 = R3     ; unsigned int
TST.W           LR, #1
MOV.W           LR, LR,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum5 = R14      ; unsigned int
TST.W           OpenCoreNum6, #1
MOV.W           OpenCoreNum6, OpenCoreNum6,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum6 = R12      ; unsigned int
TST.W           OpenCoreNum7, #1
MOV.W           OpenCoreNum7, OpenCoreNum7,LSR#1
IT NE
ADDNE           the_core_should_be_test, #1
OpenCoreNum7 = R11      ; unsigned int
SUBS.W          R9, R9, #1
BNE             loc_28D3C
LDR             OpenCoreNum1, [SP,#0x14+OpenCoreNum8]
SUB.W           OpenCoreNum4_0, R6, #0xDF

loc_28D9C
i = R9                  ; unsigned int
OpenCoreNum8_0 = R1     ; unsigned int
TST.W           OpenCoreNum8_0, #1
ADD.W           i, i, #1
IT NE
ADDNE           the_core_should_be_test, #1
CMP             R9, R3
MOV.W           OpenCoreNum8_0, OpenCoreNum8_0,LSR#1
i = R9                  ; unsigned int
BNE             loc_28D9C
B               loc_289BC

loc_28DB2
OpenCoreNum1 = R1       ; unsigned int
OpenCoreNum8_0 = R3     ; unsigned int
MOVW            OpenCoreNum2, #:lower16:aSWhichCoreDErr ; "%s: which_core = %d, error!!!\n"
MOV             R2, R6
MOVT            R0, #:upper16:aSWhichCoreDErr ; "%s: which_core = %d, error!!!\n"
LDR             OpenCoreNum1, =__FUNCTION__.8698 ; "single_BM1397_check_nonce"
BLX             printf
MOV.W           R2, #0xFFFFFFFF
B               loc_289BE
; End of function single_BM1397_check_nonce

off_28DC8 DCD __FUNCTION__.8698 ; "single_BM1397_check_nonce"



; int __fastcall single_BM1397_check_register_value(unsigned __int8 which_chain, unsigned int *buf)
EXPORT single_BM1397_check_register_value
single_BM1397_check_register_value
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
PUSH            {R3-R7,LR}
MOV             R5, #reg_value_buf
LDR             R3, [R5]
LDR             R3, [R3,#8]
CMP.W           R3, #0x1FE
BHI             loc_28E3C
LDM.W           buf, {R4,R7}
LSLS            R3, R4, #0x19
BMI             loc_28E66
ANDS.W          R6, R4, #0x20000000
BNE             loc_28E4E
MOV             R0, #reg_mutex ; mutex
BLX             pthread_mutex_lock
LDR             R2, [R5]
LSRS            R3, data_0, #8
LSRS            R5, data_0, #0x10
UBFX.W          LR, data_0, #0x18, #5
AND.W           data_0, data_0, #0xF
data_1 = R7             ; unsigned int
LDR             R1, [R2]
ADD.W           R0, R2, R1,LSL#3
ADDS            R1, #1
CMP.W           R1, #0x200
STR             data_1, [R0,#0x10]
STRB.W          LR, [R0,#0x16]
STRB            R5, [R0,#0x14]
STRB            R4, [R0,#0x17]
STRB            R3, [R0,#0x15]
MOVW            R0, #:lower16:reg_mutex
LDR             R3, [R2,#8]
MOVT            R0, #:upper16:reg_mutex ; mutex
STR             R1, [R2]
IT CS
STRCS           R6, [R2]
ADDS            R3, #1
STR             R3, [R2,#8]
BLX             pthread_mutex_unlock
MOVS            R0, #0
POP             {R3-data_1,PC}

loc_28E3C
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
MOVW            which_chain, #:lower16:aSRegValueBufBu ; "%s: reg_value_buf buffer is full!\n"
LDR             buf, =__FUNCTION__.8752 ; "single_BM1397_check_register_value"
MOVT            R0, #:upper16:aSRegValueBufBu ; "%s: reg_value_buf buffer is full!\n"
BLX             printf
MOVS            R0, #0
POP             {R3-R7,PC}

loc_28E4E
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
data_0 = R4             ; unsigned int
data_1 = R7             ; unsigned int
MOVW            which_chain, #:lower16:aSRegTypeErrorD ; "%s: REG_TYPE error. data[0] = 0x%08x, r"...
MOV             R3, data_1
MOV             R2, data_0
LDR             buf, =__FUNCTION__.8752 ; "single_BM1397_check_register_value"
MOVT            R0, #:upper16:aSRegTypeErrorD ; "%s: REG_TYPE error. data[0] = 0x%08x, r"...
BLX             printf
MOV.W           R0, #0xFFFFFFFF
POP             {R3-data_1,PC}

loc_28E66
which_chain = R0        ; unsigned __int8
buf = R1                ; unsigned int *
data_0 = R4             ; unsigned int
data_1 = R7             ; unsigned int
MOVW            which_chain, #:lower16:aSRegCrcErrorDa ; "%s: reg crc error. data[0] = 0x%08x, re"...
MOV             R3, data_1
MOV             R2, data_0
LDR             buf, =__FUNCTION__.8752 ; "single_BM1397_check_register_value"
MOVT            R0, #:upper16:aSRegCrcErrorDa ; "%s: reg crc error. data[0] = 0x%08x, re"...
BLX             printf
MOV.W           R0, #0xFFFFFFFF
POP             {R3-data_1,PC}
; End of function single_BM1397_check_register_value

ALIGN 0x10
off_28E80 DCD __FUNCTION__.8752 ; "single_BM1397_check_register_value"



; void *__fastcall single_BM1397_receive_func(void *arg)
EXPORT single_BM1397_receive_func
single_BM1397_receive_func

buf= -8

chain_info = R0         ; chain_info *
which_chain = R7        ; unsigned __int8
PUSH.W          {R4-R10,LR}
MOVS            R3, #0
SUB             SP, SP, #8
MOVW            R6, #:lower16:start_receive
MOVW            R8, #:lower16:gBegin_Get_Nonce
MOVT            R6, #:upper16:start_receive
LDRB            which_chain, [chain_info]
MOVT            R8, #:upper16:gBegin_Get_Nonce
LDR.W           R9, =__FUNCTION__.8673 ; "BM1397_check_nonce_flag"
STR             R3, [SP,#8+buf]
STR             R3, [SP,#8+buf+4]
B               loc_28EBC

loc_28EA8               ; useconds
MOVW            R0, #0x1388
BLX             usleep
MOVS            R0, #6  ; address
BL              read_axi_fpga
UBFX.W          R4, R0, #0, #9
nonce_number = R4       ; unsigned int
CBNZ            nonce_number, loc_28EC8

loc_28EBC
LDRB            R0, [R6]
CMP             R0, #0
BNE             loc_28EA8
ADD             SP, SP, #8
POP.W           {R4-R10,PC}

loc_28EC8
nonce_number = R4       ; unsigned int
MOVW            R10, #:lower16:aSData0x08x ; "%s: data = 0x%08x\n"
MOVS            R5, #0
MOVT            R10, #:upper16:aSData0x08x ; "%s: data = 0x%08x\n"
B               loc_28EDE

loc_28ED4
i = R5                  ; unsigned int
BL              single_BM1397_check_register_value

loc_28ED8
ADDS            i, #1
CMP             nonce_number, i
BLS             loc_28EBC

loc_28EDE               ; buf
MOV             R0, SP
BL              get_return_nonce
LDR             R2, [SP,#8+buf]
MOV             R1, SP  ; buf
MOV             R0, which_chain ; which_chain
CMP             R2, #0
BGE             loc_28ED4
LDRB.W          R3, [R8]
AND.W           R1, R2, #0xE0
CMP             R3, #0
BEQ             loc_28ED8
CMP             R1, #0x80
MOV             R0, R10 ; format
MOV             R1, R9
BEQ             loc_28F08
BLX             printf
B               loc_28ED8

loc_28F08               ; buf
MOV             R1, SP
MOV             R0, which_chain ; which_chain
BL              single_BM1397_check_nonce
B               loc_28ED8
; End of function single_BM1397_receive_func

ALIGN 4
off_28F14 DCD __FUNCTION__.8673 ; "BM1397_check_nonce_flag"



; void singleAsicTest_BM1397()
EXPORT singleAsicTest_BM1397
singleAsicTest_BM1397

lcd_display_buf= -0x10

PUSH.W          {R4-R10,LR}
SUB             SP, SP, #0x10
LDR             R5, =dword_2F268
MOV             R4, SP
MOV             R6, #lcd_fd
LDR             R2, [R5,#(dword_2F270 - 0x2F268)]
LDR             R3, [R5,#(dword_2F274 - 0x2F268)]
LDR             R0, [R5]
LDR             R1, [R5,#(dword_2F26C - 0x2F268)]
STM             R4!, {R0-R3}
MOVW            R0, #:lower16:aBeginSTest ; "\nBegin %s test\n"
ADD.W           R1, R5, #0x10
MOVT            R0, #:upper16:aBeginSTest ; "\nBegin %s test\n"
BLX             printf
MOV             R0, #aDate ; "date"
BLX             system
MOVS            R0, #0xA ; c
BLX             putchar
MOVW            R0, #:lower16:lcd_output
MOVS            R2, #0x40 ; '@' ; n
MOVT            R0, #:upper16:lcd_output ; s
MOVS            R1, #0x20 ; ' ' ; c
BLX             memset
LDR             R0, [R6] ; fd
CMP             R0, #0
BLE             loc_28F84
MOVS            R2, #0  ; whence
MOV             R1, R2  ; offset
BLX             lseek
MOVW            R1, #:lower16:lcd_output
LDR             R0, [R6] ; fd
MOVT            R1, #:upper16:lcd_output ; buf
MOVS            R2, #0x40 ; '@' ; n
BLX             write

loc_28F84
BL              init_fpga
MOVS            R1, #0  ; data
MOVS            R0, #0x3E ; '>' ; address
BL              write_axi_fpga
MOVW            R0, #:lower16:loc_186A0
MOVW            R4, #:lower16:gChain
MOVT            R0, #:upper16:loc_186A0 ; useconds
MOVT            R4, #:upper16:gChain
BLX             usleep
MOVS            R0, #0  ; address
BL              read_axi_fpga
ORR.W           R1, R0, #0x40000000 ; data
MOVS            R0, #0  ; address
BL              write_axi_fpga
BL              reset_single_BM1397_global_arg
BL              check_chain
LDRB            R3, [R4]
CMP             R3, #0xFF
BEQ.W           loc_2913E
LDR             R6, =cgpu.show_id
MOV             R5, #chain_info_0
MOVW            R2, #:lower16:(single_BM1397_show_status_func+1)
ADD.W           R3, R5, R3,LSL#1 ; arg
MOVT            R2, #:upper16:(single_BM1397_show_status_func+1) ; start_routine
MOV             R0, R6  ; newthread
MOVS            R1, #0  ; attr
BLX             pthread_create
thread_ret = R0         ; int
MOV             R7, thread_ret
CBZ             thread_ret, loc_29030
LDR             thread_ret, [R6] ; th
thread_ret = R7         ; int
BLX             pthread_cancel
MOVW            R1, #:lower16:aCreatShow ; "   Creat show   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCreatShow ; "   Creat show   "
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R0, #1  ; line
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreateSingleB_2 ; "\n!!!%s: create single_BM1397_show_stat"...
LDR             R1, =__FUNCTION__.8830 ; "singleAsicTest_BM1397"
MOVT            R0, #:upper16:aSCreateSingleB_2 ; "\n!!!%s: create single_BM1397_show_stat"...
BLX             printf

loc_2902A
ADD             SP, SP, #0x10
POP.W           {R4-R10,PC}

loc_29030
thread_ret = R0         ; int
BL              reset_hash_board
LDRB            R3, [R4]
MOVW            LR, #:lower16:start_receive
MOVW            R2, #:lower16:(single_BM1397_receive_func+1)
MOVT            LR, #:upper16:start_receive
MOV.W           R9, #1
MOVT            R2, #:upper16:(single_BM1397_receive_func+1) ; start_routine
MOV             R1, thread_ret ; attr
SUBS            R0, R6, #4 ; newthread
ADD.W           R3, R5, R3,LSL#1 ; arg
STRB.W          R9, [LR]
BLX             pthread_create
thread_ret = R0         ; int
MOV             R8, thread_ret
CMP             thread_ret, #0
BNE             loc_29160
MOVS            thread_ret, #0x40 ; '@' ; address
thread_ret = R8         ; int
SUB.W           R7, R6, #0x80008
BL              read_axi_fpga
BIC.W           R1, R0, #0x8100
MOVS            R0, #0x40 ; '@' ; address
BIC.W           R1, R1, #0xE0
ORR.W           R1, R1, #0x8100 ; data
BL              write_axi_fpga
MOV             R0, #aCheckAsicNumbe ; "\n--- check asic number"
BLX             puts
MOV             R3, R9  ; mode
MOV             R2, thread_ret ; reg
MOV             R1, thread_ret ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              check_BM1397_asic_reg
LDRB            R3, [R4]
MOV             R0, #aCheckChainAsic ; "\n--- check chain: asicNum = %d\n"
ADD             R3, R7
ADD.W           R3, R3, #0x100000
LDRB.W          R1, [R3,#0x30C]
BLX             printf
LDRB            R3, [R4]
ADD             R3, R7
ADD.W           R3, R3, #0x100000
LDRB.W          R10, [R3,#0x30C]
CMP.W           R10, #1
BEQ             loc_291B2
LDR.W           R0, [R6,#(cgpu.receive_id - 0x2B0FCC)] ; th
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
LDRB            R3, [R4]
MOV             R1, #(aT1DT2D+0xC) ; format
ADD.W           R0, SP, #0x10+lcd_display_buf+7 ; s
ADD             R3, R7
ADD.W           R3, R3, #0x100000
LDRB.W          R2, [R3,#0x30C]
BLX             sprintf
MOVW            R1, #:lower16:aOnlyHave ; "   Only have    "
MOV             R0, thread_ret ; line
MOVT            R1, #:upper16:aOnlyHave ; "   Only have    "
MOVS            R2, #0x10 ; size
BL              write_lcd
MOV             R1, SP  ; buf
MOV             R0, R9  ; line
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aAsic ; "      ASIC      "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aAsic ; "      ASIC      "
MOVS            R0, #2  ; line
BL              write_lcd_no_memset
LDRB            R3, [R4]
MOVW            R0, #:lower16:aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
LDR             R1, =__FUNCTION__.8830 ; "singleAsicTest_BM1397"
MOVT            R0, #:upper16:aSOnlyHaveDAsic ; "\n\n---%s: Only have %d ASIC\n"
ADD             R7, R3
ADD.W           R7, R7, #0x100000
LDRB.W          R2, [R7,#0x30C]
BLX             printf
MOV             R0, #asc_29F80 ; "----------------------------\n\n"
BLX             puts
ADD             SP, SP, #0x10
POP.W           {R4-R10,PC}

loc_2913E
MOV             R0, #aNoHashBoardPle ; "\nNo hash board, please plug in it"
BLX             puts
MOVW            R1, #:lower16:aNoHashBoard_0 ; " no hash board  "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aNoHashBoard_0 ; " no hash board  "
MOVS            R0, #1  ; line
BL              write_lcd
ADD             SP, SP, #0x10
POP.W           {R4-R10,PC}

loc_29160               ; th
thread_ret = R0         ; int
LDR.W           thread_ret, [R6,#(cgpu.receive_id - 0x2B0FCC)]
thread_ret = R8         ; int
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
MOVW            R1, #:lower16:aCreatReceive ; "  Creat receive "
MOV             R0, R7  ; line
MOVT            R1, #:upper16:aCreatReceive ; "  Creat receive "
MOVS            R2, #0x10 ; size
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOV             R0, R9  ; line
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreateSingleB_3 ; "\n!!!%s: create single_BM1397_receive_f"...
LDR             R1, =__FUNCTION__.8830 ; "singleAsicTest_BM1397"
MOVT            R0, #:upper16:aSCreateSingleB_3 ; "\n!!!%s: create single_BM1397_receive_f"...
BLX             printf
ADD             SP, SP, #0x10
POP.W           {R4-R10,PC}

loc_291B2
MOV             R7, #Conf
BL              single_BM1397_calculate_timeout_and_baud
LDR             R2, [R7,#configuration.Freq] ; freq
MOV             R3, R10 ; mode
MOV             R1, thread_ret ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              set_BM1397_freq
LDRB            R0, [R4] ; which_chain
BL              BM1397_software_set_address
LDR.W           R1, [R7,#configuration.baud] ; baud
LDRB            R0, [R4] ; which_chain
BL              BM1397_set_baud
MOV             R3, R10 ; mode
MOVS            R2, #0x18 ; reg
MOV             R1, thread_ret ; chip_addr
LDRB            R0, [R4] ; which_chain
BL              check_BM1397_asic_reg
LDR.W           R1, [R7,#configuration.timeout]
MOVS            R0, #0x22 ; '"' ; address
ORR.W           R1, R1, #0x80000000 ; data
BL              write_axi_fpga
LDR.W           R3, [R7,#configuration.sensor_model]
SUBS            R2, R3, #1
CMP             R2, #1
BLS             loc_29240
SUBS            R3, #3
CMP             R3, #6
BLS             loc_292F8
LDR.W           R0, [R6,#(cgpu.receive_id - 0x2B0FCC)] ; th
BLX             pthread_cancel
LDR             R0, [R6] ; th
BLX             pthread_cancel
MOVW            R1, #:lower16:aSensorModelErr ; "Sensor Model Err"
MOV             R0, thread_ret ; line
MOVT            R1, #:upper16:aSensorModelErr ; "Sensor Model Err"
MOVS            R2, #0x10 ; size
BL              write_lcd
MOVW            R0, #:lower16:aSPleaseConfigS ; "\n%s: please config sensor_model in Con"...
LDR             R1, =__FUNCTION__.8830 ; "singleAsicTest_BM1397"
MOVT            R0, #:upper16:aSPleaseConfigS ; "\n%s: please config sensor_model in Con"...
BLX             printf
B               loc_2902A
ALIGN 4
off_29234 DCD dword_2F268
off_29238 DCD cgpu.show_id
off_2923C DCD __FUNCTION__.8830 ; "singleAsicTest_BM1397"

loc_29240
MOVW            R3, #:lower16:pattern_test_time
LDRB            R0, [R4] ; which_chain
MOVT            R3, #:upper16:pattern_test_time
LDRB            R3, [R3]
CMP             R3, #0
BNE             loc_29338
BL              BM1397_soft_reset_sensor
LDRB            R0, [R4] ; which_chain
BL              BM1397_enable_extended_mode_of_temperature_sensor
LDRB            R0, [R4] ; which_chain
BL              BM1397_get_temperature_offset_value_from_asic
LDRB            R0, [R4] ; which_chain
BL              BM1397_set_default_temperature_offset_value

loc_29266
MOVW            R3, #:lower16:gIsReadTemp
LDRB            R0, [R4] ; which_chain
MOVT            R3, #:upper16:gIsReadTemp
MOVS            R7, #1
STRB            R7, [R3]
BL              single_BM1397_open_core
MOVW            R0, #:lower16:aBeginSendTestP ; "\nBegin send test pattern"
LDR             R6, =cgpu.send_id
MOVT            R0, #:upper16:aBeginSendTestP ; "\nBegin send test pattern"
BLX             puts
MOVS            R0, #0xA ; c
BLX             putchar
LDRB            R3, [R4]
MOVW            R2, #:lower16:(single_BM1397_send_func+1)
MOV             R0, R6  ; newthread
MOVT            R2, #:upper16:(single_BM1397_send_func+1) ; start_routine
MOVS            R1, #0  ; attr
ADD.W           R3, R5, R3,LSL#1 ; arg
BLX             pthread_create
thread_ret = R0         ; int
MOV             R5, thread_ret
CBZ             thread_ret, loc_29300
LDR             thread_ret, [R6] ; th
thread_ret = R5         ; int
BLX             pthread_cancel
LDR             R0, [R6,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDR             R0, [R6,#(cgpu.show_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
MOVW            R1, #:lower16:aCreatSend ; "   Creat send   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aCreatSend ; "   Creat send   "
MOVS            R0, #0  ; line
BL              write_lcd
MOVW            R1, #:lower16:aThreadFail ; "   thread fail  "
MOV             R0, R7  ; line
MOVT            R1, #:upper16:aThreadFail ; "   thread fail  "
MOVS            R2, #0x10 ; size
BL              write_lcd_no_memset
MOVW            R1, #:lower16:aTestAgain ; "   test again   "
MOVS            R2, #0x10 ; size
MOVT            R1, #:upper16:aTestAgain ; "   test again   "
MOVS            R0, #3  ; line
BL              write_lcd_no_memset
MOVW            R0, #:lower16:aSCreateSingleB_4 ; "\n!!!%s: create single_BM1397_send_func"...
LDR             R1, =__FUNCTION__.8830 ; "singleAsicTest_BM1397"
MOVT            R0, #:upper16:aSCreateSingleB_4 ; "\n!!!%s: create single_BM1397_send_func"...
BLX             printf
B               loc_2902A

loc_292F8               ; which_chain
thread_ret = R8         ; int
LDRB            R0, [R4]
BL              BM1397_enable_extended_mode_of_temperature_sensor
B               loc_29266

loc_29300               ; thread_return
thread_ret = R0         ; int
MOV             R1, thread_ret
LDR             thread_ret, [R6] ; th
thread_ret = R5         ; int
BLX             pthread_join
MOV             R1, R5  ; thread_return
LDR             R0, [R6,#(cgpu.receive_id - 0x2B0FC4)] ; th
BLX             pthread_join
LDR             R0, [R6,#(cgpu.show_id - 0x2B0FC4)] ; th
BLX             pthread_cancel
LDRB            R0, [R4] ; which_chain
BL              single_BM1397_get_result
result = R0             ; unsigned int
MOV             R1, result ; result
LDRB            result, [R4] ; which_chain
result = R1             ; unsigned int
BL              single_BM1397_print_lcd
MOV             R0, R5  ; speed
BL              set_fan_speed
MOV             R0, #(gAsic_Core_Nonce_Num+0x492DC) ; useconds
BLX             usleep
B               loc_2902A

loc_29338
thread_ret = R8         ; int
BL              BM1397_enable_extended_mode_of_temperature_sensor
LDRB            R0, [R4] ; which_chain
BL              BM1397_set_default_temperature_offset_value
B               loc_29266
; End of function singleAsicTest_BM1397

off_29344 DCD cgpu.send_id
off_29348 DCD __FUNCTION__.8830 ; "singleAsicTest_BM1397"
ALIGN 0x10


; Alternative name is '__udivsi3'
; Alternative name is '.udivsi3_skip_div0_test'

EXPORT __aeabi_uidiv
__aeabi_uidiv
SUBS            R2, R1, #1
IT EQ
BXEQ            LR
BCC.W           loc_295A2
CMP             R0, R1
BLS.W           loc_2958C
TST             R1, R2
BEQ.W           loc_29594
CLZ.W           R3, R0
CLZ.W           R2, R1
SUB.W           R3, R2, R3
RSB.W           R3, R3, #0x1F
ADR             R2, loc_29388
ADD.W           R3, R2, R3,LSL#4
MOV.W           R2, #0
MOV             PC, R3
ALIGN 8

loc_29388
CMP.W           R0, R1,LSL#31
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#31
CMP.W           R0, R1,LSL#30
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#30
CMP.W           R0, R1,LSL#29
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#29
CMP.W           R0, R1,LSL#28
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#28
CMP.W           R0, R1,LSL#27
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#27
CMP.W           R0, R1,LSL#26
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#26
CMP.W           R0, R1,LSL#25
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#25
CMP.W           R0, R1,LSL#24
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#24
CMP.W           R0, R1,LSL#23
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#23
CMP.W           R0, R1,LSL#22
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#22
CMP.W           R0, R1,LSL#21
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#21
CMP.W           R0, R1,LSL#20
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#20
CMP.W           R0, R1,LSL#19
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#19
CMP.W           R0, R1,LSL#18
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#18
CMP.W           R0, R1,LSL#17
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#17
CMP.W           R0, R1,LSL#16
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#16
CMP.W           R0, R1,LSL#15
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#15
CMP.W           R0, R1,LSL#14
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#14
CMP.W           R0, R1,LSL#13
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#13
CMP.W           R0, R1,LSL#12
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#12
CMP.W           R0, R1,LSL#11
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#11
CMP.W           R0, R1,LSL#10
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#10
CMP.W           R0, R1,LSL#9
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#9
CMP.W           R0, R1,LSL#8
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#8
CMP.W           R0, R1,LSL#7
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#7
CMP.W           R0, R1,LSL#6
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#6
CMP.W           R0, R1,LSL#5
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#5
CMP.W           R0, R1,LSL#4
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#4
CMP.W           R0, R1,LSL#3
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#3
CMP.W           R0, R1,LSL#2
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#2
CMP.W           R0, R1,LSL#1
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1,LSL#1
CMP.W           R0, R1
NOP
ADC.W           R2, R2, R2
IT CS
SUBCS.W         R0, R0, R1
MOV             R0, R2
BX              LR

loc_2958C
ITE EQ
MOVEQ           R0, #1
MOVNE           R0, #0
BX              LR

loc_29594
CLZ.W           R2, R1
RSB.W           R2, R2, #0x1F
LSR.W           R0, R0, R2
BX              LR

loc_295A2
CBZ             R0, loc_295A8
MOV.W           R0, #0xFFFFFFFF

loc_295A8
B.W             __aeabi_ldiv0
; End of function __aeabi_uidiv




EXPORT __aeabi_uidivmod
__aeabi_uidivmod
CMP             R1, #0
BEQ             loc_295A2
PUSH.W          {R0,R1,LR}
BL              __aeabi_uidiv
POP.W           {R1,R2,LR}
MUL             R3, R2, R0
SUB.W           R1, R1, R3
BX              LR
; End of function __aeabi_uidivmod

ALIGN 4


; Alternative name is '__aeabi_idiv0'

; int _aeabi_ldiv0()
WEAK __aeabi_ldiv0
__aeabi_ldiv0
PUSH            {R1,LR}
MOV.W           R0, #8  ; sig
BLX             raise
POP             {R1,PC}
; End of function __aeabi_ldiv0




; void __fastcall init(int argc, char **argv, char **envp)
EXPORT init
init
argc = R0               ; int
argv = R1               ; char **
envp = R2               ; char **
PUSH.W          {R3-R9,LR}
MOV             R6, argc
LDR             R5, =(__do_global_dtors_aux_fini_array_entry - 0x295E8)
MOV             R7, argv
MOV             R8, envp
LDR.W           R9, =(__frame_dummy_init_array_entry - 0x295EE)
ADD             R5, PC  ; __do_global_dtors_aux_fini_array_entry
BLX             .init_proc
ADD             R9, PC  ; __frame_dummy_init_array_entry
SUB.W           R5, R5, R9
ASRS            R5, R5, #2
BEQ             locret_29608
MOVS            R4, #0

loc_295F6
i = R4                  ; size_t
LDR.W           R3, [R9,i,LSL#2]
MOV             R2, envp
ADDS            i, #1
MOV             R1, argv
MOV             R0, argc
BLX             R3
i = R4                  ; size_t
CMP             i, R5
BNE             loc_295F6

locret_29608
POP.W           {R3-R9,PC}
; End of function init

off_2960C DCD __do_global_dtors_aux_fini_array_entry - 0x295E8
off_29610 DCD __frame_dummy_init_array_entry - 0x295EE



; void _libc_csu_fini()
EXPORT __libc_csu_fini
__libc_csu_fini
BX              LR
; End of function __libc_csu_fini

ALIGN 4
; .text ends


; Segment type: Pure code
AREA .fini, CODE
; ORG 0x29618
CODE32


; Alternative name is '_fini'

; void term_proc()
EXPORT .term_proc
.term_proc
PUSH            {R3,LR}
POP             {R3,PC}
; End of function .term_proc

; .fini ends


; Segment type: Pure data
AREA .rodata, DATA, READONLY
; ORG 0x29620
EXPORT _IO_stdin_used
; const int IO_stdin_used
_IO_stdin_used DCD 0x20001
; Function-local static variable
; const char _FUNCTION___8222[24]
__FUNCTION__.8222 DCB "single_BM1385_send_func",0
; Function-local static variable
; const char _FUNCTION___7992[19]
__FUNCTION__.7992 DCB "get_BM1385_plldata",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8000[26]
__FUNCTION__.8000 DCB "read_BM1385_asic_register",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8012[16]
__FUNCTION__.8012 DCB "set_BM1385_freq",0
; Function-local static variable
; const char _FUNCTION___8023[22]
__FUNCTION__.8023 DCB "check_BM1385_asic_reg",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8069[31]
__FUNCTION__.8069 DCB "reset_single_BM1385_global_arg",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8088[41]
__FUNCTION__.8088 DCB "single_BM1385_calculate_timeout_an"
DCB "d_baud",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8105[26]
__FUNCTION__.8105 DCB "single_BM1385_set_address",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8113[23]
__FUNCTION__.8113 DCB "single_BM1385_set_baud",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8121[24]
__FUNCTION__.8121 DCB "single_BM1385_open_core",0
dword_2972C DCD 0x20202020
dword_29730 DCD 0x57482020
dword_29734 DCD 0x20202020
dword_29738 DCD 0x20202020
; Function-local static variable
; const char _FUNCTION___8184[26]
__FUNCTION__.8184 DCB "single_BM1385_check_nonce",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8201[35]
__FUNCTION__.8201 DCB "single_BM1385_check_register_value"
DCB 0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8259[27]
__FUNCTION__.8259 DCB "single_BM1385_receive_func",0
ALIGN 4
dword_29798 DCD 0x20202020
dword_2979C DCD 0x20202020
dword_297A0 DCD 0x20202020
dword_297A4 DCD 0x20202020
; Function-local static variable
; const char _FUNCTION___8283[22]
__FUNCTION__.8283 DCB "singleAsicTest_BM1385",0
ALIGN 0x10
aTimeDs DCB "   time %ds",0
aNonceD DCB "   nonce=%d",0
aSThereAreDCore DCB "%s: There are %d cores should be t"
DCB "est",0xA
DCB 0xA,0
aSChainDSendWor_0 DCB 0xA
DCB 0xA
DCB "---%s: Chain%d send work num : %d",0xA
DCB 0
ALIGN 4
aSendTestPatter DCB 0xA
DCB "send test pattern done",0
aDate DCB "date",0
ALIGN 4
aToStopReceive DCB "to stop receive",0
aSChainDSendWor DCB 0xA
DCB 0xA
DCB "---%s: Chain%d send work num : %d,"
DCB " less than %d",0xA,0
ALIGN 4
a08x DCB "%08x",0
ALIGN 4
a04x DCB "%04x",0
ALIGN 4
aSFreqSPll1SPll DCB "%s: Freq %s, PLL1 %s, PLL2 %s, vil"
DCB "pll %s",0xA,0
ALIGN 4
aSPll1XPll2XVil DCB "%s: PLL1 %#x, PLL2 %#x, vilpll %#x"
DCB 0xA,0
aSIDSizeofFreqP DCB "%s: i = %d, sizeof(freq_pll_1385)/"
DCB "sizeof(freq_pll_1385[0]) = %d",0xA
DCB 0
ALIGN 0x10
aSFreqSetErr DCB "%s: Freq set Err!!!!",0xA,0
ALIGN 4
aSUsing200m DCB "%s: Using 200M",0xA,0
aSBuf00xXBuf10x DCB "%s: buf[0]=0x%x, buf[1]=0x%x, buf["
DCB "2]=0x%x, buf[3]=0x%x",0xA,0
aS DCB 0xA
DCB "--- %s",0xA,0
ALIGN 4
aSCheckChainJD DCB "%s: check chain J%d ",0xA,0
ALIGN 4
aSTheReturnData DCB "%s: the return data is from chain%"
DCB "d, but it should be from chain%d",0xA
DCB 0
aSCrcIs0xXButIt DCB "%s: crc is 0x%x, but it should be "
DCB "0x%x",0xA,0
aSTheAsicFreqIs DCB "%s: the asic freq is 0x%08x",0xA,0
ALIGN 0x10
aSNoAsicAddress DCB "%s: no asic address register come "
DCB "back for %d time.",0xA,0
ALIGN 4
aSChainJDHasDAs DCB "%s: chain J%d has %d ASIC",0xA,0
ALIGN 4
aSPatternTestTi DCB "%s: pattern_test_time = %d, error!"
DCB "!! ",0xA,0
ALIGN 4
aSChainD DCB 0xA
DCB "--- %s: Chain : %d",0xA,0
ALIGN 4
aSChainDBaudD DCB 0xA
DCB "--- %s: Chain : %d, baud = %d",0xA
DCB 0
asc_29AF4 DCB 0xA
DCB 0xA
DCB "----------------------------------"
DCB "----------------------------------"
DCB "----------------------------------"
DCB 0xA,0
ALIGN 0x10
aEveryCoreRequi DCB "every CORE require nonce number: %"
DCB "u",0xA
DCB 0xA,0
ALIGN 4
aOpenCoreNumber DCB "Open core number : Conf.OpenCoreNu"
DCB "m1 = %u = 0x%08x",0xA,0
aOpenCoreNumber_0 DCB "Open core number : Conf.OpenCoreNu"
DCB "m2 = %u = 0x%08x",0xA,0
aOpenCoreNumber_1 DCB "Open core number : Conf.OpenCoreNu"
DCB "m3 = %u = 0x%08x",0xA,0
aOpenCoreNumber_2 DCB "Open core number : Conf.OpenCoreNu"
DCB "m4 = %u = 0x%08x",0xA
DCB 0xA,0
ALIGN 4
aCore02d02d DCB "core[%02d]=%02d",9,0
ALIGN 0x10
aCore02dDLostTh DCB "core[%02d] = %d,      lost these n"
DCB "once : ",0
ALIGN 4
aD DCB "%d  ",0
ALIGN 4
asc_29CA4 DCB 0xA
DCB "----------------------------------"
DCB "----------------------------------"
DCB "----------------------------------"
DCB 0xA,0
ALIGN 0x10
aChainDTotalVal DCB "Chain%d total valid nonce number: "
DCB "%d",0xA
DCB 0xA,0
ALIGN 4
aPatternOk DCB "Pattern OK",0xA,0
aPatternNg DCB "Pattern NG",0xA,0
aHwNumberD DCB "HW number = %d",0xA
DCB 0xA,0
ALIGN 4
aPatternOk_0 DCB "   Pattern OK   ",0
ALIGN 4
aPatternNg_0 DCB "   Pattern NG   ",0
ALIGN 4
aSReceivedAsic0 DCB "%s: received ASIC%02d nonce. error"
DCB "!!!",9,0
ALIGN 4
aReceivedDataIs DCB ",received data is : 0x%02x%02x%02x"
DCB "%02x%02x",0xA,0
aSReceivedCore0 DCB "%s: received core%02d nonce. error"
DCB "!!!",9,0
ALIGN 4
aSReceivedWorkI DCB "%s: received work_id = %02d nonce."
DCB " error!!!",9,0
ALIGN 4
aSFindAHwChainD DCB "%s: Find a HW. Chain%d ASIC%d Core"
DCB "%d : nonce = 0x%08x.",0xA,0
aSRegValueBufBu DCB "%s: reg_value_buf buffer is full!",0xA
DCB 0
ALIGN 4
aSWhichChainDWh DCB "%s: which_chain = %d, which_i2c = "
DCB "%d",0xA,0
ALIGN 4
aBeginSTest DCB 0xA
DCB "Begin %s test",0xA,0
aNoHashBoard DCB "  no hash board ",0
ALIGN 0x10
aNoHashBoardPle DCB 0xA
DCB "No hash board, please plug in it",0
ALIGN 4
aCheckAsicNumbe DCB 0xA
DCB "--- check asic number",0
ALIGN 4
aCheckChainAsic DCB 0xA
DCB "--- check chain: asicNum = %d",0xA
DCB 0
aOnlyHave DCB "   Only have    ",0
ALIGN 0x10
aAsic DCB "      ASIC      ",0
ALIGN 4
aSOnlyHaveDAsic DCB 0xA
DCB 0xA
DCB "---%s: Only have %d ASIC",0xA,0
asc_29F80 DCB "----------------------------",0xA
DCB 0xA,0
ALIGN 0x10
aBeginSendTestP DCB 0xA
DCB "Begin send test pattern",0
ALIGN 4
a19 DCB "19",0
ALIGN 0x10
a22 DCB "22",0
ALIGN 4
a26 DCB "26",0
ALIGN 4
a28 DCB "28",0
ALIGN 4
a33 DCB "33",0
ALIGN 0x10
a40 DCB "40",0
ALIGN 4
a50 DCB "50",0
ALIGN 4
a57 DCB "57",0
ALIGN 4
a66 DCB "66",0
ALIGN 0x10
a80 DCB "80",0
ALIGN 4
a100 DCB "100",0
a125 DCB "125",0
a150 DCB "150",0
a175 DCB "175",0
a200 DCB "200",0
a225 DCB "225",0
a250 DCB "250",0
a275 DCB "275",0
a300 DCB "300",0
a325 DCB "325",0
a350 DCB "350",0
a375 DCB "375",0
off_2A014 DCD cgpu.subid+0x51DC4
unk_2A018 DCB 0x34 ; 4
DCB 0x30 ; 0
DCB 0x34 ; 4
DCB    0
unk_2A01C DCB 0x34 ; 4
DCB 0x30 ; 0
DCB 0x36 ; 6
DCB    0
unk_2A020 DCB 0x34 ; 4
DCB 0x30 ; 0
DCB 0x38 ; 8
DCB    0
off_2A024 DCD cgpu.subid+0x71EC4
unk_2A028 DCB 0x34 ; 4
DCB 0x31 ; 1
DCB 0x36 ; 6
DCB    0
unk_2A02C DCB 0x34 ; 4
DCB 0x31 ; 1
DCB 0x38 ; 8
DCB    0
off_2A030 DCD cgpu.subid+0x51FC4
unk_2A034 DCB 0x34 ; 4
DCB 0x32 ; 2
DCB 0x35 ; 5
DCB    0
unk_2A038 DCB 0x34 ; 4
DCB 0x32 ; 2
DCB 0x39 ; 9
DCB    0
off_2A03C DCD cgpu.subid+0x620C4
off_2A040 DCD gWorks_For_Hw_Check.midstate+0x1EA4
unk_2A044 DCB 0x34 ; 4
DCB 0x33 ; 3
DCB 0x37 ; 7
DCB    0
off_2A048 DCD cgpu.subid+0x621C4
off_2A04C DCD gWorks_For_Hw_Check.midstate+0x1FA4
unk_2A050 DCB 0x34 ; 4
DCB 0x34 ; 4
DCB 0x35 ; 5
DCB    0
off_2A054 DCD cgpu.subid+0x522C4
unk_2A058 DCB 0x34 ; 4
DCB 0x35 ; 5
DCB 0x34 ; 4
DCB    0
unk_2A05C DCB 0x34 ; 4
DCB 0x35 ; 5
DCB 0x36 ; 6
DCB    0
unk_2A060 DCB 0x34 ; 4
DCB 0x35 ; 5
DCB 0x38 ; 8
DCB    0
off_2A064 DCD cgpu.subid+0x723C4
unk_2A068 DCB 0x34 ; 4
DCB 0x36 ; 6
DCB 0x36 ; 6
DCB    0
unk_2A06C DCB 0x34 ; 4
DCB 0x36 ; 6
DCB 0x38 ; 8
DCB    0
off_2A070 DCD cgpu.subid+0x524C4
unk_2A074 DCB 0x34 ; 4
DCB 0x37 ; 7
DCB 0x35 ; 5
DCB    0
unk_2A078 DCB 0x34 ; 4
DCB 0x37 ; 7
DCB 0x39 ; 9
DCB    0
off_2A07C DCD cgpu.subid+0x625C4
off_2A080 DCD gWorks_For_Hw_Check.midstate+0x23A4
unk_2A084 DCB 0x34 ; 4
DCB 0x38 ; 8
DCB 0x37 ; 7
DCB    0
off_2A088 DCD cgpu.subid+0x626C4
off_2A08C DCD gWorks_For_Hw_Check.data+0x24B0
unk_2A090 DCB 0x34 ; 4
DCB 0x39 ; 9
DCB 0x35 ; 5
DCB    0
unk_2A094 DCB 0x35 ; 5
DCB 0x30 ; 0
DCB 0x30 ; 0
DCB    0
unk_2A098 DCB 0x35 ; 5
DCB 0x30 ; 0
DCB 0x34 ; 4
DCB    0
unk_2A09C DCB 0x35 ; 5
DCB 0x30 ; 0
DCB 0x36 ; 6
DCB    0
unk_2A0A0 DCB 0x35 ; 5
DCB 0x30 ; 0
DCB 0x38 ; 8
DCB    0
unk_2A0A4 DCB 0x35 ; 5
DCB 0x31 ; 1
DCB 0x32 ; 2
DCB    0
unk_2A0A8 DCB 0x35 ; 5
DCB 0x31 ; 1
DCB 0x36 ; 6
DCB    0
unk_2A0AC DCB 0x35 ; 5
DCB 0x31 ; 1
DCB 0x38 ; 8
DCB    0
unk_2A0B0 DCB 0x35 ; 5
DCB 0x32 ; 2
DCB 0x30 ; 0
DCB    0
unk_2A0B4 DCB 0x35 ; 5
DCB 0x32 ; 2
DCB 0x35 ; 5
DCB    0
unk_2A0B8 DCB 0x35 ; 5
DCB 0x32 ; 2
DCB 0x39 ; 9
DCB    0
unk_2A0BC DCB 0x35 ; 5
DCB 0x33 ; 3
DCB 0x31 ; 1
DCB    0
unk_2A0C0 DCB 0x35 ; 5
DCB 0x33 ; 3
DCB 0x33 ; 3
DCB    0
unk_2A0C4 DCB 0x35 ; 5
DCB 0x33 ; 3
DCB 0x37 ; 7
DCB    0
unk_2A0C8 DCB 0x35 ; 5
DCB 0x34 ; 4
DCB 0x33 ; 3
DCB    0
unk_2A0CC DCB 0x35 ; 5
DCB 0x35 ; 5
DCB 0x30 ; 0
DCB    0
unk_2A0D0 DCB 0x35 ; 5
DCB 0x35 ; 5
DCB 0x36 ; 6
DCB    0
unk_2A0D4 DCB 0x35 ; 5
DCB 0x36 ; 6
DCB 0x32 ; 2
DCB    0
unk_2A0D8 DCB 0x35 ; 5
DCB 0x36 ; 6
DCB 0x38 ; 8
DCB    0
unk_2A0DC DCB 0x35 ; 5
DCB 0x37 ; 7
DCB 0x35 ; 5
DCB    0
unk_2A0E0 DCB 0x35 ; 5
DCB 0x38 ; 8
DCB 0x31 ; 1
DCB    0
unk_2A0E4 DCB 0x35 ; 5
DCB 0x38 ; 8
DCB 0x37 ; 7
DCB    0
unk_2A0E8 DCB 0x35 ; 5
DCB 0x39 ; 9
DCB 0x33 ; 3
DCB    0
unk_2A0EC DCB 0x36 ; 6
DCB 0x30 ; 0
DCB 0x30 ; 0
DCB    0
unk_2A0F0 DCB 0x36 ; 6
DCB 0x30 ; 0
DCB 0x36 ; 6
DCB    0
unk_2A0F4 DCB 0x36 ; 6
DCB 0x31 ; 1
DCB 0x32 ; 2
DCB    0
unk_2A0F8 DCB 0x36 ; 6
DCB 0x31 ; 1
DCB 0x38 ; 8
DCB    0
unk_2A0FC DCB 0x36 ; 6
DCB 0x32 ; 2
DCB 0x35 ; 5
DCB    0
unk_2A100 DCB 0x36 ; 6
DCB 0x33 ; 3
DCB 0x31 ; 1
DCB    0
unk_2A104 DCB 0x36 ; 6
DCB 0x33 ; 3
DCB 0x37 ; 7
DCB    0
unk_2A108 DCB 0x36 ; 6
DCB 0x34 ; 4
DCB 0x33 ; 3
DCB    0
unk_2A10C DCB 0x36 ; 6
DCB 0x35 ; 5
DCB 0x30 ; 0
DCB    0
unk_2A110 DCB 0x36 ; 6
DCB 0x35 ; 5
DCB 0x36 ; 6
DCB    0
unk_2A114 DCB 0x36 ; 6
DCB 0x36 ; 6
DCB 0x32 ; 2
DCB    0
unk_2A118 DCB 0x36 ; 6
DCB 0x36 ; 6
DCB 0x38 ; 8
DCB    0
unk_2A11C DCB 0x36 ; 6
DCB 0x37 ; 7
DCB 0x35 ; 5
DCB    0
unk_2A120 DCB 0x36 ; 6
DCB 0x38 ; 8
DCB 0x31 ; 1
DCB    0
unk_2A124 DCB 0x36 ; 6
DCB 0x38 ; 8
DCB 0x37 ; 7
DCB    0
unk_2A128 DCB 0x36 ; 6
DCB 0x39 ; 9
DCB 0x33 ; 3
DCB    0
unk_2A12C DCB 0x37 ; 7
DCB 0x30 ; 0
DCB 0x30 ; 0
DCB    0
unk_2A130 DCB 0x37 ; 7
DCB 0x30 ; 0
DCB 0x36 ; 6
DCB    0
unk_2A134 DCB 0x37 ; 7
DCB 0x31 ; 1
DCB 0x32 ; 2
DCB    0
unk_2A138 DCB 0x37 ; 7
DCB 0x31 ; 1
DCB 0x38 ; 8
DCB    0
unk_2A13C DCB 0x37 ; 7
DCB 0x32 ; 2
DCB 0x35 ; 5
DCB    0
unk_2A140 DCB 0x37 ; 7
DCB 0x33 ; 3
DCB 0x31 ; 1
DCB    0
unk_2A144 DCB 0x37 ; 7
DCB 0x33 ; 3
DCB 0x37 ; 7
DCB    0
unk_2A148 DCB 0x37 ; 7
DCB 0x34 ; 4
DCB 0x33 ; 3
DCB    0
unk_2A14C DCB 0x37 ; 7
DCB 0x35 ; 5
DCB 0x30 ; 0
DCB    0
unk_2A150 DCB 0x37 ; 7
DCB 0x35 ; 5
DCB 0x36 ; 6
DCB    0
unk_2A154 DCB 0x37 ; 7
DCB 0x36 ; 6
DCB 0x32 ; 2
DCB    0
unk_2A158 DCB 0x37 ; 7
DCB 0x36 ; 6
DCB 0x38 ; 8
DCB    0
unk_2A15C DCB 0x37 ; 7
DCB 0x37 ; 7
DCB 0x35 ; 5
DCB    0
unk_2A160 DCB 0x37 ; 7
DCB 0x38 ; 8
DCB 0x31 ; 1
DCB    0
unk_2A164 DCB 0x37 ; 7
DCB 0x38 ; 8
DCB 0x37 ; 7
DCB    0
unk_2A168 DCB 0x37 ; 7
DCB 0x39 ; 9
DCB 0x33 ; 3
DCB    0
off_2A16C DCD cgpu.subid+0x51DC8
unk_2A170 DCB 0x38 ; 8
DCB 0x32 ; 2
DCB 0x35 ; 5
DCB    0
off_2A174 DCD cgpu.subid+0x522C8
unk_2A178 DCB 0x38 ; 8
DCB 0x37 ; 7
DCB 0x35 ; 5
DCB    0
unk_2A17C DCB 0x39 ; 9
DCB 0x30 ; 0
DCB 0x30 ; 0
DCB    0
unk_2A180 DCB 0x39 ; 9
DCB 0x32 ; 2
DCB 0x35 ; 5
DCB    0
unk_2A184 DCB 0x39 ; 9
DCB 0x35 ; 5
DCB 0x30 ; 0
DCB    0
unk_2A188 DCB 0x39 ; 9
DCB 0x37 ; 7
DCB 0x35 ; 5
DCB    0
a1000 DCB "1000",0
ALIGN 4
a1025 DCB "1025",0
ALIGN 4
a1050 DCB "1050",0
ALIGN 4
a1075 DCB "1075",0
ALIGN 4
a1100 DCB "1100",0
ALIGN 4
a1125 DCB "1125",0
ALIGN 4
a1150 DCB "1150",0
ALIGN 4
a1175 DCB "1175",0
ALIGN 4
aMntCardSingleB DCB "/mnt/card/single-BM1385-ASIC-test",0
ALIGN 0x10
EXPORT chCRCHTalbe
; const uint8_t chCRCHTalbe[256]
chCRCHTalbe DCB 0, 0xC1, 0x81, 0x40, 1, 0xC0, 0x80, 0x41
DCB 1, 0xC0, 0x80, 0x41, 0, 0xC1, 0x81, 0x40
DCB 1, 0xC0, 0x80, 0x41, 0, 0xC1, 0x81, 0x40
DCB 0, 0xC1, 0x81, 0x40, 1, 0xC0, 0x80, 0x41
DCB 1, 0xC0, 0x80, 0x41, 0, 0xC1, 0x81, 0x40
DCB 0, 0xC1, 0x81, 0x40, 1, 0xC0, 0x80, 0x41
DCB 0, 0xC1, 0x81, 0x40, 1, 0xC0, 0x80, 0x41
DCB 1, 0xC0, 0x80, 0x41, 0, 0xC1, 0x81, 0x40
DCB 1, 0xC0, 0x80, 0x41, 0, 0xC1, 0x81, 0x40
DCB 0, 0xC1, 0x81, 0x40, 1, 0xC0, 0x80, 0x41
DCB 0, 0xC1, 0x81, 0x40, 1, 0xC0, 0x80, 0x41
DCB 1, 0xC0, 0x80, 0x41, 0, 0xC1, 0x81, 0x40
DCB 0, 0xC1, 0x81, 0x40, 1, 0xC0, 0x80, 0x41
DCB 1, 0xC0, 0x80, 0x41, 0, 0xC1, 0x81, 0x40
DCB 1, 0xC0, 0x80, 0x41, 0, 0xC1, 0x81, 0x40
DCB 0, 0xC1, 0x81, 0x40, 1, 0xC0, 0x80, 0x41
DCB 1, 0xC0, 0x80, 0x41, 0, 0xC1, 0x81, 0x40
DCB 0, 0xC1, 0x81, 0x40, 1, 0xC0, 0x80, 0x41
DCB 0, 0xC1, 0x81, 0x40, 1, 0xC0, 0x80, 0x41
DCB 1, 0xC0, 0x80, 0x41, 0, 0xC1, 0x81, 0x40
DCB 0, 0xC1, 0x81, 0x40, 1, 0xC0, 0x80, 0x41
DCB 1, 0xC0, 0x80, 0x41, 0, 0xC1, 0x81, 0x40
DCB 1, 0xC0, 0x80, 0x41, 0, 0xC1, 0x81, 0x40
DCB 0, 0xC1, 0x81, 0x40, 1, 0xC0, 0x80, 0x41
DCB 0, 0xC1, 0x81, 0x40, 1, 0xC0, 0x80, 0x41
DCB 1, 0xC0, 0x80, 0x41, 0, 0xC1, 0x81, 0x40
DCB 1, 0xC0, 0x80, 0x41, 0, 0xC1, 0x81, 0x40
DCB 0, 0xC1, 0x81, 0x40, 1, 0xC0, 0x80, 0x41
DCB 1, 0xC0, 0x80, 0x41, 0, 0xC1, 0x81, 0x40
DCB 0, 0xC1, 0x81, 0x40, 1, 0xC0, 0x80, 0x41
DCB 0, 0xC1, 0x81, 0x40, 1, 0xC0, 0x80, 0x41
DCB 1, 0xC0, 0x80, 0x41, 0, 0xC1, 0x81, 0x40
EXPORT chCRCLTalbe
; const uint8_t chCRCLTalbe[256]
chCRCLTalbe DCB 0, 0xC0, 0xC1, 1, 0xC3, 3, 2, 0xC2, 0xC6
DCB 6, 7, 0xC7, 5, 0xC5, 0xC4, 4, 0xCC, 0xC
DCB 0xD, 0xCD, 0xF, 0xCF, 0xCE, 0xE, 0xA
DCB 0xCA, 0xCB, 0xB, 0xC9, 9, 8, 0xC8, 0xD8
DCB 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A
DCB 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C
DCB 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17
DCB 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 0x11
DCB 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1
DCB 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7
DCB 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC
DCB 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA
DCB 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38
DCB 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A
DCB 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED
DCB 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27
DCB 0xE7, 0xE6, 0x26, 0x22, 0xE2, 0xE3, 0x23
DCB 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61
DCB 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6
DCB 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C
DCB 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE
DCB 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8
DCB 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B
DCB 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D
DCB 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5
DCB 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3
DCB 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90
DCB 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96
DCB 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54
DCB 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E
DCB 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59
DCB 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B
DCB 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F
DCB 0x8D, 0x4D, 0x4C, 0x8C, 0x44, 0x84, 0x85
DCB 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42
DCB 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
; Function-local static variable
; const char _FUNCTION___8697[24]
__FUNCTION__.8697 DCB "single_BM1391_send_func",0
__FUNCTION__.8160 DCB "BM1391_get_pllparam_divider",0
; Function-local static variable
; const char _FUNCTION___8200[16]
__FUNCTION__.8200 DCB "set_BM1391_freq",0
; Function-local static variable
; const char _FUNCTION___8213[22]
__FUNCTION__.8213 DCB "check_BM1391_asic_reg",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8228[22]
__FUNCTION__.8228 DCB "BM1391_chain_inactive",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8249[30]
__FUNCTION__.8249 DCB "single_BM1391_set_IO_strength",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8269[31]
__FUNCTION__.8269 DCB "reset_single_BM1391_global_arg",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8287[41]
__FUNCTION__.8287 DCB "single_BM1391_calculate_timeout_an"
DCB "d_baud",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8304[28]
__FUNCTION__.8304 DCB "BM1391_software_set_address",0
; Function-local static variable
; const char _FUNCTION___8312[16]
__FUNCTION__.8312 DCB "BM1391_set_baud",0
; Function-local static variable
; const char _FUNCTION___8350[25]
__FUNCTION__.8350 DCB "single_BM1391P_open_core",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8379[25]
__FUNCTION__.8379 DCB "single_BM1391S_open_core",0
ALIGN 4
dword_2A534 DCD 0x20202020
dword_2A538 DCD 0x57482020
dword_2A53C DCD 0x20202020
dword_2A540 DCD 0x20202020
; Function-local static variable
; const char _FUNCTION___8451[25]
__FUNCTION__.8451 DCB "BM1391_soft_reset_sensor",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8467[50]
__FUNCTION__.8467 DCB "BM1391_enable_extended_mode_of_tem"
DCB "perature_sensor",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8489[46]
__FUNCTION__.8489 DCB "BM1391_get_temperature_offset_valu"
DCB "e_from_asic",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8513[44]
__FUNCTION__.8513 DCB "BM1391_set_default_temperature_off"
DCB "set_value",0
; Function-local static variable
; const char _FUNCTION___8539[42]
__FUNCTION__.8539 DCB "BM1391_read_asic_temperature_local"
DCB "_remote",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8558[35]
__FUNCTION__.8558 DCB "BM1391_read_asic_temperature_local"
DCB 0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8567[31]
__FUNCTION__.8567 DCB "single_BM1391_show_status_func",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8575[24]
__FUNCTION__.8575 DCB "BM1391_check_nonce_flag",0
; Function-local static variable
; const char _FUNCTION___8600[26]
__FUNCTION__.8600 DCB "single_BM1391_check_nonce",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8654[35]
__FUNCTION__.8654 DCB "single_BM1391_check_register_value"
DCB 0
ALIGN 4
dword_2A6B8 DCD 0x20202020
dword_2A6BC DCD 0x20202020
dword_2A6C0 DCD 0x20202020
dword_2A6C4 DCD 0x20202020
; Function-local static variable
; const char _FUNCTION___8732[22]
__FUNCTION__.8732 DCB "singleAsicTest_BM1391",0
ALIGN 0x10
aSThereAreDCore_0 DCB "%s: There are %d cores should be t"
DCB "est",0xA,0
ALIGN 4
aSPllDivDecimal DCB 0xA
DCB "--- %s: pll_div decimals %f postdi"
DCB "v_f %f",0xA,0
ALIGN 4
aSNeedRecal1 DCB 0xA
DCB "--- %s: need recal 1",0xA,0
ALIGN 4
aSNeedRecal2 DCB 0xA
DCB "--- %s: need recal 2",0xA,0
ALIGN 4
aSDonTFindPostd DCB 0xA
DCB "--- %s: Don't find postdiv1 %d * p"
DCB "ostdiv2 %d = postdiv %d",0xA,0
aSSetFreqDonTOk DCB 0xA
DCB "--- %s: !!!!!!!!!!!!!!!Set freq do"
DCB "n't ok!!!!!!!!!! using 200M pll",0xA
DCB 0
aSWantFreqFReal DCB 0xA
DCB "--- %s: Want freq %f  real freq %f"
DCB 0xA,0
ALIGN 4
aSPllVcoFFbdivX DCB 0xA
DCB "--- %s: pll_vco %f, fbdiv %#x refd"
DCB "iv %#x postdiv1 %#x postdiv2 %#x, "
DCB "pll_divider %d ,{pll_value %#x}",0xA
DCB 0
ALIGN 4
aSFreqDPllParam DCB 0xA
DCB "--- %s: freq = %d, pll_param = 0x%"
DCB "08x, divider = %d",0xA,0
ALIGN 4
aSErrorAsicAddr DCB "%s: error asic address : 0x%08x",0xA
DCB 0
ALIGN 0x10
aSIoStrengthIs0 DCB 0xA
DCB "--- %s: IO strength is 0x%08x",0xA
DCB 0
aSBaudrateDTime DCB 0xA
DCB "---%s: Baudrate = %d, timeout = %d"
DCB " us",0xA,0
aSEndChainD DCB 0xA
DCB "--- %s end: Chain : %d",0xA,0
ALIGN 4
aOpenCoreNumber_3 DCB "Open core number : Conf.OpenCoreNu"
DCB "m4 = %u = 0x%08x",0xA,0
aOpenCoreNumber_4 DCB "Open core number : Conf.OpenCoreNu"
DCB "m5 = %u = 0x%08x",0xA,0
aOpenCoreNumber_5 DCB "Open core number : Conf.OpenCoreNu"
DCB "m6 = %u = 0x%08x",0xA,0
aOpenCoreNumber_6 DCB "Open core number : Conf.OpenCoreNu"
DCB "m7 = %u = 0x%08x",0xA,0
aOpenCoreNumber_7 DCB "Open core number : Conf.OpenCoreNu"
DCB "m8 = %u = 0x%08x",0xA
DCB 0xA,0
ALIGN 4
aCore03d02d DCB "core[%03d]=%02d",9,0
ALIGN 0x10
aCore03dDLostTh DCB "core[%03d] = %d,      lost these n"
DCB "once : ",0
ALIGN 4
aTemperature1Ch DCB "temperature1 check error",0
ALIGN 4
aTemperature1D DCB "temperature1 = %d",0xA,0
ALIGN 4
aTemperature2Ch DCB "temperature2 check error",0
ALIGN 4
aTemperature2D DCB "temperature2 = %d",0xA,0
ALIGN 4
aTemperature3Ch DCB "temperature3 check error",0
ALIGN 4
aTemperature3D DCB "temperature3 = %d",0xA,0
ALIGN 4
aSensorOk DCB "Sensor OK",0xA,0
ALIGN 4
aSensorNg DCB "Sensor NG",0xA,0
ALIGN 4
aSensorOk_0 DCB "    Sensor OK   ",0
ALIGN 4
aSensorNg_0 DCB "    Sensor NG   ",0
ALIGN 4
aSCanTReadOutGe DCB "%s: Can't read out GENERAL_I2C_COM"
DCB "MAND. ret = 0x%08x",0xA,0
ALIGN 4
aSCanTSetExtend DCB 0xA
DCB "!!! %s: Can't set extended mode. r"
DCB "et = 0x%08x",0xA,0
aSCanTReadOutGe_0 DCB 0xA
DCB "!!! %s: Can't read out GENERAL_I2C"
DCB "_COMMAND. ret = 0x%08x",0xA,0
ALIGN 0x10
aTempOffsetValu DCB 0xA
DCB "temp_offset_value = %d",0xA,0
ALIGN 4
aAsicTemperatur DCB 0xA
DCB "ASIC temperature is %d",0xA,0
ALIGN 4
aSCanTReadOutAs DCB "%s: Can't read out ASIC TEMP. ret "
DCB "= 0x%08x",0xA,0
aPcbTemperature DCB 0xA
DCB "PCB temperature is %d",0xA,0
aSCanTReadOutHa DCB "%s: Can't read out HASH BOARD TEMP"
DCB ". ret = 0x%08x",0xA,0
ALIGN 0x10
aSensor1IsError DCB "!!! sensor1 is error!",0xA,0
ALIGN 4
aSensor2IsError DCB "!!! sensor2 is error!",0xA,0
ALIGN 0x10
aSensor3IsError DCB "!!! sensor3 is error!",0xA,0
ALIGN 4
aBeginTestStart DCB 0xA
DCB "Begin test!!! Start sensor is %d, "
DCB "ASIC temperature is %d",0xA
DCB 0xA,0
aAsicDTemperatu DCB 0xA
DCB "ASIC %d temperature is %d, waiting"
DCB " it raise to start temperature %d",0xA
DCB 0xA,0
ALIGN 4
aGmaxtempgapVal DCB "gMaxTempGap_value is %d",0xA
DCB 0xA,0
ALIGN 4
aSDoNotReadOutA_0 DCB 0xA
DCB "!!! %s: do not read out ASIC %d te"
DCB "mperature",0xA
DCB 0xA,0
ALIGN 4
aAsicDTempIsD DCB 0xA
DCB "ASIC %d TEMP is : %d",0xA,0
ALIGN 0x10
aAsicDHashBoard DCB 0xA
DCB "ASIC %d Hash Board temperature is "
DCB "%d",0xA
DCB 0xA,0
aTempOffsetValu_0 DCB "temp_offset_value = %d",0xA
DCB 0xA,0
ALIGN 4
aSDoNotReadOutA DCB 0xA
DCB "!!! %s: do not read out ASIC %d Ha"
DCB "sh Board temperature",0xA
DCB 0xA,0
ALIGN 0x10
aAsicDHashBoard_0 DCB 0xA
DCB "ASIC %d Hash Board temperature is "
DCB "%d",0xA,0
ALIGN 4
aBeginTestStart_0 DCB 0xA
DCB "Begin test!!! Start sensor is %d, "
DCB "Hash Board temperature is %d",0xA
DCB 0xA,0
ALIGN 4
aAsicDHashBoard_1 DCB 0xA
DCB "ASIC %d Hash Board temperature is "
DCB "%d, waiting it raise to start temp"
DCB "erature %d",0xA
DCB 0xA,0
ALIGN 0x10
aSDoNotReadOutA_1 DCB "%s: do not read out ASIC %d Hash B"
DCB "oardtemperature. ret = 0x%08x",0xA
DCB 0xA,0
ALIGN 4
aSPleaseConfigS DCB 0xA
DCB "%s: please config sensor_model in "
DCB "Config.ini",0xA,0
ALIGN 4
aT1DC DCB "   T1 %d `C",0
aGvalidNonceNum DCB 0xA
DCB "gValid_Nonce_Num = %d",0xA,0
aSData0x08x DCB "%s: data = 0x%08x",0xA,0
ALIGN 4
aSReceivedAsic0_0 DCB "%s: received ASIC%02d nonce. error"
DCB "!!! data[0] = 0x%08x, received non"
DCB "ce = 0x%08x",0xA,0
ALIGN 0x10
aSReceivedWorkI_0 DCB "%s: received work_id = %02d nonce."
DCB " error!!! data[0] = 0x%08x, receiv"
DCB "ed nonce = 0x%08x",0xA,0
ALIGN 4
aSRegCrcErrorDa DCB "%s: reg crc error. data[0] = 0x%08"
DCB "x, reg_value = 0x%08x",0xA,0
ALIGN 4
aSRegTypeErrorD DCB "%s: REG_TYPE error. data[0] = 0x%0"
DCB "8x, reg_value = 0x%08x",0xA,0
ALIGN 0x10
aNoHashBoard_0 DCB " no hash board  ",0
ALIGN 4
aCreatShow DCB "   Creat show   ",0
ALIGN 4
aThreadFail DCB "   thread fail  ",0
ALIGN 4
aTestAgain DCB "   test again   ",0
ALIGN 0x10
aSCreateSingleB DCB 0xA
DCB "!!!%s: create single_BM1391_show_s"
DCB "tatus_func fail",0xA
DCB 0xA
DCB 0xA,0
ALIGN 4
aCreatReceive DCB "  Creat receive ",0
ALIGN 4
aSCreateSingleB_0 DCB 0xA
DCB "!!!%s: create single_BM1391_receiv"
DCB "e_func fail",0xA
DCB 0xA
DCB 0xA,0
ALIGN 0x10
aSensorModelErr DCB "Sensor Model Err",0
ALIGN 4
aAsicTypeErr DCB " Asic Type Err  ",0
ALIGN 4
aSConfAsictypeD DCB 0xA
DCB "!!! %s: Conf.AsicType = %d, error",0xA
DCB 0
aCreatSend DCB "   Creat send   ",0
ALIGN 0x10
aSCreateSingleB_1 DCB 0xA
DCB "!!!%s: create single_BM1391_send_f"
DCB "unc fail",0xA
DCB 0xA
DCB 0xA,0
ALIGN 0x10
aMntCardSingleB_0 DCB "/mnt/card/single-BM1391-ASIC-test",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___7893[12]
__FUNCTION__.7893 DCB "check_chain",0
aSTestZhijuOnly DCB 0xA
DCB "!!! %s: Test zhiju only support 1 "
DCB "plug, but now is 0x%08x",0xA,0
aSGchainDGi2cD DCB 0xA
DCB "--- %s: gChain = %d, gI2c = %d",0xA
DCB 0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___6339[10]
__FUNCTION__.6339 DCB "write_lcd",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___6349[20]
__FUNCTION__.6349 DCB "write_lcd_no_memset",0
aDevBitmainLcd DCB "/dev/bitmain-lcd",0
ALIGN 4
aOpenLcdFailed DCB "open lcd failed!!!",0
ALIGN 4
aLcdClosed DCB "lcd closed!!!",0
ALIGN 4
aLcdCloseFailed DCB "lcd close failed!!!",0
aSWriteLcdSArgI DCB "%s: write_lcd's arg is overflow",0xA
DCB 0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8008[33]
__FUNCTION__.8008 DCB "check_how_many_uart_data_in_fpga",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8033[23]
__FUNCTION__.8033 DCB "read_uart_data_in_fpga",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8070[10]
__FUNCTION__.8070 DCB "uart_send",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8092[13]
__FUNCTION__.8092 DCB "uart_receive",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8114[21]
__FUNCTION__.8114 DCB "clear_uart_send_fifo",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8122[19]
__FUNCTION__.8122 DCB "clear_uart_rx_fifo",0
ALIGN 4
aSTheUartDIsNot DCB "%s: The uart%d is not supported!!!"
DCB 0xA,0
aSTheUartIsNotS DCB "%s: The uart is not supported!!!",0xA
DCB 0
ALIGN 4
aSUartDAlwaysDo DCB "%s: uart%d always dose not has eno"
DCB "ugh send fifo space, break",0xA,0
ALIGN 4
aSUartDAlwaysBu DCB "%s: uart%d always busy, break",0xA
DCB 0
ALIGN 4
aSNbytesBufLeng DCB "%s: nbytes > buf_length",0xA,0
ALIGN 4
aSChainSendRead DCB "--- %s: chain_send_ready_addr %d, "
DCB "chain_send_buffer_addr %d",0xA,0
ALIGN 4
aSWaitingFpgaUa DCB "%s: waiting fpga uart%d clear send"
DCB " fifo space ...",0xA,0
ALIGN 4
aS_0 DCB "--- %s",0xA,0
aSUartDMallocBu DCB "%s: uart%d malloc buffer error",0xA
DCB 0
aSUartDClearRxF DCB "%s: uart%d clear rx fifo error. nb"
DCB "ytes = %d, len = %d",0xA,0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8156[16]
__FUNCTION__.8156 DCB "hash_board_test",0
aBeginSingleasi_0 DCB 0xA
DCB "Begin singleAsicTest_BM1385",0xA,0
ALIGN 4
aBeginSingleasi_1 DCB 0xA
DCB "Begin singleAsicTest_BM1391",0xA,0
ALIGN 4
aBeginSingleasi DCB 0xA
DCB "Begin singleAsicTest_BM1397",0xA,0
ALIGN 4
aSingleAsicTest DCB "Single ASIC test: Can't find ASIC "
DCB "type!!! AsicType = %d",0xA,0
ALIGN 4
aSPleaseConfigH DCB "%s: Please config HashBoard name i"
DCB "n Config.ini",0xA,0
aSPatternTestTi_0 DCB "%s: pattern_test_time %d, gHowMany"
DCB "VoltageLevel %d",0xA,0
ALIGN 4
aVersion DCB "--- version:",0
ALIGN 4
aLastCommitVers DCB "last commit version: 4e0ba0e commi"
DCB "t time: 2019-05-06 17:16:11 build:"
DCB " 2019-08-17 11:22:48",0
ALIGN 4
aReadyBeginTest DCB 0xA
DCB 0xA
DCB "Ready begin test",0xA,0
aPressTestKeyTo DCB 0xA
DCB "Press 'test' key to continue",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8281[26]
__FUNCTION__.8281 DCB "BHB91603_show_status_func",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8326[19]
__FUNCTION__.8326 DCB "BHB91603_send_func",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8151[34]
__FUNCTION__.8151 DCB "BHB91603_AT24C02_write_total_data",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8157[21]
__FUNCTION__.8157 DCB "BHB91603_set_voltage",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8174[36]
__FUNCTION__.8174 DCB "BHB91603_calculate_timeout_and_bau"
DCB "d",0
; Function-local static variable
; const char _FUNCTION___8180[21]
__FUNCTION__.8180 DCB "BHB91603_set_address",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8188[18]
__FUNCTION__.8188 DCB "BHB91603_set_baud",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8195[21]
__FUNCTION__.8195 DCB "BHB91603_P_open_core",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8207[25]
__FUNCTION__.8207 DCB "BHB91603_P_pre_open_core",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8222_0[21]
__FUNCTION__.8222_0 DCB "BHB91603_S_open_core",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8240[25]
__FUNCTION__.8240 DCB "BHB91603_S_pre_open_core",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8298[21]
__FUNCTION__.8298 DCB "BHB91603_check_nonce",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8307[30]
__FUNCTION__.8307 DCB "BHB91603_check_register_value",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8371[22]
__FUNCTION__.8371 DCB "BHB91603_receive_func",0
ALIGN 0x10
dword_2B8A0 DCD 0x20202020
dword_2B8A4 DCD 0x20202020
dword_2B8A8 DCD 0x20202020
dword_2B8AC DCD 0x20202020
; Function-local static variable
; const char _FUNCTION___8385[32]
__FUNCTION__.8385 DCB "singleBoardTest_BHB91603_BM1391",0
aSWhichChainDWh_0 DCB 0xA
DCB "--- %s: which_chain = %d, which_i2"
DCB "c = %d",0xA,0
ALIGN 4
aT1DT2D DCB " T1:%d   T2:%d",0
ALIGN 4
aT3DT4D DCB " T3:%d   T4:%d",0
ALIGN 4
aT3D DCB " T3:%d",0
ALIGN 4
aT2DC DCB "   T2 %d `C",0
aTempSettingErr DCB "temp setting err!",0
ALIGN 4
aSSaveDataIntoE_0 DCB "--- %s: save data into EEPROM succ"
DCB "ess! ",0xA,0
ALIGN 0x10
aSSaveDataIntoE DCB "!!! %s: save data into EEPROM fail"
DCB "! ",0xA,0
ALIGN 4
aCanNotFind DCB "  Can not find  ",0
ALIGN 4
aMatchVoltage DCB "  match voltage ",0
ALIGN 0x10
aSCanTFindMatch DCB 0xA
DCB "!!! %s: Can't find match voltage!",0xA
DCB 0
aMaximumNValue DCB " Maximum N value",0
ALIGN 4
aCanNotMatch DCB " can not match  ",0
ALIGN 4
aVoltage DCB "    voltage     ",0
ALIGN 0x10
aSMaximumNValue DCB 0xA
DCB "!!! %s: Maximum N value can't matc"
DCB "h voltage!",0xA,0
ALIGN 0x10
aMinimumNValue DCB " Minimum N value",0
ALIGN 4
aSMinimumNValue DCB 0xA
DCB "!!! %s: Minimum N value can't matc"
DCB "h voltage!",0xA,0
ALIGN 4
aSBaudDTimeout0 DCB 0xA
DCB "--- %s: baud = %d, timeout = 0x%08"
DCB "x = %d us, freq = %d",0xA,0
ALIGN 0x10
aSChainDWorkFif DCB "%s: chain%d work fifo not ready: 0"
DCB "x%x",0xA,0
ALIGN 4
aEveryAsicRequi DCB "every ASIC require nonce number: %"
DCB "u",0xA,0
ALIGN 0x10
aAsic02dD DCB "asic[%02d]=%d",9,0
ALIGN 0x10
aAsic02dD_0 DCB "asic[%02d] = %d",0xA,0
ALIGN 4
aErrorAsicIsD DCB 0xA
DCB " error asic is %d",0xA,0
aHwNumberDConfM DCB "HW number = %d, Conf.Most_HW_Num ="
DCB " %d",0xA
DCB 0xA,0
aSensor1CheckEr DCB 0xA
DCB "Sensor 1 check error",0
ALIGN 4
aSensor2CheckEr DCB 0xA
DCB "Sensor 2 check error",0
ALIGN 0x10
aSensor3CheckEr DCB 0xA
DCB "Sensor 3 check error",0
ALIGN 4
aSensor4CheckEr DCB 0xA
DCB "Sensor 4 check error",0
ALIGN 0x10
aChainDTotalVal_0 DCB "Chain%d total valid nonce number: "
DCB "%d, lost %d nonce",0xA
DCB 0xA,0
ALIGN 4
aNonceRateF DCB "Nonce rate = %f ",0xA
DCB 0xA,0
ALIGN 4
aTemperatureOk_0 DCB "Temperature OK",0xA,0
aTemperatureNg_0 DCB "Temperature NG",0xA,0
aCrcErrorNumber DCB "CRC error number = %d",0xA
DCB 0xA,0
aSensorOk_1 DCB "   Sensor OK    ",0
ALIGN 4
aSensorNg_1 DCB "   Sensor NG    ",0
ALIGN 4
aEepromNg DCB "   EEPROM NG   ",0
aEepromOk DCB "   EEPROM OK   ",0
aSNonceCrcError DCB 0xA
DCB "!!! %s: nonce crc error! nonce = 0"
DCB "x%08x, which_asic = %d, which_core"
DCB " = %d, which_pattern = %d",0xA,0
aSIoThreadLxUsi DCB 0xA
DCB "--- %s: IO Thread #%lx using %d pr"
DCB "iority scheduler! ",0
ALIGN 4
aSWhichChainDWh_1 DCB 0xA
DCB "--- %s: which_chain = %d, which_i2"
DCB "c = %d",0xA
DCB 0xA,0
aSCheckEepromEr DCB 0xA
DCB "!!! %s: Check EEPROM error!!!",0xA
DCB 0xA,0
ALIGN 4
aSCheckEepromOk DCB 0xA
DCB "--- %s: Check EEPROM ok!!!",0xA,0
ALIGN 4
aCreatHeartBeat DCB "Creat heart beat",0
ALIGN 4
aSCreatePicHear DCB 0xA
DCB "!!!%s: create pic_heart_beat_func "
DCB "fail",0xA
DCB 0xA
DCB 0xA,0
ALIGN 4
aSCreateBhb9160 DCB 0xA
DCB "!!!%s: create BHB91603_receive_fun"
DCB "c fail",0xA
DCB 0xA
DCB 0xA,0
ALIGN 4
aSConfOpencoren DCB 0xA
DCB "---%s: Conf.OpenCoreNum1 = %d, Con"
DCB "f.OpenCoreNum2 = %d",0xA,0
aBhb91603CheckA DCB 0xA
DCB "--- BHB91603 check asic number",0
aCheckChainJDHa DCB 0xA
DCB "--- check chain: J%d has asicNum ="
DCB " %d",0xA,0
aConfig DCB "     Config     ",0
ALIGN 4
aHashboardType DCB " Hashboard Type ",0
ALIGN 4
aInConfigIni DCB " in Config.ini  ",0
ALIGN 0x10
aSCanTFindHashb DCB 0xA
DCB "!!!%s: Can't find Hashboard type w"
DCB "hen open core, fail",0xA
DCB 0xA
DCB 0xA,0
ALIGN 4
aDoubleCheckAsi DCB 0xA
DCB "--- double check asic number",0
ALIGN 4
aFindAllAsic DCB " find all ASIC  ",0
ALIGN 0x10
aOk DCB "       OK       ",0
ALIGN 4
aFindDAsicOk DCB 0xA
DCB "Find %d ASIC, OK",0xA,0
ALIGN 4
aCanTOpenCoreCh DCB "Can't open core, change to next vo"
DCB "ltage and freq",0
ALIGN 4
aCanTOpenCore DCB "Can't open core ",0
ALIGN 0x10
aChangeToNext DCB "change  to  next",0
ALIGN 4
aSCreateBhb9160_0 DCB 0xA
DCB "!!!%s: create BHB91603_send_func f"
DCB "ail",0xA
DCB 0xA
DCB 0xA,0
ALIGN 0x10
aEepromOk_0 DCB 0xA
DCB "EEPROM OK",0xA,0
aEepromNg_0 DCB 0xA
DCB "EEPROM NG",0xA,0
aSDonTSaveDataI DCB 0xA
DCB "!!!%s: Don't save data into EEPROM"
DCB ", because EEPROM test fail!!",0xA
DCB 0xA,0
ALIGN 4
aMntCardMinerte_0 DCB "/mnt/card/minertest-BHB91603-BM139"
DCB "1/btc-asic-",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8218[12]
__FUNCTION__.8218 DCB "read_config",0
aMntCardConfigI DCB "/mnt/card/Config.ini",0
ALIGN 0x10
aName DCB "Name=",0
ALIGN 4
aSGhashboardBhb_2 DCB 0xA
DCB "---%s: gHashBoard_BHB91601P",0xA
DCB 0xA,0
ALIGN 4
aSGhashboardBhb_1 DCB 0xA
DCB "---%s: gHashBoard_BHB91601S",0xA
DCB 0xA,0
ALIGN 4
aSGhashboardBhb_0 DCB 0xA
DCB "---%s: gHashBoard_BHB91603S",0xA
DCB 0xA,0
ALIGN 4
aSGhashboardBhb DCB 0xA
DCB "---%s: gHashBoard_BHB07601",0xA
DCB 0xA,0
ALIGN 4
aSGhashboardV9 DCB 0xA
DCB "---%s: gHashBoard_V9",0xA
DCB 0xA,0
aPatternNumber DCB "pattern_number=",0
aGpatternNumber DCB "gPattern_number = %d",0xA,0
ALIGN 4
aAsicnum DCB "AsicNum=",0
ALIGN 4
aAsictype DCB "AsicType=",0
ALIGN 0x10
aX DCB "%x",0
ALIGN 4
aFreq1 DCB "Freq1=",0
ALIGN 4
aFreq2 DCB "Freq2=",0
ALIGN 4
aFreq3 DCB "Freq3=",0
ALIGN 4
aFreq4 DCB "Freq4=",0
ALIGN 4
aFreq5 DCB "Freq5=",0
ALIGN 4
aFreq6 DCB "Freq6=",0
ALIGN 4
aFreq7 DCB "Freq7=",0
ALIGN 4
aFreq8 DCB "Freq8=",0
ALIGN 4
aFreq9 DCB "Freq9=",0
ALIGN 4
aVoltage1 DCB "Voltage1=",0
ALIGN 4
aVoltage1D DCB "Voltage1 = %d",0xA,0
ALIGN 4
aVoltage2 DCB "Voltage2=",0
ALIGN 4
aVoltage3 DCB "Voltage3=",0
ALIGN 0x10
aVoltage4 DCB "Voltage4=",0
ALIGN 4
aVoltage5 DCB "Voltage5=",0
ALIGN 4
aVoltage6 DCB "Voltage6=",0
ALIGN 4
aVoltage7 DCB "Voltage7=",0
ALIGN 0x10
aVoltage8 DCB "Voltage8=",0
ALIGN 4
aVoltage9 DCB "Voltage9=",0
ALIGN 4
aVoltageAccurac DCB "Voltage_accuracy=",0
ALIGN 4
aOpencoregap DCB "OpenCoreGap=",0
ALIGN 4
aChecktemp DCB "CheckTemp=",0
ALIGN 4
aOpenCoreNum1 DCB "Open_Core_Num1=",0
aOpenCoreNum2 DCB "Open_Core_Num2=",0
aOpenCoreNum3 DCB "Open_Core_Num3=",0
aOpenCoreNum4 DCB "Open_Core_Num4=",0
aOpenCoreNum5 DCB "Open_Core_Num5=",0
aOpenCoreNum6 DCB "Open_Core_Num6=",0
aOpenCoreNum7 DCB "Open_Core_Num7=",0
aOpenCoreNum8 DCB "Open_Core_Num8=",0
aSensorModel DCB "sensor_model=",0
ALIGN 4
aRemoteLocalGap DCB "remote_local_gap=",0
ALIGN 4
aUd DCB "%ud",0
aTempsensor1 DCB "TempSensor1=",0
ALIGN 0x10
aTempsensor2 DCB "TempSensor2=",0
ALIGN 0x10
aTempsensor3 DCB "TempSensor3=",0
ALIGN 0x10
aTempsensor4 DCB "TempSensor4=",0
ALIGN 0x10
aStartsensor DCB "StartSensor=",0
ALIGN 0x10
aStarttemp DCB "StartTemp=",0
ALIGN 4
aStarttempD DCB "StartTemp = %d",0xA,0
aTargettemp DCB "TargetTemp=",0
aTargettempD DCB "TargetTemp = %d",0xA,0
ALIGN 4
aAddVoltageAfte DCB "add_voltage_after_test_ok=",0
ALIGN 4
aAddVoltageValu DCB "add_voltage_value=",0
ALIGN 4
aAlarmtemp DCB "AlarmTemp=",0
ALIGN 4
aAlarmtempD DCB "AlarmTemp = %d",0xA,0
aHeatinguptime DCB "HeatingUpTime=",0
ALIGN 4
aMaxtempgap DCB "MaxTempGap=",0
aInvalidAsicNum DCB "Invalid_Asic_Num=",0
ALIGN 4
aInvalidAsicNum_0 DCB "Invalid_Asic_Num = %d",0xA,0
ALIGN 0x10
aInvalidCoreNum DCB "Invalid_Core_Num=",0
ALIGN 4
aInvalidCoreNum_0 DCB "Invalid_Core_Num = %d",0xA,0
ALIGN 4
aLeastNoncePerC DCB "Least_nonce_per_core=",0
ALIGN 4
aLeastNoncePerC_0 DCB "Least_nonce_per_core = %d",0xA,0
ALIGN 0x10
aMostHwNum DCB "Most_HW_Num=",0
ALIGN 0x10
aMostHwNumD DCB "Most_HW_Num = %d",0xA,0
ALIGN 4
aClosePowerDela DCB "close_power_delay=",0
ALIGN 4
aFanSpeed DCB "fan_speed=",0
ALIGN 4
aFanSpeedD DCB "fan_speed = %d",0xA,0
aHashboardHardw DCB "HashBoard_Hardware_Version_1=",0
ALIGN 4
aHashboardHardw_0 DCB "HashBoard_Hardware_Version_1 = %d",0xA
DCB 0
ALIGN 4
aHashboardHardw_1 DCB "HashBoard_Hardware_Version_2=",0
ALIGN 4
aHashboardHardw_2 DCB "HashBoard_Hardware_Version_2 = %d",0xA
DCB 0
ALIGN 4
aHashboardBomVe DCB "HashBoard_Bom_Version_1=",0
ALIGN 4
aHashboardBomVe_0 DCB "HashBoard_Bom_Version_1 = %d",0xA,0
ALIGN 4
aHashboardBomVe_1 DCB "HashBoard_Bom_Version_2=",0
ALIGN 4
aHashboardBomVe_2 DCB "HashBoard_Bom_Version_2 = %d",0xA,0
ALIGN 4
aHashboardProdu DCB "HashBoard_Product_ID=",0
ALIGN 4
aHashboardProdu_0 DCB "HashBoard_Product_ID = %d",0xA,0
ALIGN 4
aTimeoutPercent DCB "timeout_percent=",0
ALIGN 4
aTimeoutPercent_0 DCB "timeout_percent = %d",0xA,0
ALIGN 4
aBaudrate DCB "baudrate=",0
ALIGN 0x10
aBaudrateD DCB "baudrate = %d",0xA,0
ALIGN 0x10
aOnlyFindAsic DCB "Only_find_ASIC=",0
aOnlyFindAsicD DCB "Only_find_ASIC = %d",0xA,0
ALIGN 4
aPreOpenCoreVol DCB "pre_open_core_voltage=",0
ALIGN 0x10
aPreOpenCoreVol_0 DCB "pre_open_core_voltage = %d",0xA,0
aIoStrength DCB "io_strength=",0
ALIGN 4
aIoStrength0x08 DCB "io_strength = 0x%08x",0xA,0
ALIGN 4
aRepairMode DCB "repair_mode=",0
ALIGN 4
aRepairModeD DCB "repair_mode = %d",0xA,0
ALIGN 4
aDumpLostNonce DCB "Dump_Lost_Nonce=",0
ALIGN 4
aDumpLostNonceD DCB "Dump_Lost_Nonce = %d",0xA,0
ALIGN 4
aCoreclockdelay DCB "CoreClockDelay=",0
aCoreclockdelay_0 DCB "CoreClockDelay = 0x%02x",0xA,0
ALIGN 0x10
aBadChipNonceRa DCB "bad_chip_nonce_rate=",0
ALIGN 4
aBadChipNonceRa_0 DCB "bad_chip_nonce_rate = %d",0xA,0
ALIGN 4
aBadChipNum DCB "bad_chip_num=",0
ALIGN 4
aBadChipNumD DCB "bad_chip_num = %d",0xA,0
ALIGN 4
aSDonTFindAsicn DCB 0xA
DCB "!!! %s: Don't find AsicNum in Conf"
DCB "ig.ini, please config it",0xA
DCB 0xA,0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8213_0[13]
__FUNCTION__.8213_0 DCB "V9_send_func",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8075[15]
__FUNCTION__.8075 DCB "V9_set_voltage",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8093[30]
__FUNCTION__.8093 DCB "V9_calculate_timeout_and_baud",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8099[15]
__FUNCTION__.8099 DCB "V9_set_address",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8107[12]
__FUNCTION__.8107 DCB "V9_set_baud",0
; Function-local static variable
; const char _FUNCTION___8114_0[13]
__FUNCTION__.8114_0 DCB "V9_open_core",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8173[15]
__FUNCTION__.8173 DCB "v9_check_nonce",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8181[24]
__FUNCTION__.8181 DCB "V9_check_register_value",0
; Function-local static variable
; const char _FUNCTION___8235[16]
__FUNCTION__.8235 DCB "V9_receive_func",0
dword_2C8BC DCD 0x20202020
dword_2C8C0 DCD 0x20202020
dword_2C8C4 DCD 0x20202020
dword_2C8C8 DCD 0x20202020
; Function-local static variable
; const char _FUNCTION___8262[29]
__FUNCTION__.8262 DCB "singleBoardTest_V9_BM1385_45",0
ALIGN 4
aTempDC DCB "   temp %d `C",0
ALIGN 4
aBeginTestHashB DCB 0xA
DCB "Begin test!!! Hash Board temperatu"
DCB "re is %d",0xA,0
ALIGN 4
aHashBoardTempe DCB 0xA
DCB "Hash Board temperature is %d, wait"
DCB "ing it raise to start temperature "
DCB "%d",0xA,0
ALIGN 4
aChainDGetValid DCB 0xA
DCB "Chain%d get valid nonce number : %"
DCB "d. temperature is %d",0xA,0
ALIGN 4
aCanTFindVoltag DCB 0xA
DCB "--- Can't find voltage%d",0xA,0
ALIGN 0x10
aSRealVoltageDT DCB 0xA
DCB "--- %s: real voltage = %d, temp_vo"
DCB "ltage = %.6f, Pic_Voltage = %d",0xA
DCB 0
ALIGN 4
aSBaudDTimeout0_0 DCB 0xA
DCB "--- %s: baud = %d, timeout = 0x%08"
DCB "x = %d",0xA,0
ALIGN 0x10
aRetD DCB "ret = %d",0xA,0
ALIGN 4
aTemperatureOk DCB " Temperature OK ",0
ALIGN 0x10
aTemperatureNg DCB " Temperature NG ",0
ALIGN 4
aV9CheckAsicNum DCB 0xA
DCB "--- V9 check asic number",0
ALIGN 0x10
aMntCardMinerte_1 DCB "/mnt/card/minertest64-BM1385/btc-a"
DCB "sic-",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8004[19]
__FUNCTION__.8004 DCB "get_target_voltage",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8046[23]
__FUNCTION__.8046 DCB "APW8_calculate_voltage",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8056[23]
__FUNCTION__.8056 DCB "APW9_calculate_voltage",0
ALIGN 4
off_2CAFC DCD 0x8306AA55
dword_2CB00 DCD 0
; Function-local static variable
; const char _FUNCTION___8088_0[20]
__FUNCTION__.8088_0 DCB "Calibration_voltage",0
; Function-local static variable
; const char _FUNCTION___8104[26]
__FUNCTION__.8104 DCB "set_pre_open_core_voltage",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8114_1[15]
__FUNCTION__.8114_1 DCB "adjust_voltage",0
ALIGN 4
aPowerTypeApw93 DCB "power type APW9 3600W",0
ALIGN 4
aPowerTypeApw82 DCB "power type APW8 2000W",0
ALIGN 4
aSysClassGpioGp DCB "/sys/class/gpio/gpio907/value",0
ALIGN 4
aOpenPowerContr DCB "open power control gpio failed!!!",0
ALIGN 4
aPowerControlGp DCB "power control gpio closed!!!",0
ALIGN 4
a0 DCB "0",0
ALIGN 4
a1 DCB "1",0
ALIGN 0x10
aSNotSupportVol DCB "!!!%s: not support Voltage%d, we u"
DCB "se Voltage1 as default value",0xA,0
aSTargetVoltage DCB 0xA
DCB "--- %s: target voltage is %d",0xA,0
ALIGN 0x10
aPowerReplyData DCB "power reply data error:",0
a02x DCB "%02x ",0
ALIGN 0x10
aPowerReplyCrcE DCB "power reply crc error, crc %04x !="
DCB " crc_reply %04x:",0xA,0
aPowerSendCmd0x DCB "power send cmd 0x%02x failed, retr"
DCB "y for %d times",0xA,0
ALIGN 4
aSUseBhb9160184 DCB 0xA
DCB "!!! %s Use BHB91601 84P power as d"
DCB "efault!",0xA
DCB 0xA,0
ALIGN 4
aSPleaseCheckHa DCB 0xA
DCB "!!! %s Please check Hashboard type"
DCB "!",0xA
DCB 0xA,0
ALIGN 0x10
aSVoltageNFWeUs DCB 0xA
DCB "!!! %s: voltage_n = %f, we use N ="
DCB " %d as default",0xA,0
ALIGN 4
aSVoltageNFND DCB 0xA
DCB "--- %s: voltage_n = %f, N = %d",0xA
DCB 0
ALIGN 4
aSTargetV0DND DCB 0xA
DCB "--- %s: target_V0 = %d, N = %d",0xA
DCB 0
ALIGN 4
aSVoltageV0FTar DCB 0xA
DCB "--- %s: voltage_V0 = %f, target_V0"
DCB " = %d, error_value = %f",0xA
DCB 0xA,0
ALIGN 4
aSCalibrationVo DCB 0xA
DCB "--- %s: Calibration voltage done. "
DCB "voltage_V0 = %f, N = %d, Voltage_a"
DCB "ccuracy = %d",0xA,0
ALIGN 0x10
aSNDFail DCB 0xA
DCB "!!! %s: N = %d, fail",0xA,0
ALIGN 4
aSND DCB 0xA
DCB "--- %s: N = %d",0xA,0
ALIGN 4
aSCalibrationCo DCB 0xA
DCB "!!! %s: calibration_counter = %d, "
DCB "fail",0xA,0
ALIGN 4
aSConfPreOpenCo DCB 0xA
DCB "--- %s: Conf.pre_open_core_voltage"
DCB " = %d, N = %d",0xA,0
ALIGN 4
aSLineDEnterHas DCB "%s line %d: Enter hash board power"
DCB " on flow:",0xA,0
ALIGN 4
aSLineDResetHas DCB "%s line %d: Reset hash board done",0xA
DCB 0
ALIGN 0x10
aSLineDDcDcEnab DCB "%s line %d: dc dc enable done",0xA
DCB 0
ALIGN 0x10
aSLineDReleaseH DCB "%s line %d: release hash board res"
DCB "et done.",0xA,0
aSTargetNDOrigi DCB 0xA
DCB "--- %s: target_N = %d, origin_N = "
DCB "%d",0xA,0
ALIGN 4
aSDone DCB 0xA
DCB "--- %s: done",0xA,0
ALIGN 4
CSWTCH.3 DCB "d",0
ALIGN 4
aZP text "UTF-16LE", "Z",0xA,"P"
DCB 0x14
DCB    0
DCB 0x46 ; F
DCB    0
DCB 0x1E
DCB    0
DCB 0x3C ; <
DCB    0
DCB 0x28 ; (
DCB    0
DCB 0x32 ; 2
DCB    0
DCB 0x32 ; 2
DCB    0
DCB 0x28 ; (
DCB    0
DCB 0x3C ; <
DCB    0
DCB 0x1E
DCB    0
DCB 0x46 ; F
DCB    0
DCB 0x14
DCB    0
DCB 0x50 ; P
DCB    0
DCB  0xA
DCB    0
DCB 0x5A ; Z
DCB    0
DCB    0
DCB    0
DCB 0x64 ; d
DCB    0
; Function-local static variable
; const char _FUNCTION___8285[26]
__FUNCTION__.8285 DCB "BHB91601_show_status_func",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8330[19]
__FUNCTION__.8330 DCB "BHB91601_send_func",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8155[34]
__FUNCTION__.8155 DCB "BHB91601_AT24C02_write_total_data",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8161[21]
__FUNCTION__.8161 DCB "BHB91601_set_voltage",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8178[36]
__FUNCTION__.8178 DCB "BHB91601_calculate_timeout_and_bau"
DCB "d",0
; Function-local static variable
; const char _FUNCTION___8184_0[21]
__FUNCTION__.8184_0 DCB "BHB91601_set_address",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8192[18]
__FUNCTION__.8192 DCB "BHB91601_set_baud",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8199[21]
__FUNCTION__.8199 DCB "BHB91601_P_open_core",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8211[25]
__FUNCTION__.8211 DCB "BHB91601_P_pre_open_core",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8226[21]
__FUNCTION__.8226 DCB "BHB91601_S_open_core",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8244[25]
__FUNCTION__.8244 DCB "BHB91601_S_pre_open_core",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8302[21]
__FUNCTION__.8302 DCB "BHB91601_check_nonce",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8311[30]
__FUNCTION__.8311 DCB "BHB91601_check_register_value",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8375[22]
__FUNCTION__.8375 DCB "BHB91601_receive_func",0
ALIGN 4
dword_2D134 DCD 0x20202020
dword_2D138 DCD 0x20202020
dword_2D13C DCD 0x20202020
dword_2D140 DCD 0x20202020
; Function-local static variable
; const char _FUNCTION___8389[32]
__FUNCTION__.8389 DCB "singleBoardTest_BHB91601_BM1391",0
aSTestEepromPar DCB 0xA
DCB "!!! %s: Test_EEPROM_part_area: Che"
DCB "ck EEPROM error!!!",0xA
DCB 0xA,0
aSTestEepromPar_0 DCB 0xA
DCB "--- %s: Test_EEPROM_part_area: Che"
DCB "ck EEPROM ok!!!",0xA,0
aSTestEepromChe DCB 0xA
DCB "!!! %s: Test_EEPROM: Check EEPROM "
DCB "error!!!",0xA
DCB 0xA,0
ALIGN 0x10
aSTestEepromChe_0 DCB 0xA
DCB "--- %s: Test_EEPROM: Check EEPROM "
DCB "ok!!!",0xA,0
ALIGN 4
aSCreateBhb9160_1 DCB 0xA
DCB "!!!%s: create BHB91601_receive_fun"
DCB "c fail",0xA
DCB 0xA
DCB 0xA,0
ALIGN 4
aBhb91601CheckA DCB 0xA
DCB "--- BHB91601 check asic number",0
aSCheckSensorOk DCB 0xA
DCB "---%s: check sensor ok",0xA,0
ALIGN 4
aSCheckSensorDT DCB 0xA
DCB "---%s: check sensor %d time",0xA,0
ALIGN 4
aSCreateBhb9160_2 DCB 0xA
DCB "!!!%s: create BHB91601_send_func f"
DCB "ail",0xA
DCB 0xA
DCB 0xA,0
ALIGN 4
aMntCardMinerte DCB "/mnt/card/minertest-BM1391/btc-asi"
DCB "c-",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___5378[9]
__FUNCTION__.5378 DCB "read_key",0
ALIGN 4
aSysClassGpioGp_0 DCB "/sys/class/gpio/gpio943/value",0
ALIGN 4
aOpenKeyFailed DCB "open key failed!!!",0
ALIGN 4
aKeyClosed DCB "key closed!!!",0
ALIGN 4
aSCanTReadOutKe DCB "%s: can't read out key value",0xA,0
ALIGN 4
; const unsigned __int8 sha2_padding[64]
sha2_padding DCB 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
; Function-local static variable
; const char _FUNCTION___8427[19]
__FUNCTION__.8427 DCB "BHB07601_send_func",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8242[34]
__FUNCTION__.8242 DCB "BHB07601_AT24C02_write_total_data",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8252[21]
__FUNCTION__.8252 DCB "BHB07601_set_voltage",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8269_0[36]
__FUNCTION__.8269_0 DCB "BHB07601_calculate_timeout_and_bau"
DCB "d",0
; Function-local static variable
; const char _FUNCTION___8275[21]
__FUNCTION__.8275 DCB "BHB07601_set_address",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8283_0[18]
__FUNCTION__.8283_0 DCB "BHB07601_set_baud",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8293[19]
__FUNCTION__.8293 DCB "BHB07601_open_core",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8311_0[23]
__FUNCTION__.8311_0 DCB "BHB07601_pre_open_core",0
ALIGN 4
dword_2D488 DCD 0x20202020
dword_2D48C DCD 0x20202020
dword_2D490 DCD 0x20202020
dword_2D494 DCD 0x20202020
; Function-local static variable
; const char _FUNCTION___8385_0[26]
__FUNCTION__.8385_0 DCB "BHB07601_show_status_func",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8401[21]
__FUNCTION__.8401 DCB "BHB07601_check_nonce",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8407[30]
__FUNCTION__.8407 DCB "BHB07601_check_register_value",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8469[22]
__FUNCTION__.8469 DCB "BHB07601_receive_func",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8483[32]
__FUNCTION__.8483 DCB "singleBoardTest_BHB07601_BM1397",0
aDumpEepromInfo DCB 0xA
DCB "--- dump eeprom info:",0
ALIGN 4
aFixtureHeader0 DCB "fixture_header:      0x%04x",0xA,0
ALIGN 4
aFixtureVersion DCB "fixture_version:     0x%04x",0xA,0
ALIGN 4
aHashBoardSn0x DCB "hash_board_sn:       0x",0
a02x_0 DCB "%02x",0
ALIGN 4
aPcbVersion0x04 DCB "pcb_version:         0x%04x",0xA,0
ALIGN 4
aBomVersion0x04 DCB "bom_version:         0x%04x",0xA,0
ALIGN 4
aTempSensorType DCB "temp_sensor_type:    0x%02x",0xA,0
ALIGN 4
aProductId0x02x DCB "product_id:          0x%02x",0xA,0
ALIGN 4
aCrcTestFixture DCB "crc_test_fixture:    0x%04x",0xA,0
ALIGN 4
aSEeprom0xX0xX0 DCB "!!! %s: eeprom[0x%x] 0x%x != 0x%x!"
DCB 0xA,0
aSClearEepromDa DCB "!!! %s: clear EEPROM data! ",0xA,0
ALIGN 0x10
aIc02d10d DCB "IC[%02d]=%-10d",0
ALIGN 0x10
aErrorAsicIsD_0 DCB 0xA
DCB "error asic is %d",0xA,0
ALIGN 4
aEveryDomainReq DCB 0xA
DCB "every Domain require nonce number:"
DCB " %u",0xA,0
aD02d10d DCB "D[%02d]:%-10d ",0
ALIGN 4
aDBig02d10d DCB "D_BIG[%02d]:%-10d",0xA,0
ALIGN 0x10
aHwNumberDConfM_0 DCB 0xA
DCB "HW number = %d, Conf.Most_HW_Num ="
DCB " %d",0xA
DCB 0xA,0
ALIGN 4
aChainDTotalBad DCB "Chain%d total bad number: %d",0xA
DCB 0xA,0
ALIGN 4
aNonceRateF_0 DCB "Nonce rate = %f%% ",0xA
DCB 0xA,0
ALIGN 4
aBadChipCheckOk DCB "Bad Chip Check OK",0xA,0
ALIGN 4
aBadChipCheckNg DCB "Bad Chip Check NG",0xA,0
ALIGN 4
aBadchipNum2d DCB "BadChip Num=%2d ",0
ALIGN 0x10
a2d4d2d4d DCB "%2d-%4d  %2d-%4d",0xA,0
ALIGN 4
a2d4d2d4d_0 DCB "%2d-%4d %2d-%4d ",0
ALIGN 4
aPowerOffHashbo DCB 0xA
DCB "power off hashboard",0
ALIGN 0x10
aTempIsHigerTha DCB "Temp is higer than AlarmTemp %d",0xA
DCB 0
ALIGN 4
aFpgaVersion0x0 DCB "FPGA version 0x%04x",0xA,0
ALIGN 4
aSCreateSingleB_2 DCB 0xA
DCB "!!!%s: create single_BM1397_show_s"
DCB "tatus_func fail",0xA
DCB 0xA
DCB 0xA,0
ALIGN 4
aSCreateBhb0760 DCB 0xA
DCB "!!!%s: create BHB07601_receive_fun"
DCB "c fail",0xA
DCB 0xA
DCB 0xA,0
ALIGN 4
aBhb07601CheckA DCB 0xA
DCB "--- BHB07601 check asic number",0
aSCreateBhb0760_0 DCB 0xA
DCB "!!!%s: create BHB07601_send_func f"
DCB "ail",0xA
DCB 0xA
DCB 0xA,0
ALIGN 0x10
a07601Pattern48 DCB "07601_pattern_48",0
ALIGN 4
aMntCard DCB "/mnt/card/",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8274[10]
__FUNCTION__.8274 DCB "cgpu_init",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8287_0[20]
__FUNCTION__.8287_0 DCB "malloc_register_buf",0
; Function-local static variable
; const char _FUNCTION___8309[22]
__FUNCTION__.8309 DCB "calculate_core_number",0
ALIGN 4
off_2D918 DCD 0x20202020
byte_2D91C DCB 0x20
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8353[17]
__FUNCTION__.8353 DCB "reset_global_arg",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8381[9]
__FUNCTION__.8381 DCB "check_hw",0
ALIGN 0x10
EXPORT read_loop
; const unsigned int read_loop
read_loop DCD 2
aSOpenLcdDriver DCB "!!! %s: open lcd driver error",0xA
DCB 0
ALIGN 4
aSOpenStartKeyE DCB "!!! %s: open start key error",0xA,0
ALIGN 4
aSOpenRedLedErr DCB "!!! %s: open red led error",0xA,0
aSOpenGreenLedE DCB "!!! %s: open green led error",0xA,0
ALIGN 0x10
aSOpenPowerCont DCB "!!! %s: open power control gpio er"
DCB "ror",0xA,0
ALIGN 4
aSMallocRegValu DCB "%s: malloc reg_value_buf failed",0xA
DCB 0
ALIGN 4
aGetWorksTook3f DCB "get_works took %.3fs",0xA,0
ALIGN 4
aIc2dP2d DCB "IC:%2d P:%2d",0
ALIGN 4
aFreqD DCB "FREQ: %d",0
ALIGN 0x10
aVoltageD DCB "Voltage: %d",0
aSLineDNoteActu DCB "%s line %d: Note actual_core_num i"
DCB "s 0!",0xA,0
a2d DCB "%2d",0
aLevelD DCB "Level: %d",0xA
DCB 0xA,0
aSGotAHw DCB 0xA
DCB "%s: Got a HW!",0xA,0
aHash10x DCB "hash1=0x",0
ALIGN 0x10
aMidstate0x DCB "midstate=0x",0
aData20x DCB 9,"data2=0x",0
ALIGN 4
aReturnNonce0x0 DCB 9,"return nonce=0x%08x, but it shou"
DCB "ld be nonce=0x%08x",0xA,0
ALIGN 0x10
aBtcCore DCB "/btc-core-",0
ALIGN 4
aSysClassGpioGp_1 DCB "/sys/class/gpio/gpio941/value",0
ALIGN 4
aOpenRedLedFail DCB "open red led failed!!!",0
ALIGN 4
aRedLedClosed DCB "red led closed!!!",0
ALIGN 4
aSysClassGpioGp_2 DCB "/sys/class/gpio/gpio942/value",0
ALIGN 4
aOpenGreenLedFa DCB "open green led failed!!!",0
ALIGN 4
aGreenLedClosed DCB "green led closed!!!",0
; Function-local static variable
; const char _FUNCTION___8002[29]
__FUNCTION__.8002 DCB "set_PIC16F1704_flash_pointer",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8026[24]
__FUNCTION__.8026 DCB "send_data_to_PIC16F1704",0
; Function-local static variable
; const char _FUNCTION___8045[30]
__FUNCTION__.8045 DCB "read_PIC16F1704_flash_pointer",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8063[27]
__FUNCTION__.8063 DCB "read_PIC16F1704_flash_data",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8083[23]
__FUNCTION__.8083 DCB "erase_PIC16F1704_flash",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8100[33]
__FUNCTION__.8100 DCB "write_data_into_PIC16F1704_flash",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8117[35]
__FUNCTION__.8117 DCB "jump_from_loader_to_app_PIC16F1704"
DCB 0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8134[21]
__FUNCTION__.8134 DCB "reset_PIC16F1704_pic",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8146[23]
__FUNCTION__.8146 DCB "set_PIC16F1704_voltage",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8176[25]
__FUNCTION__.8176 DCB "write_hash_ID_PIC16F1704",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8194[24]
__FUNCTION__.8194 DCB "read_hash_id_PIC16F1704",0
; Function-local static variable
; const char _FUNCTION___8209[24]
__FUNCTION__.8209 DCB "enable_PIC16F1704_dc_dc",0
; Function-local static variable
; const char _FUNCTION___8232[22]
__FUNCTION__.8232 DCB "heart_beat_PIC16F1704",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8250[32]
__FUNCTION__.8250 DCB "get_PIC16F1704_software_version",0
; Function-local static variable
; const char _FUNCTION___8268[23]
__FUNCTION__.8268 DCB "get_PIC16F1704_voltage",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8292[36]
__FUNCTION__.8292 DCB "write_temperature_offset_PIC16F170"
DCB "4",0
; Function-local static variable
; const char _FUNCTION___8310[35]
__FUNCTION__.8310 DCB "read_temperature_offset_PIC16F1704"
DCB 0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8326_0[27]
__FUNCTION__.8326_0 DCB "erase_PIC16F1704_app_flash",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8347[31]
__FUNCTION__.8347 DCB "PIC1704_update_pic_app_program",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8374[21]
__FUNCTION__.8374 DCB "save_freq_PIC16F1704",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8392[20]
__FUNCTION__.8392 DCB "get_PIC16F1704_freq",0
; Function-local static variable
; const char _FUNCTION___8398[29]
__FUNCTION__.8398 DCB "set_temperature_offset_value",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8404[27]
__FUNCTION__.8404 DCB "write_sensor_info_into_pic",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8428[30]
__FUNCTION__.8428 DCB "send_data_to_dsPIC33EP16GS202",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8445[41]
__FUNCTION__.8445 DCB "jump_from_loader_to_app_dsPIC33EP1"
DCB "6GS202",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8462[27]
__FUNCTION__.8462 DCB "reset_dsPIC33EP16GS202_pic",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8473[39]
__FUNCTION__.8473 DCB "dsPIC33EP16GS202_erase_pic_app_pro"
DCB "gram",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8491[29]
__FUNCTION__.8491 DCB "set_dsPIC33EP16GS202_voltage",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8513_0[39]
__FUNCTION__.8513_0 DCB "set_dsPIC33EP16GS202_threshold_vol"
DCB "tage",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8531[30]
__FUNCTION__.8531 DCB "enable_dsPIC33EP16GS202_dc_dc",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8549[41]
__FUNCTION__.8549 DCB "enable_dsPIC33EP16GS202_clamping_v"
DCB "oltage",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8572[28]
__FUNCTION__.8572 DCB "heart_beat_dsPIC33EP16GS202",0
; Function-local static variable
; const char _FUNCTION___8590[38]
__FUNCTION__.8590 DCB "get_dsPIC33EP16GS202_software_vers"
DCB "ion",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8611[36]
__FUNCTION__.8611 DCB "dsPIC33EP16GS202_read_out_4_voltag"
DCB "e",0
; Function-local static variable
; const char _FUNCTION___8618[20]
__FUNCTION__.8618 DCB "pic_heart_beat_func",0
; Function-local static variable
; const char _FUNCTION___8624[22]
__FUNCTION__.8624 DCB "dsPIC33EP16GS202_test",0
ALIGN 4
aSFailedReadBac DCB 0xA
DCB "--- %s failed! read_back_data[0] ="
DCB " 0x%02x, read_back_data[1] = 0x%02"
DCB "x",0xA
DCB 0xA,0
ALIGN 4
aSOk DCB 0xA
DCB "--- %s ok",0xA
DCB 0xA,0
ALIGN 4
aSFailedReadBac_0 DCB 0xA
DCB "--- %s failed! read_back_data[0] ="
DCB " 0x%x, read_back_data[1] = 0x%x, r"
DCB "ead_back_data[2] = 0x%x, read_back"
DCB "_data[3] = 0x%x, read_back_data[4]"
DCB " = 0x%x, read_back_data[5] = 0x%x",0xA
DCB 0xA,0
ALIGN 4
aSOkFlashAddrH0 DCB 0xA
DCB "--- %s ok! flash_addr_h = 0x%02x, "
DCB "flash_addr_l = 0x%02x",0xA
DCB 0xA,0
ALIGN 4
aSReadBackData0 DCB "--- %s: read_back_data[0] = 0x%x, "
DCB "read_back_data[1] = 0x%x, read_bac"
DCB "k_data[2] = 0x%x, read_back_data[3"
DCB "] = 0x%x,         read_back_data[4"
DCB "] = 0x%x, read_back_data[5] = 0x%x"
DCB ", read_back_data[6] = 0x%x, read_b"
DCB "ack_data[7] = 0x%x,         read_b"
DCB "ack_data[8] = 0x%x, read_back_data"
DCB "[9] = 0x%x, read_back_data[10] = 0"
DCB "x%x, read_back_data[11] = 0x%x,   "
DCB "      read_back_data[12] = 0x%x, r"
DCB "ead_back_data[13] = 0x%x, read_bac"
DCB "k_data[14] = 0x%x, read_back_data["
DCB "15] = 0x%x,         read_back_data"
DCB "[16] = 0x%x, read_back_data[17] = "
DCB "0x%x, read_back_data[18] = 0x%x, r"
DCB "ead_back_data[19] = 0x%x",0xA,0
ALIGN 0x10
aSFailed DCB 0xA
DCB "--- %s failed!",0xA
DCB 0xA,0
ALIGN 4
aSFailedCrc0x04 DCB 0xA
DCB "--- %s failed! crc = 0x%04x",0xA
DCB 0xA,0
ALIGN 4
aSReadBackData0_0 DCB "--- %s: read_back_data[0] = 0x%x, "
DCB "read_back_data[1] = 0x%x, read_bac"
DCB "k_data[2] = 0x%x, read_back_data[3"
DCB "] = 0x%x,        read_back_data[4]"
DCB " = 0x%x, read_back_data[5] = 0x%x,"
DCB " read_back_data[6] = 0x%x, read_ba"
DCB "ck_data[7] = 0x%x,        read_bac"
DCB "k_data[8] = 0x%x, read_back_data[9"
DCB "] = 0x%x, read_back_data[10] = 0x%"
DCB "x, read_back_data[11] = 0x%x,     "
DCB "   read_back_data[12] = 0x%x, read"
DCB "_back_data[13] = 0x%x, read_back_d"
DCB "ata[14] = 0x%x, read_back_data[15]"
DCB " = 0x%x",0xA,0
ALIGN 4
aSReadBackData0_1 DCB "--- %s: read_back_data[0] = 0x%x, "
DCB "read_back_data[1] = 0x%x, read_bac"
DCB "k_data[2] = 0x%x, read_back_data[3"
DCB "] = 0x%x, read_back_data[4] = 0x%x"
DCB 0xA,0
ALIGN 4
aSOkVersion0x02 DCB 0xA
DCB "--- %s ok, version = 0x%02x",0xA
DCB 0xA,0
ALIGN 4
aSOkVoltage0x02 DCB 0xA
DCB "--- %s ok, voltage = 0x%02x",0xA
DCB 0xA,0
ALIGN 4
aSReadBackData0_2 DCB "--- %s: read_back_data[0] = 0x%x, "
DCB "read_back_data[1] = 0x%x, read_bac"
DCB "k_data[2] = 0x%x, read_back_data[3"
DCB "] = 0x%x,         read_back_data[4"
DCB "] = 0x%x, read_back_data[5] = 0x%x"
DCB ", read_back_data[6] = 0x%x, read_b"
DCB "ack_data[7] = 0x%x,         read_b"
DCB "ack_data[8] = 0x%x, read_back_data"
DCB "[9] = 0x%x, read_back_data[10] = 0"
DCB "x%x, read_back_data[11] = 0x%x",0xA
DCB 0
ALIGN 4
aSEraseLoopD DCB "%s: erase_loop = %d",0xA,0
ALIGN 0x10
aUpdatePicProgr DCB 0xA
DCB "--- update pic program",0
aMntCardPic16f1 DCB "/mnt/card/pic16f1704_app.txt",0
ALIGN 4
aSOpenPic16f170 DCB 0xA
DCB "%s: open pic16f1704_app.txt failed"
DCB 0xA,0
ALIGN 0x10
aPicFlashLength DCB "pic_flash_length = %d",0xA,0
ALIGN 4
aSResetPicError DCB "!!! %s: reset pic error!",0xA
DCB 0xA,0
ALIGN 4
aSEraseFlashErr DCB "!!! %s: erase flash error!",0xA
DCB 0xA,0
ALIGN 4
aSSetFlashPoint DCB "!!! %s: set flash pointer error!",0xA
DCB 0xA,0
ALIGN 4
aSendPicProgram DCB "send pic program time: %d",0xA,0
ALIGN 4
aBufD0x02x DCB "buf[%d] = 0x%02x",0xA,0
ALIGN 4
aSReadBackData0_3 DCB "--- %s: read_back_data[0] = 0x%x, "
DCB "read_back_data[1] = 0x%x, read_bac"
DCB "k_data[2] = 0x%x, read_back_data[3"
DCB "] = 0x%x, read_back_data[4] = 0x%x"
DCB ", read_back_data[5] = 0x%x",0xA,0
aSOkFreqD DCB 0xA
DCB "--- %s ok, freq = %d",0xA
DCB 0xA,0
aSCrcData00xXCr DCB "--- %s: crc_data[0] = 0x%x, crc_da"
DCB "ta[1] = 0x%x",0xA,0
aSReadBackData0_4 DCB "--- %s: read_back_data[0] = 0x%x, "
DCB "read_back_data[1] = 0x%x",0xA,0
aSOn DCB 0xA
DCB "--- %s on",0xA,0
aSOff DCB 0xA
DCB "--- %s off",0xA,0
ALIGN 4
aSAdc0DAdc1DAdc DCB 0xA
DCB "--- %s ADC0 = %d, ADC1 = %d, ADC2 "
DCB "= %d, ADC3 = %d",0xA,0
; Function-local static variable
; const char _FUNCTION___7971[36]
__FUNCTION__.7971 DCB "read_temperature_from_fpga_registe"
DCB "r",0
aSWhichChainDBu DCB "%s: which_chain = %d, but it is wr"
DCB "ong! ",0xA,0
ALIGN 0x10
aSChainDTempera DCB 0xA
DCB "%s: Chain%d temperature is %d",0xA
DCB 0xA,0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___7777[20]
__FUNCTION__.7777 DCB "AT24C02_write_bytes",0
; Function-local static variable
; const char _FUNCTION___7789[19]
__FUNCTION__.7789 DCB "AT24C02_read_bytes",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___7835[26]
__FUNCTION__.7835 DCB "AT24C02_save_offset_value",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___7844[21]
__FUNCTION__.7844 DCB "AT24C02_save_voltage",0
ALIGN 0x10
aSAddressLength DCB 0xA
DCB "--- %s: address + length = %d > EE"
DCB "PROM_LENGTH(%d)",0xA,0
aSOffsetValueDD DCB "%s: offset_value[%d] = %d",0xA,0
ALIGN 0x10
aSVoltage0x02x DCB "%s: voltage = 0x%02x",0xA,0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8187[12]
__FUNCTION__.8187 DCB "print_works",0
; Function-local static variable
; const char _FUNCTION___8380[13]
__FUNCTION__.8380 DCB "get_works_v1",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8412[13]
__FUNCTION__.8412 DCB "get_works_v2",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8440[24]
__FUNCTION__.8440 DCB "clear_nonce_return_flag",0
aInputValueErro DCB "input value error: %c",0xA,0
ALIGN 4
aS2hexParaError DCB "s2hex para error dst(%p), src(%p),"
DCB " inlen(%d)",0xA,0
ALIGN 4
aSBegin DCB 0xA
DCB "--- %s begin",0xA
DCB 0xA,0
aCore02d02dMids DCB "core[%02d][%02d].midstate=0x",0
ALIGN 4
aData2 DCB " data2=",0
aNonce0x08x DCB " nonce=0x%08x",0xA,0
ALIGN 4
aSEnd DCB 0xA
DCB "--- %s end",0xA
DCB 0xA,0
ALIGN 4
aAsic02d02d02dM DCB "asic[%02d][%02d][%02d].midstate=0x"
DCB 0
ALIGN 0x10
aMallocStructWo DCB "malloc struct work err",0
ALIGN 4
aNonce DCB "nonce",0
ALIGN 0x10
aMidstate DCB "midstate",0
ALIGN 4
aData DCB "data",0
ALIGN 4
aGetWorkErr DCB "get work err",0
ALIGN 4
aAsictypeError DCB " AsicType Error ",0
ALIGN 4
aSAsictypeError DCB 0xA
DCB "!!!%s: AsicType error",0xA,0
aBoardName DCB "   Board Name   ",0
ALIGN 4
aError DCB "      Error     ",0
ALIGN 4
aSBoardNameIsSE DCB 0xA
DCB "!!!%s: Board Name is: %s, error",0xA
DCB 0
ALIGN 4
aSMallocStructW DCB "%s: malloc struct work err!",0xA,0
ALIGN 4
aS02iS03iTxt DCB "%s%02i%s%03i.txt",0
ALIGN 0x10
aGetPattern DCB "   Get pattern  ",0
ALIGN 4
aSOpenTestFileS DCB "%s: Open test file %s error",0xA,0
ALIGN 4
aGetLessWork DCB "Get Less Work",0
ALIGN 4
aSCgpuSubidDDIs DCB "%s: cgpu.subid[%d] = %d, is the le"
DCB "ast pattern number",0xA,0
ALIGN 4
aSSTxt DCB "%s%s.txt",0
ALIGN 4
aSPatternNumDTo DCB "%s: pattern_num %d too large",0xA,0
ALIGN 4
aSSingleAsicGet DCB "%s: single ASIC get_pattern_loop ="
DCB " %d",0xA,0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___7923[18]
__FUNCTION__.7923 DCB "bitmain_axi_close",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___7936[10]
__FUNCTION__.7936 DCB "init_fpga",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___7954[21]
__FUNCTION__.7954 DCB "set_BC_write_command",0
ALIGN 4
aDevAxiFpgaDev DCB "/dev/axi_fpga_dev",0
ALIGN 4
aDevAxiFpgaDevO DCB "/dev/axi_fpga_dev open failed. fd "
DCB "= %d",0xA,0
aMmapAxiFpgaAdd_0 DCB "mmap axi_fpga_addr failed. axi_fpg"
DCB "a_addr = %p",0xA,0
ALIGN 4
aMmapAxiFpgaAdd DCB "mmap axi_fpga_addr = %p",0xA,0
ALIGN 0x10
aAxiFpgaAddrDat DCB "axi_fpga_addr data = 0x%x",0xA,0
ALIGN 4
aDevFpgaMem DCB "/dev/fpga_mem",0
ALIGN 4
aDevFpgaMemOpen DCB "/dev/fpga_mem open failed. fd_fpga"
DCB "_mem = %d",0xA,0
ALIGN 4
aMmapFpgaMemAdd_0 DCB "mmap fpga_mem_addr failed. fpga_me"
DCB "m_addr = %p",0xA,0
ALIGN 4
aMmapFpgaMemAdd DCB "mmap fpga_mem_addr = %p",0xA,0
ALIGN 4
aS_1 DCB 0xA
DCB 0xA
DCB "--- %s",0xA,0
ALIGN 4
aMunmapFailed DCB "munmap failed!",0
ALIGN 4
aSTimeout DCB 0xA
DCB "%s: timeout",0xA
DCB 0xA,0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8795[24]
__FUNCTION__.8795 DCB "single_BM1397_send_func",0
__FUNCTION__.8248 DCB "BM1397_get_pllparam_divider",0
; Function-local static variable
; const char _FUNCTION___8312_0[22]
__FUNCTION__.8312_0 DCB "check_BM1397_asic_reg",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8327[22]
__FUNCTION__.8327 DCB "BM1397_chain_inactive",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8355[13]
__FUNCTION__.8355 DCB "set_baud_ext",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8370[30]
__FUNCTION__.8370 DCB "single_BM1397_set_IO_strength",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8390[31]
__FUNCTION__.8390 DCB "reset_single_BM1397_global_arg",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8408[41]
__FUNCTION__.8408 DCB "single_BM1397_calculate_timeout_an"
DCB "d_baud",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8425[28]
__FUNCTION__.8425 DCB "BM1397_software_set_address",0
; Function-local static variable
; const char _FUNCTION___8433[16]
__FUNCTION__.8433 DCB "BM1397_set_baud",0
; Function-local static variable
; const char _FUNCTION___8472[24]
__FUNCTION__.8472 DCB "single_BM1397_open_core",0
; Function-local static variable
; const char _FUNCTION___8526[25]
__FUNCTION__.8526 DCB "single_BM1397_get_result",0
ALIGN 4
dword_2F0E4 DCD 0x20202020
dword_2F0E8 DCD 0x57482020
dword_2F0EC DCD 0x20202020
dword_2F0F0 DCD 0x20202020
; Function-local static variable
; const char _FUNCTION___8544[25]
__FUNCTION__.8544 DCB "BM1397_soft_reset_sensor",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8560[50]
__FUNCTION__.8560 DCB "BM1397_enable_extended_mode_of_tem"
DCB "perature_sensor",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8582[46]
__FUNCTION__.8582 DCB "BM1397_get_temperature_offset_valu"
DCB "e_from_asic",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8606[44]
__FUNCTION__.8606 DCB "BM1397_set_default_temperature_off"
DCB "set_value",0
; Function-local static variable
; const char _FUNCTION___8637[42]
__FUNCTION__.8637 DCB "BM1397_read_asic_temperature_local"
DCB "_remote",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8656[35]
__FUNCTION__.8656 DCB "BM1397_read_asic_temperature_local"
DCB 0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8665[31]
__FUNCTION__.8665 DCB "single_BM1397_show_status_func",0
ALIGN 0x10
; Function-local static variable
; const char _FUNCTION___8673[24]
__FUNCTION__.8673 DCB "BM1397_check_nonce_flag",0
; Function-local static variable
; const char _FUNCTION___8698[26]
__FUNCTION__.8698 DCB "single_BM1397_check_nonce",0
ALIGN 4
; Function-local static variable
; const char _FUNCTION___8752[35]
__FUNCTION__.8752 DCB "single_BM1397_check_register_value"
DCB 0
ALIGN 4
dword_2F268 DCD 0x20202020
dword_2F26C DCD 0x20202020
dword_2F270 DCD 0x20202020
dword_2F274 DCD 0x20202020
; Function-local static variable
; const char _FUNCTION___8830[22]
__FUNCTION__.8830 DCB "singleAsicTest_BM1397",0
ALIGN 0x10
aChainDSetOrder DCB "chain[%d]: set order clock, strage"
DCB "gy 3",0xA,0
aSSetBaudExt DCB 0xA
DCB "--- %s: set baud ext",0xA,0
ALIGN 0x10
aSWhichCoreDErr DCB "%s: which_core = %d, error!!!",0xA
DCB 0
ALIGN 0x10
aS1StartReceive DCB "%s 1: start_receive = %d",0xA,0
ALIGN 4
aS1GisreadtempD DCB "%s 1: gIsReadTemp = %d",0xA,0
aS1ConfSensorMo DCB "%s 1: Conf.sensor_model = %d",0xA,0
ALIGN 4
aSD DCB "%s %d",0xA,0
ALIGN 4
aSReceivedCore0_0 DCB "%s: received core%02d nonce. error"
DCB "!!! data[0] = 0x%08x, received non"
DCB "ce = 0x%08x",0xA,0
ALIGN 0x10
aSCreateSingleB_3 DCB 0xA
DCB "!!!%s: create single_BM1397_receiv"
DCB "e_func fail",0xA
DCB 0xA
DCB 0xA,0
ALIGN 4
aSCreateSingleB_4 DCB 0xA
DCB "!!!%s: create single_BM1397_send_f"
DCB "unc fail",0xA
DCB 0xA
DCB 0xA,0
ALIGN 4
; .rodata ends


; Segment type: Pure data
AREA .ARM.exidx, DATA, READONLY
; ORG 0x2F404
unk_2F404 DCB 0x94
DCB 0x18
DCB 0xFE
DCB 0x7F ; 
DCB    1
DCB    0
DCB    0
DCB    0
; .ARM.exidx ends


; Segment type: Pure data
AREA .eh_frame, DATA, READONLY
; ORG 0x2F40C
__FRAME_END__ ALIGN 0x10
; .eh_frame ends

; ELF Initialization Function Table

; Segment type: Pure data
AREA .init_array, DATA
; ORG 0x30000
__frame_dummy_init_array_entry DCD frame_dummy+1 ; Alternative name is '__init_array_start'
; .init_array ends

; ELF Termination Function Table

; Segment type: Pure data
AREA .fini_array, DATA
; ORG 0x30004
__do_global_dtors_aux_fini_array_entry DCD __do_global_dtors_aux+1 ; Alternative name is '__init_array_end'
; .fini_array ends


; Segment type: Pure data
AREA .jcr, DATA
; ORG 0x30008
__JCR_LIST__ DCD 0      ; Alternative name is '__JCR_END__'
; .jcr ends

; ELF Dynamic Information

; Segment type: Pure data
AREA LOAD, DATA, ALIGN=0
; ORG 0x3000C
_DYNAMIC Elf32_Dyn <1, <1>> ; DT_NEEDED libpthread.so.0
Elf32_Dyn <1, <0x102>>  ; DT_NEEDED libc.so.6
Elf32_Dyn <0xC, <0x109EC>> ; DT_INIT
Elf32_Dyn <0xD, <0x29618>> ; DT_FINI
Elf32_Dyn <0x19, <0x30000>> ; DT_INIT_ARRAY
Elf32_Dyn <0x1B, <4>>   ; DT_INIT_ARRAYSZ
Elf32_Dyn <0x1A, <0x30004>> ; DT_FINI_ARRAY
Elf32_Dyn <0x1C, <4>>   ; DT_FINI_ARRAYSZ
Elf32_Dyn <4, <0x10194>> ; DT_HASH
Elf32_Dyn <5, <0x105DC>> ; DT_STRTAB
Elf32_Dyn <6, <0x102EC>> ; DT_SYMTAB
Elf32_Dyn <0xA, <0x201>> ; DT_STRSZ
Elf32_Dyn <0xB, <0x10>> ; DT_SYMENT
Elf32_Dyn <0x15, <0>>   ; DT_DEBUG
Elf32_Dyn <3, <0x300FC>> ; DT_PLTGOT
Elf32_Dyn <2, <0x158>>  ; DT_PLTRELSZ
Elf32_Dyn <0x14, <0x11>> ; DT_PLTREL
Elf32_Dyn <0x17, <0x10894>> ; DT_JMPREL
Elf32_Dyn <0x11, <0x1088C>> ; DT_REL
Elf32_Dyn <0x12, <8>>   ; DT_RELSZ
Elf32_Dyn <0x13, <8>>   ; DT_RELENT
Elf32_Dyn <0x6FFFFFFE, <0x1083C>> ; DT_VERNEED
Elf32_Dyn <0x6FFFFFFF, <2>> ; DT_VERNEEDNUM
Elf32_Dyn <0x6FFFFFF0, <0x107DE>> ; DT_VERSYM
Elf32_Dyn <0>           ; DT_NULL
ALIGN 8
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
; LOAD ends


; Segment type: Pure data
AREA .got, DATA
; ORG 0x300FC
_GLOBAL_OFFSET_TABLE_ DCD _DYNAMIC
DCD 0
off_30104 DCD 0
pthread_mutex_unlock_ptr DCD __imp_pthread_mutex_unlock
calloc_ptr DCD __imp_calloc
strstr_ptr DCD __imp_strstr
raise_ptr DCD __imp_raise
printf_ptr DCD __imp_printf
fopen_ptr DCD __imp_fopen
read_ptr DCD __imp_read
free_ptr DCD __imp_free
fgets_ptr DCD __imp_fgets
pthread_mutex_lock_ptr DCD __imp_pthread_mutex_lock
pthread_self_ptr DCD __imp_pthread_self
memcpy_ptr DCD __imp_memcpy
pthread_mutex_init_ptr DCD __imp_pthread_mutex_init
lseek_ptr DCD __imp_lseek
memcmp_ptr DCD __imp_memcmp
sleep_ptr DCD __imp_sleep
usleep_ptr DCD __imp_usleep
strcpy_ptr DCD __imp_strcpy
gettimeofday_ptr DCD __imp_gettimeofday
pthread_create_ptr DCD __imp_pthread_create
sched_get_priority_max_ptr DCD __imp_sched_get_priority_max
puts_ptr DCD __imp_puts
malloc_ptr DCD __imp_malloc
__libc_start_main_ptr DCD __imp___libc_start_main
system_ptr DCD __imp_system
__gmon_start___ptr DCD __imp___gmon_start__
open_ptr DCD __imp_open
strtoul_ptr DCD __imp_strtoul
strlen_ptr DCD __imp_strlen
mmap_ptr DCD __imp_mmap
__isoc99_sscanf_ptr DCD __imp___isoc99_sscanf
memset_ptr DCD __imp_memset
putchar_ptr DCD __imp_putchar
pthread_cancel_ptr DCD __imp_pthread_cancel
write_ptr DCD __imp_write
fclose_ptr DCD __imp_fclose
munmap_ptr DCD __imp_munmap
pthread_join_ptr DCD __imp_pthread_join
sprintf_ptr DCD __imp_sprintf
pthread_setschedparam_ptr DCD __imp_pthread_setschedparam
fseek_ptr DCD __imp_fseek
abort_ptr DCD __imp_abort
close_ptr DCD __imp_close
__gmon_start___ptr_0 DCD __imp___gmon_start__
; .got ends


; Segment type: Pure data
AREA .data, DATA
; ORG 0x301B8
EXPORT __data_start
__data_start DCB    0
DCB    0
DCB    0
DCB    0
EXPORT __dso_handle
__dso_handle ALIGN 0x10
EXPORT freq_pll_1385
; freq_pll freq_pll_1385[124]
freq_pll_1385 freq_pll <a19, 0x20040, 0x420, 0x200273> ; "19"
freq_pll <a22, 0x20040, 0x420, 0x200263> ; "22"
freq_pll <a26, 0x20040, 0x420, 0x200253> ; "26"
freq_pll <a28, 0x20040, 0x420, 0x200272> ; "28"
freq_pll <a33, 0x20040, 0x420, 0x200243> ; "33"
freq_pll <a40, 0x20040, 0x420, 0x200252> ; "40"
freq_pll <a50, 0x20040, 0x420, 0x200242> ; "50"
freq_pll <a57, 0x20040, 0x420, 0x200271> ; "57"
freq_pll <a66, 0x20040, 0x420, 0x200261> ; "66"
freq_pll <a80, 0x20040, 0x420, 0x200251> ; "80"
freq_pll <a100, 0x20040, 0x420, \ ; "100"
          0x200241>
freq_pll <a125, 0x28040, 0x420, \ ; "125"
          0x280241>
freq_pll <a150, 0x30040, 0x420, \ ; "150"
          0x300241>
freq_pll <a175, 0x38040, 0x420, \ ; "175"
          0x380241>
freq_pll <a200, 0x40040, 0x420, \ ; "200"
          0x400241>
freq_pll <a225, 0x48040, 0x420, \ ; "225"
          0x480241>
freq_pll <a250, 0x50040, 0x420, \ ; "250"
          0x500241>
freq_pll <a275, 0x58040, 0x420, \ ; "275"
          0x580241>
freq_pll <a300, 0x60040, 0x420, \ ; "300"
          0x600241>
freq_pll <a325, 0x68040, 0x420, \ ; "325"
          0x680241>
freq_pll <a350, 0x70040, 0x420, \ ; "350"
          0x700241>
freq_pll <a375, 0x78040, 0x420, \ ; "375"
          0x780241>
freq_pll <off_2A014, 0x80040, 0x420, \
          0x800241>
freq_pll <unk_2A018, 0x61040, 0x320, \
          0x610231>
freq_pll <unk_2A01C, 0x41040, 0x220, \
          0x410221>
freq_pll <unk_2A020, 0x62040, 0x320, \
          0x620231>
freq_pll <off_2A024, 0x42040, 0x220, \
          0x420221>
freq_pll <unk_2A028, 0x64040, 0x320, \
          0x640231>
freq_pll <unk_2A02C, 0x43040, 0x220, \
          0x430221>
freq_pll <off_2A030, 0x65040, 0x320, \
          0x650231>
freq_pll <unk_2A034, 0x44040, 0x220, \
          0x440221>
freq_pll <unk_2A038, 0x67040, 0x320, \
          0x670231>
freq_pll <off_2A03C, 0x45040, 0x220, \
          0x450221>
freq_pll <off_2A040, 0x68040, 0x320, \
          0x680231>
freq_pll <unk_2A044, 0x46040, 0x220, \
          0x460221>
freq_pll <off_2A048, 0x6A040, 0x320, \
          0x6A0231>
freq_pll <off_2A04C, 0x47040, 0x220, \
          0x470221>
freq_pll <unk_2A050, 0x6B040, 0x320, \
          0x6B0231>
freq_pll <off_2A054, 0x48040, 0x220, \
          0x480221>
freq_pll <unk_2A058, 0x6D040, 0x320, \
          0x6D0231>
freq_pll <unk_2A05C, 0x49040, 0x220, \
          0x490221>
freq_pll <unk_2A060, 0x6E040, 0x320, \
          0x6E0231>
freq_pll <off_2A064, 0x4A040, 0x220, \
          0x4A0221>
freq_pll <unk_2A068, 0x70040, 0x320, \
          0x700231>
freq_pll <unk_2A06C, 0x4B040, 0x220, \
          0x4B0221>
freq_pll <off_2A070, 0x71040, 0x320, \
          0x710231>
freq_pll <unk_2A074, 0x4C040, 0x220, \
          0x4C0221>
freq_pll <unk_2A078, 0x73040, 0x320, \
          0x730231>
freq_pll <off_2A07C, 0x4D040, 0x220, \
          0x4D0221>
freq_pll <off_2A080, 0x74040, 0x320, \
          0x740231>
freq_pll <unk_2A084, 0x4E040, 0x220, \
          0x4E0221>
freq_pll <off_2A088, 0x76040, 0x320, \
          0x760231>
freq_pll <off_2A08C, 0x4F040, 0x220, \
          0x4F0221>
freq_pll <unk_2A090, 0x77040, 0x320, \
          0x770231>
freq_pll <unk_2A094, 0x50040, 0x220, \
          0x500221>
freq_pll <unk_2A098, 0x79040, 0x320, \
          0x790231>
freq_pll <unk_2A09C, 0x51040, 0x220, \
          0x510221>
freq_pll <unk_2A0A0, 0x7A040, 0x320, \
          0x7A0231>
freq_pll <unk_2A0A4, 0x52040, 0x220, \
          0x520221>
freq_pll <unk_2A0A8, 0x7C040, 0x320, \
          0x7C0231>
freq_pll <unk_2A0AC, 0x53040, 0x220, \
          0x530221>
freq_pll <unk_2A0B0, 0x7D040, 0x320, \
          0x7D0231>
freq_pll <unk_2A0B4, 0x54040, 0x220, \
          0x540221>
freq_pll <unk_2A0B8, 0x7F040, 0x320, \
          0x7F0231>
freq_pll <unk_2A0BC, 0x55040, 0x220, \
          0x550221>
freq_pll <unk_2A0C0, 0x80040, 0x320, \
          0x800231>
freq_pll <unk_2A0C4, 0x56040, 0x220, \
          0x560221>
freq_pll <unk_2A0C8, 0x57040, 0x220, \
          0x570221>
freq_pll <unk_2A0CC, 0x58040, 0x220, \
          0x580221>
freq_pll <unk_2A0D0, 0x59040, 0x220, \
          0x590221>
freq_pll <unk_2A0D4, 0x5A040, 0x220, \
          0x5A0221>
freq_pll <unk_2A0D8, 0x5B040, 0x220, \
          0x5B0221>
freq_pll <unk_2A0DC, 0x5C040, 0x220, \
          0x5C0221>
freq_pll <unk_2A0E0, 0x5D040, 0x220, \
          0x5D0221>
freq_pll <unk_2A0E4, 0x5E040, 0x220, \
          0x5E0221>
freq_pll <unk_2A0E8, 0x5F040, 0x220, \
          0x5F0221>
freq_pll <unk_2A0EC, 0x60040, 0x220, \
          0x600221>
freq_pll <unk_2A0F0, 0x61040, 0x220, \
          0x610221>
freq_pll <unk_2A0F4, 0x62040, 0x220, \
          0x620221>
freq_pll <unk_2A0F8, 0x63040, 0x220, \
          0x630221>
freq_pll <unk_2A0FC, 0x64040, 0x220, \
          0x640221>
freq_pll <unk_2A100, 0x65040, 0x220, \
          0x650221>
freq_pll <unk_2A104, 0x66040, 0x220, \
          0x660221>
freq_pll <unk_2A108, 0x67040, 0x220, \
          0x670221>
freq_pll <unk_2A10C, 0x68040, 0x220, \
          0x680221>
freq_pll <unk_2A110, 0x69040, 0x220, \
          0x690221>
freq_pll <unk_2A114, 0x6A040, 0x220, \
          0x6A0221>
freq_pll <unk_2A118, 0x6B040, 0x220, \
          0x6B0221>
freq_pll <unk_2A11C, 0x6C040, 0x220, \
          0x6C0221>
freq_pll <unk_2A120, 0x6D040, 0x220, \
          0x6D0221>
freq_pll <unk_2A124, 0x6E040, 0x220, \
          0x6E0221>
freq_pll <unk_2A128, 0x6F040, 0x220, \
          0x6F0221>
freq_pll <unk_2A12C, 0x70040, 0x220, \
          0x700221>
freq_pll <unk_2A130, 0x71040, 0x220, \
          0x710221>
freq_pll <unk_2A134, 0x72040, 0x220, \
          0x720221>
freq_pll <unk_2A138, 0x73040, 0x220, \
          0x730221>
freq_pll <unk_2A13C, 0x74040, 0x220, \
          0x740221>
freq_pll <unk_2A140, 0x75040, 0x220, \
          0x750221>
freq_pll <unk_2A144, 0x76040, 0x220, \
          0x760221>
freq_pll <unk_2A148, 0x77040, 0x220, \
          0x770221>
freq_pll <unk_2A14C, 0x78040, 0x220, \
          0x780221>
freq_pll <unk_2A150, 0x79040, 0x220, \
          0x790221>
freq_pll <unk_2A154, 0x7A040, 0x220, \
          0x7A0221>
freq_pll <unk_2A158, 0x7B040, 0x220, \
          0x7B0221>
freq_pll <unk_2A15C, 0x7C040, 0x220, \
          0x7C0221>
freq_pll <unk_2A160, 0x7D040, 0x220, \
          0x7D0221>
freq_pll <unk_2A164, 0x7E040, 0x220, \
          0x7E0221>
freq_pll <unk_2A168, 0x7F040, 0x220, \
          0x7F0221>
freq_pll <off_2A16C, 0x80040, 0x220, \
          0x800221>
freq_pll <unk_2A170, 0x42040, 0x120, \
          0x420211>
freq_pll <off_2A174, 0x44040, 0x120, \
          0x440211>
freq_pll <unk_2A178, 0x46040, 0x120, \
          0x460221>
freq_pll <unk_2A17C, 0x48040, 0x120, \
          0x480221>
freq_pll <unk_2A180, 0x4A040, 0x120, \
          0x4A0221>
freq_pll <unk_2A184, 0x4C040, 0x120, \
          0x4C0221>
freq_pll <unk_2A188, 0x4E040, 0x120, \
          0x4E0221>
freq_pll <a1000, 0x50040, 0x120, \ ; "1000"
          0x500221>
freq_pll <a1025, 0x52040, 0x120, \ ; "1025"
          0x520221>
freq_pll <a1050, 0x54040, 0x120, \ ; "1050"
          0x540221>
freq_pll <a1075, 0x56040, 0x120, \ ; "1075"
          0x560221>
freq_pll <a1100, 0x58040, 0x120, \ ; "1100"
          0x580221>
freq_pll <a1125, 0x5A040, 0x120, \ ; "1125"
          0x5A0221>
freq_pll <a1150, 0x5C040, 0x120, \ ; "1150"
          0x5C0221>
freq_pll <a1175, 0x5E040, 0x120, \ ; "1175"
          0x5E0221>
EXPORT Single_BM1385_WorkDataPathPrefix
; char *Single_BM1385_WorkDataPathPrefix
Single_BM1385_WorkDataPathPrefix DCD aMntCardSingleB ; "/mnt/card/single-BM1385-ASIC-test"
EXPORT gBM1391_MISC_CONTROL_reg
; unsigned int gBM1391_MISC_CONTROL_reg
gBM1391_MISC_CONTROL_reg DCD 0x3A01
EXPORT Single_BM1391_WorkDataPathPrefix
; char *Single_BM1391_WorkDataPathPrefix
Single_BM1391_WorkDataPathPrefix DCD aMntCardSingleB_0 ; "/mnt/card/single-BM1391-ASIC-test"
EXPORT lcd_output
; char lcd_output[64]
lcd_output DCB 0x20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
EXPORT lcd_buf
; char lcd_buf[16]
lcd_buf DCB "                "
EXPORT lcd_buffer
; char lcd_buffer[16]
lcd_buffer DCB ' ', ' ', ' ', 'L', 'e', 'v', 'e', 'l'
DCB ':', ' ', ' ', ' ', ' ', ' ', ' ', ' '
EXPORT BHB91603_WorkDataPathPrefix
; char *BHB91603_WorkDataPathPrefix
BHB91603_WorkDataPathPrefix DCD aMntCardMinerte_0 ; "/mnt/card/minertest-BHB91603-BM1391/btc"...
EXPORT V9_WorkDataPathPrefix
; char *V9_WorkDataPathPrefix
V9_WorkDataPathPrefix DCD aMntCardMinerte_1 ; "/mnt/card/minertest64-BM1385/btc-asic-"
EXPORT g_power_type
; uint16_t g_power_type
g_power_type DCW 1
ALIGN 4
EXPORT sha256_k
; uint32_t sha256_k[64]
sha256_k DCD 0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5
DCD 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5
DCD 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3
DCD 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174
DCD 0xE49B69C1, 0xEFBE4786, 0xFC19DC6, 0x240CA1CC
DCD 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA
DCD 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7
DCD 0xC6E00BF3, 0xD5A79147, 0x6CA6351, 0x14292967
DCD 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13
DCD 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85
DCD 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3
DCD 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070
DCD 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5
DCD 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3
DCD 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208
DCD 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
EXPORT sha256_h0
; uint32_t sha256_h0[8]
sha256_h0 DCD 0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A
DCD 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19
EXPORT BHB91601_WorkDataPathPrefix
; char *BHB91601_WorkDataPathPrefix
BHB91601_WorkDataPathPrefix DCD aMntCardMinerte ; "/mnt/card/minertest-BM1391/btc-asic-"
EXPORT BHB07601_WorkDataFilePrefix
; char *BHB07601_WorkDataFilePrefix
BHB07601_WorkDataFilePrefix DCD a07601Pattern48 ; "07601_pattern_48"
EXPORT BHB07601_WorkDataPathPrefix
; char *BHB07601_WorkDataPathPrefix
BHB07601_WorkDataPathPrefix DCD aMntCard ; "/mnt/card/"
EXPORT gChain
; unsigned __int8 gChain
gChain DCB 0xFF
EXPORT Sensor1_OK
; unsigned __int8 Sensor1_OK
Sensor1_OK DCB 1
EXPORT Sensor2_OK
; unsigned __int8 Sensor2_OK
Sensor2_OK DCB 1
EXPORT Sensor3_OK
; unsigned __int8 Sensor3_OK
Sensor3_OK DCB 1
EXPORT Sensor4_OK
; unsigned __int8 Sensor4_OK
Sensor4_OK DCB 1
ALIGN 4
EXPORT gSensor_OK
; bool gSensor_OK[4][4]
gSensor_OK DCB 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0
EXPORT bit_swap_table
; unsigned __int8 bit_swap_table[256]
bit_swap_table DCB 0, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60
DCB 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0
DCB 0x70, 0xF0, 8, 0x88, 0x48, 0xC8, 0x28
DCB 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8
DCB 0x38, 0xB8, 0x78, 0xF8, 4, 0x84, 0x44
DCB 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94
DCB 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4, 0xC
DCB 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC
DCB 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C
DCB 0xFC, 2, 0x82, 0x42, 0xC2, 0x22, 0xA2
DCB 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32
DCB 0xB2, 0x72, 0xF2, 0xA, 0x8A, 0x4A, 0xCA
DCB 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A
DCB 0xDA, 0x3A, 0xBA, 0x7A, 0xFA, 6, 0x86
DCB 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16
DCB 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6
DCB 0xE, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E
DCB 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE
DCB 0x7E, 0xFE, 1, 0x81, 0x41, 0xC1, 0x21
DCB 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1
DCB 0x31, 0xB1, 0x71, 0xF1, 9, 0x89, 0x49
DCB 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99
DCB 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9, 5
DCB 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5
DCB 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75
DCB 0xF5, 0xD, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD
DCB 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D
DCB 0xBD, 0x7D, 0xFD, 3, 0x83, 0x43, 0xC3
DCB 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53
DCB 0xD3, 0x33, 0xB3, 0x73, 0xF3, 0xB, 0x8B
DCB 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B
DCB 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB
DCB 7, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67
DCB 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7
DCB 0x77, 0xF7, 0xF, 0x8F, 0x4F, 0xCF, 0x2F
DCB 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF
DCB 0x3F, 0xBF, 0x7F, 0xFF
EXPORT BTC_WorkDataFilePrefix
; char *BTC_WorkDataFilePrefix
BTC_WorkDataFilePrefix DCD aBtcCore ; "/btc-core-"
EXPORT gAT24C02_data_map
; unsigned __int8 gAT24C02_data_map[256]
gAT24C02_data_map DCB 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
DCB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
EXPORT gBM1397_MISC_CONTROL_reg
; unsigned int gBM1397_MISC_CONTROL_reg
gBM1397_MISC_CONTROL_reg DCD 0x3A01
EXPORT Single_BM1397_WorkDataFilePrefix
; char *Single_BM1397_WorkDataFilePrefix
Single_BM1397_WorkDataFilePrefix DCD a07601Pattern48 ; "07601_pattern_48"
EXPORT Single_BM1397_WorkDataPathPrefix
; char *Single_BM1397_WorkDataPathPrefix
Single_BM1397_WorkDataPathPrefix DCD aMntCard ; "/mnt/card/"
; .data ends


; Segment type: Uninitialized
AREA .bss, DATA
; ORG 0x30D4C
EXPORT __TMC_END__
__TMC_END__ % 1         ; Alternative name is 'completed.9251'
                        ; Alternative name is '__bss_start__'
                        ; Alternative name is '_edata'
                        ; Alternative name is '__bss_start'
ALIGN 0x10
EXPORT lcd_fd
; int lcd_fd
lcd_fd % 4
EXPORT uart_send_mutex
; pthread_mutex_t uart_send_mutex[4]
uart_send_mutex pthread_mutex_t <?>
pthread_mutex_t <?>
pthread_mutex_t <?>
pthread_mutex_t <?>
EXPORT uart_receive_mutex
; pthread_mutex_t uart_receive_mutex[4]
uart_receive_mutex pthread_mutex_t <?>
pthread_mutex_t <?>
pthread_mutex_t <?>
pthread_mutex_t <?>
EXPORT BHB91603_ASIC_NUMBER
; unsigned int BHB91603_ASIC_NUMBER
BHB91603_ASIC_NUMBER % 4
EXPORT power_control_fd
; int power_control_fd
power_control_fd % 4
EXPORT BHB91601_ASIC_NUMBER
; unsigned int BHB91601_ASIC_NUMBER
BHB91601_ASIC_NUMBER % 4
EXPORT key_fd
; int key_fd
key_fd % 4
EXPORT BHB07601_ASIC_NUMBER
; unsigned int BHB07601_ASIC_NUMBER
BHB07601_ASIC_NUMBER % 4
EXPORT gName_len
; unsigned int gName_len
gName_len % 4
EXPORT reg_mutex
; pthread_mutex_t reg_mutex
reg_mutex pthread_mutex_t <?>
EXPORT gAsic_Core_Nonce_Num
; unsigned int gAsic_Core_Nonce_Num[4][128][1024]
gAsic_Core_Nonce_Num % 0x200000
EXPORT pattern_test_time
; unsigned __int8 pattern_test_time
pattern_test_time % 1
ALIGN 4
EXPORT time_counter
; unsigned int time_counter
time_counter % 4
EXPORT gHighest_Temp
; unsigned int gHighest_Temp
gHighest_Temp % 4
EXPORT gWork_Num_For_Hw_Check
; unsigned __int8 gWork_Num_For_Hw_Check
gWork_Num_For_Hw_Check % 1
ALIGN 4
EXPORT Sensor1_temp
; int Sensor1_temp
Sensor1_temp % 4
EXPORT Sensor2_temp
; int Sensor2_temp
Sensor2_temp % 4
EXPORT Sensor3_temp
; int Sensor3_temp
Sensor3_temp % 4
EXPORT Sensor4_temp
; int Sensor4_temp
Sensor4_temp % 4
EXPORT last_Sensor1_temp
; int last_Sensor1_temp
last_Sensor1_temp % 4
EXPORT last_Sensor2_temp
; int last_Sensor2_temp
last_Sensor2_temp % 4
EXPORT last_Sensor3_temp
; int last_Sensor3_temp
last_Sensor3_temp % 4
EXPORT last_Sensor4_temp
; int last_Sensor4_temp
last_Sensor4_temp % 4
EXPORT highest_temp
; int highest_temp
highest_temp % 4
EXPORT lowest_temp
; int lowest_temp
lowest_temp % 4
EXPORT gGlobalHighestTemp
; int gGlobalHighestTemp
gGlobalHighestTemp % 4
EXPORT temp_change
; int temp_change
temp_change % 4
EXPORT gNotReadOutTemp
; bool gNotReadOutTemp
gNotReadOutTemp % 1
EXPORT gIsOpenCoreEnd
; bool gIsOpenCoreEnd
gIsOpenCoreEnd % 1
EXPORT gT1_offset_value
; char gT1_offset_value
gT1_offset_value % 1
EXPORT gT2_offset_value
; char gT2_offset_value
gT2_offset_value % 1
EXPORT gT3_offset_value
; char gT3_offset_value
gT3_offset_value % 1
EXPORT gT4_offset_value
; char gT4_offset_value
gT4_offset_value % 1
EXPORT gHigherThanMaxTempGap
; bool gHigherThanMaxTempGap
gHigherThanMaxTempGap % 1
ALIGN 4
EXPORT gMaxTempGap_value
; int gMaxTempGap_value
gMaxTempGap_value % 4
EXPORT gIsReadTemp
; bool gIsReadTemp
gIsReadTemp % 1
EXPORT gReadingTemp
; bool gReadingTemp
gReadingTemp % 1
EXPORT gEEPROM_error
; bool gEEPROM_error
gEEPROM_error % 1
EXPORT gStartTest
; bool gStartTest
gStartTest % 1
EXPORT gBegin_Get_Nonce
; bool gBegin_Get_Nonce
gBegin_Get_Nonce % 1
EXPORT start_receive
; bool start_receive
start_receive % 1
ALIGN 4
EXPORT gValid_Nonce_Num
; unsigned int gValid_Nonce_Num[4]
gValid_Nonce_Num % 0x10
EXPORT gHw_Nonce_Num
; unsigned int gHw_Nonce_Num[4]
gHw_Nonce_Num % 0x10
EXPORT gRepeated_Nonce_Id
; unsigned int gRepeated_Nonce_Id[4]
gRepeated_Nonce_Id % 0x10
EXPORT gSensor_read_ok_counter
; unsigned int gSensor_read_ok_counter[4][4]
gSensor_read_ok_counter % 0x40
EXPORT HW_check_mutex
; pthread_mutex_t HW_check_mutex[4]
HW_check_mutex pthread_mutex_t <?>
pthread_mutex_t <?>
pthread_mutex_t <?>
pthread_mutex_t <?>
EXPORT gSensor_number
; unsigned int gSensor_number
gSensor_number % 4
EXPORT gSend_Work_Num
; unsigned int gSend_Work_Num[4]
gSend_Work_Num % 0x10
EXPORT gHigherThanAlarmTemp
; bool gHigherThanAlarmTemp
gHigherThanAlarmTemp % 1
EXPORT gIsOpeningCore
; bool gIsOpeningCore
gIsOpeningCore % 1
ALIGN 0x10
EXPORT gPattern_number
; unsigned int gPattern_number
gPattern_number % 4
EXPORT gChain_Asic_Interval
; unsigned int gChain_Asic_Interval
gChain_Asic_Interval % 4
EXPORT gHowManyVoltageLevel
; unsigned __int8 gHowManyVoltageLevel
gHowManyVoltageLevel % 1
ALIGN 4
EXPORT gSensor_i2c_addr_high_4_bit
; unsigned int gSensor_i2c_addr_high_4_bit
gSensor_i2c_addr_high_4_bit % 4
EXPORT gPic_addr_high_4_bit
; unsigned int gPic_addr_high_4_bit
gPic_addr_high_4_bit % 4
EXPORT gI2c
; unsigned __int8 gI2c
gI2c % 1
EXPORT gHashBoard_BHB07601
; bool gHashBoard_BHB07601
gHashBoard_BHB07601 % 1
EXPORT gHashBoard_BHB91603P
; bool gHashBoard_BHB91603P
gHashBoard_BHB91603P % 1
EXPORT gHashBoard_BHB91603S
; bool gHashBoard_BHB91603S
gHashBoard_BHB91603S % 1
EXPORT gHashBoard_BHB91601S
; bool gHashBoard_BHB91601S
gHashBoard_BHB91601S % 1
EXPORT gHashBoard_BHB91601P
; bool gHashBoard_BHB91601P
gHashBoard_BHB91601P % 1
EXPORT gHashBoard_V9
; bool gHashBoard_V9
gHashBoard_V9 % 1
ALIGN 4
EXPORT red_led_fd
; int red_led_fd
red_led_fd % 4
EXPORT green_led_fd
; int green_led_fd
green_led_fd % 4
EXPORT i2c_mutex
; pthread_mutex_t i2c_mutex
i2c_mutex pthread_mutex_t <?>
EXPORT axi_fpga_addr
; unsigned int *axi_fpga_addr
axi_fpga_addr % 4
EXPORT fpga_mem_addr
; unsigned int *fpga_mem_addr
fpga_mem_addr % 4
EXPORT cgpu
; cgpu_info cgpu
cgpu cgpu_info <?>
EXPORT chain_info_0
; chain_info chain_info_0[4]
chain_info_0 chain_info <?>
chain_info <?>
chain_info <?>
chain_info <?>
EXPORT reg_value_buf
; reg_buf *reg_value_buf
reg_value_buf % 4
EXPORT Conf
; configuration Conf
Conf configuration <?>
EXPORT gWorks_For_Hw_Check
; work gWorks_For_Hw_Check[4][128]
gWorks_For_Hw_Check work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
work <?>
EXPORT gBad_Chip
; bad_chip gBad_Chip
gBad_Chip bad_chip <?>
EXPORT fd_fpga_mem
; int fd_fpga_mem
fd_fpga_mem % 4
; .bss ends


; Segment type: Zero-length
AREA .prgend, DATA, ALIGN=0
; ORG 0x339CA4
_end
; .prgend ends


; Segment type: Externs
; int pthread_mutex_unlock(pthread_mutex_t *mutex)
IMPORT __imp_pthread_mutex_unlock
; void *calloc(size_t nmemb, size_t size)
IMPORT __imp_calloc
; char *strstr(const char *haystack, const char *needle)
IMPORT __imp_strstr
; int raise(int sig)
IMPORT __imp_raise
; int printf(const char *format, ...)
IMPORT __imp_printf
; FILE *fopen(const char *filename, const char *modes)
IMPORT __imp_fopen
; ssize_t read(int fd, void *buf, size_t nbytes)
IMPORT __imp_read
; void free(void *ptr)
IMPORT __imp_free
; char *fgets(char *s, int n, FILE *stream)
IMPORT __imp_fgets
; int pthread_mutex_lock(pthread_mutex_t *mutex)
IMPORT __imp_pthread_mutex_lock
; pthread_t pthread_self(void)
IMPORT __imp_pthread_self
; void *memcpy(void *dest, const void *src, size_t n)
IMPORT __imp_memcpy
; int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr)
IMPORT __imp_pthread_mutex_init
; __off_t lseek(int fd, __off_t offset, int whence)
IMPORT __imp_lseek
; int memcmp(const void *s1, const void *s2, size_t n)
IMPORT __imp_memcmp
; unsigned int sleep(unsigned int seconds)
IMPORT __imp_sleep
; int usleep(__useconds_t useconds)
IMPORT __imp_usleep
; char *strcpy(char *dest, const char *src)
IMPORT __imp_strcpy
; int gettimeofday(struct timeval *tv, __timezone_ptr_t tz)
IMPORT __imp_gettimeofday
; int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)
IMPORT __imp_pthread_create
; int sched_get_priority_max(int algorithm)
IMPORT __imp_sched_get_priority_max
; int puts(const char *s)
IMPORT __imp_puts
; void *malloc(size_t size)
IMPORT __imp_malloc
; int __libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end)
IMPORT __imp___libc_start_main
; int system(const char *command)
IMPORT __imp_system
; int open(const char *file, int oflag, ...)
IMPORT __imp_open
; unsigned int strtoul(const char *nptr, char **endptr, int base)
IMPORT __imp_strtoul
; size_t strlen(const char *s)
IMPORT __imp_strlen
; void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset)
IMPORT __imp_mmap
IMPORT __imp___isoc99_sscanf
; void *memset(void *s, int c, size_t n)
IMPORT __imp_memset
; int putchar(int c)
IMPORT __imp_putchar
; int pthread_cancel(pthread_t th)
IMPORT __imp_pthread_cancel
; ssize_t write(int fd, const void *buf, size_t n)
IMPORT __imp_write
; int fclose(FILE *stream)
IMPORT __imp_fclose
; int munmap(void *addr, size_t len)
IMPORT __imp_munmap
; int pthread_join(pthread_t th, void **thread_return)
IMPORT __imp_pthread_join
; int sprintf(char *s, const char *format, ...)
IMPORT __imp_sprintf
; int pthread_setschedparam(pthread_t target_thread, int policy, const struct sched_param *param)
IMPORT __imp_pthread_setschedparam
; int fseek(FILE *stream, int off, int whence)
IMPORT __imp_fseek
; void abort(void)
IMPORT __imp_abort
; int close(int fd)
IMPORT __imp_close
IMPORT _ITM_deregisterTMCloneTable, WEAK
IMPORT __imp___gmon_start__, WEAK
IMPORT _Jv_RegisterClasses, WEAK
IMPORT _ITM_registerTMCloneTable, WEAK


; Segment type: Absolute symbols
shift = 0

END _start
